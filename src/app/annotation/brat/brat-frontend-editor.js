(function () {
  function r(e, n, t) {
    function o(i, f) {
      if (!n[i]) {
        if (!e[i]) {
          var c = "function" == typeof require && require;
          if (!f && c) return c(i, !0);
          if (u) return u(i, !0);
          var a = new Error("Cannot find module '" + i + "'");
          throw a.code = "MODULE_NOT_FOUND", a
        }
        var p = n[i] = {exports: {}};
        e[i][0].call(p.exports, function (r) {
          var n = e[i][1][r];
          return o(n || r)
        }, p, p.exports, r, e, n, t)
      }
      return n[i].exports
    }

    for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);
    return o
  }

  return r
})()({
  1: [function (require, module, exports) {
    module.exports = "<div id=\"brat-frontend-editor\">\r\n    <div id=\"commentpopup\"></div>\r\n    <div id=\"svg\"></div>\r\n\r\n    <!-- Span dialog (view+edit) -->\r\n    <form id=\"span_form\" class=\"dialog\" title=\"Span\">\r\n        <!-- Span dialog annotated text -->\r\n        <fieldset id=\"span_selected_fset\">\r\n            <legend>Text</legend>\r\n            <a target=\"brat_linked\" id=\"span_highlight_link\" href=\"#\">Link</a>\r\n            <div id=\"span_selected\"/>\r\n        </fieldset>\r\n        <!-- Span dialog search links -->\r\n        <fieldset id=\"span_search_fieldset\">\r\n            <legend>Search</legend>\r\n            <div id=\"span_search_links\"/>\r\n        </fieldset>\r\n        <!-- Span dialog type selector -->\r\n        <fieldset>\r\n            <div id=\"entity_and_event_wrapper\" class=\"split_wrapper\">\r\n                <div id=\"span_entity_section\" class=\"wrapper_half_left\">\r\n                    <div id=\"entity_label\" class=\"label-like\">\r\n                        Entity type\r\n                    </div>\r\n                    <div id=\"entity_types\" class=\"scroll_wrapper_upper\">\r\n                        <div class=\"scroller\"></div>\r\n                    </div>\r\n                    <!-- NOTE: the attribute labels must be *outside* of the\r\n                         divs they logically belong to prevent scrollers\r\n                         overflowing them. -->\r\n                    <div id=\"entity_attribute_label\" class=\"label-like wrapper_lower_label\">\r\n                        Entity attributes\r\n                    </div>\r\n                    <div id=\"entity_attributes\" class=\"scroll_wrapper_lower\">\r\n                        <div class=\"scroller small-buttons\"></div>\r\n                    </div>\r\n                </div>\r\n                <div id=\"span_event_section\" class=\"wrapper_half_right\">\r\n                    <div id=\"event_label\" class=\"label-like\">\r\n                        Event type\r\n                    </div>\r\n                    <div id=\"event_types\" class=\"scroll_wrapper_upper\">\r\n                        <div class=\"scroller\"></div>\r\n                    </div>\r\n                    <div id=\"event_attribute_label\" class=\"wrapper_lower_label label-like\">\r\n                        Event attributes\r\n                    </div>\r\n                    <div id=\"event_attributes\" class=\"scroll_wrapper_lower\">\r\n                        <div class=\"scroller small-buttons\"></div>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </fieldset>\r\n        <!-- Span dialog normalization -->\r\n        <fieldset id=\"norm_fieldset\">\r\n            <legend>Normalization</legend>\r\n            <div id=\"norm_container\">\r\n                <select id=\"span_norm_db\"/>\r\n                <a id=\"span_norm_db_link\" target=\"brat_linked\" href=\"#\" title=\"Search DB\"><img class=\"brat-fugue-shadowless-magnifier\" src=\"assets/brat-client/static/img/Fugue-shadowless-magnifier.png\" style=\"vertical-align: middle\"/></a>\r\n                <span class=\"span_norm_label\">ID:</span>\r\n                <input id=\"span_norm_id\" class=\"span_norm_id_input\"\r\n                       style=\"width:20%\"/>\r\n                <span class=\"span_norm_label\">Ref:</span>\r\n                <input id=\"span_norm_txt\" class=\"span_norm_txt_input\"\r\n                       readonly=\"readonly\" style=\"width:45%\"\r\n                       placeholder=\"Click here to search\"/>\r\n                <a id=\"span_norm_ref_link\" target=\"brat_linked\" href=\"#\" title=\"See in DB\"><img class=\"brat-fugue-shadowless-external\" src=\"assets/brat-client/static/img/Fugue-shadowless-external.png\" style=\"vertical-align: middle\"/></a>\r\n                <input id=\"clear_norm_button\" type=\"button\"\r\n                       value=\"&#x2715;\" title=\"Clear normalization\"/>\r\n            </div>\r\n        </fieldset>\r\n        <!-- Span dialog notes -->\r\n        <fieldset>\r\n            <legend>Notes</legend>\r\n            <div id=\"notes_container\">\r\n                <input id=\"span_notes\" class=\"borderless\"/>\r\n                <input id=\"clear_notes_button\" type=\"button\"\r\n                       value=\"&#x2715;\" title=\"Clear notes\"/>\r\n            </div>\r\n        </fieldset>\r\n    </form>\r\n\r\n    <!-- Rapid mode span dialog -->\r\n    <form id=\"rapid_span_form\" class=\"dialog\" title=\"Span type\">\r\n        <fieldset id=\"rapid_span_selected_fset\">\r\n            <legend>Text</legend>\r\n            <div id=\"rapid_span_selected\"/>\r\n        </fieldset>\r\n        <div id=\"rapid_span_types\" class=\"scroll_fset\" style=\"height:250px\">\r\n            <fieldset>\r\n                <legend>Select type</legend>\r\n                <div class=\"scroller\" id=\"rapid_span_types_div\">\r\n                    <!-- filled dynamically -->\r\n                </div>\r\n            </fieldset>\r\n        </div>\r\n    </form>\r\n\r\n    <!-- Arc dialog -->\r\n    <form id=\"arc_form\" class=\"dialog\" title=\"Arc\">\r\n        <fieldset id=\"arc_origin_fset\">\r\n            <legend>From</legend>\r\n            <a target=\"brat_linked\" id=\"arc_highlight_link\" href=\"#\">Link</a>\r\n            <div id=\"arc_origin\"/>\r\n        </fieldset>\r\n\r\n        <fieldset id=\"arc_target_fset\">\r\n            <legend>To</legend>\r\n            <div id=\"arc_target\"/>\r\n        </fieldset>\r\n\r\n        <div id=\"arc_roles\" class=\"scroll_fset\">\r\n            <fieldset>\r\n                <legend>Type</legend>\r\n                <div class=\"scroller\"/>\r\n            </fieldset>\r\n        </div>\r\n\r\n        <fieldset id=\"arc_notes_fieldset\">\r\n            <legend>Notes</legend>\r\n            <input id=\"arc_notes\" class=\"borderless\"/>\r\n        </fieldset>\r\n\r\n    </form>\r\n\r\n    <!-- Split span annotation dialog -->\r\n    <form id=\"split_form\" class=\"dialog\" title=\"Split the Span\">\r\n        <fieldset>\r\n            <legend>Split Roles</legend>\r\n            <div id=\"split_roles\" class=\"scroll_fset\"/>\r\n        </fieldset>\r\n    </form>\r\n\r\n    <!-- Spinner -->\r\n    <!--<div id=\"waiter\" class=\"dialog\" title=\"Please wait\">\r\n        <img class=\"brat-spinner\" src=\"./assets/brat-client/static/img/spinner.gif\"/>\r\n    </div>-->\r\n</div>";

  }, {}], 2: [function (require, module, exports) {
    /*!
 * jQuery UI 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI
 */
    (function (c, j) {
      function k(a, b) {
        var d = a.nodeName.toLowerCase();
        if ("area" === d) {
          b = a.parentNode;
          d = b.name;
          if (!a.href || !d || b.nodeName.toLowerCase() !== "map") return false;
          a = c("img[usemap=#" + d + "]")[0];
          return !!a && l(a)
        }
        return (/input|select|textarea|button|object/.test(d) ? !a.disabled : "a" == d ? a.href || b : b) && l(a)
      }

      function l(a) {
        return !c(a).parents().andSelf().filter(function () {
          return c.curCSS(this, "visibility") === "hidden" || c.expr.filters.hidden(this)
        }).length
      }

      c.ui = c.ui || {};
      if (!c.ui.version) {
        c.extend(c.ui, {
          version: "1.8.16",
          keyCode: {
            ALT: 18,
            BACKSPACE: 8,
            CAPS_LOCK: 20,
            COMMA: 188,
            COMMAND: 91,
            COMMAND_LEFT: 91,
            COMMAND_RIGHT: 93,
            CONTROL: 17,
            DELETE: 46,
            DOWN: 40,
            END: 35,
            ENTER: 13,
            ESCAPE: 27,
            HOME: 36,
            INSERT: 45,
            LEFT: 37,
            MENU: 93,
            NUMPAD_ADD: 107,
            NUMPAD_DECIMAL: 110,
            NUMPAD_DIVIDE: 111,
            NUMPAD_ENTER: 108,
            NUMPAD_MULTIPLY: 106,
            NUMPAD_SUBTRACT: 109,
            PAGE_DOWN: 34,
            PAGE_UP: 33,
            PERIOD: 190,
            RIGHT: 39,
            SHIFT: 16,
            SPACE: 32,
            TAB: 9,
            UP: 38,
            WINDOWS: 91
          }
        });
        c.fn.extend({
          propAttr: c.fn.prop || c.fn.attr, _focus: c.fn.focus, focus: function (a, b) {
            return typeof a === "number" ? this.each(function () {
              var d =
                this;
              setTimeout(function () {
                c(d).focus();
                b && b.call(d)
              }, a)
            }) : this._focus.apply(this, arguments)
          }, scrollParent: function () {
            var a;
            a = c.browser.msie && /(static|relative)/.test(this.css("position")) || /absolute/.test(this.css("position")) ? this.parents().filter(function () {
              return /(relative|absolute|fixed)/.test(c.curCSS(this, "position", 1)) && /(auto|scroll)/.test(c.curCSS(this, "overflow", 1) + c.curCSS(this, "overflow-y", 1) + c.curCSS(this, "overflow-x", 1))
            }).eq(0) : this.parents().filter(function () {
              return /(auto|scroll)/.test(c.curCSS(this,
                "overflow", 1) + c.curCSS(this, "overflow-y", 1) + c.curCSS(this, "overflow-x", 1))
            }).eq(0);
            return /fixed/.test(this.css("position")) || !a.length ? c(document) : a
          }, zIndex: function (a) {
            if (a !== j) return this.css("zIndex", a);
            if (this.length) {
              a = c(this[0]);
              for (var b; a.length && a[0] !== document;) {
                b = a.css("position");
                if (b === "absolute" || b === "relative" || b === "fixed") {
                  b = parseInt(a.css("zIndex"), 10);
                  if (!isNaN(b) && b !== 0) return b
                }
                a = a.parent()
              }
            }
            return 0
          }, disableSelection: function () {
            return this.bind((c.support.selectstart ? "selectstart" :
              "mousedown") + ".ui-disableSelection", function (a) {
              a.preventDefault()
            })
          }, enableSelection: function () {
            return this.unbind(".ui-disableSelection")
          }
        });
        c.each(["Width", "Height"], function (a, b) {
          function d(f, g, m, n) {
            c.each(e, function () {
              g -= parseFloat(c.curCSS(f, "padding" + this, true)) || 0;
              if (m) g -= parseFloat(c.curCSS(f, "border" + this + "Width", true)) || 0;
              if (n) g -= parseFloat(c.curCSS(f, "margin" + this, true)) || 0
            });
            return g
          }

          var e = b === "Width" ? ["Left", "Right"] : ["Top", "Bottom"], h = b.toLowerCase(), i = {
            innerWidth: c.fn.innerWidth, innerHeight: c.fn.innerHeight,
            outerWidth: c.fn.outerWidth, outerHeight: c.fn.outerHeight
          };
          c.fn["inner" + b] = function (f) {
            if (f === j) return i["inner" + b].call(this);
            return this.each(function () {
              c(this).css(h, d(this, f) + "px")
            })
          };
          c.fn["outer" + b] = function (f, g) {
            if (typeof f !== "number") return i["outer" + b].call(this, f);
            return this.each(function () {
              c(this).css(h, d(this, f, true, g) + "px")
            })
          }
        });
        c.extend(c.expr[":"], {
          data: function (a, b, d) {
            return !!c.data(a, d[3])
          }, focusable: function (a) {
            return k(a, !isNaN(c.attr(a, "tabindex")))
          }, tabbable: function (a) {
            var b = c.attr(a,
              "tabindex"), d = isNaN(b);
            return (d || b >= 0) && k(a, !d)
          }
        });
        c(function () {
          var a = document.body, b = a.appendChild(b = document.createElement("div"));
          c.extend(b.style, {minHeight: "100px", height: "auto", padding: 0, borderWidth: 0});
          c.support.minHeight = b.offsetHeight === 100;
          c.support.selectstart = "onselectstart" in b;
          a.removeChild(b).style.display = "none"
        });
        c.extend(c.ui, {
          plugin: {
            add: function (a, b, d) {
              a = c.ui[a].prototype;
              for (var e in d) {
                a.plugins[e] = a.plugins[e] || [];
                a.plugins[e].push([b, d[e]])
              }
            }, call: function (a, b, d) {
              if ((b = a.plugins[b]) &&
                a.element[0].parentNode) for (var e = 0; e < b.length; e++) a.options[b[e][0]] && b[e][1].apply(a.element, d)
            }
          }, contains: function (a, b) {
            return document.compareDocumentPosition ? a.compareDocumentPosition(b) & 16 : a !== b && a.contains(b)
          }, hasScroll: function (a, b) {
            if (c(a).css("overflow") === "hidden") return false;
            b = b && b === "left" ? "scrollLeft" : "scrollTop";
            var d = false;
            if (a[b] > 0) return true;
            a[b] = 1;
            d = a[b] > 0;
            a[b] = 0;
            return d
          }, isOverAxis: function (a, b, d) {
            return a > b && a < b + d
          }, isOver: function (a, b, d, e, h, i) {
            return c.ui.isOverAxis(a, d, h) &&
              c.ui.isOverAxis(b, e, i)
          }
        })
      }
    })(jQuery);
    ;
    /*!
 * jQuery UI Widget 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Widget
 */
    (function (b, j) {
      if (b.cleanData) {
        var k = b.cleanData;
        b.cleanData = function (a) {
          for (var c = 0, d; (d = a[c]) != null; c++) try {
            b(d).triggerHandler("remove")
          } catch (e) {
          }
          k(a)
        }
      } else {
        var l = b.fn.remove;
        b.fn.remove = function (a, c) {
          return this.each(function () {
            if (!c) if (!a || b.filter(a, [this]).length) b("*", this).add([this]).each(function () {
              try {
                b(this).triggerHandler("remove")
              } catch (d) {
              }
            });
            return l.call(b(this), a, c)
          })
        }
      }
      b.widget = function (a, c, d) {
        var e = a.split(".")[0], f;
        a = a.split(".")[1];
        f = e + "-" + a;
        if (!d) {
          d = c;
          c = b.Widget
        }
        b.expr[":"][f] =
          function (h) {
            return !!b.data(h, a)
          };
        b[e] = b[e] || {};
        b[e][a] = function (h, g) {
          arguments.length && this._createWidget(h, g)
        };
        c = new c;
        c.options = b.extend(true, {}, c.options);
        b[e][a].prototype = b.extend(true, c, {
          namespace: e,
          widgetName: a,
          widgetEventPrefix: b[e][a].prototype.widgetEventPrefix || a,
          widgetBaseClass: f
        }, d);
        b.widget.bridge(a, b[e][a])
      };
      b.widget.bridge = function (a, c) {
        b.fn[a] = function (d) {
          var e = typeof d === "string", f = Array.prototype.slice.call(arguments, 1), h = this;
          d = !e && f.length ? b.extend.apply(null, [true, d].concat(f)) :
            d;
          if (e && d.charAt(0) === "_") return h;
          e ? this.each(function () {
            var g = b.data(this, a), i = g && b.isFunction(g[d]) ? g[d].apply(g, f) : g;
            if (i !== g && i !== j) {
              h = i;
              return false
            }
          }) : this.each(function () {
            var g = b.data(this, a);
            g ? g.option(d || {})._init() : b.data(this, a, new c(d, this))
          });
          return h
        }
      };
      b.Widget = function (a, c) {
        arguments.length && this._createWidget(a, c)
      };
      b.Widget.prototype = {
        widgetName: "widget", widgetEventPrefix: "", options: {disabled: false}, _createWidget: function (a, c) {
          b.data(c, this.widgetName, this);
          this.element = b(c);
          this.options =
            b.extend(true, {}, this.options, this._getCreateOptions(), a);
          var d = this;
          this.element.bind("remove." + this.widgetName, function () {
            d.destroy()
          });
          this._create();
          this._trigger("create");
          this._init()
        }, _getCreateOptions: function () {
          return b.metadata && b.metadata.get(this.element[0])[this.widgetName]
        }, _create: function () {
        }, _init: function () {
        }, destroy: function () {
          this.element.unbind("." + this.widgetName).removeData(this.widgetName);
          this.widget().unbind("." + this.widgetName).removeAttr("aria-disabled").removeClass(this.widgetBaseClass +
            "-disabled ui-state-disabled")
        }, widget: function () {
          return this.element
        }, option: function (a, c) {
          var d = a;
          if (arguments.length === 0) return b.extend({}, this.options);
          if (typeof a === "string") {
            if (c === j) return this.options[a];
            d = {};
            d[a] = c
          }
          this._setOptions(d);
          return this
        }, _setOptions: function (a) {
          var c = this;
          b.each(a, function (d, e) {
            c._setOption(d, e)
          });
          return this
        }, _setOption: function (a, c) {
          this.options[a] = c;
          if (a === "disabled") this.widget()[c ? "addClass" : "removeClass"](this.widgetBaseClass + "-disabled ui-state-disabled").attr("aria-disabled",
            c);
          return this
        }, enable: function () {
          return this._setOption("disabled", false)
        }, disable: function () {
          return this._setOption("disabled", true)
        }, _trigger: function (a, c, d) {
          var e = this.options[a];
          c = b.Event(c);
          c.type = (a === this.widgetEventPrefix ? a : this.widgetEventPrefix + a).toLowerCase();
          d = d || {};
          if (c.originalEvent) {
            a = b.event.props.length;
            for (var f; a;) {
              f = b.event.props[--a];
              c[f] = c.originalEvent[f]
            }
          }
          this.element.trigger(c, d);
          return !(b.isFunction(e) && e.call(this.element[0], c, d) === false || c.isDefaultPrevented())
        }
      }
    })(jQuery);
    ;
    /*!
 * jQuery UI Mouse 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Mouse
 *
 * Depends:
 *	jquery.ui.widget.js
 */
    (function (b) {
      var d = false;
      b(document).mouseup(function () {
        d = false
      });
      b.widget("ui.mouse", {
        options: {cancel: ":input,option", distance: 1, delay: 0}, _mouseInit: function () {
          var a = this;
          this.element.bind("mousedown." + this.widgetName, function (c) {
            return a._mouseDown(c)
          }).bind("click." + this.widgetName, function (c) {
            if (true === b.data(c.target, a.widgetName + ".preventClickEvent")) {
              b.removeData(c.target, a.widgetName + ".preventClickEvent");
              c.stopImmediatePropagation();
              return false
            }
          });
          this.started = false
        }, _mouseDestroy: function () {
          this.element.unbind("." +
            this.widgetName)
        }, _mouseDown: function (a) {
          if (!d) {
            this._mouseStarted && this._mouseUp(a);
            this._mouseDownEvent = a;
            var c = this, f = a.which == 1,
              g = typeof this.options.cancel == "string" && a.target.nodeName ? b(a.target).closest(this.options.cancel).length : false;
            if (!f || g || !this._mouseCapture(a)) return true;
            this.mouseDelayMet = !this.options.delay;
            if (!this.mouseDelayMet) this._mouseDelayTimer = setTimeout(function () {
              c.mouseDelayMet = true
            }, this.options.delay);
            if (this._mouseDistanceMet(a) && this._mouseDelayMet(a)) {
              this._mouseStarted =
                this._mouseStart(a) !== false;
              if (!this._mouseStarted) {
                a.preventDefault();
                return true
              }
            }
            true === b.data(a.target, this.widgetName + ".preventClickEvent") && b.removeData(a.target, this.widgetName + ".preventClickEvent");
            this._mouseMoveDelegate = function (e) {
              return c._mouseMove(e)
            };
            this._mouseUpDelegate = function (e) {
              return c._mouseUp(e)
            };
            b(document).bind("mousemove." + this.widgetName, this._mouseMoveDelegate).bind("mouseup." + this.widgetName, this._mouseUpDelegate);
            a.preventDefault();
            return d = true
          }
        }, _mouseMove: function (a) {
          if (b.browser.msie &&
            !(document.documentMode >= 9) && !a.button) return this._mouseUp(a);
          if (this._mouseStarted) {
            this._mouseDrag(a);
            return a.preventDefault()
          }
          if (this._mouseDistanceMet(a) && this._mouseDelayMet(a)) (this._mouseStarted = this._mouseStart(this._mouseDownEvent, a) !== false) ? this._mouseDrag(a) : this._mouseUp(a);
          return !this._mouseStarted
        }, _mouseUp: function (a) {
          b(document).unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
          if (this._mouseStarted) {
            this._mouseStarted =
              false;
            a.target == this._mouseDownEvent.target && b.data(a.target, this.widgetName + ".preventClickEvent", true);
            this._mouseStop(a)
          }
          return false
        }, _mouseDistanceMet: function (a) {
          return Math.max(Math.abs(this._mouseDownEvent.pageX - a.pageX), Math.abs(this._mouseDownEvent.pageY - a.pageY)) >= this.options.distance
        }, _mouseDelayMet: function () {
          return this.mouseDelayMet
        }, _mouseStart: function () {
        }, _mouseDrag: function () {
        }, _mouseStop: function () {
        }, _mouseCapture: function () {
          return true
        }
      })
    })(jQuery);
    ;
    /*
 * jQuery UI Position 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Position
 */
    (function (c) {
      c.ui = c.ui || {};
      var n = /left|center|right/, o = /top|center|bottom/, t = c.fn.position, u = c.fn.offset;
      c.fn.position = function (b) {
        if (!b || !b.of) return t.apply(this, arguments);
        b = c.extend({}, b);
        var a = c(b.of), d = a[0], g = (b.collision || "flip").split(" "), e = b.offset ? b.offset.split(" ") : [0, 0],
          h, k, j;
        if (d.nodeType === 9) {
          h = a.width();
          k = a.height();
          j = {top: 0, left: 0}
        } else if (d.setTimeout) {
          h = a.width();
          k = a.height();
          j = {top: a.scrollTop(), left: a.scrollLeft()}
        } else if (d.preventDefault) {
          b.at = "left top";
          h = k = 0;
          j = {
            top: b.of.pageY,
            left: b.of.pageX
          }
        } else {
          h = a.outerWidth();
          k = a.outerHeight();
          j = a.offset()
        }
        c.each(["my", "at"], function () {
          var f = (b[this] || "").split(" ");
          if (f.length === 1) f = n.test(f[0]) ? f.concat(["center"]) : o.test(f[0]) ? ["center"].concat(f) : ["center", "center"];
          f[0] = n.test(f[0]) ? f[0] : "center";
          f[1] = o.test(f[1]) ? f[1] : "center";
          b[this] = f
        });
        if (g.length === 1) g[1] = g[0];
        e[0] = parseInt(e[0], 10) || 0;
        if (e.length === 1) e[1] = e[0];
        e[1] = parseInt(e[1], 10) || 0;
        if (b.at[0] === "right") j.left += h; else if (b.at[0] === "center") j.left += h / 2;
        if (b.at[1] === "bottom") j.top +=
          k; else if (b.at[1] === "center") j.top += k / 2;
        j.left += e[0];
        j.top += e[1];
        return this.each(function () {
          var f = c(this), l = f.outerWidth(), m = f.outerHeight(),
            p = parseInt(c.curCSS(this, "marginLeft", true)) || 0, q = parseInt(c.curCSS(this, "marginTop", true)) || 0,
            v = l + p + (parseInt(c.curCSS(this, "marginRight", true)) || 0),
            w = m + q + (parseInt(c.curCSS(this, "marginBottom", true)) || 0), i = c.extend({}, j), r;
          if (b.my[0] === "right") i.left -= l; else if (b.my[0] === "center") i.left -= l / 2;
          if (b.my[1] === "bottom") i.top -= m; else if (b.my[1] === "center") i.top -=
            m / 2;
          i.left = Math.round(i.left);
          i.top = Math.round(i.top);
          r = {left: i.left - p, top: i.top - q};
          c.each(["left", "top"], function (s, x) {
            c.ui.position[g[s]] && c.ui.position[g[s]][x](i, {
              targetWidth: h,
              targetHeight: k,
              elemWidth: l,
              elemHeight: m,
              collisionPosition: r,
              collisionWidth: v,
              collisionHeight: w,
              offset: e,
              my: b.my,
              at: b.at
            })
          });
          c.fn.bgiframe && f.bgiframe();
          f.offset(c.extend(i, {using: b.using}))
        })
      };
      c.ui.position = {
        fit: {
          left: function (b, a) {
            var d = c(window);
            d = a.collisionPosition.left + a.collisionWidth - d.width() - d.scrollLeft();
            b.left =
              d > 0 ? b.left - d : Math.max(b.left - a.collisionPosition.left, b.left)
          }, top: function (b, a) {
            var d = c(window);
            d = a.collisionPosition.top + a.collisionHeight - d.height() - d.scrollTop();
            b.top = d > 0 ? b.top - d : Math.max(b.top - a.collisionPosition.top, b.top)
          }
        }, flip: {
          left: function (b, a) {
            if (a.at[0] !== "center") {
              var d = c(window);
              d = a.collisionPosition.left + a.collisionWidth - d.width() - d.scrollLeft();
              var g = a.my[0] === "left" ? -a.elemWidth : a.my[0] === "right" ? a.elemWidth : 0,
                e = a.at[0] === "left" ? a.targetWidth : -a.targetWidth, h = -2 * a.offset[0];
              b.left +=
                a.collisionPosition.left < 0 ? g + e + h : d > 0 ? g + e + h : 0
            }
          }, top: function (b, a) {
            if (a.at[1] !== "center") {
              var d = c(window);
              d = a.collisionPosition.top + a.collisionHeight - d.height() - d.scrollTop();
              var g = a.my[1] === "top" ? -a.elemHeight : a.my[1] === "bottom" ? a.elemHeight : 0,
                e = a.at[1] === "top" ? a.targetHeight : -a.targetHeight, h = -2 * a.offset[1];
              b.top += a.collisionPosition.top < 0 ? g + e + h : d > 0 ? g + e + h : 0
            }
          }
        }
      };
      if (!c.offset.setOffset) {
        c.offset.setOffset = function (b, a) {
          if (/(static)/.test(c.curCSS(b, "position"))) b.style.position = "relative";
          var d = c(b),
            g = d.offset(), e = parseInt(c.curCSS(b, "top", true), 10) || 0,
            h = parseInt(c.curCSS(b, "left", true), 10) || 0;
          g = {top: a.top - g.top + e, left: a.left - g.left + h};
          "using" in a ? a.using.call(b, g) : d.css(g)
        };
        c.fn.offset = function (b) {
          var a = this[0];
          if (!a || !a.ownerDocument) return null;
          if (b) return this.each(function () {
            c.offset.setOffset(this, b)
          });
          return u.call(this)
        }
      }
    })(jQuery);
    ;
    /*
 * jQuery UI Draggable 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Draggables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
    (function (d) {
      d.widget("ui.draggable", d.ui.mouse, {
        widgetEventPrefix: "drag",
        options: {
          addClasses: true,
          appendTo: "parent",
          axis: false,
          connectToSortable: false,
          containment: false,
          cursor: "auto",
          cursorAt: false,
          grid: false,
          handle: false,
          helper: "original",
          iframeFix: false,
          opacity: false,
          refreshPositions: false,
          revert: false,
          revertDuration: 500,
          scope: "default",
          scroll: true,
          scrollSensitivity: 20,
          scrollSpeed: 20,
          snap: false,
          snapMode: "both",
          snapTolerance: 20,
          stack: false,
          zIndex: false
        },
        _create: function () {
          if (this.options.helper ==
            "original" && !/^(?:r|a|f)/.test(this.element.css("position"))) this.element[0].style.position = "relative";
          this.options.addClasses && this.element.addClass("ui-draggable");
          this.options.disabled && this.element.addClass("ui-draggable-disabled");
          this._mouseInit()
        },
        destroy: function () {
          if (this.element.data("draggable")) {
            this.element.removeData("draggable").unbind(".draggable").removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled");
            this._mouseDestroy();
            return this
          }
        },
        _mouseCapture: function (a) {
          var b =
            this.options;
          if (this.helper || b.disabled || d(a.target).is(".ui-resizable-handle")) return false;
          this.handle = this._getHandle(a);
          if (!this.handle) return false;
          if (b.iframeFix) d(b.iframeFix === true ? "iframe" : b.iframeFix).each(function () {
            d('<div class="ui-draggable-iframeFix" style="background: #fff;"></div>').css({
              width: this.offsetWidth + "px",
              height: this.offsetHeight + "px",
              position: "absolute",
              opacity: "0.001",
              zIndex: 1E3
            }).css(d(this).offset()).appendTo("body")
          });
          return true
        },
        _mouseStart: function (a) {
          var b = this.options;
          this.helper = this._createHelper(a);
          this._cacheHelperProportions();
          if (d.ui.ddmanager) d.ui.ddmanager.current = this;
          this._cacheMargins();
          this.cssPosition = this.helper.css("position");
          this.scrollParent = this.helper.scrollParent();
          this.offset = this.positionAbs = this.element.offset();
          this.offset = {top: this.offset.top - this.margins.top, left: this.offset.left - this.margins.left};
          d.extend(this.offset, {
            click: {left: a.pageX - this.offset.left, top: a.pageY - this.offset.top},
            parent: this._getParentOffset(),
            relative: this._getRelativeOffset()
          });
          this.originalPosition = this.position = this._generatePosition(a);
          this.originalPageX = a.pageX;
          this.originalPageY = a.pageY;
          b.cursorAt && this._adjustOffsetFromHelper(b.cursorAt);
          b.containment && this._setContainment();
          if (this._trigger("start", a) === false) {
            this._clear();
            return false
          }
          this._cacheHelperProportions();
          d.ui.ddmanager && !b.dropBehaviour && d.ui.ddmanager.prepareOffsets(this, a);
          this.helper.addClass("ui-draggable-dragging");
          this._mouseDrag(a, true);
          d.ui.ddmanager && d.ui.ddmanager.dragStart(this, a);
          return true
        },
        _mouseDrag: function (a, b) {
          this.position = this._generatePosition(a);
          this.positionAbs = this._convertPositionTo("absolute");
          if (!b) {
            b = this._uiHash();
            if (this._trigger("drag", a, b) === false) {
              this._mouseUp({});
              return false
            }
            this.position = b.position
          }
          if (!this.options.axis || this.options.axis != "y") this.helper[0].style.left = this.position.left + "px";
          if (!this.options.axis || this.options.axis != "x") this.helper[0].style.top = this.position.top + "px";
          d.ui.ddmanager && d.ui.ddmanager.drag(this, a);
          return false
        },
        _mouseStop: function (a) {
          var b =
            false;
          if (d.ui.ddmanager && !this.options.dropBehaviour) b = d.ui.ddmanager.drop(this, a);
          if (this.dropped) {
            b = this.dropped;
            this.dropped = false
          }
          if ((!this.element[0] || !this.element[0].parentNode) && this.options.helper == "original") return false;
          if (this.options.revert == "invalid" && !b || this.options.revert == "valid" && b || this.options.revert === true || d.isFunction(this.options.revert) && this.options.revert.call(this.element, b)) {
            var c = this;
            d(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration,
              10), function () {
              c._trigger("stop", a) !== false && c._clear()
            })
          } else this._trigger("stop", a) !== false && this._clear();
          return false
        },
        _mouseUp: function (a) {
          this.options.iframeFix === true && d("div.ui-draggable-iframeFix").each(function () {
            this.parentNode.removeChild(this)
          });
          d.ui.ddmanager && d.ui.ddmanager.dragStop(this, a);
          return d.ui.mouse.prototype._mouseUp.call(this, a)
        },
        cancel: function () {
          this.helper.is(".ui-draggable-dragging") ? this._mouseUp({}) : this._clear();
          return this
        },
        _getHandle: function (a) {
          var b = !this.options.handle ||
          !d(this.options.handle, this.element).length ? true : false;
          d(this.options.handle, this.element).find("*").andSelf().each(function () {
            if (this == a.target) b = true
          });
          return b
        },
        _createHelper: function (a) {
          var b = this.options;
          a = d.isFunction(b.helper) ? d(b.helper.apply(this.element[0], [a])) : b.helper == "clone" ? this.element.clone().removeAttr("id") : this.element;
          a.parents("body").length || a.appendTo(b.appendTo == "parent" ? this.element[0].parentNode : b.appendTo);
          a[0] != this.element[0] && !/(fixed|absolute)/.test(a.css("position")) &&
          a.css("position", "absolute");
          return a
        },
        _adjustOffsetFromHelper: function (a) {
          if (typeof a == "string") a = a.split(" ");
          if (d.isArray(a)) a = {left: +a[0], top: +a[1] || 0};
          if ("left" in a) this.offset.click.left = a.left + this.margins.left;
          if ("right" in a) this.offset.click.left = this.helperProportions.width - a.right + this.margins.left;
          if ("top" in a) this.offset.click.top = a.top + this.margins.top;
          if ("bottom" in a) this.offset.click.top = this.helperProportions.height - a.bottom + this.margins.top
        },
        _getParentOffset: function () {
          this.offsetParent =
            this.helper.offsetParent();
          var a = this.offsetParent.offset();
          if (this.cssPosition == "absolute" && this.scrollParent[0] != document && d.ui.contains(this.scrollParent[0], this.offsetParent[0])) {
            a.left += this.scrollParent.scrollLeft();
            a.top += this.scrollParent.scrollTop()
          }
          if (this.offsetParent[0] == document.body || this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() == "html" && d.browser.msie) a = {
            top: 0,
            left: 0
          };
          return {
            top: a.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
            left: a.left + (parseInt(this.offsetParent.css("borderLeftWidth"),
              10) || 0)
          }
        },
        _getRelativeOffset: function () {
          if (this.cssPosition == "relative") {
            var a = this.element.position();
            return {
              top: a.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
              left: a.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
            }
          } else return {top: 0, left: 0}
        },
        _cacheMargins: function () {
          this.margins = {
            left: parseInt(this.element.css("marginLeft"), 10) || 0,
            top: parseInt(this.element.css("marginTop"), 10) || 0,
            right: parseInt(this.element.css("marginRight"), 10) || 0,
            bottom: parseInt(this.element.css("marginBottom"),
              10) || 0
          }
        },
        _cacheHelperProportions: function () {
          this.helperProportions = {width: this.helper.outerWidth(), height: this.helper.outerHeight()}
        },
        _setContainment: function () {
          var a = this.options;
          if (a.containment == "parent") a.containment = this.helper[0].parentNode;
          if (a.containment == "document" || a.containment == "window") this.containment = [a.containment == "document" ? 0 : d(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left, a.containment == "document" ? 0 : d(window).scrollTop() - this.offset.relative.top - this.offset.parent.top,
            (a.containment == "document" ? 0 : d(window).scrollLeft()) + d(a.containment == "document" ? document : window).width() - this.helperProportions.width - this.margins.left, (a.containment == "document" ? 0 : d(window).scrollTop()) + (d(a.containment == "document" ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top];
          if (!/^(document|window|parent)$/.test(a.containment) && a.containment.constructor != Array) {
            a = d(a.containment);
            var b = a[0];
            if (b) {
              a.offset();
              var c = d(b).css("overflow") !=
                "hidden";
              this.containment = [(parseInt(d(b).css("borderLeftWidth"), 10) || 0) + (parseInt(d(b).css("paddingLeft"), 10) || 0), (parseInt(d(b).css("borderTopWidth"), 10) || 0) + (parseInt(d(b).css("paddingTop"), 10) || 0), (c ? Math.max(b.scrollWidth, b.offsetWidth) : b.offsetWidth) - (parseInt(d(b).css("borderLeftWidth"), 10) || 0) - (parseInt(d(b).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right, (c ? Math.max(b.scrollHeight, b.offsetHeight) : b.offsetHeight) - (parseInt(d(b).css("borderTopWidth"),
                10) || 0) - (parseInt(d(b).css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top - this.margins.bottom];
              this.relative_container = a
            }
          } else if (a.containment.constructor == Array) this.containment = a.containment
        },
        _convertPositionTo: function (a, b) {
          if (!b) b = this.position;
          a = a == "absolute" ? 1 : -1;
          var c = this.cssPosition == "absolute" && !(this.scrollParent[0] != document && d.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
            f = /(html|body)/i.test(c[0].tagName);
          return {
            top: b.top +
            this.offset.relative.top * a + this.offset.parent.top * a - (d.browser.safari && d.browser.version < 526 && this.cssPosition == "fixed" ? 0 : (this.cssPosition == "fixed" ? -this.scrollParent.scrollTop() : f ? 0 : c.scrollTop()) * a),
            left: b.left + this.offset.relative.left * a + this.offset.parent.left * a - (d.browser.safari && d.browser.version < 526 && this.cssPosition == "fixed" ? 0 : (this.cssPosition == "fixed" ? -this.scrollParent.scrollLeft() : f ? 0 : c.scrollLeft()) * a)
          }
        },
        _generatePosition: function (a) {
          var b = this.options, c = this.cssPosition == "absolute" &&
            !(this.scrollParent[0] != document && d.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
            f = /(html|body)/i.test(c[0].tagName), e = a.pageX, h = a.pageY;
          if (this.originalPosition) {
            var g;
            if (this.containment) {
              if (this.relative_container) {
                g = this.relative_container.offset();
                g = [this.containment[0] + g.left, this.containment[1] + g.top, this.containment[2] + g.left, this.containment[3] + g.top]
              } else g = this.containment;
              if (a.pageX - this.offset.click.left < g[0]) e = g[0] + this.offset.click.left;
              if (a.pageY - this.offset.click.top < g[1]) h = g[1] + this.offset.click.top;
              if (a.pageX - this.offset.click.left > g[2]) e = g[2] + this.offset.click.left;
              if (a.pageY - this.offset.click.top > g[3]) h = g[3] + this.offset.click.top
            }
            if (b.grid) {
              h = b.grid[1] ? this.originalPageY + Math.round((h - this.originalPageY) / b.grid[1]) * b.grid[1] : this.originalPageY;
              h = g ? !(h - this.offset.click.top < g[1] || h - this.offset.click.top > g[3]) ? h : !(h - this.offset.click.top < g[1]) ? h - b.grid[1] : h + b.grid[1] : h;
              e = b.grid[0] ? this.originalPageX + Math.round((e - this.originalPageX) /
                b.grid[0]) * b.grid[0] : this.originalPageX;
              e = g ? !(e - this.offset.click.left < g[0] || e - this.offset.click.left > g[2]) ? e : !(e - this.offset.click.left < g[0]) ? e - b.grid[0] : e + b.grid[0] : e
            }
          }
          return {
            top: h - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + (d.browser.safari && d.browser.version < 526 && this.cssPosition == "fixed" ? 0 : this.cssPosition == "fixed" ? -this.scrollParent.scrollTop() : f ? 0 : c.scrollTop()),
            left: e - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + (d.browser.safari && d.browser.version <
            526 && this.cssPosition == "fixed" ? 0 : this.cssPosition == "fixed" ? -this.scrollParent.scrollLeft() : f ? 0 : c.scrollLeft())
          }
        },
        _clear: function () {
          this.helper.removeClass("ui-draggable-dragging");
          this.helper[0] != this.element[0] && !this.cancelHelperRemoval && this.helper.remove();
          this.helper = null;
          this.cancelHelperRemoval = false
        },
        _trigger: function (a, b, c) {
          c = c || this._uiHash();
          d.ui.plugin.call(this, a, [b, c]);
          if (a == "drag") this.positionAbs = this._convertPositionTo("absolute");
          return d.Widget.prototype._trigger.call(this, a, b,
            c)
        },
        plugins: {},
        _uiHash: function () {
          return {
            helper: this.helper,
            position: this.position,
            originalPosition: this.originalPosition,
            offset: this.positionAbs
          }
        }
      });
      d.extend(d.ui.draggable, {version: "1.8.16"});
      d.ui.plugin.add("draggable", "connectToSortable", {
        start: function (a, b) {
          var c = d(this).data("draggable"), f = c.options, e = d.extend({}, b, {item: c.element});
          c.sortables = [];
          d(f.connectToSortable).each(function () {
            var h = d.data(this, "sortable");
            if (h && !h.options.disabled) {
              c.sortables.push({instance: h, shouldRevert: h.options.revert});
              h.refreshPositions();
              h._trigger("activate", a, e)
            }
          })
        }, stop: function (a, b) {
          var c = d(this).data("draggable"), f = d.extend({}, b, {item: c.element});
          d.each(c.sortables, function () {
            if (this.instance.isOver) {
              this.instance.isOver = 0;
              c.cancelHelperRemoval = true;
              this.instance.cancelHelperRemoval = false;
              if (this.shouldRevert) this.instance.options.revert = true;
              this.instance._mouseStop(a);
              this.instance.options.helper = this.instance.options._helper;
              c.options.helper == "original" && this.instance.currentItem.css({top: "auto", left: "auto"})
            } else {
              this.instance.cancelHelperRemoval =
                false;
              this.instance._trigger("deactivate", a, f)
            }
          })
        }, drag: function (a, b) {
          var c = d(this).data("draggable"), f = this;
          d.each(c.sortables, function () {
            this.instance.positionAbs = c.positionAbs;
            this.instance.helperProportions = c.helperProportions;
            this.instance.offset.click = c.offset.click;
            if (this.instance._intersectsWith(this.instance.containerCache)) {
              if (!this.instance.isOver) {
                this.instance.isOver = 1;
                this.instance.currentItem = d(f).clone().removeAttr("id").appendTo(this.instance.element).data("sortable-item", true);
                this.instance.options._helper = this.instance.options.helper;
                this.instance.options.helper = function () {
                  return b.helper[0]
                };
                a.target = this.instance.currentItem[0];
                this.instance._mouseCapture(a, true);
                this.instance._mouseStart(a, true, true);
                this.instance.offset.click.top = c.offset.click.top;
                this.instance.offset.click.left = c.offset.click.left;
                this.instance.offset.parent.left -= c.offset.parent.left - this.instance.offset.parent.left;
                this.instance.offset.parent.top -= c.offset.parent.top - this.instance.offset.parent.top;
                c._trigger("toSortable", a);
                c.dropped = this.instance.element;
                c.currentItem = c.element;
                this.instance.fromOutside = c
              }
              this.instance.currentItem && this.instance._mouseDrag(a)
            } else if (this.instance.isOver) {
              this.instance.isOver = 0;
              this.instance.cancelHelperRemoval = true;
              this.instance.options.revert = false;
              this.instance._trigger("out", a, this.instance._uiHash(this.instance));
              this.instance._mouseStop(a, true);
              this.instance.options.helper = this.instance.options._helper;
              this.instance.currentItem.remove();
              this.instance.placeholder &&
              this.instance.placeholder.remove();
              c._trigger("fromSortable", a);
              c.dropped = false
            }
          })
        }
      });
      d.ui.plugin.add("draggable", "cursor", {
        start: function () {
          var a = d("body"), b = d(this).data("draggable").options;
          if (a.css("cursor")) b._cursor = a.css("cursor");
          a.css("cursor", b.cursor)
        }, stop: function () {
          var a = d(this).data("draggable").options;
          a._cursor && d("body").css("cursor", a._cursor)
        }
      });
      d.ui.plugin.add("draggable", "opacity", {
        start: function (a, b) {
          a = d(b.helper);
          b = d(this).data("draggable").options;
          if (a.css("opacity")) b._opacity =
            a.css("opacity");
          a.css("opacity", b.opacity)
        }, stop: function (a, b) {
          a = d(this).data("draggable").options;
          a._opacity && d(b.helper).css("opacity", a._opacity)
        }
      });
      d.ui.plugin.add("draggable", "scroll", {
        start: function () {
          var a = d(this).data("draggable");
          if (a.scrollParent[0] != document && a.scrollParent[0].tagName != "HTML") a.overflowOffset = a.scrollParent.offset()
        }, drag: function (a) {
          var b = d(this).data("draggable"), c = b.options, f = false;
          if (b.scrollParent[0] != document && b.scrollParent[0].tagName != "HTML") {
            if (!c.axis || c.axis !=
              "x") if (b.overflowOffset.top + b.scrollParent[0].offsetHeight - a.pageY < c.scrollSensitivity) b.scrollParent[0].scrollTop = f = b.scrollParent[0].scrollTop + c.scrollSpeed; else if (a.pageY - b.overflowOffset.top < c.scrollSensitivity) b.scrollParent[0].scrollTop = f = b.scrollParent[0].scrollTop - c.scrollSpeed;
            if (!c.axis || c.axis != "y") if (b.overflowOffset.left + b.scrollParent[0].offsetWidth - a.pageX < c.scrollSensitivity) b.scrollParent[0].scrollLeft = f = b.scrollParent[0].scrollLeft + c.scrollSpeed; else if (a.pageX - b.overflowOffset.left <
              c.scrollSensitivity) b.scrollParent[0].scrollLeft = f = b.scrollParent[0].scrollLeft - c.scrollSpeed
          } else {
            if (!c.axis || c.axis != "x") if (a.pageY - d(document).scrollTop() < c.scrollSensitivity) f = d(document).scrollTop(d(document).scrollTop() - c.scrollSpeed); else if (d(window).height() - (a.pageY - d(document).scrollTop()) < c.scrollSensitivity) f = d(document).scrollTop(d(document).scrollTop() + c.scrollSpeed);
            if (!c.axis || c.axis != "y") if (a.pageX - d(document).scrollLeft() < c.scrollSensitivity) f = d(document).scrollLeft(d(document).scrollLeft() -
              c.scrollSpeed); else if (d(window).width() - (a.pageX - d(document).scrollLeft()) < c.scrollSensitivity) f = d(document).scrollLeft(d(document).scrollLeft() + c.scrollSpeed)
          }
          f !== false && d.ui.ddmanager && !c.dropBehaviour && d.ui.ddmanager.prepareOffsets(b, a)
        }
      });
      d.ui.plugin.add("draggable", "snap", {
        start: function () {
          var a = d(this).data("draggable"), b = a.options;
          a.snapElements = [];
          d(b.snap.constructor != String ? b.snap.items || ":data(draggable)" : b.snap).each(function () {
            var c = d(this), f = c.offset();
            this != a.element[0] && a.snapElements.push({
              item: this,
              width: c.outerWidth(), height: c.outerHeight(), top: f.top, left: f.left
            })
          })
        }, drag: function (a, b) {
          for (var c = d(this).data("draggable"), f = c.options, e = f.snapTolerance, h = b.offset.left, g = h + c.helperProportions.width, n = b.offset.top, o = n + c.helperProportions.height, i = c.snapElements.length - 1; i >= 0; i--) {
            var j = c.snapElements[i].left, l = j + c.snapElements[i].width, k = c.snapElements[i].top,
              m = k + c.snapElements[i].height;
            if (j - e < h && h < l + e && k - e < n && n < m + e || j - e < h && h < l + e && k - e < o && o < m + e || j - e < g && g < l + e && k - e < n && n < m + e || j - e < g && g < l + e && k - e < o &&
              o < m + e) {
              if (f.snapMode != "inner") {
                var p = Math.abs(k - o) <= e, q = Math.abs(m - n) <= e, r = Math.abs(j - g) <= e,
                  s = Math.abs(l - h) <= e;
                if (p) b.position.top = c._convertPositionTo("relative", {
                  top: k - c.helperProportions.height,
                  left: 0
                }).top - c.margins.top;
                if (q) b.position.top = c._convertPositionTo("relative", {top: m, left: 0}).top - c.margins.top;
                if (r) b.position.left = c._convertPositionTo("relative", {
                  top: 0,
                  left: j - c.helperProportions.width
                }).left - c.margins.left;
                if (s) b.position.left = c._convertPositionTo("relative", {top: 0, left: l}).left - c.margins.left
              }
              var t =
                p || q || r || s;
              if (f.snapMode != "outer") {
                p = Math.abs(k - n) <= e;
                q = Math.abs(m - o) <= e;
                r = Math.abs(j - h) <= e;
                s = Math.abs(l - g) <= e;
                if (p) b.position.top = c._convertPositionTo("relative", {top: k, left: 0}).top - c.margins.top;
                if (q) b.position.top = c._convertPositionTo("relative", {
                  top: m - c.helperProportions.height,
                  left: 0
                }).top - c.margins.top;
                if (r) b.position.left = c._convertPositionTo("relative", {top: 0, left: j}).left - c.margins.left;
                if (s) b.position.left = c._convertPositionTo("relative", {
                  top: 0,
                  left: l - c.helperProportions.width
                }).left - c.margins.left
              }
              if (!c.snapElements[i].snapping &&
                (p || q || r || s || t)) c.options.snap.snap && c.options.snap.snap.call(c.element, a, d.extend(c._uiHash(), {snapItem: c.snapElements[i].item}));
              c.snapElements[i].snapping = p || q || r || s || t
            } else {
              c.snapElements[i].snapping && c.options.snap.release && c.options.snap.release.call(c.element, a, d.extend(c._uiHash(), {snapItem: c.snapElements[i].item}));
              c.snapElements[i].snapping = false
            }
          }
        }
      });
      d.ui.plugin.add("draggable", "stack", {
        start: function () {
          var a = d(this).data("draggable").options;
          a = d.makeArray(d(a.stack)).sort(function (c, f) {
            return (parseInt(d(c).css("zIndex"),
              10) || 0) - (parseInt(d(f).css("zIndex"), 10) || 0)
          });
          if (a.length) {
            var b = parseInt(a[0].style.zIndex) || 0;
            d(a).each(function (c) {
              this.style.zIndex = b + c
            });
            this[0].style.zIndex = b + a.length
          }
        }
      });
      d.ui.plugin.add("draggable", "zIndex", {
        start: function (a, b) {
          a = d(b.helper);
          b = d(this).data("draggable").options;
          if (a.css("zIndex")) b._zIndex = a.css("zIndex");
          a.css("zIndex", b.zIndex)
        }, stop: function (a, b) {
          a = d(this).data("draggable").options;
          a._zIndex && d(b.helper).css("zIndex", a._zIndex)
        }
      })
    })(jQuery);
    ;
    /*
 * jQuery UI Droppable 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Droppables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *	jquery.ui.mouse.js
 *	jquery.ui.draggable.js
 */
    (function (d) {
      d.widget("ui.droppable", {
        widgetEventPrefix: "drop",
        options: {
          accept: "*",
          activeClass: false,
          addClasses: true,
          greedy: false,
          hoverClass: false,
          scope: "default",
          tolerance: "intersect"
        },
        _create: function () {
          var a = this.options, b = a.accept;
          this.isover = 0;
          this.isout = 1;
          this.accept = d.isFunction(b) ? b : function (c) {
            return c.is(b)
          };
          this.proportions = {width: this.element[0].offsetWidth, height: this.element[0].offsetHeight};
          d.ui.ddmanager.droppables[a.scope] = d.ui.ddmanager.droppables[a.scope] || [];
          d.ui.ddmanager.droppables[a.scope].push(this);
          a.addClasses && this.element.addClass("ui-droppable")
        },
        destroy: function () {
          for (var a = d.ui.ddmanager.droppables[this.options.scope], b = 0; b < a.length; b++) a[b] == this && a.splice(b, 1);
          this.element.removeClass("ui-droppable ui-droppable-disabled").removeData("droppable").unbind(".droppable");
          return this
        },
        _setOption: function (a, b) {
          if (a == "accept") this.accept = d.isFunction(b) ? b : function (c) {
            return c.is(b)
          };
          d.Widget.prototype._setOption.apply(this, arguments)
        },
        _activate: function (a) {
          var b = d.ui.ddmanager.current;
          this.options.activeClass &&
          this.element.addClass(this.options.activeClass);
          b && this._trigger("activate", a, this.ui(b))
        },
        _deactivate: function (a) {
          var b = d.ui.ddmanager.current;
          this.options.activeClass && this.element.removeClass(this.options.activeClass);
          b && this._trigger("deactivate", a, this.ui(b))
        },
        _over: function (a) {
          var b = d.ui.ddmanager.current;
          if (!(!b || (b.currentItem || b.element)[0] == this.element[0])) if (this.accept.call(this.element[0], b.currentItem || b.element)) {
            this.options.hoverClass && this.element.addClass(this.options.hoverClass);
            this._trigger("over", a, this.ui(b))
          }
        },
        _out: function (a) {
          var b = d.ui.ddmanager.current;
          if (!(!b || (b.currentItem || b.element)[0] == this.element[0])) if (this.accept.call(this.element[0], b.currentItem || b.element)) {
            this.options.hoverClass && this.element.removeClass(this.options.hoverClass);
            this._trigger("out", a, this.ui(b))
          }
        },
        _drop: function (a, b) {
          var c = b || d.ui.ddmanager.current;
          if (!c || (c.currentItem || c.element)[0] == this.element[0]) return false;
          var e = false;
          this.element.find(":data(droppable)").not(".ui-draggable-dragging").each(function () {
            var g =
              d.data(this, "droppable");
            if (g.options.greedy && !g.options.disabled && g.options.scope == c.options.scope && g.accept.call(g.element[0], c.currentItem || c.element) && d.ui.intersect(c, d.extend(g, {offset: g.element.offset()}), g.options.tolerance)) {
              e = true;
              return false
            }
          });
          if (e) return false;
          if (this.accept.call(this.element[0], c.currentItem || c.element)) {
            this.options.activeClass && this.element.removeClass(this.options.activeClass);
            this.options.hoverClass && this.element.removeClass(this.options.hoverClass);
            this._trigger("drop",
              a, this.ui(c));
            return this.element
          }
          return false
        },
        ui: function (a) {
          return {draggable: a.currentItem || a.element, helper: a.helper, position: a.position, offset: a.positionAbs}
        }
      });
      d.extend(d.ui.droppable, {version: "1.8.16"});
      d.ui.intersect = function (a, b, c) {
        if (!b.offset) return false;
        var e = (a.positionAbs || a.position.absolute).left, g = e + a.helperProportions.width,
          f = (a.positionAbs || a.position.absolute).top, h = f + a.helperProportions.height, i = b.offset.left,
          k = i + b.proportions.width, j = b.offset.top, l = j + b.proportions.height;
        switch (c) {
          case "fit":
            return i <= e && g <= k && j <= f && h <= l;
          case "intersect":
            return i < e + a.helperProportions.width / 2 && g - a.helperProportions.width / 2 < k && j < f + a.helperProportions.height / 2 && h - a.helperProportions.height / 2 < l;
          case "pointer":
            return d.ui.isOver((a.positionAbs || a.position.absolute).top + (a.clickOffset || a.offset.click).top, (a.positionAbs || a.position.absolute).left + (a.clickOffset || a.offset.click).left, j, i, b.proportions.height, b.proportions.width);
          case "touch":
            return (f >= j && f <= l || h >= j && h <= l || f < j && h > l) && (e >=
              i && e <= k || g >= i && g <= k || e < i && g > k);
          default:
            return false
        }
      };
      d.ui.ddmanager = {
        current: null, droppables: {"default": []}, prepareOffsets: function (a, b) {
          var c = d.ui.ddmanager.droppables[a.options.scope] || [], e = b ? b.type : null,
            g = (a.currentItem || a.element).find(":data(droppable)").andSelf(), f = 0;
          a:for (; f < c.length; f++) if (!(c[f].options.disabled || a && !c[f].accept.call(c[f].element[0], a.currentItem || a.element))) {
            for (var h = 0; h < g.length; h++) if (g[h] == c[f].element[0]) {
              c[f].proportions.height = 0;
              continue a
            }
            c[f].visible = c[f].element.css("display") !=
              "none";
            if (c[f].visible) {
              e == "mousedown" && c[f]._activate.call(c[f], b);
              c[f].offset = c[f].element.offset();
              c[f].proportions = {width: c[f].element[0].offsetWidth, height: c[f].element[0].offsetHeight}
            }
          }
        }, drop: function (a, b) {
          var c = false;
          d.each(d.ui.ddmanager.droppables[a.options.scope] || [], function () {
            if (this.options) {
              if (!this.options.disabled && this.visible && d.ui.intersect(a, this, this.options.tolerance)) c = c || this._drop.call(this, b);
              if (!this.options.disabled && this.visible && this.accept.call(this.element[0], a.currentItem ||
                a.element)) {
                this.isout = 1;
                this.isover = 0;
                this._deactivate.call(this, b)
              }
            }
          });
          return c
        }, dragStart: function (a, b) {
          a.element.parents(":not(body,html)").bind("scroll.droppable", function () {
            a.options.refreshPositions || d.ui.ddmanager.prepareOffsets(a, b)
          })
        }, drag: function (a, b) {
          a.options.refreshPositions && d.ui.ddmanager.prepareOffsets(a, b);
          d.each(d.ui.ddmanager.droppables[a.options.scope] || [], function () {
            if (!(this.options.disabled || this.greedyChild || !this.visible)) {
              var c = d.ui.intersect(a, this, this.options.tolerance);
              if (c = !c && this.isover == 1 ? "isout" : c && this.isover == 0 ? "isover" : null) {
                var e;
                if (this.options.greedy) {
                  var g = this.element.parents(":data(droppable):eq(0)");
                  if (g.length) {
                    e = d.data(g[0], "droppable");
                    e.greedyChild = c == "isover" ? 1 : 0
                  }
                }
                if (e && c == "isover") {
                  e.isover = 0;
                  e.isout = 1;
                  e._out.call(e, b)
                }
                this[c] = 1;
                this[c == "isout" ? "isover" : "isout"] = 0;
                this[c == "isover" ? "_over" : "_out"].call(this, b);
                if (e && c == "isout") {
                  e.isout = 0;
                  e.isover = 1;
                  e._over.call(e, b)
                }
              }
            }
          })
        }, dragStop: function (a, b) {
          a.element.parents(":not(body,html)").unbind("scroll.droppable");
          a.options.refreshPositions || d.ui.ddmanager.prepareOffsets(a, b)
        }
      }
    })(jQuery);
    ;
    /*
 * jQuery UI Resizable 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Resizables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
    (function (e) {
      e.widget("ui.resizable", e.ui.mouse, {
        widgetEventPrefix: "resize",
        options: {
          alsoResize: false,
          animate: false,
          animateDuration: "slow",
          animateEasing: "swing",
          aspectRatio: false,
          autoHide: false,
          containment: false,
          ghost: false,
          grid: false,
          handles: "e,s,se",
          helper: false,
          maxHeight: null,
          maxWidth: null,
          minHeight: 10,
          minWidth: 10,
          zIndex: 1E3
        },
        _create: function () {
          var b = this, a = this.options;
          this.element.addClass("ui-resizable");
          e.extend(this, {
            _aspectRatio: !!a.aspectRatio,
            aspectRatio: a.aspectRatio,
            originalElement: this.element,
            _proportionallyResizeElements: [],
            _helper: a.helper || a.ghost || a.animate ? a.helper || "ui-resizable-helper" : null
          });
          if (this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) {
            /relative/.test(this.element.css("position")) && e.browser.opera && this.element.css({
              position: "relative",
              top: "auto",
              left: "auto"
            });
            this.element.wrap(e('<div class="ui-wrapper" style="overflow: hidden;"></div>').css({
              position: this.element.css("position"),
              width: this.element.outerWidth(),
              height: this.element.outerHeight(),
              top: this.element.css("top"),
              left: this.element.css("left")
            }));
            this.element = this.element.parent().data("resizable", this.element.data("resizable"));
            this.elementIsWrapper = true;
            this.element.css({
              marginLeft: this.originalElement.css("marginLeft"),
              marginTop: this.originalElement.css("marginTop"),
              marginRight: this.originalElement.css("marginRight"),
              marginBottom: this.originalElement.css("marginBottom")
            });
            this.originalElement.css({marginLeft: 0, marginTop: 0, marginRight: 0, marginBottom: 0});
            this.originalResizeStyle =
              this.originalElement.css("resize");
            this.originalElement.css("resize", "none");
            this._proportionallyResizeElements.push(this.originalElement.css({
              position: "static",
              zoom: 1,
              display: "block"
            }));
            this.originalElement.css({margin: this.originalElement.css("margin")});
            this._proportionallyResize()
          }
          this.handles = a.handles || (!e(".ui-resizable-handle", this.element).length ? "e,s,se" : {
            n: ".ui-resizable-n",
            e: ".ui-resizable-e",
            s: ".ui-resizable-s",
            w: ".ui-resizable-w",
            se: ".ui-resizable-se",
            sw: ".ui-resizable-sw",
            ne: ".ui-resizable-ne",
            nw: ".ui-resizable-nw"
          });
          if (this.handles.constructor == String) {
            if (this.handles == "all") this.handles = "n,e,s,w,se,sw,ne,nw";
            var c = this.handles.split(",");
            this.handles = {};
            for (var d = 0; d < c.length; d++) {
              var f = e.trim(c[d]), g = e('<div class="ui-resizable-handle ' + ("ui-resizable-" + f) + '"></div>');
              /sw|se|ne|nw/.test(f) && g.css({zIndex: ++a.zIndex});
              "se" == f && g.addClass("ui-icon ui-icon-gripsmall-diagonal-se");
              this.handles[f] = ".ui-resizable-" + f;
              this.element.append(g)
            }
          }
          this._renderAxis = function (h) {
            h = h || this.element;
            for (var i in this.handles) {
              if (this.handles[i].constructor ==
                String) this.handles[i] = e(this.handles[i], this.element).show();
              if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {
                var j = e(this.handles[i], this.element), l = 0;
                l = /sw|ne|nw|se|n|s/.test(i) ? j.outerHeight() : j.outerWidth();
                j = ["padding", /ne|nw|n/.test(i) ? "Top" : /se|sw|s/.test(i) ? "Bottom" : /^e$/.test(i) ? "Right" : "Left"].join("");
                h.css(j, l);
                this._proportionallyResize()
              }
              e(this.handles[i])
            }
          };
          this._renderAxis(this.element);
          this._handles = e(".ui-resizable-handle", this.element).disableSelection();
          this._handles.mouseover(function () {
            if (!b.resizing) {
              if (this.className) var h = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
              b.axis = h && h[1] ? h[1] : "se"
            }
          });
          if (a.autoHide) {
            this._handles.hide();
            e(this.element).addClass("ui-resizable-autohide").hover(function () {
              if (!a.disabled) {
                e(this).removeClass("ui-resizable-autohide");
                b._handles.show()
              }
            }, function () {
              if (!a.disabled) if (!b.resizing) {
                e(this).addClass("ui-resizable-autohide");
                b._handles.hide()
              }
            })
          }
          this._mouseInit()
        },
        destroy: function () {
          this._mouseDestroy();
          var b = function (c) {
            e(c).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing").removeData("resizable").unbind(".resizable").find(".ui-resizable-handle").remove()
          };
          if (this.elementIsWrapper) {
            b(this.element);
            var a = this.element;
            a.after(this.originalElement.css({
              position: a.css("position"),
              width: a.outerWidth(),
              height: a.outerHeight(),
              top: a.css("top"),
              left: a.css("left")
            })).remove()
          }
          this.originalElement.css("resize", this.originalResizeStyle);
          b(this.originalElement);
          return this
        },
        _mouseCapture: function (b) {
          var a =
            false;
          for (var c in this.handles) if (e(this.handles[c])[0] == b.target) a = true;
          return !this.options.disabled && a
        },
        _mouseStart: function (b) {
          var a = this.options, c = this.element.position(), d = this.element;
          this.resizing = true;
          this.documentScroll = {top: e(document).scrollTop(), left: e(document).scrollLeft()};
          if (d.is(".ui-draggable") || /absolute/.test(d.css("position"))) d.css({
            position: "absolute",
            top: c.top,
            left: c.left
          });
          e.browser.opera && /relative/.test(d.css("position")) && d.css({
            position: "relative",
            top: "auto",
            left: "auto"
          });
          this._renderProxy();
          c = m(this.helper.css("left"));
          var f = m(this.helper.css("top"));
          if (a.containment) {
            c += e(a.containment).scrollLeft() || 0;
            f += e(a.containment).scrollTop() || 0
          }
          this.offset = this.helper.offset();
          this.position = {left: c, top: f};
          this.size = this._helper ? {width: d.outerWidth(), height: d.outerHeight()} : {
            width: d.width(),
            height: d.height()
          };
          this.originalSize = this._helper ? {width: d.outerWidth(), height: d.outerHeight()} : {
            width: d.width(),
            height: d.height()
          };
          this.originalPosition = {left: c, top: f};
          this.sizeDiff =
            {width: d.outerWidth() - d.width(), height: d.outerHeight() - d.height()};
          this.originalMousePosition = {left: b.pageX, top: b.pageY};
          this.aspectRatio = typeof a.aspectRatio == "number" ? a.aspectRatio : this.originalSize.width / this.originalSize.height || 1;
          a = e(".ui-resizable-" + this.axis).css("cursor");
          e("body").css("cursor", a == "auto" ? this.axis + "-resize" : a);
          d.addClass("ui-resizable-resizing");
          this._propagate("start", b);
          return true
        },
        _mouseDrag: function (b) {
          var a = this.helper, c = this.originalMousePosition, d = this._change[this.axis];
          if (!d) return false;
          c = d.apply(this, [b, b.pageX - c.left || 0, b.pageY - c.top || 0]);
          this._updateVirtualBoundaries(b.shiftKey);
          if (this._aspectRatio || b.shiftKey) c = this._updateRatio(c, b);
          c = this._respectSize(c, b);
          this._propagate("resize", b);
          a.css({
            top: this.position.top + "px",
            left: this.position.left + "px",
            width: this.size.width + "px",
            height: this.size.height + "px"
          });
          !this._helper && this._proportionallyResizeElements.length && this._proportionallyResize();
          this._updateCache(c);
          this._trigger("resize", b, this.ui());
          return false
        },
        _mouseStop: function (b) {
          this.resizing = false;
          var a = this.options, c = this;
          if (this._helper) {
            var d = this._proportionallyResizeElements, f = d.length && /textarea/i.test(d[0].nodeName);
            d = f && e.ui.hasScroll(d[0], "left") ? 0 : c.sizeDiff.height;
            f = f ? 0 : c.sizeDiff.width;
            f = {width: c.helper.width() - f, height: c.helper.height() - d};
            d = parseInt(c.element.css("left"), 10) + (c.position.left - c.originalPosition.left) || null;
            var g = parseInt(c.element.css("top"), 10) + (c.position.top - c.originalPosition.top) || null;
            a.animate || this.element.css(e.extend(f,
              {top: g, left: d}));
            c.helper.height(c.size.height);
            c.helper.width(c.size.width);
            this._helper && !a.animate && this._proportionallyResize()
          }
          e("body").css("cursor", "auto");
          this.element.removeClass("ui-resizable-resizing");
          this._propagate("stop", b);
          this._helper && this.helper.remove();
          return false
        },
        _updateVirtualBoundaries: function (b) {
          var a = this.options, c, d, f;
          a = {
            minWidth: k(a.minWidth) ? a.minWidth : 0,
            maxWidth: k(a.maxWidth) ? a.maxWidth : Infinity,
            minHeight: k(a.minHeight) ? a.minHeight : 0,
            maxHeight: k(a.maxHeight) ? a.maxHeight :
              Infinity
          };
          if (this._aspectRatio || b) {
            b = a.minHeight * this.aspectRatio;
            d = a.minWidth / this.aspectRatio;
            c = a.maxHeight * this.aspectRatio;
            f = a.maxWidth / this.aspectRatio;
            if (b > a.minWidth) a.minWidth = b;
            if (d > a.minHeight) a.minHeight = d;
            if (c < a.maxWidth) a.maxWidth = c;
            if (f < a.maxHeight) a.maxHeight = f
          }
          this._vBoundaries = a
        },
        _updateCache: function (b) {
          this.offset = this.helper.offset();
          if (k(b.left)) this.position.left = b.left;
          if (k(b.top)) this.position.top = b.top;
          if (k(b.height)) this.size.height = b.height;
          if (k(b.width)) this.size.width =
            b.width
        },
        _updateRatio: function (b) {
          var a = this.position, c = this.size, d = this.axis;
          if (k(b.height)) b.width = b.height * this.aspectRatio; else if (k(b.width)) b.height = b.width / this.aspectRatio;
          if (d == "sw") {
            b.left = a.left + (c.width - b.width);
            b.top = null
          }
          if (d == "nw") {
            b.top = a.top + (c.height - b.height);
            b.left = a.left + (c.width - b.width)
          }
          return b
        },
        _respectSize: function (b) {
          var a = this._vBoundaries, c = this.axis, d = k(b.width) && a.maxWidth && a.maxWidth < b.width,
            f = k(b.height) && a.maxHeight && a.maxHeight < b.height, g = k(b.width) && a.minWidth &&
            a.minWidth > b.width, h = k(b.height) && a.minHeight && a.minHeight > b.height;
          if (g) b.width = a.minWidth;
          if (h) b.height = a.minHeight;
          if (d) b.width = a.maxWidth;
          if (f) b.height = a.maxHeight;
          var i = this.originalPosition.left + this.originalSize.width, j = this.position.top + this.size.height,
            l = /sw|nw|w/.test(c);
          c = /nw|ne|n/.test(c);
          if (g && l) b.left = i - a.minWidth;
          if (d && l) b.left = i - a.maxWidth;
          if (h && c) b.top = j - a.minHeight;
          if (f && c) b.top = j - a.maxHeight;
          if ((a = !b.width && !b.height) && !b.left && b.top) b.top = null; else if (a && !b.top && b.left) b.left =
            null;
          return b
        },
        _proportionallyResize: function () {
          if (this._proportionallyResizeElements.length) for (var b = this.helper || this.element, a = 0; a < this._proportionallyResizeElements.length; a++) {
            var c = this._proportionallyResizeElements[a];
            if (!this.borderDif) {
              var d = [c.css("borderTopWidth"), c.css("borderRightWidth"), c.css("borderBottomWidth"), c.css("borderLeftWidth")],
                f = [c.css("paddingTop"), c.css("paddingRight"), c.css("paddingBottom"), c.css("paddingLeft")];
              this.borderDif = e.map(d, function (g, h) {
                g = parseInt(g, 10) ||
                  0;
                h = parseInt(f[h], 10) || 0;
                return g + h
              })
            }
            e.browser.msie && (e(b).is(":hidden") || e(b).parents(":hidden").length) || c.css({
              height: b.height() - this.borderDif[0] - this.borderDif[2] || 0,
              width: b.width() - this.borderDif[1] - this.borderDif[3] || 0
            })
          }
        },
        _renderProxy: function () {
          var b = this.options;
          this.elementOffset = this.element.offset();
          if (this._helper) {
            this.helper = this.helper || e('<div style="overflow:hidden;"></div>');
            var a = e.browser.msie && e.browser.version < 7, c = a ? 1 : 0;
            a = a ? 2 : -1;
            this.helper.addClass(this._helper).css({
              width: this.element.outerWidth() +
              a,
              height: this.element.outerHeight() + a,
              position: "absolute",
              left: this.elementOffset.left - c + "px",
              top: this.elementOffset.top - c + "px",
              zIndex: ++b.zIndex
            });
            this.helper.appendTo("body").disableSelection()
          } else this.helper = this.element
        },
        _change: {
          e: function (b, a) {
            return {width: this.originalSize.width + a}
          }, w: function (b, a) {
            return {left: this.originalPosition.left + a, width: this.originalSize.width - a}
          }, n: function (b, a, c) {
            return {top: this.originalPosition.top + c, height: this.originalSize.height - c}
          }, s: function (b, a, c) {
            return {
              height: this.originalSize.height +
              c
            }
          }, se: function (b, a, c) {
            return e.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [b, a, c]))
          }, sw: function (b, a, c) {
            return e.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [b, a, c]))
          }, ne: function (b, a, c) {
            return e.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [b, a, c]))
          }, nw: function (b, a, c) {
            return e.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [b, a, c]))
          }
        },
        _propagate: function (b, a) {
          e.ui.plugin.call(this, b, [a, this.ui()]);
          b != "resize" && this._trigger(b, a, this.ui())
        },
        plugins: {},
        ui: function () {
          return {
            originalElement: this.originalElement,
            element: this.element,
            helper: this.helper,
            position: this.position,
            size: this.size,
            originalSize: this.originalSize,
            originalPosition: this.originalPosition
          }
        }
      });
      e.extend(e.ui.resizable, {version: "1.8.16"});
      e.ui.plugin.add("resizable", "alsoResize", {
        start: function () {
          var b = e(this).data("resizable").options, a = function (c) {
            e(c).each(function () {
              var d = e(this);
              d.data("resizable-alsoresize", {
                width: parseInt(d.width(),
                  10),
                height: parseInt(d.height(), 10),
                left: parseInt(d.css("left"), 10),
                top: parseInt(d.css("top"), 10),
                position: d.css("position")
              })
            })
          };
          if (typeof b.alsoResize == "object" && !b.alsoResize.parentNode) if (b.alsoResize.length) {
            b.alsoResize = b.alsoResize[0];
            a(b.alsoResize)
          } else e.each(b.alsoResize, function (c) {
            a(c)
          }); else a(b.alsoResize)
        }, resize: function (b, a) {
          var c = e(this).data("resizable");
          b = c.options;
          var d = c.originalSize, f = c.originalPosition, g = {
            height: c.size.height - d.height || 0, width: c.size.width - d.width || 0, top: c.position.top -
            f.top || 0, left: c.position.left - f.left || 0
          }, h = function (i, j) {
            e(i).each(function () {
              var l = e(this), q = e(this).data("resizable-alsoresize"), p = {},
                r = j && j.length ? j : l.parents(a.originalElement[0]).length ? ["width", "height"] : ["width", "height", "top", "left"];
              e.each(r, function (n, o) {
                if ((n = (q[o] || 0) + (g[o] || 0)) && n >= 0) p[o] = n || null
              });
              if (e.browser.opera && /relative/.test(l.css("position"))) {
                c._revertToRelativePosition = true;
                l.css({position: "absolute", top: "auto", left: "auto"})
              }
              l.css(p)
            })
          };
          typeof b.alsoResize == "object" && !b.alsoResize.nodeType ?
            e.each(b.alsoResize, function (i, j) {
              h(i, j)
            }) : h(b.alsoResize)
        }, stop: function () {
          var b = e(this).data("resizable"), a = b.options, c = function (d) {
            e(d).each(function () {
              var f = e(this);
              f.css({position: f.data("resizable-alsoresize").position})
            })
          };
          if (b._revertToRelativePosition) {
            b._revertToRelativePosition = false;
            typeof a.alsoResize == "object" && !a.alsoResize.nodeType ? e.each(a.alsoResize, function (d) {
              c(d)
            }) : c(a.alsoResize)
          }
          e(this).removeData("resizable-alsoresize")
        }
      });
      e.ui.plugin.add("resizable", "animate", {
        stop: function (b) {
          var a =
              e(this).data("resizable"), c = a.options, d = a._proportionallyResizeElements,
            f = d.length && /textarea/i.test(d[0].nodeName),
            g = f && e.ui.hasScroll(d[0], "left") ? 0 : a.sizeDiff.height;
          f = {width: a.size.width - (f ? 0 : a.sizeDiff.width), height: a.size.height - g};
          g = parseInt(a.element.css("left"), 10) + (a.position.left - a.originalPosition.left) || null;
          var h = parseInt(a.element.css("top"), 10) + (a.position.top - a.originalPosition.top) || null;
          a.element.animate(e.extend(f, h && g ? {top: h, left: g} : {}), {
            duration: c.animateDuration, easing: c.animateEasing,
            step: function () {
              var i = {
                width: parseInt(a.element.css("width"), 10),
                height: parseInt(a.element.css("height"), 10),
                top: parseInt(a.element.css("top"), 10),
                left: parseInt(a.element.css("left"), 10)
              };
              d && d.length && e(d[0]).css({width: i.width, height: i.height});
              a._updateCache(i);
              a._propagate("resize", b)
            }
          })
        }
      });
      e.ui.plugin.add("resizable", "containment", {
        start: function () {
          var b = e(this).data("resizable"), a = b.element, c = b.options.containment;
          if (a = c instanceof e ? c.get(0) : /parent/.test(c) ? a.parent().get(0) : c) {
            b.containerElement =
              e(a);
            if (/document/.test(c) || c == document) {
              b.containerOffset = {left: 0, top: 0};
              b.containerPosition = {left: 0, top: 0};
              b.parentData = {
                element: e(document),
                left: 0,
                top: 0,
                width: e(document).width(),
                height: e(document).height() || document.body.parentNode.scrollHeight
              }
            } else {
              var d = e(a), f = [];
              e(["Top", "Right", "Left", "Bottom"]).each(function (i, j) {
                f[i] = m(d.css("padding" + j))
              });
              b.containerOffset = d.offset();
              b.containerPosition = d.position();
              b.containerSize = {height: d.innerHeight() - f[3], width: d.innerWidth() - f[1]};
              c = b.containerOffset;
              var g = b.containerSize.height, h = b.containerSize.width;
              h = e.ui.hasScroll(a, "left") ? a.scrollWidth : h;
              g = e.ui.hasScroll(a) ? a.scrollHeight : g;
              b.parentData = {element: a, left: c.left, top: c.top, width: h, height: g}
            }
          }
        }, resize: function (b) {
          var a = e(this).data("resizable"), c = a.options, d = a.containerOffset, f = a.position;
          b = a._aspectRatio || b.shiftKey;
          var g = {top: 0, left: 0}, h = a.containerElement;
          if (h[0] != document && /(static)/.test(h.css("position"))) g = d;
          if (f.left < (a._helper ? d.left : 0)) {
            a.size.width += a._helper ? a.position.left - d.left :
              a.position.left - g.left;
            if (b) a.size.height = a.size.width / c.aspectRatio;
            a.position.left = c.helper ? d.left : 0
          }
          if (f.top < (a._helper ? d.top : 0)) {
            a.size.height += a._helper ? a.position.top - d.top : a.position.top;
            if (b) a.size.width = a.size.height * c.aspectRatio;
            a.position.top = a._helper ? d.top : 0
          }
          a.offset.left = a.parentData.left + a.position.left;
          a.offset.top = a.parentData.top + a.position.top;
          c = Math.abs((a._helper ? a.offset.left - g.left : a.offset.left - g.left) + a.sizeDiff.width);
          d = Math.abs((a._helper ? a.offset.top - g.top : a.offset.top -
            d.top) + a.sizeDiff.height);
          f = a.containerElement.get(0) == a.element.parent().get(0);
          g = /relative|absolute/.test(a.containerElement.css("position"));
          if (f && g) c -= a.parentData.left;
          if (c + a.size.width >= a.parentData.width) {
            a.size.width = a.parentData.width - c;
            if (b) a.size.height = a.size.width / a.aspectRatio
          }
          if (d + a.size.height >= a.parentData.height) {
            a.size.height = a.parentData.height - d;
            if (b) a.size.width = a.size.height * a.aspectRatio
          }
        }, stop: function () {
          var b = e(this).data("resizable"), a = b.options, c = b.containerOffset, d = b.containerPosition,
            f = b.containerElement, g = e(b.helper), h = g.offset(), i = g.outerWidth() - b.sizeDiff.width;
          g = g.outerHeight() - b.sizeDiff.height;
          b._helper && !a.animate && /relative/.test(f.css("position")) && e(this).css({
            left: h.left - d.left - c.left,
            width: i,
            height: g
          });
          b._helper && !a.animate && /(static)/.test(f.css("position")) && e(this).css({
            left: h.left - d.left - c.left,
            width: i,
            height: g
          })
        }
      });
      e.ui.plugin.add("resizable", "ghost", {
        start: function () {
          var b = e(this).data("resizable"), a = b.options, c = b.size;
          b.ghost = b.originalElement.clone();
          b.ghost.css({
            opacity: 0.25,
            display: "block", position: "relative", height: c.height, width: c.width, margin: 0, left: 0, top: 0
          }).addClass("ui-resizable-ghost").addClass(typeof a.ghost == "string" ? a.ghost : "");
          b.ghost.appendTo(b.helper)
        }, resize: function () {
          var b = e(this).data("resizable");
          b.ghost && b.ghost.css({position: "relative", height: b.size.height, width: b.size.width})
        }, stop: function () {
          var b = e(this).data("resizable");
          b.ghost && b.helper && b.helper.get(0).removeChild(b.ghost.get(0))
        }
      });
      e.ui.plugin.add("resizable", "grid", {
        resize: function () {
          var b =
              e(this).data("resizable"), a = b.options, c = b.size, d = b.originalSize, f = b.originalPosition,
            g = b.axis;
          a.grid = typeof a.grid == "number" ? [a.grid, a.grid] : a.grid;
          var h = Math.round((c.width - d.width) / (a.grid[0] || 1)) * (a.grid[0] || 1);
          a = Math.round((c.height - d.height) / (a.grid[1] || 1)) * (a.grid[1] || 1);
          if (/^(se|s|e)$/.test(g)) {
            b.size.width = d.width + h;
            b.size.height = d.height + a
          } else if (/^(ne)$/.test(g)) {
            b.size.width = d.width + h;
            b.size.height = d.height + a;
            b.position.top = f.top - a
          } else {
            if (/^(sw)$/.test(g)) {
              b.size.width = d.width + h;
              b.size.height =
                d.height + a
            } else {
              b.size.width = d.width + h;
              b.size.height = d.height + a;
              b.position.top = f.top - a
            }
            b.position.left = f.left - h
          }
        }
      });
      var m = function (b) {
        return parseInt(b, 10) || 0
      }, k = function (b) {
        return !isNaN(parseInt(b, 10))
      }
    })(jQuery);
    ;
    /*
 * jQuery UI Selectable 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Selectables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
    (function (e) {
      e.widget("ui.selectable", e.ui.mouse, {
        options: {appendTo: "body", autoRefresh: true, distance: 0, filter: "*", tolerance: "touch"},
        _create: function () {
          var c = this;
          this.element.addClass("ui-selectable");
          this.dragged = false;
          var f;
          this.refresh = function () {
            f = e(c.options.filter, c.element[0]);
            f.each(function () {
              var d = e(this), b = d.offset();
              e.data(this, "selectable-item", {
                element: this,
                $element: d,
                left: b.left,
                top: b.top,
                right: b.left + d.outerWidth(),
                bottom: b.top + d.outerHeight(),
                startselected: false,
                selected: d.hasClass("ui-selected"),
                selecting: d.hasClass("ui-selecting"),
                unselecting: d.hasClass("ui-unselecting")
              })
            })
          };
          this.refresh();
          this.selectees = f.addClass("ui-selectee");
          this._mouseInit();
          this.helper = e("<div class='ui-selectable-helper'></div>")
        },
        destroy: function () {
          this.selectees.removeClass("ui-selectee").removeData("selectable-item");
          this.element.removeClass("ui-selectable ui-selectable-disabled").removeData("selectable").unbind(".selectable");
          this._mouseDestroy();
          return this
        },
        _mouseStart: function (c) {
          var f = this;
          this.opos = [c.pageX,
            c.pageY];
          if (!this.options.disabled) {
            var d = this.options;
            this.selectees = e(d.filter, this.element[0]);
            this._trigger("start", c);
            e(d.appendTo).append(this.helper);
            this.helper.css({left: c.clientX, top: c.clientY, width: 0, height: 0});
            d.autoRefresh && this.refresh();
            this.selectees.filter(".ui-selected").each(function () {
              var b = e.data(this, "selectable-item");
              b.startselected = true;
              if (!c.metaKey) {
                b.$element.removeClass("ui-selected");
                b.selected = false;
                b.$element.addClass("ui-unselecting");
                b.unselecting = true;
                f._trigger("unselecting",
                  c, {unselecting: b.element})
              }
            });
            e(c.target).parents().andSelf().each(function () {
              var b = e.data(this, "selectable-item");
              if (b) {
                var g = !c.metaKey || !b.$element.hasClass("ui-selected");
                b.$element.removeClass(g ? "ui-unselecting" : "ui-selected").addClass(g ? "ui-selecting" : "ui-unselecting");
                b.unselecting = !g;
                b.selecting = g;
                (b.selected = g) ? f._trigger("selecting", c, {selecting: b.element}) : f._trigger("unselecting", c, {unselecting: b.element});
                return false
              }
            })
          }
        },
        _mouseDrag: function (c) {
          var f = this;
          this.dragged = true;
          if (!this.options.disabled) {
            var d =
              this.options, b = this.opos[0], g = this.opos[1], h = c.pageX, i = c.pageY;
            if (b > h) {
              var j = h;
              h = b;
              b = j
            }
            if (g > i) {
              j = i;
              i = g;
              g = j
            }
            this.helper.css({left: b, top: g, width: h - b, height: i - g});
            this.selectees.each(function () {
              var a = e.data(this, "selectable-item");
              if (!(!a || a.element == f.element[0])) {
                var k = false;
                if (d.tolerance == "touch") k = !(a.left > h || a.right < b || a.top > i || a.bottom < g); else if (d.tolerance == "fit") k = a.left > b && a.right < h && a.top > g && a.bottom < i;
                if (k) {
                  if (a.selected) {
                    a.$element.removeClass("ui-selected");
                    a.selected = false
                  }
                  if (a.unselecting) {
                    a.$element.removeClass("ui-unselecting");
                    a.unselecting = false
                  }
                  if (!a.selecting) {
                    a.$element.addClass("ui-selecting");
                    a.selecting = true;
                    f._trigger("selecting", c, {selecting: a.element})
                  }
                } else {
                  if (a.selecting) if (c.metaKey && a.startselected) {
                    a.$element.removeClass("ui-selecting");
                    a.selecting = false;
                    a.$element.addClass("ui-selected");
                    a.selected = true
                  } else {
                    a.$element.removeClass("ui-selecting");
                    a.selecting = false;
                    if (a.startselected) {
                      a.$element.addClass("ui-unselecting");
                      a.unselecting = true
                    }
                    f._trigger("unselecting", c, {unselecting: a.element})
                  }
                  if (a.selected) if (!c.metaKey &&
                    !a.startselected) {
                    a.$element.removeClass("ui-selected");
                    a.selected = false;
                    a.$element.addClass("ui-unselecting");
                    a.unselecting = true;
                    f._trigger("unselecting", c, {unselecting: a.element})
                  }
                }
              }
            });
            return false
          }
        },
        _mouseStop: function (c) {
          var f = this;
          this.dragged = false;
          e(".ui-unselecting", this.element[0]).each(function () {
            var d = e.data(this, "selectable-item");
            d.$element.removeClass("ui-unselecting");
            d.unselecting = false;
            d.startselected = false;
            f._trigger("unselected", c, {unselected: d.element})
          });
          e(".ui-selecting", this.element[0]).each(function () {
            var d =
              e.data(this, "selectable-item");
            d.$element.removeClass("ui-selecting").addClass("ui-selected");
            d.selecting = false;
            d.selected = true;
            d.startselected = true;
            f._trigger("selected", c, {selected: d.element})
          });
          this._trigger("stop", c);
          this.helper.remove();
          return false
        }
      });
      e.extend(e.ui.selectable, {version: "1.8.16"})
    })(jQuery);
    ;
    /*
 * jQuery UI Sortable 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Sortables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
    (function (d) {
      d.widget("ui.sortable", d.ui.mouse, {
        widgetEventPrefix: "sort",
        options: {
          appendTo: "parent",
          axis: false,
          connectWith: false,
          containment: false,
          cursor: "auto",
          cursorAt: false,
          dropOnEmpty: true,
          forcePlaceholderSize: false,
          forceHelperSize: false,
          grid: false,
          handle: false,
          helper: "original",
          items: "> *",
          opacity: false,
          placeholder: false,
          revert: false,
          scroll: true,
          scrollSensitivity: 20,
          scrollSpeed: 20,
          scope: "default",
          tolerance: "intersect",
          zIndex: 1E3
        },
        _create: function () {
          var a = this.options;
          this.containerCache = {};
          this.element.addClass("ui-sortable");
          this.refresh();
          this.floating = this.items.length ? a.axis === "x" || /left|right/.test(this.items[0].item.css("float")) || /inline|table-cell/.test(this.items[0].item.css("display")) : false;
          this.offset = this.element.offset();
          this._mouseInit()
        },
        destroy: function () {
          this.element.removeClass("ui-sortable ui-sortable-disabled").removeData("sortable").unbind(".sortable");
          this._mouseDestroy();
          for (var a = this.items.length - 1; a >= 0; a--) this.items[a].item.removeData("sortable-item");
          return this
        },
        _setOption: function (a, b) {
          if (a ===
            "disabled") {
            this.options[a] = b;
            this.widget()[b ? "addClass" : "removeClass"]("ui-sortable-disabled")
          } else d.Widget.prototype._setOption.apply(this, arguments)
        },
        _mouseCapture: function (a, b) {
          if (this.reverting) return false;
          if (this.options.disabled || this.options.type == "static") return false;
          this._refreshItems(a);
          var c = null, e = this;
          d(a.target).parents().each(function () {
            if (d.data(this, "sortable-item") == e) {
              c = d(this);
              return false
            }
          });
          if (d.data(a.target, "sortable-item") == e) c = d(a.target);
          if (!c) return false;
          if (this.options.handle &&
            !b) {
            var f = false;
            d(this.options.handle, c).find("*").andSelf().each(function () {
              if (this == a.target) f = true
            });
            if (!f) return false
          }
          this.currentItem = c;
          this._removeCurrentsFromItems();
          return true
        },
        _mouseStart: function (a, b, c) {
          b = this.options;
          var e = this;
          this.currentContainer = this;
          this.refreshPositions();
          this.helper = this._createHelper(a);
          this._cacheHelperProportions();
          this._cacheMargins();
          this.scrollParent = this.helper.scrollParent();
          this.offset = this.currentItem.offset();
          this.offset = {
            top: this.offset.top - this.margins.top,
            left: this.offset.left - this.margins.left
          };
          this.helper.css("position", "absolute");
          this.cssPosition = this.helper.css("position");
          d.extend(this.offset, {
            click: {left: a.pageX - this.offset.left, top: a.pageY - this.offset.top},
            parent: this._getParentOffset(),
            relative: this._getRelativeOffset()
          });
          this.originalPosition = this._generatePosition(a);
          this.originalPageX = a.pageX;
          this.originalPageY = a.pageY;
          b.cursorAt && this._adjustOffsetFromHelper(b.cursorAt);
          this.domPosition = {prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0]};
          this.helper[0] != this.currentItem[0] && this.currentItem.hide();
          this._createPlaceholder();
          b.containment && this._setContainment();
          if (b.cursor) {
            if (d("body").css("cursor")) this._storedCursor = d("body").css("cursor");
            d("body").css("cursor", b.cursor)
          }
          if (b.opacity) {
            if (this.helper.css("opacity")) this._storedOpacity = this.helper.css("opacity");
            this.helper.css("opacity", b.opacity)
          }
          if (b.zIndex) {
            if (this.helper.css("zIndex")) this._storedZIndex = this.helper.css("zIndex");
            this.helper.css("zIndex", b.zIndex)
          }
          if (this.scrollParent[0] !=
            document && this.scrollParent[0].tagName != "HTML") this.overflowOffset = this.scrollParent.offset();
          this._trigger("start", a, this._uiHash());
          this._preserveHelperProportions || this._cacheHelperProportions();
          if (!c) for (c = this.containers.length - 1; c >= 0; c--) this.containers[c]._trigger("activate", a, e._uiHash(this));
          if (d.ui.ddmanager) d.ui.ddmanager.current = this;
          d.ui.ddmanager && !b.dropBehaviour && d.ui.ddmanager.prepareOffsets(this, a);
          this.dragging = true;
          this.helper.addClass("ui-sortable-helper");
          this._mouseDrag(a);
          return true
        },
        _mouseDrag: function (a) {
          this.position = this._generatePosition(a);
          this.positionAbs = this._convertPositionTo("absolute");
          if (!this.lastPositionAbs) this.lastPositionAbs = this.positionAbs;
          if (this.options.scroll) {
            var b = this.options, c = false;
            if (this.scrollParent[0] != document && this.scrollParent[0].tagName != "HTML") {
              if (this.overflowOffset.top + this.scrollParent[0].offsetHeight - a.pageY < b.scrollSensitivity) this.scrollParent[0].scrollTop = c = this.scrollParent[0].scrollTop + b.scrollSpeed; else if (a.pageY - this.overflowOffset.top <
                b.scrollSensitivity) this.scrollParent[0].scrollTop = c = this.scrollParent[0].scrollTop - b.scrollSpeed;
              if (this.overflowOffset.left + this.scrollParent[0].offsetWidth - a.pageX < b.scrollSensitivity) this.scrollParent[0].scrollLeft = c = this.scrollParent[0].scrollLeft + b.scrollSpeed; else if (a.pageX - this.overflowOffset.left < b.scrollSensitivity) this.scrollParent[0].scrollLeft = c = this.scrollParent[0].scrollLeft - b.scrollSpeed
            } else {
              if (a.pageY - d(document).scrollTop() < b.scrollSensitivity) c = d(document).scrollTop(d(document).scrollTop() -
                b.scrollSpeed); else if (d(window).height() - (a.pageY - d(document).scrollTop()) < b.scrollSensitivity) c = d(document).scrollTop(d(document).scrollTop() + b.scrollSpeed);
              if (a.pageX - d(document).scrollLeft() < b.scrollSensitivity) c = d(document).scrollLeft(d(document).scrollLeft() - b.scrollSpeed); else if (d(window).width() - (a.pageX - d(document).scrollLeft()) < b.scrollSensitivity) c = d(document).scrollLeft(d(document).scrollLeft() + b.scrollSpeed)
            }
            c !== false && d.ui.ddmanager && !b.dropBehaviour && d.ui.ddmanager.prepareOffsets(this,
              a)
          }
          this.positionAbs = this._convertPositionTo("absolute");
          if (!this.options.axis || this.options.axis != "y") this.helper[0].style.left = this.position.left + "px";
          if (!this.options.axis || this.options.axis != "x") this.helper[0].style.top = this.position.top + "px";
          for (b = this.items.length - 1; b >= 0; b--) {
            c = this.items[b];
            var e = c.item[0], f = this._intersectsWithPointer(c);
            if (f) if (e != this.currentItem[0] && this.placeholder[f == 1 ? "next" : "prev"]()[0] != e && !d.ui.contains(this.placeholder[0], e) && (this.options.type == "semi-dynamic" ? !d.ui.contains(this.element[0],
              e) : true)) {
              this.direction = f == 1 ? "down" : "up";
              if (this.options.tolerance == "pointer" || this._intersectsWithSides(c)) this._rearrange(a, c); else break;
              this._trigger("change", a, this._uiHash());
              break
            }
          }
          this._contactContainers(a);
          d.ui.ddmanager && d.ui.ddmanager.drag(this, a);
          this._trigger("sort", a, this._uiHash());
          this.lastPositionAbs = this.positionAbs;
          return false
        },
        _mouseStop: function (a, b) {
          if (a) {
            d.ui.ddmanager && !this.options.dropBehaviour && d.ui.ddmanager.drop(this, a);
            if (this.options.revert) {
              var c = this;
              b = c.placeholder.offset();
              c.reverting = true;
              d(this.helper).animate({
                left: b.left - this.offset.parent.left - c.margins.left + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollLeft),
                top: b.top - this.offset.parent.top - c.margins.top + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollTop)
              }, parseInt(this.options.revert, 10) || 500, function () {
                c._clear(a)
              })
            } else this._clear(a, b);
            return false
          }
        },
        cancel: function () {
          var a = this;
          if (this.dragging) {
            this._mouseUp({target: null});
            this.options.helper == "original" ? this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper") :
              this.currentItem.show();
            for (var b = this.containers.length - 1; b >= 0; b--) {
              this.containers[b]._trigger("deactivate", null, a._uiHash(this));
              if (this.containers[b].containerCache.over) {
                this.containers[b]._trigger("out", null, a._uiHash(this));
                this.containers[b].containerCache.over = 0
              }
            }
          }
          if (this.placeholder) {
            this.placeholder[0].parentNode && this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
            this.options.helper != "original" && this.helper && this.helper[0].parentNode && this.helper.remove();
            d.extend(this, {
              helper: null,
              dragging: false, reverting: false, _noFinalSort: null
            });
            this.domPosition.prev ? d(this.domPosition.prev).after(this.currentItem) : d(this.domPosition.parent).prepend(this.currentItem)
          }
          return this
        },
        serialize: function (a) {
          var b = this._getItemsAsjQuery(a && a.connected), c = [];
          a = a || {};
          d(b).each(function () {
            var e = (d(a.item || this).attr(a.attribute || "id") || "").match(a.expression || /(.+)[-=_](.+)/);
            if (e) c.push((a.key || e[1] + "[]") + "=" + (a.key && a.expression ? e[1] : e[2]))
          });
          !c.length && a.key && c.push(a.key + "=");
          return c.join("&")
        },
        toArray: function (a) {
          var b = this._getItemsAsjQuery(a && a.connected), c = [];
          a = a || {};
          b.each(function () {
            c.push(d(a.item || this).attr(a.attribute || "id") || "")
          });
          return c
        },
        _intersectsWith: function (a) {
          var b = this.positionAbs.left, c = b + this.helperProportions.width, e = this.positionAbs.top,
            f = e + this.helperProportions.height, g = a.left, h = g + a.width, i = a.top, k = i + a.height,
            j = this.offset.click.top, l = this.offset.click.left;
          j = e + j > i && e + j < k && b + l > g && b + l < h;
          return this.options.tolerance == "pointer" || this.options.forcePointerForContainers ||
          this.options.tolerance != "pointer" && this.helperProportions[this.floating ? "width" : "height"] > a[this.floating ? "width" : "height"] ? j : g < b + this.helperProportions.width / 2 && c - this.helperProportions.width / 2 < h && i < e + this.helperProportions.height / 2 && f - this.helperProportions.height / 2 < k
        },
        _intersectsWithPointer: function (a) {
          var b = d.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, a.top, a.height);
          a = d.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, a.left, a.width);
          b = b && a;
          a = this._getDragVerticalDirection();
          var c = this._getDragHorizontalDirection();
          if (!b) return false;
          return this.floating ? c && c == "right" || a == "down" ? 2 : 1 : a && (a == "down" ? 2 : 1)
        },
        _intersectsWithSides: function (a) {
          var b = d.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, a.top + a.height / 2, a.height);
          a = d.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, a.left + a.width / 2, a.width);
          var c = this._getDragVerticalDirection(), e = this._getDragHorizontalDirection();
          return this.floating && e ? e == "right" && a || e == "left" && !a : c && (c == "down" && b || c == "up" && !b)
        },
        _getDragVerticalDirection: function () {
          var a = this.positionAbs.top - this.lastPositionAbs.top;
          return a != 0 && (a > 0 ? "down" : "up")
        },
        _getDragHorizontalDirection: function () {
          var a = this.positionAbs.left - this.lastPositionAbs.left;
          return a != 0 && (a > 0 ? "right" : "left")
        },
        refresh: function (a) {
          this._refreshItems(a);
          this.refreshPositions();
          return this
        },
        _connectWith: function () {
          var a = this.options;
          return a.connectWith.constructor == String ? [a.connectWith] : a.connectWith
        },
        _getItemsAsjQuery: function (a) {
          var b = [], c = [], e = this._connectWith();
          if (e && a) for (a = e.length - 1; a >= 0; a--) for (var f = d(e[a]), g = f.length - 1; g >= 0; g--) {
            var h = d.data(f[g], "sortable");
            if (h && h != this && !h.options.disabled) c.push([d.isFunction(h.options.items) ? h.options.items.call(h.element) : d(h.options.items, h.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), h])
          }
          c.push([d.isFunction(this.options.items) ? this.options.items.call(this.element, null, {
            options: this.options,
            item: this.currentItem
          }) : d(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),
            this]);
          for (a = c.length - 1; a >= 0; a--) c[a][0].each(function () {
            b.push(this)
          });
          return d(b)
        },
        _removeCurrentsFromItems: function () {
          for (var a = this.currentItem.find(":data(sortable-item)"), b = 0; b < this.items.length; b++) for (var c = 0; c < a.length; c++) a[c] == this.items[b].item[0] && this.items.splice(b, 1)
        },
        _refreshItems: function (a) {
          this.items = [];
          this.containers = [this];
          var b = this.items,
            c = [[d.isFunction(this.options.items) ? this.options.items.call(this.element[0], a, {item: this.currentItem}) : d(this.options.items, this.element),
              this]], e = this._connectWith();
          if (e) for (var f = e.length - 1; f >= 0; f--) for (var g = d(e[f]), h = g.length - 1; h >= 0; h--) {
            var i = d.data(g[h], "sortable");
            if (i && i != this && !i.options.disabled) {
              c.push([d.isFunction(i.options.items) ? i.options.items.call(i.element[0], a, {item: this.currentItem}) : d(i.options.items, i.element), i]);
              this.containers.push(i)
            }
          }
          for (f = c.length - 1; f >= 0; f--) {
            a = c[f][1];
            e = c[f][0];
            h = 0;
            for (g = e.length; h < g; h++) {
              i = d(e[h]);
              i.data("sortable-item", a);
              b.push({item: i, instance: a, width: 0, height: 0, left: 0, top: 0})
            }
          }
        },
        refreshPositions: function (a) {
          if (this.offsetParent &&
            this.helper) this.offset.parent = this._getParentOffset();
          for (var b = this.items.length - 1; b >= 0; b--) {
            var c = this.items[b];
            if (!(c.instance != this.currentContainer && this.currentContainer && c.item[0] != this.currentItem[0])) {
              var e = this.options.toleranceElement ? d(this.options.toleranceElement, c.item) : c.item;
              if (!a) {
                c.width = e.outerWidth();
                c.height = e.outerHeight()
              }
              e = e.offset();
              c.left = e.left;
              c.top = e.top
            }
          }
          if (this.options.custom && this.options.custom.refreshContainers) this.options.custom.refreshContainers.call(this); else for (b =
                                                                                                                                          this.containers.length - 1; b >= 0; b--) {
            e = this.containers[b].element.offset();
            this.containers[b].containerCache.left = e.left;
            this.containers[b].containerCache.top = e.top;
            this.containers[b].containerCache.width = this.containers[b].element.outerWidth();
            this.containers[b].containerCache.height = this.containers[b].element.outerHeight()
          }
          return this
        },
        _createPlaceholder: function (a) {
          var b = a || this, c = b.options;
          if (!c.placeholder || c.placeholder.constructor == String) {
            var e = c.placeholder;
            c.placeholder = {
              element: function () {
                var f =
                  d(document.createElement(b.currentItem[0].nodeName)).addClass(e || b.currentItem[0].className + " ui-sortable-placeholder").removeClass("ui-sortable-helper")[0];
                if (!e) f.style.visibility = "hidden";
                return f
              }, update: function (f, g) {
                if (!(e && !c.forcePlaceholderSize)) {
                  g.height() || g.height(b.currentItem.innerHeight() - parseInt(b.currentItem.css("paddingTop") || 0, 10) - parseInt(b.currentItem.css("paddingBottom") || 0, 10));
                  g.width() || g.width(b.currentItem.innerWidth() - parseInt(b.currentItem.css("paddingLeft") || 0, 10) - parseInt(b.currentItem.css("paddingRight") ||
                    0, 10))
                }
              }
            }
          }
          b.placeholder = d(c.placeholder.element.call(b.element, b.currentItem));
          b.currentItem.after(b.placeholder);
          c.placeholder.update(b, b.placeholder)
        },
        _contactContainers: function (a) {
          for (var b = null, c = null, e = this.containers.length - 1; e >= 0; e--) if (!d.ui.contains(this.currentItem[0], this.containers[e].element[0])) if (this._intersectsWith(this.containers[e].containerCache)) {
            if (!(b && d.ui.contains(this.containers[e].element[0], b.element[0]))) {
              b = this.containers[e];
              c = e
            }
          } else if (this.containers[e].containerCache.over) {
            this.containers[e]._trigger("out",
              a, this._uiHash(this));
            this.containers[e].containerCache.over = 0
          }
          if (b) if (this.containers.length === 1) {
            this.containers[c]._trigger("over", a, this._uiHash(this));
            this.containers[c].containerCache.over = 1
          } else if (this.currentContainer != this.containers[c]) {
            b = 1E4;
            e = null;
            for (var f = this.positionAbs[this.containers[c].floating ? "left" : "top"], g = this.items.length - 1; g >= 0; g--) if (d.ui.contains(this.containers[c].element[0], this.items[g].item[0])) {
              var h = this.items[g][this.containers[c].floating ? "left" : "top"];
              if (Math.abs(h -
                f) < b) {
                b = Math.abs(h - f);
                e = this.items[g]
              }
            }
            if (e || this.options.dropOnEmpty) {
              this.currentContainer = this.containers[c];
              e ? this._rearrange(a, e, null, true) : this._rearrange(a, null, this.containers[c].element, true);
              this._trigger("change", a, this._uiHash());
              this.containers[c]._trigger("change", a, this._uiHash(this));
              this.options.placeholder.update(this.currentContainer, this.placeholder);
              this.containers[c]._trigger("over", a, this._uiHash(this));
              this.containers[c].containerCache.over = 1
            }
          }
        },
        _createHelper: function (a) {
          var b =
            this.options;
          a = d.isFunction(b.helper) ? d(b.helper.apply(this.element[0], [a, this.currentItem])) : b.helper == "clone" ? this.currentItem.clone() : this.currentItem;
          a.parents("body").length || d(b.appendTo != "parent" ? b.appendTo : this.currentItem[0].parentNode)[0].appendChild(a[0]);
          if (a[0] == this.currentItem[0]) this._storedCSS = {
            width: this.currentItem[0].style.width,
            height: this.currentItem[0].style.height,
            position: this.currentItem.css("position"),
            top: this.currentItem.css("top"),
            left: this.currentItem.css("left")
          };
          if (a[0].style.width ==
            "" || b.forceHelperSize) a.width(this.currentItem.width());
          if (a[0].style.height == "" || b.forceHelperSize) a.height(this.currentItem.height());
          return a
        },
        _adjustOffsetFromHelper: function (a) {
          if (typeof a == "string") a = a.split(" ");
          if (d.isArray(a)) a = {left: +a[0], top: +a[1] || 0};
          if ("left" in a) this.offset.click.left = a.left + this.margins.left;
          if ("right" in a) this.offset.click.left = this.helperProportions.width - a.right + this.margins.left;
          if ("top" in a) this.offset.click.top = a.top + this.margins.top;
          if ("bottom" in a) this.offset.click.top =
            this.helperProportions.height - a.bottom + this.margins.top
        },
        _getParentOffset: function () {
          this.offsetParent = this.helper.offsetParent();
          var a = this.offsetParent.offset();
          if (this.cssPosition == "absolute" && this.scrollParent[0] != document && d.ui.contains(this.scrollParent[0], this.offsetParent[0])) {
            a.left += this.scrollParent.scrollLeft();
            a.top += this.scrollParent.scrollTop()
          }
          if (this.offsetParent[0] == document.body || this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() == "html" && d.browser.msie) a =
            {top: 0, left: 0};
          return {
            top: a.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
            left: a.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
          }
        },
        _getRelativeOffset: function () {
          if (this.cssPosition == "relative") {
            var a = this.currentItem.position();
            return {
              top: a.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
              left: a.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
            }
          } else return {top: 0, left: 0}
        },
        _cacheMargins: function () {
          this.margins = {
            left: parseInt(this.currentItem.css("marginLeft"),
              10) || 0, top: parseInt(this.currentItem.css("marginTop"), 10) || 0
          }
        },
        _cacheHelperProportions: function () {
          this.helperProportions = {width: this.helper.outerWidth(), height: this.helper.outerHeight()}
        },
        _setContainment: function () {
          var a = this.options;
          if (a.containment == "parent") a.containment = this.helper[0].parentNode;
          if (a.containment == "document" || a.containment == "window") this.containment = [0 - this.offset.relative.left - this.offset.parent.left, 0 - this.offset.relative.top - this.offset.parent.top, d(a.containment == "document" ?
            document : window).width() - this.helperProportions.width - this.margins.left, (d(a.containment == "document" ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top];
          if (!/^(document|window|parent)$/.test(a.containment)) {
            var b = d(a.containment)[0];
            a = d(a.containment).offset();
            var c = d(b).css("overflow") != "hidden";
            this.containment = [a.left + (parseInt(d(b).css("borderLeftWidth"), 10) || 0) + (parseInt(d(b).css("paddingLeft"), 10) || 0) - this.margins.left, a.top + (parseInt(d(b).css("borderTopWidth"),
              10) || 0) + (parseInt(d(b).css("paddingTop"), 10) || 0) - this.margins.top, a.left + (c ? Math.max(b.scrollWidth, b.offsetWidth) : b.offsetWidth) - (parseInt(d(b).css("borderLeftWidth"), 10) || 0) - (parseInt(d(b).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left, a.top + (c ? Math.max(b.scrollHeight, b.offsetHeight) : b.offsetHeight) - (parseInt(d(b).css("borderTopWidth"), 10) || 0) - (parseInt(d(b).css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top]
          }
        },
        _convertPositionTo: function (a, b) {
          if (!b) b =
            this.position;
          a = a == "absolute" ? 1 : -1;
          var c = this.cssPosition == "absolute" && !(this.scrollParent[0] != document && d.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
            e = /(html|body)/i.test(c[0].tagName);
          return {
            top: b.top + this.offset.relative.top * a + this.offset.parent.top * a - (d.browser.safari && this.cssPosition == "fixed" ? 0 : (this.cssPosition == "fixed" ? -this.scrollParent.scrollTop() : e ? 0 : c.scrollTop()) * a),
            left: b.left + this.offset.relative.left * a + this.offset.parent.left * a - (d.browser.safari &&
            this.cssPosition == "fixed" ? 0 : (this.cssPosition == "fixed" ? -this.scrollParent.scrollLeft() : e ? 0 : c.scrollLeft()) * a)
          }
        },
        _generatePosition: function (a) {
          var b = this.options,
            c = this.cssPosition == "absolute" && !(this.scrollParent[0] != document && d.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
            e = /(html|body)/i.test(c[0].tagName);
          if (this.cssPosition == "relative" && !(this.scrollParent[0] != document && this.scrollParent[0] != this.offsetParent[0])) this.offset.relative = this._getRelativeOffset();
          var f = a.pageX, g = a.pageY;
          if (this.originalPosition) {
            if (this.containment) {
              if (a.pageX - this.offset.click.left < this.containment[0]) f = this.containment[0] + this.offset.click.left;
              if (a.pageY - this.offset.click.top < this.containment[1]) g = this.containment[1] + this.offset.click.top;
              if (a.pageX - this.offset.click.left > this.containment[2]) f = this.containment[2] + this.offset.click.left;
              if (a.pageY - this.offset.click.top > this.containment[3]) g = this.containment[3] + this.offset.click.top
            }
            if (b.grid) {
              g = this.originalPageY + Math.round((g -
                this.originalPageY) / b.grid[1]) * b.grid[1];
              g = this.containment ? !(g - this.offset.click.top < this.containment[1] || g - this.offset.click.top > this.containment[3]) ? g : !(g - this.offset.click.top < this.containment[1]) ? g - b.grid[1] : g + b.grid[1] : g;
              f = this.originalPageX + Math.round((f - this.originalPageX) / b.grid[0]) * b.grid[0];
              f = this.containment ? !(f - this.offset.click.left < this.containment[0] || f - this.offset.click.left > this.containment[2]) ? f : !(f - this.offset.click.left < this.containment[0]) ? f - b.grid[0] : f + b.grid[0] : f
            }
          }
          return {
            top: g -
            this.offset.click.top - this.offset.relative.top - this.offset.parent.top + (d.browser.safari && this.cssPosition == "fixed" ? 0 : this.cssPosition == "fixed" ? -this.scrollParent.scrollTop() : e ? 0 : c.scrollTop()),
            left: f - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + (d.browser.safari && this.cssPosition == "fixed" ? 0 : this.cssPosition == "fixed" ? -this.scrollParent.scrollLeft() : e ? 0 : c.scrollLeft())
          }
        },
        _rearrange: function (a, b, c, e) {
          c ? c[0].appendChild(this.placeholder[0]) : b.item[0].parentNode.insertBefore(this.placeholder[0],
            this.direction == "down" ? b.item[0] : b.item[0].nextSibling);
          this.counter = this.counter ? ++this.counter : 1;
          var f = this, g = this.counter;
          window.setTimeout(function () {
            g == f.counter && f.refreshPositions(!e)
          }, 0)
        },
        _clear: function (a, b) {
          this.reverting = false;
          var c = [];
          !this._noFinalSort && this.currentItem.parent().length && this.placeholder.before(this.currentItem);
          this._noFinalSort = null;
          if (this.helper[0] == this.currentItem[0]) {
            for (var e in this._storedCSS) if (this._storedCSS[e] == "auto" || this._storedCSS[e] == "static") this._storedCSS[e] =
              "";
            this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper")
          } else this.currentItem.show();
          this.fromOutside && !b && c.push(function (f) {
            this._trigger("receive", f, this._uiHash(this.fromOutside))
          });
          if ((this.fromOutside || this.domPosition.prev != this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent != this.currentItem.parent()[0]) && !b) c.push(function (f) {
            this._trigger("update", f, this._uiHash())
          });
          if (!d.ui.contains(this.element[0], this.currentItem[0])) {
            b || c.push(function (f) {
              this._trigger("remove",
                f, this._uiHash())
            });
            for (e = this.containers.length - 1; e >= 0; e--) if (d.ui.contains(this.containers[e].element[0], this.currentItem[0]) && !b) {
              c.push(function (f) {
                return function (g) {
                  f._trigger("receive", g, this._uiHash(this))
                }
              }.call(this, this.containers[e]));
              c.push(function (f) {
                return function (g) {
                  f._trigger("update", g, this._uiHash(this))
                }
              }.call(this, this.containers[e]))
            }
          }
          for (e = this.containers.length - 1; e >= 0; e--) {
            b || c.push(function (f) {
              return function (g) {
                f._trigger("deactivate", g, this._uiHash(this))
              }
            }.call(this,
              this.containers[e]));
            if (this.containers[e].containerCache.over) {
              c.push(function (f) {
                return function (g) {
                  f._trigger("out", g, this._uiHash(this))
                }
              }.call(this, this.containers[e]));
              this.containers[e].containerCache.over = 0
            }
          }
          this._storedCursor && d("body").css("cursor", this._storedCursor);
          this._storedOpacity && this.helper.css("opacity", this._storedOpacity);
          if (this._storedZIndex) this.helper.css("zIndex", this._storedZIndex == "auto" ? "" : this._storedZIndex);
          this.dragging = false;
          if (this.cancelHelperRemoval) {
            if (!b) {
              this._trigger("beforeStop",
                a, this._uiHash());
              for (e = 0; e < c.length; e++) c[e].call(this, a);
              this._trigger("stop", a, this._uiHash())
            }
            return false
          }
          b || this._trigger("beforeStop", a, this._uiHash());
          this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
          this.helper[0] != this.currentItem[0] && this.helper.remove();
          this.helper = null;
          if (!b) {
            for (e = 0; e < c.length; e++) c[e].call(this, a);
            this._trigger("stop", a, this._uiHash())
          }
          this.fromOutside = false;
          return true
        },
        _trigger: function () {
          d.Widget.prototype._trigger.apply(this, arguments) === false && this.cancel()
        },
        _uiHash: function (a) {
          var b = a || this;
          return {
            helper: b.helper,
            placeholder: b.placeholder || d([]),
            position: b.position,
            originalPosition: b.originalPosition,
            offset: b.positionAbs,
            item: b.currentItem,
            sender: a ? a.element : null
          }
        }
      });
      d.extend(d.ui.sortable, {version: "1.8.16"})
    })(jQuery);
    ;
    /*
 * jQuery UI Accordion 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Accordion
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 */
    (function (c) {
      c.widget("ui.accordion", {
        options: {
          active: 0,
          animated: "slide",
          autoHeight: true,
          clearStyle: false,
          collapsible: false,
          event: "click",
          fillSpace: false,
          header: "> li > :first-child,> :not(li):even",
          icons: {header: "ui-icon-triangle-1-e", headerSelected: "ui-icon-triangle-1-s"},
          navigation: false,
          navigationFilter: function () {
            return this.href.toLowerCase() === location.href.toLowerCase()
          }
        }, _create: function () {
          var a = this, b = a.options;
          a.running = 0;
          a.element.addClass("ui-accordion ui-widget ui-helper-reset").children("li").addClass("ui-accordion-li-fix");
          a.headers = a.element.find(b.header).addClass("ui-accordion-header ui-helper-reset ui-state-default ui-corner-all").bind("mouseenter.accordion", function () {
            b.disabled || c(this).addClass("ui-state-hover")
          }).bind("mouseleave.accordion", function () {
            b.disabled || c(this).removeClass("ui-state-hover")
          }).bind("focus.accordion", function () {
            b.disabled || c(this).addClass("ui-state-focus")
          }).bind("blur.accordion", function () {
            b.disabled || c(this).removeClass("ui-state-focus")
          });
          a.headers.next().addClass("ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom");
          if (b.navigation) {
            var d = a.element.find("a").filter(b.navigationFilter).eq(0);
            if (d.length) {
              var h = d.closest(".ui-accordion-header");
              a.active = h.length ? h : d.closest(".ui-accordion-content").prev()
            }
          }
          a.active = a._findActive(a.active || b.active).addClass("ui-state-default ui-state-active").toggleClass("ui-corner-all").toggleClass("ui-corner-top");
          a.active.next().addClass("ui-accordion-content-active");
          a._createIcons();
          a.resize();
          a.element.attr("role", "tablist");
          a.headers.attr("role", "tab").bind("keydown.accordion",
            function (f) {
              return a._keydown(f)
            }).next().attr("role", "tabpanel");
          a.headers.not(a.active || "").attr({
            "aria-expanded": "false",
            "aria-selected": "false",
            tabIndex: -1
          }).next().hide();
          a.active.length ? a.active.attr({
            "aria-expanded": "true",
            "aria-selected": "true",
            tabIndex: 0
          }) : a.headers.eq(0).attr("tabIndex", 0);
          c.browser.safari || a.headers.find("a").attr("tabIndex", -1);
          b.event && a.headers.bind(b.event.split(" ").join(".accordion ") + ".accordion", function (f) {
            a._clickHandler.call(a, f, this);
            f.preventDefault()
          })
        }, _createIcons: function () {
          var a =
            this.options;
          if (a.icons) {
            c("<span></span>").addClass("ui-icon " + a.icons.header).prependTo(this.headers);
            this.active.children(".ui-icon").toggleClass(a.icons.header).toggleClass(a.icons.headerSelected);
            this.element.addClass("ui-accordion-icons")
          }
        }, _destroyIcons: function () {
          this.headers.children(".ui-icon").remove();
          this.element.removeClass("ui-accordion-icons")
        }, destroy: function () {
          var a = this.options;
          this.element.removeClass("ui-accordion ui-widget ui-helper-reset").removeAttr("role");
          this.headers.unbind(".accordion").removeClass("ui-accordion-header ui-accordion-disabled ui-helper-reset ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top").removeAttr("role").removeAttr("aria-expanded").removeAttr("aria-selected").removeAttr("tabIndex");
          this.headers.find("a").removeAttr("tabIndex");
          this._destroyIcons();
          var b = this.headers.next().css("display", "").removeAttr("role").removeClass("ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-accordion-disabled ui-state-disabled");
          if (a.autoHeight || a.fillHeight) b.css("height", "");
          return c.Widget.prototype.destroy.call(this)
        }, _setOption: function (a, b) {
          c.Widget.prototype._setOption.apply(this, arguments);
          a == "active" && this.activate(b);
          if (a == "icons") {
            this._destroyIcons();
            b && this._createIcons()
          }
          if (a == "disabled") this.headers.add(this.headers.next())[b ? "addClass" : "removeClass"]("ui-accordion-disabled ui-state-disabled")
        }, _keydown: function (a) {
          if (!(this.options.disabled || a.altKey || a.ctrlKey)) {
            var b = c.ui.keyCode, d = this.headers.length, h = this.headers.index(a.target), f = false;
            switch (a.keyCode) {
              case b.RIGHT:
              case b.DOWN:
                f = this.headers[(h + 1) % d];
                break;
              case b.LEFT:
              case b.UP:
                f = this.headers[(h - 1 + d) % d];
                break;
              case b.SPACE:
              case b.ENTER:
                this._clickHandler({target: a.target}, a.target);
                a.preventDefault()
            }
            if (f) {
              c(a.target).attr("tabIndex", -1);
              c(f).attr("tabIndex", 0);
              f.focus();
              return false
            }
            return true
          }
        }, resize: function () {
          var a = this.options, b;
          if (a.fillSpace) {
            if (c.browser.msie) {
              var d = this.element.parent().css("overflow");
              this.element.parent().css("overflow", "hidden")
            }
            b = this.element.parent().height();
            c.browser.msie && this.element.parent().css("overflow", d);
            this.headers.each(function () {
              b -= c(this).outerHeight(true)
            });
            this.headers.next().each(function () {
              c(this).height(Math.max(0, b - c(this).innerHeight() +
                c(this).height()))
            }).css("overflow", "auto")
          } else if (a.autoHeight) {
            b = 0;
            this.headers.next().each(function () {
              b = Math.max(b, c(this).height("").height())
            }).height(b)
          }
          return this
        }, activate: function (a) {
          this.options.active = a;
          a = this._findActive(a)[0];
          this._clickHandler({target: a}, a);
          return this
        }, _findActive: function (a) {
          return a ? typeof a === "number" ? this.headers.filter(":eq(" + a + ")") : this.headers.not(this.headers.not(a)) : a === false ? c([]) : this.headers.filter(":eq(0)")
        }, _clickHandler: function (a, b) {
          var d = this.options;
          if (!d.disabled) if (a.target) {
            a = c(a.currentTarget || b);
            b = a[0] === this.active[0];
            d.active = d.collapsible && b ? false : this.headers.index(a);
            if (!(this.running || !d.collapsible && b)) {
              var h = this.active;
              j = a.next();
              g = this.active.next();
              e = {
                options: d,
                newHeader: b && d.collapsible ? c([]) : a,
                oldHeader: this.active,
                newContent: b && d.collapsible ? c([]) : j,
                oldContent: g
              };
              var f = this.headers.index(this.active[0]) > this.headers.index(a[0]);
              this.active = b ? c([]) : a;
              this._toggle(j, g, e, b, f);
              h.removeClass("ui-state-active ui-corner-top").addClass("ui-state-default ui-corner-all").children(".ui-icon").removeClass(d.icons.headerSelected).addClass(d.icons.header);
              if (!b) {
                a.removeClass("ui-state-default ui-corner-all").addClass("ui-state-active ui-corner-top").children(".ui-icon").removeClass(d.icons.header).addClass(d.icons.headerSelected);
                a.next().addClass("ui-accordion-content-active")
              }
            }
          } else if (d.collapsible) {
            this.active.removeClass("ui-state-active ui-corner-top").addClass("ui-state-default ui-corner-all").children(".ui-icon").removeClass(d.icons.headerSelected).addClass(d.icons.header);
            this.active.next().addClass("ui-accordion-content-active");
            var g = this.active.next(),
              e = {options: d, newHeader: c([]), oldHeader: d.active, newContent: c([]), oldContent: g},
              j = this.active = c([]);
            this._toggle(j, g, e)
          }
        }, _toggle: function (a, b, d, h, f) {
          var g = this, e = g.options;
          g.toShow = a;
          g.toHide = b;
          g.data = d;
          var j = function () {
            if (g) return g._completed.apply(g, arguments)
          };
          g._trigger("changestart", null, g.data);
          g.running = b.size() === 0 ? a.size() : b.size();
          if (e.animated) {
            d = {};
            d = e.collapsible && h ? {
              toShow: c([]),
              toHide: b,
              complete: j,
              down: f,
              autoHeight: e.autoHeight || e.fillSpace
            } : {
              toShow: a, toHide: b, complete: j, down: f, autoHeight: e.autoHeight ||
              e.fillSpace
            };
            if (!e.proxied) e.proxied = e.animated;
            if (!e.proxiedDuration) e.proxiedDuration = e.duration;
            e.animated = c.isFunction(e.proxied) ? e.proxied(d) : e.proxied;
            e.duration = c.isFunction(e.proxiedDuration) ? e.proxiedDuration(d) : e.proxiedDuration;
            h = c.ui.accordion.animations;
            var i = e.duration, k = e.animated;
            if (k && !h[k] && !c.easing[k]) k = "slide";
            h[k] || (h[k] = function (l) {
              this.slide(l, {easing: k, duration: i || 700})
            });
            h[k](d)
          } else {
            if (e.collapsible && h) a.toggle(); else {
              b.hide();
              a.show()
            }
            j(true)
          }
          b.prev().attr({
            "aria-expanded": "false",
            "aria-selected": "false", tabIndex: -1
          }).blur();
          a.prev().attr({"aria-expanded": "true", "aria-selected": "true", tabIndex: 0}).focus()
        }, _completed: function (a) {
          this.running = a ? 0 : --this.running;
          if (!this.running) {
            this.options.clearStyle && this.toShow.add(this.toHide).css({height: "", overflow: ""});
            this.toHide.removeClass("ui-accordion-content-active");
            if (this.toHide.length) this.toHide.parent()[0].className = this.toHide.parent()[0].className;
            this._trigger("change", null, this.data)
          }
        }
      });
      c.extend(c.ui.accordion, {
        version: "1.8.16",
        animations: {
          slide: function (a, b) {
            a = c.extend({easing: "swing", duration: 300}, a, b);
            if (a.toHide.size()) if (a.toShow.size()) {
              var d = a.toShow.css("overflow"), h = 0, f = {}, g = {}, e;
              b = a.toShow;
              e = b[0].style.width;
              b.width(parseInt(b.parent().width(), 10) - parseInt(b.css("paddingLeft"), 10) - parseInt(b.css("paddingRight"), 10) - (parseInt(b.css("borderLeftWidth"), 10) || 0) - (parseInt(b.css("borderRightWidth"), 10) || 0));
              c.each(["height", "paddingTop", "paddingBottom"], function (j, i) {
                g[i] = "hide";
                j = ("" + c.css(a.toShow[0], i)).match(/^([\d+-.]+)(.*)$/);
                f[i] = {value: j[1], unit: j[2] || "px"}
              });
              a.toShow.css({height: 0, overflow: "hidden"}).show();
              a.toHide.filter(":hidden").each(a.complete).end().filter(":visible").animate(g, {
                step: function (j, i) {
                  if (i.prop == "height") h = i.end - i.start === 0 ? 0 : (i.now - i.start) / (i.end - i.start);
                  a.toShow[0].style[i.prop] = h * f[i.prop].value + f[i.prop].unit
                }, duration: a.duration, easing: a.easing, complete: function () {
                  a.autoHeight || a.toShow.css("height", "");
                  a.toShow.css({width: e, overflow: d});
                  a.complete()
                }
              })
            } else a.toHide.animate({
              height: "hide",
              paddingTop: "hide", paddingBottom: "hide"
            }, a); else a.toShow.animate({height: "show", paddingTop: "show", paddingBottom: "show"}, a)
          }, bounceslide: function (a) {
            this.slide(a, {easing: a.down ? "easeOutBounce" : "swing", duration: a.down ? 1E3 : 200})
          }
        }
      })
    })(jQuery);
    ;
    /*
 * jQuery UI Autocomplete 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Autocomplete
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *	jquery.ui.position.js
 */
    (function (d) {
      var e = 0;
      d.widget("ui.autocomplete", {
        options: {
          appendTo: "body",
          autoFocus: false,
          delay: 300,
          minLength: 1,
          position: {my: "left top", at: "left bottom", collision: "none"},
          source: null
        }, pending: 0, _create: function () {
          var a = this, b = this.element[0].ownerDocument, g;
          this.element.addClass("ui-autocomplete-input").attr("autocomplete", "off").attr({
            role: "textbox",
            "aria-autocomplete": "list",
            "aria-haspopup": "true"
          }).bind("keydown.autocomplete", function (c) {
            if (!(a.options.disabled || a.element.propAttr("readOnly"))) {
              g =
                false;
              var f = d.ui.keyCode;
              switch (c.keyCode) {
                case f.PAGE_UP:
                  a._move("previousPage", c);
                  break;
                case f.PAGE_DOWN:
                  a._move("nextPage", c);
                  break;
                case f.UP:
                  a._move("previous", c);
                  c.preventDefault();
                  break;
                case f.DOWN:
                  a._move("next", c);
                  c.preventDefault();
                  break;
                case f.ENTER:
                case f.NUMPAD_ENTER:
                  if (a.menu.active) {
                    g = true;
                    c.preventDefault()
                  }
                case f.TAB:
                  if (!a.menu.active) return;
                  a.menu.select(c);
                  break;
                case f.ESCAPE:
                  a.element.val(a.term);
                  a.close(c);
                  break;
                default:
                  clearTimeout(a.searching);
                  a.searching = setTimeout(function () {
                    if (a.term !=
                      a.element.val()) {
                      a.selectedItem = null;
                      a.search(null, c)
                    }
                  }, a.options.delay);
                  break
              }
            }
          }).bind("keypress.autocomplete", function (c) {
            if (g) {
              g = false;
              c.preventDefault()
            }
          }).bind("focus.autocomplete", function () {
            if (!a.options.disabled) {
              a.selectedItem = null;
              a.previous = a.element.val()
            }
          }).bind("blur.autocomplete", function (c) {
            if (!a.options.disabled) {
              clearTimeout(a.searching);
              a.closing = setTimeout(function () {
                a.close(c);
                a._change(c)
              }, 150)
            }
          });
          this._initSource();
          this.response = function () {
            return a._response.apply(a, arguments)
          };
          this.menu = d("<ul></ul>").addClass("ui-autocomplete").appendTo(d(this.options.appendTo || "body", b)[0]).mousedown(function (c) {
            var f = a.menu.element[0];
            d(c.target).closest(".ui-menu-item").length || setTimeout(function () {
              d(document).one("mousedown", function (h) {
                h.target !== a.element[0] && h.target !== f && !d.ui.contains(f, h.target) && a.close()
              })
            }, 1);
            setTimeout(function () {
              clearTimeout(a.closing)
            }, 13)
          }).menu({
            focus: function (c, f) {
              f = f.item.data("item.autocomplete");
              false !== a._trigger("focus", c, {item: f}) && /^key/.test(c.originalEvent.type) &&
              a.element.val(f.value)
            }, selected: function (c, f) {
              var h = f.item.data("item.autocomplete"), i = a.previous;
              if (a.element[0] !== b.activeElement) {
                a.element.focus();
                a.previous = i;
                setTimeout(function () {
                  a.previous = i;
                  a.selectedItem = h
                }, 1)
              }
              false !== a._trigger("select", c, {item: h}) && a.element.val(h.value);
              a.term = a.element.val();
              a.close(c);
              a.selectedItem = h
            }, blur: function () {
              a.menu.element.is(":visible") && a.element.val() !== a.term && a.element.val(a.term)
            }
          }).zIndex(this.element.zIndex() + 1).css({top: 0, left: 0}).hide().data("menu");
          d.fn.bgiframe && this.menu.element.bgiframe()
        }, destroy: function () {
          this.element.removeClass("ui-autocomplete-input").removeAttr("autocomplete").removeAttr("role").removeAttr("aria-autocomplete").removeAttr("aria-haspopup");
          this.menu.element.remove();
          d.Widget.prototype.destroy.call(this)
        }, _setOption: function (a, b) {
          d.Widget.prototype._setOption.apply(this, arguments);
          a === "source" && this._initSource();
          if (a === "appendTo") this.menu.element.appendTo(d(b || "body", this.element[0].ownerDocument)[0]);
          a === "disabled" &&
          b && this.xhr && this.xhr.abort()
        }, _initSource: function () {
          var a = this, b, g;
          if (d.isArray(this.options.source)) {
            b = this.options.source;
            this.source = function (c, f) {
              f(d.ui.autocomplete.filter(b, c.term))
            }
          } else if (typeof this.options.source === "string") {
            g = this.options.source;
            this.source = function (c, f) {
              a.xhr && a.xhr.abort();
              a.xhr = d.ajax({
                url: g, data: c, dataType: "json", autocompleteRequest: ++e, success: function (h) {
                  this.autocompleteRequest === e && f(h)
                }, error: function () {
                  this.autocompleteRequest === e && f([])
                }
              })
            }
          } else this.source =
            this.options.source
        }, search: function (a, b) {
          a = a != null ? a : this.element.val();
          this.term = this.element.val();
          if (a.length < this.options.minLength) return this.close(b);
          clearTimeout(this.closing);
          if (this._trigger("search", b) !== false) return this._search(a)
        }, _search: function (a) {
          this.pending++;
          this.element.addClass("ui-autocomplete-loading");
          this.source({term: a}, this.response)
        }, _response: function (a) {
          if (!this.options.disabled && a && a.length) {
            a = this._normalize(a);
            this._suggest(a);
            this._trigger("open")
          } else this.close();
          this.pending--;
          this.pending || this.element.removeClass("ui-autocomplete-loading")
        }, close: function (a) {
          clearTimeout(this.closing);
          if (this.menu.element.is(":visible")) {
            this.menu.element.hide();
            this.menu.deactivate();
            this._trigger("close", a)
          }
        }, _change: function (a) {
          this.previous !== this.element.val() && this._trigger("change", a, {item: this.selectedItem})
        }, _normalize: function (a) {
          if (a.length && a[0].label && a[0].value) return a;
          return d.map(a, function (b) {
            if (typeof b === "string") return {label: b, value: b};
            return d.extend({
              label: b.label ||
              b.value, value: b.value || b.label
            }, b)
          })
        }, _suggest: function (a) {
          var b = this.menu.element.empty().zIndex(this.element.zIndex() + 1);
          this._renderMenu(b, a);
          this.menu.deactivate();
          this.menu.refresh();
          b.show();
          this._resizeMenu();
          b.position(d.extend({of: this.element}, this.options.position));
          this.options.autoFocus && this.menu.next(new d.Event("mouseover"))
        }, _resizeMenu: function () {
          var a = this.menu.element;
          a.outerWidth(Math.max(a.width("").outerWidth(), this.element.outerWidth()))
        }, _renderMenu: function (a, b) {
          var g = this;
          d.each(b, function (c, f) {
            g._renderItem(a, f)
          })
        }, _renderItem: function (a, b) {
          return d("<li></li>").data("item.autocomplete", b).append(d("<a></a>").text(b.label)).appendTo(a)
        }, _move: function (a, b) {
          if (this.menu.element.is(":visible")) if (this.menu.first() && /^previous/.test(a) || this.menu.last() && /^next/.test(a)) {
            this.element.val(this.term);
            this.menu.deactivate()
          } else this.menu[a](b); else this.search(null, b)
        }, widget: function () {
          return this.menu.element
        }
      });
      d.extend(d.ui.autocomplete, {
        escapeRegex: function (a) {
          return a.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,
            "\\$&")
        }, filter: function (a, b) {
          var g = new RegExp(d.ui.autocomplete.escapeRegex(b), "i");
          return d.grep(a, function (c) {
            return g.test(c.label || c.value || c)
          })
        }
      })
    })(jQuery);
    (function (d) {
      d.widget("ui.menu", {
        _create: function () {
          var e = this;
          this.element.addClass("ui-menu ui-widget ui-widget-content ui-corner-all").attr({
            role: "listbox",
            "aria-activedescendant": "ui-active-menuitem"
          }).click(function (a) {
            if (d(a.target).closest(".ui-menu-item a").length) {
              a.preventDefault();
              e.select(a)
            }
          });
          this.refresh()
        }, refresh: function () {
          var e = this;
          this.element.children("li:not(.ui-menu-item):has(a)").addClass("ui-menu-item").attr("role", "menuitem").children("a").addClass("ui-corner-all").attr("tabindex",
            -1).mouseenter(function (a) {
            e.activate(a, d(this).parent())
          }).mouseleave(function () {
            e.deactivate()
          })
        }, activate: function (e, a) {
          this.deactivate();
          if (this.hasScroll()) {
            var b = a.offset().top - this.element.offset().top, g = this.element.scrollTop(), c = this.element.height();
            if (b < 0) this.element.scrollTop(g + b); else b >= c && this.element.scrollTop(g + b - c + a.height())
          }
          this.active = a.eq(0).children("a").addClass("ui-state-hover").attr("id", "ui-active-menuitem").end();
          this._trigger("focus", e, {item: a})
        }, deactivate: function () {
          if (this.active) {
            this.active.children("a").removeClass("ui-state-hover").removeAttr("id");
            this._trigger("blur");
            this.active = null
          }
        }, next: function (e) {
          this.move("next", ".ui-menu-item:first", e)
        }, previous: function (e) {
          this.move("prev", ".ui-menu-item:last", e)
        }, first: function () {
          return this.active && !this.active.prevAll(".ui-menu-item").length
        }, last: function () {
          return this.active && !this.active.nextAll(".ui-menu-item").length
        }, move: function (e, a, b) {
          if (this.active) {
            e = this.active[e + "All"](".ui-menu-item").eq(0);
            e.length ? this.activate(b, e) : this.activate(b, this.element.children(a))
          } else this.activate(b,
            this.element.children(a))
        }, nextPage: function (e) {
          if (this.hasScroll()) if (!this.active || this.last()) this.activate(e, this.element.children(".ui-menu-item:first")); else {
            var a = this.active.offset().top, b = this.element.height(),
              g = this.element.children(".ui-menu-item").filter(function () {
                var c = d(this).offset().top - a - b + d(this).height();
                return c < 10 && c > -10
              });
            g.length || (g = this.element.children(".ui-menu-item:last"));
            this.activate(e, g)
          } else this.activate(e, this.element.children(".ui-menu-item").filter(!this.active ||
          this.last() ? ":first" : ":last"))
        }, previousPage: function (e) {
          if (this.hasScroll()) if (!this.active || this.first()) this.activate(e, this.element.children(".ui-menu-item:last")); else {
            var a = this.active.offset().top, b = this.element.height();
            result = this.element.children(".ui-menu-item").filter(function () {
              var g = d(this).offset().top - a + b - d(this).height();
              return g < 10 && g > -10
            });
            result.length || (result = this.element.children(".ui-menu-item:first"));
            this.activate(e, result)
          } else this.activate(e, this.element.children(".ui-menu-item").filter(!this.active ||
          this.first() ? ":last" : ":first"))
        }, hasScroll: function () {
          return this.element.height() < this.element[d.fn.prop ? "prop" : "attr"]("scrollHeight")
        }, select: function (e) {
          this._trigger("selected", e, {item: this.active})
        }
      })
    })(jQuery);
    ;
    /*
 * jQuery UI Button 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Button
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 */
    (function (b) {
      var h, i, j, g, l = function () {
        var a = b(this).find(":ui-button");
        setTimeout(function () {
          a.button("refresh")
        }, 1)
      }, k = function (a) {
        var c = a.name, e = a.form, f = b([]);
        if (c) f = e ? b(e).find("[name='" + c + "']") : b("[name='" + c + "']", a.ownerDocument).filter(function () {
          return !this.form
        });
        return f
      };
      b.widget("ui.button", {
        options: {disabled: null, text: true, label: null, icons: {primary: null, secondary: null}},
        _create: function () {
          this.element.closest("form").unbind("reset.button").bind("reset.button", l);
          if (typeof this.options.disabled !==
            "boolean") this.options.disabled = this.element.propAttr("disabled");
          this._determineButtonType();
          this.hasTitle = !!this.buttonElement.attr("title");
          var a = this, c = this.options, e = this.type === "checkbox" || this.type === "radio",
            f = "ui-state-hover" + (!e ? " ui-state-active" : "");
          if (c.label === null) c.label = this.buttonElement.html();
          if (this.element.is(":disabled")) c.disabled = true;
          this.buttonElement.addClass("ui-button ui-widget ui-state-default ui-corner-all").attr("role", "button").bind("mouseenter.button", function () {
            if (!c.disabled) {
              b(this).addClass("ui-state-hover");
              this === h && b(this).addClass("ui-state-active")
            }
          }).bind("mouseleave.button", function () {
            c.disabled || b(this).removeClass(f)
          }).bind("click.button", function (d) {
            if (c.disabled) {
              d.preventDefault();
              d.stopImmediatePropagation()
            }
          });
          this.element.bind("focus.button", function () {
            a.buttonElement.addClass("ui-state-focus")
          }).bind("blur.button", function () {
            a.buttonElement.removeClass("ui-state-focus")
          });
          if (e) {
            this.element.bind("change.button", function () {
              g || a.refresh()
            });
            this.buttonElement.bind("mousedown.button", function (d) {
              if (!c.disabled) {
                g =
                  false;
                i = d.pageX;
                j = d.pageY
              }
            }).bind("mouseup.button", function (d) {
              if (!c.disabled) if (i !== d.pageX || j !== d.pageY) g = true
            })
          }
          if (this.type === "checkbox") this.buttonElement.bind("click.button", function () {
            if (c.disabled || g) return false;
            b(this).toggleClass("ui-state-active");
            a.buttonElement.attr("aria-pressed", a.element[0].checked)
          }); else if (this.type === "radio") this.buttonElement.bind("click.button", function () {
            if (c.disabled || g) return false;
            b(this).addClass("ui-state-active");
            a.buttonElement.attr("aria-pressed", "true");
            var d = a.element[0];
            k(d).not(d).map(function () {
              return b(this).button("widget")[0]
            }).removeClass("ui-state-active").attr("aria-pressed", "false")
          }); else {
            this.buttonElement.bind("mousedown.button", function () {
              if (c.disabled) return false;
              b(this).addClass("ui-state-active");
              h = this;
              b(document).one("mouseup", function () {
                h = null
              })
            }).bind("mouseup.button", function () {
              if (c.disabled) return false;
              b(this).removeClass("ui-state-active")
            }).bind("keydown.button", function (d) {
              if (c.disabled) return false;
              if (d.keyCode == b.ui.keyCode.SPACE ||
                d.keyCode == b.ui.keyCode.ENTER) b(this).addClass("ui-state-active")
            }).bind("keyup.button", function () {
              b(this).removeClass("ui-state-active")
            });
            this.buttonElement.is("a") && this.buttonElement.keyup(function (d) {
              d.keyCode === b.ui.keyCode.SPACE && b(this).click()
            })
          }
          this._setOption("disabled", c.disabled);
          this._resetButton()
        },
        _determineButtonType: function () {
          this.type = this.element.is(":checkbox") ? "checkbox" : this.element.is(":radio") ? "radio" : this.element.is("input") ? "input" : "button";
          if (this.type === "checkbox" || this.type ===
            "radio") {
            var a = this.element.parents().filter(":last"), c = "label[for='" + this.element.attr("id") + "']";
            this.buttonElement = a.find(c);
            if (!this.buttonElement.length) {
              a = a.length ? a.siblings() : this.element.siblings();
              this.buttonElement = a.filter(c);
              if (!this.buttonElement.length) this.buttonElement = a.find(c)
            }
            this.element.addClass("ui-helper-hidden-accessible");
            (a = this.element.is(":checked")) && this.buttonElement.addClass("ui-state-active");
            this.buttonElement.attr("aria-pressed", a)
          } else this.buttonElement = this.element
        },
        widget: function () {
          return this.buttonElement
        },
        destroy: function () {
          this.element.removeClass("ui-helper-hidden-accessible");
          this.buttonElement.removeClass("ui-button ui-widget ui-state-default ui-corner-all ui-state-hover ui-state-active  ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only").removeAttr("role").removeAttr("aria-pressed").html(this.buttonElement.find(".ui-button-text").html());
          this.hasTitle || this.buttonElement.removeAttr("title");
          b.Widget.prototype.destroy.call(this)
        },
        _setOption: function (a, c) {
          b.Widget.prototype._setOption.apply(this, arguments);
          if (a === "disabled") c ? this.element.propAttr("disabled", true) : this.element.propAttr("disabled", false); else this._resetButton()
        },
        refresh: function () {
          var a = this.element.is(":disabled");
          a !== this.options.disabled && this._setOption("disabled", a);
          if (this.type === "radio") k(this.element[0]).each(function () {
            b(this).is(":checked") ? b(this).button("widget").addClass("ui-state-active").attr("aria-pressed",
              "true") : b(this).button("widget").removeClass("ui-state-active").attr("aria-pressed", "false")
          }); else if (this.type === "checkbox") this.element.is(":checked") ? this.buttonElement.addClass("ui-state-active").attr("aria-pressed", "true") : this.buttonElement.removeClass("ui-state-active").attr("aria-pressed", "false")
        },
        _resetButton: function () {
          if (this.type === "input") this.options.label && this.element.val(this.options.label); else {
            var a = this.buttonElement.removeClass("ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only"),
              c = b("<span></span>").addClass("ui-button-text").html(this.options.label).appendTo(a.empty()).text(),
              e = this.options.icons, f = e.primary && e.secondary, d = [];
            if (e.primary || e.secondary) {
              if (this.options.text) d.push("ui-button-text-icon" + (f ? "s" : e.primary ? "-primary" : "-secondary"));
              e.primary && a.prepend("<span class='ui-button-icon-primary ui-icon " + e.primary + "'></span>");
              e.secondary && a.append("<span class='ui-button-icon-secondary ui-icon " + e.secondary + "'></span>");
              if (!this.options.text) {
                d.push(f ? "ui-button-icons-only" :
                  "ui-button-icon-only");
                this.hasTitle || a.attr("title", c)
              }
            } else d.push("ui-button-text-only");
            a.addClass(d.join(" "))
          }
        }
      });
      b.widget("ui.buttonset", {
        options: {items: ":button, :submit, :reset, :checkbox, :radio, a, :data(button)"}, _create: function () {
          this.element.addClass("ui-buttonset")
        }, _init: function () {
          this.refresh()
        }, _setOption: function (a, c) {
          a === "disabled" && this.buttons.button("option", a, c);
          b.Widget.prototype._setOption.apply(this, arguments)
        }, refresh: function () {
          var a = this.element.css("direction") ===
            "ltr";
          this.buttons = this.element.find(this.options.items).filter(":ui-button").button("refresh").end().not(":ui-button").button().end().map(function () {
            return b(this).button("widget")[0]
          }).removeClass("ui-corner-all ui-corner-left ui-corner-right").filter(":first").addClass(a ? "ui-corner-left" : "ui-corner-right").end().filter(":last").addClass(a ? "ui-corner-right" : "ui-corner-left").end().end()
        }, destroy: function () {
          this.element.removeClass("ui-buttonset");
          this.buttons.map(function () {
            return b(this).button("widget")[0]
          }).removeClass("ui-corner-left ui-corner-right").end().button("destroy");
          b.Widget.prototype.destroy.call(this)
        }
      })
    })(jQuery);
    ;
    /*
 * jQuery UI Dialog 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Dialog
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *  jquery.ui.button.js
 *	jquery.ui.draggable.js
 *	jquery.ui.mouse.js
 *	jquery.ui.position.js
 *	jquery.ui.resizable.js
 */
    (function (c, l) {
      var m = {
        buttons: true,
        height: true,
        maxHeight: true,
        maxWidth: true,
        minHeight: true,
        minWidth: true,
        width: true
      }, n = {maxHeight: true, maxWidth: true, minHeight: true, minWidth: true}, o = c.attrFn || {
        val: true,
        css: true,
        html: true,
        text: true,
        data: true,
        width: true,
        height: true,
        offset: true,
        click: true
      };
      c.widget("ui.dialog", {
        options: {
          autoOpen: true,
          buttons: {},
          closeOnEscape: true,
          closeText: "close",
          dialogClass: "",
          draggable: true,
          hide: null,
          height: "auto",
          maxHeight: false,
          maxWidth: false,
          minHeight: 150,
          minWidth: 150,
          modal: false,
          position: {
            my: "center", at: "center", collision: "fit", using: function (a) {
              var b = c(this).css(a).offset().top;
              b < 0 && c(this).css("top", a.top - b)
            }
          },
          resizable: true,
          show: null,
          stack: true,
          title: "",
          width: 300,
          zIndex: 1E3
        }, _create: function () {
          this.originalTitle = this.element.attr("title");
          if (typeof this.originalTitle !== "string") this.originalTitle = "";
          this.options.title = this.options.title || this.originalTitle;
          var a = this, b = a.options, d = b.title || "&#160;", e = c.ui.dialog.getTitleId(a.element),
            g = (a.uiDialog = c("<div></div>")).appendTo(document.body).hide().addClass("ui-dialog ui-widget ui-widget-content ui-corner-all " +
              b.dialogClass).css({zIndex: b.zIndex}).attr("tabIndex", -1).css("outline", 0).keydown(function (i) {
              if (b.closeOnEscape && !i.isDefaultPrevented() && i.keyCode && i.keyCode === c.ui.keyCode.ESCAPE) {
                a.close(i);
                i.preventDefault()
              }
            }).attr({role: "dialog", "aria-labelledby": e}).mousedown(function (i) {
              a.moveToTop(false, i)
            });
          /* En cliquant sur un des boutons de l'entte, la fentre d'annotation se ferme*/
          $(".header a").click(function(i){ if(a._isOpen == true) a.close(i) });
          /* La fonction urlHandler permet de vrifier si l'url a chang */
          function urlHandler(){
            this.oldUrl = window.location.href;
            this.Check;
            var that = this;
            /* La fonction detect permet de dtecter le changement d'url  */
            var detect = function(){
              if(that.oldUrl!=window.location.href && a._isOpen == true){
                that.oldUrl = window.location.href;
                a.close();
              }
            };
            /* La fonction detect() est appele toutes les 100ms */
            this.Check = setInterval(function(){ detect() }, 100);
          }
          /* Appel de la fonction urlHandler */
          var urlDetection = new urlHandler();
          a.element.show().removeAttr("title").addClass("ui-dialog-content ui-widget-content").appendTo(g);
          var f = (a.uiDialogTitlebar = c("<div></div>")).addClass("ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix").prependTo(g),
            h = c('<a href="#"></a>').addClass("ui-dialog-titlebar-close ui-corner-all").attr("role", "button").hover(function () {
              h.addClass("ui-state-hover")
            }, function () {
              h.removeClass("ui-state-hover")
            }).focus(function () {
              h.addClass("ui-state-focus")
            }).blur(function () {
              h.removeClass("ui-state-focus")
            }).click(function (i) {
              a.close(i);
              return false
            }).appendTo(f);
          (a.uiDialogTitlebarCloseText = c("<span></span>")).addClass("ui-icon ui-icon-closethick").text(b.closeText).appendTo(h);
          c("<span></span>").addClass("ui-dialog-title").attr("id",
            e).html(d).prependTo(f);
          if (c.isFunction(b.beforeclose) && !c.isFunction(b.beforeClose)) b.beforeClose = b.beforeclose;
          f.find("*").add(f).disableSelection();
          b.draggable && c.fn.draggable && a._makeDraggable();
          b.resizable && c.fn.resizable && a._makeResizable();
          a._createButtons(b.buttons);
          a._isOpen = false;
          c.fn.bgiframe && g.bgiframe()
        }, _init: function () {
          this.options.autoOpen && this.open()
        }, destroy: function () {
          var a = this;
          a.overlay && a.overlay.destroy();
          a.uiDialog.hide();
          a.element.unbind(".dialog").removeData("dialog").removeClass("ui-dialog-content ui-widget-content").hide().appendTo("body");
          a.uiDialog.remove();
          a.originalTitle && a.element.attr("title", a.originalTitle);
          return a
        }, widget: function () {
          return this.uiDialog
        }, close: function (a) {
          var b = this, d, e;
          if (false !== b._trigger("beforeClose", a)) {
            b.overlay && b.overlay.destroy();
            b.uiDialog.unbind("keypress.ui-dialog");
            b._isOpen = false;
            if (b.options.hide) b.uiDialog.hide(b.options.hide, function () {
              b._trigger("close", a)
            }); else {
              b.uiDialog.hide();
              b._trigger("close", a)
            }
            c.ui.dialog.overlay.resize();
            if (b.options.modal) {
              d = 0;
              c(".ui-dialog").each(function () {
                if (this !==
                  b.uiDialog[0]) {
                  e = c(this).css("z-index");
                  isNaN(e) || (d = Math.max(d, e))
                }
              });
              c.ui.dialog.maxZ = d
            }
            return b
          }
        }, isOpen: function () {
          return this._isOpen
        }, moveToTop: function (a, b) {
          var d = this, e = d.options;
          if (e.modal && !a || !e.stack && !e.modal) return d._trigger("focus", b);
          if (e.zIndex > c.ui.dialog.maxZ) c.ui.dialog.maxZ = e.zIndex;
          if (d.overlay) {
            c.ui.dialog.maxZ += 1;
            d.overlay.$el.css("z-index", c.ui.dialog.overlay.maxZ = c.ui.dialog.maxZ)
          }
          a = {scrollTop: d.element.scrollTop(), scrollLeft: d.element.scrollLeft()};
          c.ui.dialog.maxZ += 1;
          d.uiDialog.css("z-index", c.ui.dialog.maxZ);
          d.element.attr(a);
          d._trigger("focus", b);
          return d
        }, open: function () {
          if (!this._isOpen) {
            var a = this, b = a.options, d = a.uiDialog;
            a.overlay = b.modal ? new c.ui.dialog.overlay(a) : null;
            a._size();
            a._position(b.position);
            d.show(b.show);
            a.moveToTop(true);
            b.modal && d.bind("keypress.ui-dialog", function (e) {
              if (e.keyCode === c.ui.keyCode.TAB) {
                var g = c(":tabbable", this), f = g.filter(":first");
                g = g.filter(":last");
                if (e.target === g[0] && !e.shiftKey) {
                  f.focus(1);
                  return false
                } else if (e.target ===
                  f[0] && e.shiftKey) {
                  g.focus(1);
                  return false
                }
              }
            });
            c(a.element.find(":tabbable").get().concat(d.find(".ui-dialog-buttonpane :tabbable").get().concat(d.get()))).eq(0).focus();
            a._isOpen = true;
            a._trigger("open");
            return a
          }
        }, _createButtons: function (a) {
          var b = this, d = false,
            e = c("<div></div>").addClass("ui-dialog-buttonpane ui-widget-content ui-helper-clearfix"),
            g = c("<div></div>").addClass("ui-dialog-buttonset").appendTo(e);
          b.uiDialog.find(".ui-dialog-buttonpane").remove();
          typeof a === "object" && a !== null && c.each(a,
            function () {
              return !(d = true)
            });
          if (d) {
            c.each(a, function (f, h) {
              h = c.isFunction(h) ? {click: h, text: f} : h;
              var i = c('<button type="button"></button>').click(function () {
                h.click.apply(b.element[0], arguments)
              }).appendTo(g);
              c.each(h, function (j, k) {
                if (j !== "click") j in o ? i[j](k) : i.attr(j, k)
              });
              c.fn.button && i.button()
            });
            e.appendTo(b.uiDialog)
          }
        }, _makeDraggable: function () {
          function a(f) {
            return {position: f.position, offset: f.offset}
          }

          var b = this, d = b.options, e = c(document), g;
          b.uiDialog.draggable({
            cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
            handle: ".ui-dialog-titlebar", containment: "document", start: function (f, h) {
              g = d.height === "auto" ? "auto" : c(this).height();
              c(this).height(c(this).height()).addClass("ui-dialog-dragging");
              b._trigger("dragStart", f, a(h))
            }, drag: function (f, h) {
              b._trigger("drag", f, a(h))
            }, stop: function (f, h) {
              d.position = [h.position.left - e.scrollLeft(), h.position.top - e.scrollTop()];
              c(this).removeClass("ui-dialog-dragging").height(g);
              b._trigger("dragStop", f, a(h));
              c.ui.dialog.overlay.resize()
            }
          })
        }, _makeResizable: function (a) {
          function b(f) {
            return {
              originalPosition: f.originalPosition,
              originalSize: f.originalSize, position: f.position, size: f.size
            }
          }

          a = a === l ? this.options.resizable : a;
          var d = this, e = d.options, g = d.uiDialog.css("position");
          a = typeof a === "string" ? a : "n,e,s,w,se,sw,ne,nw";
          d.uiDialog.resizable({
            cancel: ".ui-dialog-content",
            containment: "document",
            alsoResize: d.element,
            maxWidth: e.maxWidth,
            maxHeight: e.maxHeight,
            minWidth: e.minWidth,
            minHeight: d._minHeight(),
            handles: a,
            start: function (f, h) {
              c(this).addClass("ui-dialog-resizing");
              d._trigger("resizeStart", f, b(h))
            },
            resize: function (f, h) {
              d._trigger("resize",
                f, b(h))
            },
            stop: function (f, h) {
              c(this).removeClass("ui-dialog-resizing");
              e.height = c(this).height();
              e.width = c(this).width();
              d._trigger("resizeStop", f, b(h));
              c.ui.dialog.overlay.resize()
            }
          }).css("position", g).find(".ui-resizable-se").addClass("ui-icon ui-icon-grip-diagonal-se")
        }, _minHeight: function () {
          var a = this.options;
          return a.height === "auto" ? a.minHeight : Math.min(a.minHeight, a.height)
        }, _position: function (a) {
          var b = [], d = [0, 0], e;
          if (a) {
            if (typeof a === "string" || typeof a === "object" && "0" in a) {
              b = a.split ? a.split(" ") :
                [a[0], a[1]];
              if (b.length === 1) b[1] = b[0];
              c.each(["left", "top"], function (g, f) {
                if (+b[g] === b[g]) {
                  d[g] = b[g];
                  b[g] = f
                }
              });
              a = {my: b.join(" "), at: b.join(" "), offset: d.join(" ")}
            }
            a = c.extend({}, c.ui.dialog.prototype.options.position, a)
          } else a = c.ui.dialog.prototype.options.position;
          (e = this.uiDialog.is(":visible")) || this.uiDialog.show();
          this.uiDialog.css({top: 0, left: 0}).position(c.extend({of: window}, a));
          e || this.uiDialog.hide()
        }, _setOptions: function (a) {
          var b = this, d = {}, e = false;
          c.each(a, function (g, f) {
            b._setOption(g, f);
            if (g in m) e = true;
            if (g in n) d[g] = f
          });
          e && this._size();
          this.uiDialog.is(":data(resizable)") && this.uiDialog.resizable("option", d)
        }, _setOption: function (a, b) {
          var d = this, e = d.uiDialog;
          switch (a) {
            case "beforeclose":
              a = "beforeClose";
              break;
            case "buttons":
              d._createButtons(b);
              break;
            case "closeText":
              d.uiDialogTitlebarCloseText.text("" + b);
              break;
            case "dialogClass":
              e.removeClass(d.options.dialogClass).addClass("ui-dialog ui-widget ui-widget-content ui-corner-all " + b);
              break;
            case "disabled":
              b ? e.addClass("ui-dialog-disabled") :
                e.removeClass("ui-dialog-disabled");
              break;
            case "draggable":
              var g = e.is(":data(draggable)");
              g && !b && e.draggable("destroy");
              !g && b && d._makeDraggable();
              break;
            case "position":
              d._position(b);
              break;
            case "resizable":
              (g = e.is(":data(resizable)")) && !b && e.resizable("destroy");
              g && typeof b === "string" && e.resizable("option", "handles", b);
              !g && b !== false && d._makeResizable(b);
              break;
            case "title":
              c(".ui-dialog-title", d.uiDialogTitlebar).html("" + (b || "&#160;"));
              break
          }
          c.Widget.prototype._setOption.apply(d, arguments)
        }, _size: function () {
          var a =
            this.options, b, d, e = this.uiDialog.is(":visible");
          this.element.show().css({width: "auto", minHeight: 0, height: 0});
          if (a.minWidth > a.width) a.width = a.minWidth;
          b = this.uiDialog.css({height: "auto", width: a.width}).height();
          d = Math.max(0, a.minHeight - b);
          if (a.height === "auto") if (c.support.minHeight) this.element.css({minHeight: d, height: "auto"}); else {
            this.uiDialog.show();
            a = this.element.css("height", "auto").height();
            e || this.uiDialog.hide();
            this.element.height(Math.max(a, d))
          } else this.element.height(Math.max(a.height -
            b, 0));
          this.uiDialog.is(":data(resizable)") && this.uiDialog.resizable("option", "minHeight", this._minHeight())
        }
      });
      c.extend(c.ui.dialog, {
        version: "1.8.16", uuid: 0, maxZ: 0, getTitleId: function (a) {
          a = a.attr("id");
          if (!a) {
            this.uuid += 1;
            a = this.uuid
          }
          return "ui-dialog-title-" + a
        }, overlay: function (a) {
          this.$el = c.ui.dialog.overlay.create(a)
        }
      });
      c.extend(c.ui.dialog.overlay, {
        instances: [],
        oldInstances: [],
        maxZ: 0,
        events: c.map("focus,mousedown,mouseup,keydown,keypress,click".split(","), function (a) {
          return a + ".dialog-overlay"
        }).join(" "),
        create: function (a) {
          if (this.instances.length === 0) {
            setTimeout(function () {
              c.ui.dialog.overlay.instances.length && c(document).bind(c.ui.dialog.overlay.events, function (d) {
                if (c(d.target).zIndex() < c.ui.dialog.overlay.maxZ) return false
              })
            }, 1);
            c(document).bind("keydown.dialog-overlay", function (d) {
              if (a.options.closeOnEscape && !d.isDefaultPrevented() && d.keyCode && d.keyCode === c.ui.keyCode.ESCAPE) {
                a.close(d);
                d.preventDefault()
              }
            });
            c(window).bind("resize.dialog-overlay", c.ui.dialog.overlay.resize)
          }
          var b = (this.oldInstances.pop() ||
            c("<div></div>").addClass("ui-widget-overlay")).appendTo(document.body).css({
            width: this.width(),
            height: this.height()
          });
          c.fn.bgiframe && b.bgiframe();
          this.instances.push(b);
          return b
        },
        destroy: function (a) {
          var b = c.inArray(a, this.instances);
          b != -1 && this.oldInstances.push(this.instances.splice(b, 1)[0]);
          this.instances.length === 0 && c([document, window]).unbind(".dialog-overlay");
          a.remove();
          var d = 0;
          c.each(this.instances, function () {
            d = Math.max(d, this.css("z-index"))
          });
          this.maxZ = d
        },
        height: function () {
          var a, b;
          if (c.browser.msie &&
            c.browser.version < 7) {
            a = Math.max(document.documentElement.scrollHeight, document.body.scrollHeight);
            b = Math.max(document.documentElement.offsetHeight, document.body.offsetHeight);
            return a < b ? c(window).height() + "px" : a + "px"
          } else return c(document).height() + "px"
        },
        width: function () {
          var a, b;
          if (c.browser.msie) {
            a = Math.max(document.documentElement.scrollWidth, document.body.scrollWidth);
            b = Math.max(document.documentElement.offsetWidth, document.body.offsetWidth);
            return a < b ? c(window).width() + "px" : a + "px"
          } else return c(document).width() +
            "px"
        },
        resize: function () {
          var a = c([]);
          c.each(c.ui.dialog.overlay.instances, function () {
            a = a.add(this)
          });
          a.css({width: 0, height: 0}).css({width: c.ui.dialog.overlay.width(), height: c.ui.dialog.overlay.height()})
        }
      });
      c.extend(c.ui.dialog.overlay.prototype, {
        destroy: function () {
          c.ui.dialog.overlay.destroy(this.$el)
        }
      })
    })(jQuery);
    ;
    /*
 * jQuery UI Slider 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Slider
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
    (function (d) {
      d.widget("ui.slider", d.ui.mouse, {
        widgetEventPrefix: "slide",
        options: {
          animate: false,
          distance: 0,
          max: 100,
          min: 0,
          orientation: "horizontal",
          range: false,
          step: 1,
          value: 0,
          values: null
        },
        _create: function () {
          var a = this, b = this.options,
            c = this.element.find(".ui-slider-handle").addClass("ui-state-default ui-corner-all"),
            f = b.values && b.values.length || 1, e = [];
          this._mouseSliding = this._keySliding = false;
          this._animateOff = true;
          this._handleIndex = null;
          this._detectOrientation();
          this._mouseInit();
          this.element.addClass("ui-slider ui-slider-" +
            this.orientation + " ui-widget ui-widget-content ui-corner-all" + (b.disabled ? " ui-slider-disabled ui-disabled" : ""));
          this.range = d([]);
          if (b.range) {
            if (b.range === true) {
              if (!b.values) b.values = [this._valueMin(), this._valueMin()];
              if (b.values.length && b.values.length !== 2) b.values = [b.values[0], b.values[0]]
            }
            this.range = d("<div></div>").appendTo(this.element).addClass("ui-slider-range ui-widget-header" + (b.range === "min" || b.range === "max" ? " ui-slider-range-" + b.range : ""))
          }
          for (var j = c.length; j < f; j += 1) e.push("<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>");
          this.handles = c.add(d(e.join("")).appendTo(a.element));
          this.handle = this.handles.eq(0);
          this.handles.add(this.range).filter("a").click(function (g) {
            g.preventDefault()
          }).hover(function () {
            b.disabled || d(this).addClass("ui-state-hover")
          }, function () {
            d(this).removeClass("ui-state-hover")
          }).focus(function () {
            if (b.disabled) d(this).blur(); else {
              d(".ui-slider .ui-state-focus").removeClass("ui-state-focus");
              d(this).addClass("ui-state-focus")
            }
          }).blur(function () {
            d(this).removeClass("ui-state-focus")
          });
          this.handles.each(function (g) {
            d(this).data("index.ui-slider-handle",
              g)
          });
          this.handles.keydown(function (g) {
            var k = true, l = d(this).data("index.ui-slider-handle"), i, h, m;
            if (!a.options.disabled) {
              switch (g.keyCode) {
                case d.ui.keyCode.HOME:
                case d.ui.keyCode.END:
                case d.ui.keyCode.PAGE_UP:
                case d.ui.keyCode.PAGE_DOWN:
                case d.ui.keyCode.UP:
                case d.ui.keyCode.RIGHT:
                case d.ui.keyCode.DOWN:
                case d.ui.keyCode.LEFT:
                  k = false;
                  if (!a._keySliding) {
                    a._keySliding = true;
                    d(this).addClass("ui-state-active");
                    i = a._start(g, l);
                    if (i === false) return
                  }
                  break
              }
              m = a.options.step;
              i = a.options.values && a.options.values.length ?
                (h = a.values(l)) : (h = a.value());
              switch (g.keyCode) {
                case d.ui.keyCode.HOME:
                  h = a._valueMin();
                  break;
                case d.ui.keyCode.END:
                  h = a._valueMax();
                  break;
                case d.ui.keyCode.PAGE_UP:
                  h = a._trimAlignValue(i + (a._valueMax() - a._valueMin()) / 5);
                  break;
                case d.ui.keyCode.PAGE_DOWN:
                  h = a._trimAlignValue(i - (a._valueMax() - a._valueMin()) / 5);
                  break;
                case d.ui.keyCode.UP:
                case d.ui.keyCode.RIGHT:
                  if (i === a._valueMax()) return;
                  h = a._trimAlignValue(i + m);
                  break;
                case d.ui.keyCode.DOWN:
                case d.ui.keyCode.LEFT:
                  if (i === a._valueMin()) return;
                  h = a._trimAlignValue(i -
                    m);
                  break
              }
              a._slide(g, l, h);
              return k
            }
          }).keyup(function (g) {
            var k = d(this).data("index.ui-slider-handle");
            if (a._keySliding) {
              a._keySliding = false;
              a._stop(g, k);
              a._change(g, k);
              d(this).removeClass("ui-state-active")
            }
          });
          this._refreshValue();
          this._animateOff = false
        },
        destroy: function () {
          this.handles.remove();
          this.range.remove();
          this.element.removeClass("ui-slider ui-slider-horizontal ui-slider-vertical ui-slider-disabled ui-widget ui-widget-content ui-corner-all").removeData("slider").unbind(".slider");
          this._mouseDestroy();
          return this
        },
        _mouseCapture: function (a) {
          var b = this.options, c, f, e, j, g;
          if (b.disabled) return false;
          this.elementSize = {width: this.element.outerWidth(), height: this.element.outerHeight()};
          this.elementOffset = this.element.offset();
          c = this._normValueFromMouse({x: a.pageX, y: a.pageY});
          f = this._valueMax() - this._valueMin() + 1;
          j = this;
          this.handles.each(function (k) {
            var l = Math.abs(c - j.values(k));
            if (f > l) {
              f = l;
              e = d(this);
              g = k
            }
          });
          if (b.range === true && this.values(1) === b.min) {
            g += 1;
            e = d(this.handles[g])
          }
          if (this._start(a, g) === false) return false;
          this._mouseSliding = true;
          j._handleIndex = g;
          e.addClass("ui-state-active").focus();
          b = e.offset();
          this._clickOffset = !d(a.target).parents().andSelf().is(".ui-slider-handle") ? {
            left: 0,
            top: 0
          } : {
            left: a.pageX - b.left - e.width() / 2,
            top: a.pageY - b.top - e.height() / 2 - (parseInt(e.css("borderTopWidth"), 10) || 0) - (parseInt(e.css("borderBottomWidth"), 10) || 0) + (parseInt(e.css("marginTop"), 10) || 0)
          };
          this.handles.hasClass("ui-state-hover") || this._slide(a, g, c);
          return this._animateOff = true
        },
        _mouseStart: function () {
          return true
        },
        _mouseDrag: function (a) {
          var b =
            this._normValueFromMouse({x: a.pageX, y: a.pageY});
          this._slide(a, this._handleIndex, b);
          return false
        },
        _mouseStop: function (a) {
          this.handles.removeClass("ui-state-active");
          this._mouseSliding = false;
          this._stop(a, this._handleIndex);
          this._change(a, this._handleIndex);
          this._clickOffset = this._handleIndex = null;
          return this._animateOff = false
        },
        _detectOrientation: function () {
          this.orientation = this.options.orientation === "vertical" ? "vertical" : "horizontal"
        },
        _normValueFromMouse: function (a) {
          var b;
          if (this.orientation === "horizontal") {
            b =
              this.elementSize.width;
            a = a.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0)
          } else {
            b = this.elementSize.height;
            a = a.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0)
          }
          b = a / b;
          if (b > 1) b = 1;
          if (b < 0) b = 0;
          if (this.orientation === "vertical") b = 1 - b;
          a = this._valueMax() - this._valueMin();
          return this._trimAlignValue(this._valueMin() + b * a)
        },
        _start: function (a, b) {
          var c = {handle: this.handles[b], value: this.value()};
          if (this.options.values && this.options.values.length) {
            c.value = this.values(b);
            c.values = this.values()
          }
          return this._trigger("start", a, c)
        },
        _slide: function (a, b, c) {
          var f;
          if (this.options.values && this.options.values.length) {
            f = this.values(b ? 0 : 1);
            if (this.options.values.length === 2 && this.options.range === true && (b === 0 && c > f || b === 1 && c < f)) c = f;
            if (c !== this.values(b)) {
              f = this.values();
              f[b] = c;
              a = this._trigger("slide", a, {handle: this.handles[b], value: c, values: f});
              this.values(b ? 0 : 1);
              a !== false && this.values(b, c, true)
            }
          } else if (c !== this.value()) {
            a = this._trigger("slide", a, {handle: this.handles[b], value: c});
            a !== false && this.value(c)
          }
        },
        _stop: function (a, b) {
          var c = {handle: this.handles[b], value: this.value()};
          if (this.options.values && this.options.values.length) {
            c.value = this.values(b);
            c.values = this.values()
          }
          this._trigger("stop", a, c)
        },
        _change: function (a, b) {
          if (!this._keySliding && !this._mouseSliding) {
            var c = {handle: this.handles[b], value: this.value()};
            if (this.options.values && this.options.values.length) {
              c.value = this.values(b);
              c.values = this.values()
            }
            this._trigger("change", a, c)
          }
        },
        value: function (a) {
          if (arguments.length) {
            this.options.value =
              this._trimAlignValue(a);
            this._refreshValue();
            this._change(null, 0)
          } else return this._value()
        },
        values: function (a, b) {
          var c, f, e;
          if (arguments.length > 1) {
            this.options.values[a] = this._trimAlignValue(b);
            this._refreshValue();
            this._change(null, a)
          } else if (arguments.length) if (d.isArray(arguments[0])) {
            c = this.options.values;
            f = arguments[0];
            for (e = 0; e < c.length; e += 1) {
              c[e] = this._trimAlignValue(f[e]);
              this._change(null, e)
            }
            this._refreshValue()
          } else return this.options.values && this.options.values.length ? this._values(a) :
            this.value(); else return this._values()
        },
        _setOption: function (a, b) {
          var c, f = 0;
          if (d.isArray(this.options.values)) f = this.options.values.length;
          d.Widget.prototype._setOption.apply(this, arguments);
          switch (a) {
            case "disabled":
              if (b) {
                this.handles.filter(".ui-state-focus").blur();
                this.handles.removeClass("ui-state-hover");
                this.handles.propAttr("disabled", true);
                this.element.addClass("ui-disabled")
              } else {
                this.handles.propAttr("disabled", false);
                this.element.removeClass("ui-disabled")
              }
              break;
            case "orientation":
              this._detectOrientation();
              this.element.removeClass("ui-slider-horizontal ui-slider-vertical").addClass("ui-slider-" + this.orientation);
              this._refreshValue();
              break;
            case "value":
              this._animateOff = true;
              this._refreshValue();
              this._change(null, 0);
              this._animateOff = false;
              break;
            case "values":
              this._animateOff = true;
              this._refreshValue();
              for (c = 0; c < f; c += 1) this._change(null, c);
              this._animateOff = false;
              break
          }
        },
        _value: function () {
          var a = this.options.value;
          return a = this._trimAlignValue(a)
        },
        _values: function (a) {
          var b, c;
          if (arguments.length) {
            b = this.options.values[a];
            return b = this._trimAlignValue(b)
          } else {
            b = this.options.values.slice();
            for (c = 0; c < b.length; c += 1) b[c] = this._trimAlignValue(b[c]);
            return b
          }
        },
        _trimAlignValue: function (a) {
          if (a <= this._valueMin()) return this._valueMin();
          if (a >= this._valueMax()) return this._valueMax();
          var b = this.options.step > 0 ? this.options.step : 1, c = (a - this._valueMin()) % b;
          a = a - c;
          if (Math.abs(c) * 2 >= b) a += c > 0 ? b : -b;
          return parseFloat(a.toFixed(5))
        },
        _valueMin: function () {
          return this.options.min
        },
        _valueMax: function () {
          return this.options.max
        },
        _refreshValue: function () {
          var a =
              this.options.range, b = this.options, c = this, f = !this._animateOff ? b.animate : false, e, j = {}, g, k,
            l, i;
          if (this.options.values && this.options.values.length) this.handles.each(function (h) {
            e = (c.values(h) - c._valueMin()) / (c._valueMax() - c._valueMin()) * 100;
            j[c.orientation === "horizontal" ? "left" : "bottom"] = e + "%";
            d(this).stop(1, 1)[f ? "animate" : "css"](j, b.animate);
            if (c.options.range === true) if (c.orientation === "horizontal") {
              if (h === 0) c.range.stop(1, 1)[f ? "animate" : "css"]({left: e + "%"}, b.animate);
              if (h === 1) c.range[f ? "animate" : "css"]({
                width: e -
                g + "%"
              }, {queue: false, duration: b.animate})
            } else {
              if (h === 0) c.range.stop(1, 1)[f ? "animate" : "css"]({bottom: e + "%"}, b.animate);
              if (h === 1) c.range[f ? "animate" : "css"]({height: e - g + "%"}, {queue: false, duration: b.animate})
            }
            g = e
          }); else {
            k = this.value();
            l = this._valueMin();
            i = this._valueMax();
            e = i !== l ? (k - l) / (i - l) * 100 : 0;
            j[c.orientation === "horizontal" ? "left" : "bottom"] = e + "%";
            this.handle.stop(1, 1)[f ? "animate" : "css"](j, b.animate);
            if (a === "min" && this.orientation === "horizontal") this.range.stop(1, 1)[f ? "animate" : "css"]({width: e + "%"},
              b.animate);
            if (a === "max" && this.orientation === "horizontal") this.range[f ? "animate" : "css"]({width: 100 - e + "%"}, {
              queue: false,
              duration: b.animate
            });
            if (a === "min" && this.orientation === "vertical") this.range.stop(1, 1)[f ? "animate" : "css"]({height: e + "%"}, b.animate);
            if (a === "max" && this.orientation === "vertical") this.range[f ? "animate" : "css"]({height: 100 - e + "%"}, {
              queue: false,
              duration: b.animate
            })
          }
        }
      });
      d.extend(d.ui.slider, {version: "1.8.16"})
    })(jQuery);
    ;
    /*
 * jQuery UI Tabs 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Tabs
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 */
    (function (d, p) {
      function u() {
        return ++v
      }

      function w() {
        return ++x
      }

      var v = 0, x = 0;
      d.widget("ui.tabs", {
        options: {
          add: null,
          ajaxOptions: null,
          cache: false,
          cookie: null,
          collapsible: false,
          disable: null,
          disabled: [],
          enable: null,
          event: "click",
          fx: null,
          idPrefix: "ui-tabs-",
          load: null,
          panelTemplate: "<div></div>",
          remove: null,
          select: null,
          show: null,
          spinner: "<em>Loading&#8230;</em>",
          tabTemplate: "<li><a href='#{href}'><span>#{label}</span></a></li>"
        }, _create: function () {
          this._tabify(true)
        }, _setOption: function (b, e) {
          if (b == "selected") this.options.collapsible &&
          e == this.options.selected || this.select(e); else {
            this.options[b] = e;
            this._tabify()
          }
        }, _tabId: function (b) {
          return b.title && b.title.replace(/\s/g, "_").replace(/[^\w\u00c0-\uFFFF-]/g, "") || this.options.idPrefix + u()
        }, _sanitizeSelector: function (b) {
          return b.replace(/:/g, "\\:")
        }, _cookie: function () {
          var b = this.cookie || (this.cookie = this.options.cookie.name || "ui-tabs-" + w());
          return d.cookie.apply(null, [b].concat(d.makeArray(arguments)))
        }, _ui: function (b, e) {
          return {tab: b, panel: e, index: this.anchors.index(b)}
        }, _cleanup: function () {
          this.lis.filter(".ui-state-processing").removeClass("ui-state-processing").find("span:data(label.tabs)").each(function () {
            var b =
              d(this);
            b.html(b.data("label.tabs")).removeData("label.tabs")
          })
        }, _tabify: function (b) {
          function e(g, f) {
            g.css("display", "");
            !d.support.opacity && f.opacity && g[0].style.removeAttribute("filter")
          }

          var a = this, c = this.options, h = /^#.+/;
          this.list = this.element.find("ol,ul").eq(0);
          this.lis = d(" > li:has(a[href])", this.list);
          this.anchors = this.lis.map(function () {
            return d("a", this)[0]
          });
          this.panels = d([]);
          this.anchors.each(function (g, f) {
            var i = d(f).attr("href"), l = i.split("#")[0], q;
            if (l && (l === location.toString().split("#")[0] ||
              (q = d("base")[0]) && l === q.href)) {
              i = f.hash;
              f.href = i
            }
            if (h.test(i)) a.panels = a.panels.add(a.element.find(a._sanitizeSelector(i))); else if (i && i !== "#") {
              d.data(f, "href.tabs", i);
              d.data(f, "load.tabs", i.replace(/#.*$/, ""));
              i = a._tabId(f);
              f.href = "#" + i;
              f = a.element.find("#" + i);
              if (!f.length) {
                f = d(c.panelTemplate).attr("id", i).addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").insertAfter(a.panels[g - 1] || a.list);
                f.data("destroy.tabs", true)
              }
              a.panels = a.panels.add(f)
            } else c.disabled.push(g)
          });
          if (b) {
            this.element.addClass("ui-tabs ui-widget ui-widget-content ui-corner-all");
            this.list.addClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all");
            this.lis.addClass("ui-state-default ui-corner-top");
            this.panels.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom");
            if (c.selected === p) {
              location.hash && this.anchors.each(function (g, f) {
                if (f.hash == location.hash) {
                  c.selected = g;
                  return false
                }
              });
              if (typeof c.selected !== "number" && c.cookie) c.selected = parseInt(a._cookie(), 10);
              if (typeof c.selected !== "number" && this.lis.filter(".ui-tabs-selected").length) c.selected =
                this.lis.index(this.lis.filter(".ui-tabs-selected"));
              c.selected = c.selected || (this.lis.length ? 0 : -1)
            } else if (c.selected === null) c.selected = -1;
            c.selected = c.selected >= 0 && this.anchors[c.selected] || c.selected < 0 ? c.selected : 0;
            c.disabled = d.unique(c.disabled.concat(d.map(this.lis.filter(".ui-state-disabled"), function (g) {
              return a.lis.index(g)
            }))).sort();
            d.inArray(c.selected, c.disabled) != -1 && c.disabled.splice(d.inArray(c.selected, c.disabled), 1);
            this.panels.addClass("ui-tabs-hide");
            this.lis.removeClass("ui-tabs-selected ui-state-active");
            if (c.selected >= 0 && this.anchors.length) {
              a.element.find(a._sanitizeSelector(a.anchors[c.selected].hash)).removeClass("ui-tabs-hide");
              this.lis.eq(c.selected).addClass("ui-tabs-selected ui-state-active");
              a.element.queue("tabs", function () {
                a._trigger("show", null, a._ui(a.anchors[c.selected], a.element.find(a._sanitizeSelector(a.anchors[c.selected].hash))[0]))
              });
              this.load(c.selected)
            }
            d(window).bind("unload", function () {
              a.lis.add(a.anchors).unbind(".tabs");
              a.lis = a.anchors = a.panels = null
            })
          } else c.selected = this.lis.index(this.lis.filter(".ui-tabs-selected"));
          this.element[c.collapsible ? "addClass" : "removeClass"]("ui-tabs-collapsible");
          c.cookie && this._cookie(c.selected, c.cookie);
          b = 0;
          for (var j; j = this.lis[b]; b++) d(j)[d.inArray(b, c.disabled) != -1 && !d(j).hasClass("ui-tabs-selected") ? "addClass" : "removeClass"]("ui-state-disabled");
          c.cache === false && this.anchors.removeData("cache.tabs");
          this.lis.add(this.anchors).unbind(".tabs");
          if (c.event !== "mouseover") {
            var k = function (g, f) {
              f.is(":not(.ui-state-disabled)") && f.addClass("ui-state-" + g)
            }, n = function (g, f) {
              f.removeClass("ui-state-" +
                g)
            };
            this.lis.bind("mouseover.tabs", function () {
              k("hover", d(this))
            });
            this.lis.bind("mouseout.tabs", function () {
              n("hover", d(this))
            });
            this.anchors.bind("focus.tabs", function () {
              k("focus", d(this).closest("li"))
            });
            this.anchors.bind("blur.tabs", function () {
              n("focus", d(this).closest("li"))
            })
          }
          var m, o;
          if (c.fx) if (d.isArray(c.fx)) {
            m = c.fx[0];
            o = c.fx[1]
          } else m = o = c.fx;
          var r = o ? function (g, f) {
            d(g).closest("li").addClass("ui-tabs-selected ui-state-active");
            f.hide().removeClass("ui-tabs-hide").animate(o, o.duration || "normal",
              function () {
                e(f, o);
                a._trigger("show", null, a._ui(g, f[0]))
              })
          } : function (g, f) {
            d(g).closest("li").addClass("ui-tabs-selected ui-state-active");
            f.removeClass("ui-tabs-hide");
            a._trigger("show", null, a._ui(g, f[0]))
          }, s = m ? function (g, f) {
            f.animate(m, m.duration || "normal", function () {
              a.lis.removeClass("ui-tabs-selected ui-state-active");
              f.addClass("ui-tabs-hide");
              e(f, m);
              a.element.dequeue("tabs")
            })
          } : function (g, f) {
            a.lis.removeClass("ui-tabs-selected ui-state-active");
            f.addClass("ui-tabs-hide");
            a.element.dequeue("tabs")
          };
          this.anchors.bind(c.event + ".tabs", function () {
            var g = this, f = d(g).closest("li"), i = a.panels.filter(":not(.ui-tabs-hide)"),
              l = a.element.find(a._sanitizeSelector(g.hash));
            if (f.hasClass("ui-tabs-selected") && !c.collapsible || f.hasClass("ui-state-disabled") || f.hasClass("ui-state-processing") || a.panels.filter(":animated").length || a._trigger("select", null, a._ui(this, l[0])) === false) {
              this.blur();
              return false
            }
            c.selected = a.anchors.index(this);
            a.abort();
            if (c.collapsible) if (f.hasClass("ui-tabs-selected")) {
              c.selected =
                -1;
              c.cookie && a._cookie(c.selected, c.cookie);
              a.element.queue("tabs", function () {
                s(g, i)
              }).dequeue("tabs");
              this.blur();
              return false
            } else if (!i.length) {
              c.cookie && a._cookie(c.selected, c.cookie);
              a.element.queue("tabs", function () {
                r(g, l)
              });
              a.load(a.anchors.index(this));
              this.blur();
              return false
            }
            c.cookie && a._cookie(c.selected, c.cookie);
            if (l.length) {
              i.length && a.element.queue("tabs", function () {
                s(g, i)
              });
              a.element.queue("tabs", function () {
                r(g, l)
              });
              a.load(a.anchors.index(this))
            } else throw"jQuery UI Tabs: Mismatching fragment identifier.";
            d.browser.msie && this.blur()
          });
          this.anchors.bind("click.tabs", function () {
            return false
          })
        }, _getIndex: function (b) {
          if (typeof b == "string") b = this.anchors.index(this.anchors.filter("[href$=" + b + "]"));
          return b
        }, destroy: function () {
          var b = this.options;
          this.abort();
          this.element.unbind(".tabs").removeClass("ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible").removeData("tabs");
          this.list.removeClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all");
          this.anchors.each(function () {
            var e =
              d.data(this, "href.tabs");
            if (e) this.href = e;
            var a = d(this).unbind(".tabs");
            d.each(["href", "load", "cache"], function (c, h) {
              a.removeData(h + ".tabs")
            })
          });
          this.lis.unbind(".tabs").add(this.panels).each(function () {
            d.data(this, "destroy.tabs") ? d(this).remove() : d(this).removeClass("ui-state-default ui-corner-top ui-tabs-selected ui-state-active ui-state-hover ui-state-focus ui-state-disabled ui-tabs-panel ui-widget-content ui-corner-bottom ui-tabs-hide")
          });
          b.cookie && this._cookie(null, b.cookie);
          return this
        }, add: function (b,
                          e, a) {
          if (a === p) a = this.anchors.length;
          var c = this, h = this.options;
          e = d(h.tabTemplate.replace(/#\{href\}/g, b).replace(/#\{label\}/g, e));
          b = !b.indexOf("#") ? b.replace("#", "") : this._tabId(d("a", e)[0]);
          e.addClass("ui-state-default ui-corner-top").data("destroy.tabs", true);
          var j = c.element.find("#" + b);
          j.length || (j = d(h.panelTemplate).attr("id", b).data("destroy.tabs", true));
          j.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom ui-tabs-hide");
          if (a >= this.lis.length) {
            e.appendTo(this.list);
            j.appendTo(this.list[0].parentNode)
          } else {
            e.insertBefore(this.lis[a]);
            j.insertBefore(this.panels[a])
          }
          h.disabled = d.map(h.disabled, function (k) {
            return k >= a ? ++k : k
          });
          this._tabify();
          if (this.anchors.length == 1) {
            h.selected = 0;
            e.addClass("ui-tabs-selected ui-state-active");
            j.removeClass("ui-tabs-hide");
            this.element.queue("tabs", function () {
              c._trigger("show", null, c._ui(c.anchors[0], c.panels[0]))
            });
            this.load(0)
          }
          this._trigger("add", null, this._ui(this.anchors[a], this.panels[a]));
          return this
        }, remove: function (b) {
          b = this._getIndex(b);
          var e = this.options, a = this.lis.eq(b).remove(), c = this.panels.eq(b).remove();
          if (a.hasClass("ui-tabs-selected") && this.anchors.length > 1) this.select(b + (b + 1 < this.anchors.length ? 1 : -1));
          e.disabled = d.map(d.grep(e.disabled, function (h) {
            return h != b
          }), function (h) {
            return h >= b ? --h : h
          });
          this._tabify();
          this._trigger("remove", null, this._ui(a.find("a")[0], c[0]));
          return this
        }, enable: function (b) {
          b = this._getIndex(b);
          var e = this.options;
          if (d.inArray(b, e.disabled) != -1) {
            this.lis.eq(b).removeClass("ui-state-disabled");
            e.disabled = d.grep(e.disabled, function (a) {
              return a != b
            });
            this._trigger("enable", null,
              this._ui(this.anchors[b], this.panels[b]));
            return this
          }
        }, disable: function (b) {
          b = this._getIndex(b);
          var e = this.options;
          if (b != e.selected) {
            this.lis.eq(b).addClass("ui-state-disabled");
            e.disabled.push(b);
            e.disabled.sort();
            this._trigger("disable", null, this._ui(this.anchors[b], this.panels[b]))
          }
          return this
        }, select: function (b) {
          b = this._getIndex(b);
          if (b == -1) if (this.options.collapsible && this.options.selected != -1) b = this.options.selected; else return this;
          this.anchors.eq(b).trigger(this.options.event + ".tabs");
          return this
        },
        load: function (b) {
          b = this._getIndex(b);
          var e = this, a = this.options, c = this.anchors.eq(b)[0], h = d.data(c, "load.tabs");
          this.abort();
          if (!h || this.element.queue("tabs").length !== 0 && d.data(c, "cache.tabs")) this.element.dequeue("tabs"); else {
            this.lis.eq(b).addClass("ui-state-processing");
            if (a.spinner) {
              var j = d("span", c);
              j.data("label.tabs", j.html()).html(a.spinner)
            }
            this.xhr = d.ajax(d.extend({}, a.ajaxOptions, {
              url: h, success: function (k, n) {
                e.element.find(e._sanitizeSelector(c.hash)).html(k);
                e._cleanup();
                a.cache && d.data(c,
                  "cache.tabs", true);
                e._trigger("load", null, e._ui(e.anchors[b], e.panels[b]));
                try {
                  a.ajaxOptions.success(k, n)
                } catch (m) {
                }
              }, error: function (k, n) {
                e._cleanup();
                e._trigger("load", null, e._ui(e.anchors[b], e.panels[b]));
                try {
                  a.ajaxOptions.error(k, n, b, c)
                } catch (m) {
                }
              }
            }));
            e.element.dequeue("tabs");
            return this
          }
        }, abort: function () {
          this.element.queue([]);
          this.panels.stop(false, true);
          this.element.queue("tabs", this.element.queue("tabs").splice(-2, 2));
          if (this.xhr) {
            this.xhr.abort();
            delete this.xhr
          }
          this._cleanup();
          return this
        },
        url: function (b, e) {
          this.anchors.eq(b).removeData("cache.tabs").data("load.tabs", e);
          return this
        }, length: function () {
          return this.anchors.length
        }
      });
      d.extend(d.ui.tabs, {version: "1.8.16"});
      d.extend(d.ui.tabs.prototype, {
        rotation: null, rotate: function (b, e) {
          var a = this, c = this.options, h = a._rotate || (a._rotate = function (j) {
            clearTimeout(a.rotation);
            a.rotation = setTimeout(function () {
              var k = c.selected;
              a.select(++k < a.anchors.length ? k : 0)
            }, b);
            j && j.stopPropagation()
          });
          e = a._unrotate || (a._unrotate = !e ? function (j) {
            j.clientX &&
            a.rotate(null)
          } : function () {
            t = c.selected;
            h()
          });
          if (b) {
            this.element.bind("tabsshow", h);
            this.anchors.bind(c.event + ".tabs", e);
            h()
          } else {
            clearTimeout(a.rotation);
            this.element.unbind("tabsshow", h);
            this.anchors.unbind(c.event + ".tabs", e);
            delete this._rotate;
            delete this._unrotate
          }
          return this
        }
      })
    })(jQuery);
    ;
    /*
 * jQuery UI Datepicker 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Datepicker
 *
 * Depends:
 *	jquery.ui.core.js
 */
    (function (d, C) {
      function M() {
        this.debug = false;
        this._curInst = null;
        this._keyEvent = false;
        this._disabledInputs = [];
        this._inDialog = this._datepickerShowing = false;
        this._mainDivId = "ui-datepicker-div";
        this._inlineClass = "ui-datepicker-inline";
        this._appendClass = "ui-datepicker-append";
        this._triggerClass = "ui-datepicker-trigger";
        this._dialogClass = "ui-datepicker-dialog";
        this._disableClass = "ui-datepicker-disabled";
        this._unselectableClass = "ui-datepicker-unselectable";
        this._currentClass = "ui-datepicker-current-day";
        this._dayOverClass =
          "ui-datepicker-days-cell-over";
        this.regional = [];
        this.regional[""] = {
          closeText: "Done",
          prevText: "Prev",
          nextText: "Next",
          currentText: "Today",
          monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
          monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
          dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
          dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
          dayNamesMin: ["Su",
            "Mo", "Tu", "We", "Th", "Fr", "Sa"],
          weekHeader: "Wk",
          dateFormat: "mm/dd/yy",
          firstDay: 0,
          isRTL: false,
          showMonthAfterYear: false,
          yearSuffix: ""
        };
        this._defaults = {
          showOn: "focus",
          showAnim: "fadeIn",
          showOptions: {},
          defaultDate: null,
          appendText: "",
          buttonText: "...",
          buttonImage: "",
          buttonImageOnly: false,
          hideIfNoPrevNext: false,
          navigationAsDateFormat: false,
          gotoCurrent: false,
          changeMonth: false,
          changeYear: false,
          yearRange: "c-10:c+10",
          showOtherMonths: false,
          selectOtherMonths: false,
          showWeek: false,
          calculateWeek: this.iso8601Week,
          shortYearCutoff: "+10",
          minDate: null,
          maxDate: null,
          duration: "fast",
          beforeShowDay: null,
          beforeShow: null,
          onSelect: null,
          onChangeMonthYear: null,
          onClose: null,
          numberOfMonths: 1,
          showCurrentAtPos: 0,
          stepMonths: 1,
          stepBigMonths: 12,
          altField: "",
          altFormat: "",
          constrainInput: true,
          showButtonPanel: false,
          autoSize: false,
          disabled: false
        };
        d.extend(this._defaults, this.regional[""]);
        this.dpDiv = N(d('<div id="' + this._mainDivId + '" class="ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>'))
      }

      function N(a) {
        return a.bind("mouseout",
          function (b) {
            b = d(b.target).closest("button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a");
            b.length && b.removeClass("ui-state-hover ui-datepicker-prev-hover ui-datepicker-next-hover")
          }).bind("mouseover", function (b) {
          b = d(b.target).closest("button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a");
          if (!(d.datepicker._isDisabledDatepicker(J.inline ? a.parent()[0] : J.input[0]) || !b.length)) {
            b.parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover");
            b.addClass("ui-state-hover");
            b.hasClass("ui-datepicker-prev") && b.addClass("ui-datepicker-prev-hover");
            b.hasClass("ui-datepicker-next") && b.addClass("ui-datepicker-next-hover")
          }
        })
      }

      function H(a, b) {
        d.extend(a, b);
        for (var c in b) if (b[c] == null || b[c] == C) a[c] = b[c];
        return a
      }

      d.extend(d.ui, {datepicker: {version: "1.8.16"}});
      var B = (new Date).getTime(), J;
      d.extend(M.prototype, {
        markerClassName: "hasDatepicker",
        maxRows: 4,
        log: function () {
          this.debug && console.log.apply("", arguments)
        },
        _widgetDatepicker: function () {
          return this.dpDiv
        },
        setDefaults: function (a) {
          H(this._defaults, a || {});
          return this
        },
        _attachDatepicker: function (a, b) {
          var c = null;
          for (var e in this._defaults) {
            var f = a.getAttribute("date:" + e);
            if (f) {
              c = c || {};
              try {
                c[e] = eval(f)
              } catch (h) {
                c[e] = f
              }
            }
          }
          e = a.nodeName.toLowerCase();
          f = e == "div" || e == "span";
          if (!a.id) {
            this.uuid += 1;
            a.id = "dp" + this.uuid
          }
          var i = this._newInst(d(a), f);
          i.settings = d.extend({}, b || {}, c || {});
          if (e == "input") this._connectDatepicker(a, i); else f && this._inlineDatepicker(a, i)
        },
        _newInst: function (a, b) {
          return {
            id: a[0].id.replace(/([^A-Za-z0-9_-])/g,
              "\\\\$1"),
            input: a,
            selectedDay: 0,
            selectedMonth: 0,
            selectedYear: 0,
            drawMonth: 0,
            drawYear: 0,
            inline: b,
            dpDiv: !b ? this.dpDiv : N(d('<div class="' + this._inlineClass + ' ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>'))
          }
        },
        _connectDatepicker: function (a, b) {
          var c = d(a);
          b.append = d([]);
          b.trigger = d([]);
          if (!c.hasClass(this.markerClassName)) {
            this._attachments(c, b);
            c.addClass(this.markerClassName).keydown(this._doKeyDown).keypress(this._doKeyPress).keyup(this._doKeyUp).bind("setData.datepicker",
              function (e, f, h) {
                b.settings[f] = h
              }).bind("getData.datepicker", function (e, f) {
              return this._get(b, f)
            });
            this._autoSize(b);
            d.data(a, "datepicker", b);
            b.settings.disabled && this._disableDatepicker(a)
          }
        },
        _attachments: function (a, b) {
          var c = this._get(b, "appendText"), e = this._get(b, "isRTL");
          b.append && b.append.remove();
          if (c) {
            b.append = d('<span class="' + this._appendClass + '">' + c + "</span>");
            a[e ? "before" : "after"](b.append)
          }
          a.unbind("focus", this._showDatepicker);
          b.trigger && b.trigger.remove();
          c = this._get(b, "showOn");
          if (c ==
            "focus" || c == "both") a.focus(this._showDatepicker);
          if (c == "button" || c == "both") {
            c = this._get(b, "buttonText");
            var f = this._get(b, "buttonImage");
            b.trigger = d(this._get(b, "buttonImageOnly") ? d("<img/>").addClass(this._triggerClass).attr({
              src: f,
              alt: c,
              title: c
            }) : d('<button type="button"></button>').addClass(this._triggerClass).html(f == "" ? c : d("<img/>").attr({
              src: f,
              alt: c,
              title: c
            })));
            a[e ? "before" : "after"](b.trigger);
            b.trigger.click(function () {
              d.datepicker._datepickerShowing && d.datepicker._lastInput == a[0] ? d.datepicker._hideDatepicker() :
                d.datepicker._showDatepicker(a[0]);
              return false
            })
          }
        },
        _autoSize: function (a) {
          if (this._get(a, "autoSize") && !a.inline) {
            var b = new Date(2009, 11, 20), c = this._get(a, "dateFormat");
            if (c.match(/[DM]/)) {
              var e = function (f) {
                for (var h = 0, i = 0, g = 0; g < f.length; g++) if (f[g].length > h) {
                  h = f[g].length;
                  i = g
                }
                return i
              };
              b.setMonth(e(this._get(a, c.match(/MM/) ? "monthNames" : "monthNamesShort")));
              b.setDate(e(this._get(a, c.match(/DD/) ? "dayNames" : "dayNamesShort")) + 20 - b.getDay())
            }
            a.input.attr("size", this._formatDate(a, b).length)
          }
        },
        _inlineDatepicker: function (a,
                                     b) {
          var c = d(a);
          if (!c.hasClass(this.markerClassName)) {
            c.addClass(this.markerClassName).append(b.dpDiv).bind("setData.datepicker", function (e, f, h) {
              b.settings[f] = h
            }).bind("getData.datepicker", function (e, f) {
              return this._get(b, f)
            });
            d.data(a, "datepicker", b);
            this._setDate(b, this._getDefaultDate(b), true);
            this._updateDatepicker(b);
            this._updateAlternate(b);
            b.settings.disabled && this._disableDatepicker(a);
            b.dpDiv.css("display", "block")
          }
        },
        _dialogDatepicker: function (a, b, c, e, f) {
          a = this._dialogInst;
          if (!a) {
            this.uuid +=
              1;
            this._dialogInput = d('<input type="text" id="' + ("dp" + this.uuid) + '" style="position: absolute; top: -100px; width: 0px; z-index: -10;"/>');
            this._dialogInput.keydown(this._doKeyDown);
            d("body").append(this._dialogInput);
            a = this._dialogInst = this._newInst(this._dialogInput, false);
            a.settings = {};
            d.data(this._dialogInput[0], "datepicker", a)
          }
          H(a.settings, e || {});
          b = b && b.constructor == Date ? this._formatDate(a, b) : b;
          this._dialogInput.val(b);
          this._pos = f ? f.length ? f : [f.pageX, f.pageY] : null;
          if (!this._pos) this._pos = [document.documentElement.clientWidth /
          2 - 100 + (document.documentElement.scrollLeft || document.body.scrollLeft), document.documentElement.clientHeight / 2 - 150 + (document.documentElement.scrollTop || document.body.scrollTop)];
          this._dialogInput.css("left", this._pos[0] + 20 + "px").css("top", this._pos[1] + "px");
          a.settings.onSelect = c;
          this._inDialog = true;
          this.dpDiv.addClass(this._dialogClass);
          this._showDatepicker(this._dialogInput[0]);
          d.blockUI && d.blockUI(this.dpDiv);
          d.data(this._dialogInput[0], "datepicker", a);
          return this
        },
        _destroyDatepicker: function (a) {
          var b =
            d(a), c = d.data(a, "datepicker");
          if (b.hasClass(this.markerClassName)) {
            var e = a.nodeName.toLowerCase();
            d.removeData(a, "datepicker");
            if (e == "input") {
              c.append.remove();
              c.trigger.remove();
              b.removeClass(this.markerClassName).unbind("focus", this._showDatepicker).unbind("keydown", this._doKeyDown).unbind("keypress", this._doKeyPress).unbind("keyup", this._doKeyUp)
            } else if (e == "div" || e == "span") b.removeClass(this.markerClassName).empty()
          }
        },
        _enableDatepicker: function (a) {
          var b = d(a), c = d.data(a, "datepicker");
          if (b.hasClass(this.markerClassName)) {
            var e =
              a.nodeName.toLowerCase();
            if (e == "input") {
              a.disabled = false;
              c.trigger.filter("button").each(function () {
                this.disabled = false
              }).end().filter("img").css({opacity: "1.0", cursor: ""})
            } else if (e == "div" || e == "span") {
              b = b.children("." + this._inlineClass);
              b.children().removeClass("ui-state-disabled");
              b.find("select.ui-datepicker-month, select.ui-datepicker-year").removeAttr("disabled")
            }
            this._disabledInputs = d.map(this._disabledInputs, function (f) {
              return f == a ? null : f
            })
          }
        },
        _disableDatepicker: function (a) {
          var b = d(a), c = d.data(a,
            "datepicker");
          if (b.hasClass(this.markerClassName)) {
            var e = a.nodeName.toLowerCase();
            if (e == "input") {
              a.disabled = true;
              c.trigger.filter("button").each(function () {
                this.disabled = true
              }).end().filter("img").css({opacity: "0.5", cursor: "default"})
            } else if (e == "div" || e == "span") {
              b = b.children("." + this._inlineClass);
              b.children().addClass("ui-state-disabled");
              b.find("select.ui-datepicker-month, select.ui-datepicker-year").attr("disabled", "disabled")
            }
            this._disabledInputs = d.map(this._disabledInputs, function (f) {
              return f ==
              a ? null : f
            });
            this._disabledInputs[this._disabledInputs.length] = a
          }
        },
        _isDisabledDatepicker: function (a) {
          if (!a) return false;
          for (var b = 0; b < this._disabledInputs.length; b++) if (this._disabledInputs[b] == a) return true;
          return false
        },
        _getInst: function (a) {
          try {
            return d.data(a, "datepicker")
          } catch (b) {
            throw"Missing instance data for this datepicker";
          }
        },
        _optionDatepicker: function (a, b, c) {
          var e = this._getInst(a);
          if (arguments.length == 2 && typeof b == "string") return b == "defaults" ? d.extend({}, d.datepicker._defaults) : e ? b == "all" ?
            d.extend({}, e.settings) : this._get(e, b) : null;
          var f = b || {};
          if (typeof b == "string") {
            f = {};
            f[b] = c
          }
          if (e) {
            this._curInst == e && this._hideDatepicker();
            var h = this._getDateDatepicker(a, true), i = this._getMinMaxDate(e, "min"),
              g = this._getMinMaxDate(e, "max");
            H(e.settings, f);
            if (i !== null && f.dateFormat !== C && f.minDate === C) e.settings.minDate = this._formatDate(e, i);
            if (g !== null && f.dateFormat !== C && f.maxDate === C) e.settings.maxDate = this._formatDate(e, g);
            this._attachments(d(a), e);
            this._autoSize(e);
            this._setDate(e, h);
            this._updateAlternate(e);
            this._updateDatepicker(e)
          }
        },
        _changeDatepicker: function (a, b, c) {
          this._optionDatepicker(a, b, c)
        },
        _refreshDatepicker: function (a) {
          (a = this._getInst(a)) && this._updateDatepicker(a)
        },
        _setDateDatepicker: function (a, b) {
          if (a = this._getInst(a)) {
            this._setDate(a, b);
            this._updateDatepicker(a);
            this._updateAlternate(a)
          }
        },
        _getDateDatepicker: function (a, b) {
          (a = this._getInst(a)) && !a.inline && this._setDateFromField(a, b);
          return a ? this._getDate(a) : null
        },
        _doKeyDown: function (a) {
          var b = d.datepicker._getInst(a.target), c = true, e = b.dpDiv.is(".ui-datepicker-rtl");
          b._keyEvent = true;
          if (d.datepicker._datepickerShowing) switch (a.keyCode) {
            case 9:
              d.datepicker._hideDatepicker();
              c = false;
              break;
            case 13:
              c = d("td." + d.datepicker._dayOverClass + ":not(." + d.datepicker._currentClass + ")", b.dpDiv);
              c[0] && d.datepicker._selectDay(a.target, b.selectedMonth, b.selectedYear, c[0]);
              if (a = d.datepicker._get(b, "onSelect")) {
                c = d.datepicker._formatDate(b);
                a.apply(b.input ? b.input[0] : null, [c, b])
              } else d.datepicker._hideDatepicker();
              return false;
            case 27:
              d.datepicker._hideDatepicker();
              break;
            case 33:
              d.datepicker._adjustDate(a.target,
                a.ctrlKey ? -d.datepicker._get(b, "stepBigMonths") : -d.datepicker._get(b, "stepMonths"), "M");
              break;
            case 34:
              d.datepicker._adjustDate(a.target, a.ctrlKey ? +d.datepicker._get(b, "stepBigMonths") : +d.datepicker._get(b, "stepMonths"), "M");
              break;
            case 35:
              if (a.ctrlKey || a.metaKey) d.datepicker._clearDate(a.target);
              c = a.ctrlKey || a.metaKey;
              break;
            case 36:
              if (a.ctrlKey || a.metaKey) d.datepicker._gotoToday(a.target);
              c = a.ctrlKey || a.metaKey;
              break;
            case 37:
              if (a.ctrlKey || a.metaKey) d.datepicker._adjustDate(a.target, e ? +1 : -1, "D");
              c =
                a.ctrlKey || a.metaKey;
              if (a.originalEvent.altKey) d.datepicker._adjustDate(a.target, a.ctrlKey ? -d.datepicker._get(b, "stepBigMonths") : -d.datepicker._get(b, "stepMonths"), "M");
              break;
            case 38:
              if (a.ctrlKey || a.metaKey) d.datepicker._adjustDate(a.target, -7, "D");
              c = a.ctrlKey || a.metaKey;
              break;
            case 39:
              if (a.ctrlKey || a.metaKey) d.datepicker._adjustDate(a.target, e ? -1 : +1, "D");
              c = a.ctrlKey || a.metaKey;
              if (a.originalEvent.altKey) d.datepicker._adjustDate(a.target, a.ctrlKey ? +d.datepicker._get(b, "stepBigMonths") : +d.datepicker._get(b,
                "stepMonths"), "M");
              break;
            case 40:
              if (a.ctrlKey || a.metaKey) d.datepicker._adjustDate(a.target, +7, "D");
              c = a.ctrlKey || a.metaKey;
              break;
            default:
              c = false
          } else if (a.keyCode == 36 && a.ctrlKey) d.datepicker._showDatepicker(this); else c = false;
          if (c) {
            a.preventDefault();
            a.stopPropagation()
          }
        },
        _doKeyPress: function (a) {
          var b = d.datepicker._getInst(a.target);
          if (d.datepicker._get(b, "constrainInput")) {
            b = d.datepicker._possibleChars(d.datepicker._get(b, "dateFormat"));
            var c = String.fromCharCode(a.charCode == C ? a.keyCode : a.charCode);
            return a.ctrlKey || a.metaKey || c < " " || !b || b.indexOf(c) > -1
          }
        },
        _doKeyUp: function (a) {
          a = d.datepicker._getInst(a.target);
          if (a.input.val() != a.lastVal) try {
            if (d.datepicker.parseDate(d.datepicker._get(a, "dateFormat"), a.input ? a.input.val() : null, d.datepicker._getFormatConfig(a))) {
              d.datepicker._setDateFromField(a);
              d.datepicker._updateAlternate(a);
              d.datepicker._updateDatepicker(a)
            }
          } catch (b) {
            d.datepicker.log(b)
          }
          return true
        },
        _showDatepicker: function (a) {
          a = a.target || a;
          if (a.nodeName.toLowerCase() != "input") a = d("input",
            a.parentNode)[0];
          if (!(d.datepicker._isDisabledDatepicker(a) || d.datepicker._lastInput == a)) {
            var b = d.datepicker._getInst(a);
            if (d.datepicker._curInst && d.datepicker._curInst != b) {
              d.datepicker._datepickerShowing && d.datepicker._triggerOnClose(d.datepicker._curInst);
              d.datepicker._curInst.dpDiv.stop(true, true)
            }
            var c = d.datepicker._get(b, "beforeShow");
            c = c ? c.apply(a, [a, b]) : {};
            if (c !== false) {
              H(b.settings, c);
              b.lastVal = null;
              d.datepicker._lastInput = a;
              d.datepicker._setDateFromField(b);
              if (d.datepicker._inDialog) a.value =
                "";
              if (!d.datepicker._pos) {
                d.datepicker._pos = d.datepicker._findPos(a);
                d.datepicker._pos[1] += a.offsetHeight
              }
              var e = false;
              d(a).parents().each(function () {
                e |= d(this).css("position") == "fixed";
                return !e
              });
              if (e && d.browser.opera) {
                d.datepicker._pos[0] -= document.documentElement.scrollLeft;
                d.datepicker._pos[1] -= document.documentElement.scrollTop
              }
              c = {left: d.datepicker._pos[0], top: d.datepicker._pos[1]};
              d.datepicker._pos = null;
              b.dpDiv.empty();
              b.dpDiv.css({position: "absolute", display: "block", top: "-1000px"});
              d.datepicker._updateDatepicker(b);
              c = d.datepicker._checkOffset(b, c, e);
              b.dpDiv.css({
                position: d.datepicker._inDialog && d.blockUI ? "static" : e ? "fixed" : "absolute",
                display: "none",
                left: c.left + "px",
                top: c.top + "px"
              });
              if (!b.inline) {
                c = d.datepicker._get(b, "showAnim");
                var f = d.datepicker._get(b, "duration"), h = function () {
                  var i = b.dpDiv.find("iframe.ui-datepicker-cover");
                  if (i.length) {
                    var g = d.datepicker._getBorders(b.dpDiv);
                    i.css({left: -g[0], top: -g[1], width: b.dpDiv.outerWidth(), height: b.dpDiv.outerHeight()})
                  }
                };
                b.dpDiv.zIndex(d(a).zIndex() + 1);
                d.datepicker._datepickerShowing =
                  true;
                d.effects && d.effects[c] ? b.dpDiv.show(c, d.datepicker._get(b, "showOptions"), f, h) : b.dpDiv[c || "show"](c ? f : null, h);
                if (!c || !f) h();
                b.input.is(":visible") && !b.input.is(":disabled") && b.input.focus();
                d.datepicker._curInst = b
              }
            }
          }
        },
        _updateDatepicker: function (a) {
          this.maxRows = 4;
          var b = d.datepicker._getBorders(a.dpDiv);
          J = a;
          a.dpDiv.empty().append(this._generateHTML(a));
          var c = a.dpDiv.find("iframe.ui-datepicker-cover");
          c.length && c.css({left: -b[0], top: -b[1], width: a.dpDiv.outerWidth(), height: a.dpDiv.outerHeight()});
          a.dpDiv.find("." + this._dayOverClass + " a").mouseover();
          b = this._getNumberOfMonths(a);
          c = b[1];
          a.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width("");
          c > 1 && a.dpDiv.addClass("ui-datepicker-multi-" + c).css("width", 17 * c + "em");
          a.dpDiv[(b[0] != 1 || b[1] != 1 ? "add" : "remove") + "Class"]("ui-datepicker-multi");
          a.dpDiv[(this._get(a, "isRTL") ? "add" : "remove") + "Class"]("ui-datepicker-rtl");
          a == d.datepicker._curInst && d.datepicker._datepickerShowing && a.input && a.input.is(":visible") &&
          !a.input.is(":disabled") && a.input[0] != document.activeElement && a.input.focus();
          if (a.yearshtml) {
            var e = a.yearshtml;
            setTimeout(function () {
              e === a.yearshtml && a.yearshtml && a.dpDiv.find("select.ui-datepicker-year:first").replaceWith(a.yearshtml);
              e = a.yearshtml = null
            }, 0)
          }
        },
        _getBorders: function (a) {
          var b = function (c) {
            return {thin: 1, medium: 2, thick: 3}[c] || c
          };
          return [parseFloat(b(a.css("border-left-width"))), parseFloat(b(a.css("border-top-width")))]
        },
        _checkOffset: function (a, b, c) {
          var e = a.dpDiv.outerWidth(), f = a.dpDiv.outerHeight(),
            h = a.input ? a.input.outerWidth() : 0, i = a.input ? a.input.outerHeight() : 0,
            g = document.documentElement.clientWidth + d(document).scrollLeft(),
            j = document.documentElement.clientHeight + d(document).scrollTop();
          b.left -= this._get(a, "isRTL") ? e - h : 0;
          b.left -= c && b.left == a.input.offset().left ? d(document).scrollLeft() : 0;
          b.top -= c && b.top == a.input.offset().top + i ? d(document).scrollTop() : 0;
          b.left -= Math.min(b.left, b.left + e > g && g > e ? Math.abs(b.left + e - g) : 0);
          b.top -= Math.min(b.top, b.top + f > j && j > f ? Math.abs(f + i) : 0);
          return b
        },
        _findPos: function (a) {
          for (var b =
            this._get(this._getInst(a), "isRTL"); a && (a.type == "hidden" || a.nodeType != 1 || d.expr.filters.hidden(a));) a = a[b ? "previousSibling" : "nextSibling"];
          a = d(a).offset();
          return [a.left, a.top]
        },
        _triggerOnClose: function (a) {
          var b = this._get(a, "onClose");
          if (b) b.apply(a.input ? a.input[0] : null, [a.input ? a.input.val() : "", a])
        },
        _hideDatepicker: function (a) {
          var b = this._curInst;
          if (!(!b || a && b != d.data(a, "datepicker"))) if (this._datepickerShowing) {
            a = this._get(b, "showAnim");
            var c = this._get(b, "duration"), e = function () {
              d.datepicker._tidyDialog(b);
              this._curInst = null
            };
            d.effects && d.effects[a] ? b.dpDiv.hide(a, d.datepicker._get(b, "showOptions"), c, e) : b.dpDiv[a == "slideDown" ? "slideUp" : a == "fadeIn" ? "fadeOut" : "hide"](a ? c : null, e);
            a || e();
            d.datepicker._triggerOnClose(b);
            this._datepickerShowing = false;
            this._lastInput = null;
            if (this._inDialog) {
              this._dialogInput.css({position: "absolute", left: "0", top: "-100px"});
              if (d.blockUI) {
                d.unblockUI();
                d("body").append(this.dpDiv)
              }
            }
            this._inDialog = false
          }
        },
        _tidyDialog: function (a) {
          a.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar")
        },
        _checkExternalClick: function (a) {
          if (d.datepicker._curInst) {
            a = d(a.target);
            a[0].id != d.datepicker._mainDivId && a.parents("#" + d.datepicker._mainDivId).length == 0 && !a.hasClass(d.datepicker.markerClassName) && !a.hasClass(d.datepicker._triggerClass) && d.datepicker._datepickerShowing && !(d.datepicker._inDialog && d.blockUI) && d.datepicker._hideDatepicker()
          }
        },
        _adjustDate: function (a, b, c) {
          a = d(a);
          var e = this._getInst(a[0]);
          if (!this._isDisabledDatepicker(a[0])) {
            this._adjustInstDate(e, b + (c == "M" ? this._get(e, "showCurrentAtPos") :
              0), c);
            this._updateDatepicker(e)
          }
        },
        _gotoToday: function (a) {
          a = d(a);
          var b = this._getInst(a[0]);
          if (this._get(b, "gotoCurrent") && b.currentDay) {
            b.selectedDay = b.currentDay;
            b.drawMonth = b.selectedMonth = b.currentMonth;
            b.drawYear = b.selectedYear = b.currentYear
          } else {
            var c = new Date;
            b.selectedDay = c.getDate();
            b.drawMonth = b.selectedMonth = c.getMonth();
            b.drawYear = b.selectedYear = c.getFullYear()
          }
          this._notifyChange(b);
          this._adjustDate(a)
        },
        _selectMonthYear: function (a, b, c) {
          a = d(a);
          var e = this._getInst(a[0]);
          e["selected" + (c == "M" ?
            "Month" : "Year")] = e["draw" + (c == "M" ? "Month" : "Year")] = parseInt(b.options[b.selectedIndex].value, 10);
          this._notifyChange(e);
          this._adjustDate(a)
        },
        _selectDay: function (a, b, c, e) {
          var f = d(a);
          if (!(d(e).hasClass(this._unselectableClass) || this._isDisabledDatepicker(f[0]))) {
            f = this._getInst(f[0]);
            f.selectedDay = f.currentDay = d("a", e).html();
            f.selectedMonth = f.currentMonth = b;
            f.selectedYear = f.currentYear = c;
            this._selectDate(a, this._formatDate(f, f.currentDay, f.currentMonth, f.currentYear))
          }
        },
        _clearDate: function (a) {
          a = d(a);
          this._getInst(a[0]);
          this._selectDate(a, "")
        },
        _selectDate: function (a, b) {
          a = this._getInst(d(a)[0]);
          b = b != null ? b : this._formatDate(a);
          a.input && a.input.val(b);
          this._updateAlternate(a);
          var c = this._get(a, "onSelect");
          if (c) c.apply(a.input ? a.input[0] : null, [b, a]); else a.input && a.input.trigger("change");
          if (a.inline) this._updateDatepicker(a); else {
            this._hideDatepicker();
            this._lastInput = a.input[0];
            typeof a.input[0] != "object" && a.input.focus();
            this._lastInput = null
          }
        },
        _updateAlternate: function (a) {
          var b = this._get(a, "altField");
          if (b) {
            var c = this._get(a, "altFormat") || this._get(a, "dateFormat"), e = this._getDate(a),
              f = this.formatDate(c, e, this._getFormatConfig(a));
            d(b).each(function () {
              d(this).val(f)
            })
          }
        },
        noWeekends: function (a) {
          a = a.getDay();
          return [a > 0 && a < 6, ""]
        },
        iso8601Week: function (a) {
          a = new Date(a.getTime());
          a.setDate(a.getDate() + 4 - (a.getDay() || 7));
          var b = a.getTime();
          a.setMonth(0);
          a.setDate(1);
          return Math.floor(Math.round((b - a) / 864E5) / 7) + 1
        },
        parseDate: function (a, b, c) {
          if (a == null || b == null) throw"Invalid arguments";
          b = typeof b == "object" ?
            b.toString() : b + "";
          if (b == "") return null;
          var e = (c ? c.shortYearCutoff : null) || this._defaults.shortYearCutoff;
          e = typeof e != "string" ? e : (new Date).getFullYear() % 100 + parseInt(e, 10);
          for (var f = (c ? c.dayNamesShort : null) || this._defaults.dayNamesShort, h = (c ? c.dayNames : null) || this._defaults.dayNames, i = (c ? c.monthNamesShort : null) || this._defaults.monthNamesShort, g = (c ? c.monthNames : null) || this._defaults.monthNames, j = c = -1, l = -1, u = -1, k = false, o = function (p) {
            (p = A + 1 < a.length && a.charAt(A + 1) == p) && A++;
            return p
          }, m = function (p) {
            var D =
              o(p);
            p = new RegExp("^\\d{1," + (p == "@" ? 14 : p == "!" ? 20 : p == "y" && D ? 4 : p == "o" ? 3 : 2) + "}");
            p = b.substring(q).match(p);
            if (!p) throw"Missing number at position " + q;
            q += p[0].length;
            return parseInt(p[0], 10)
          }, n = function (p, D, K) {
            p = d.map(o(p) ? K : D, function (w, x) {
              return [[x, w]]
            }).sort(function (w, x) {
              return -(w[1].length - x[1].length)
            });
            var E = -1;
            d.each(p, function (w, x) {
              w = x[1];
              if (b.substr(q, w.length).toLowerCase() == w.toLowerCase()) {
                E = x[0];
                q += w.length;
                return false
              }
            });
            if (E != -1) return E + 1; else throw"Unknown name at position " + q;
          }, s =
            function () {
              if (b.charAt(q) != a.charAt(A)) throw"Unexpected literal at position " + q;
              q++
            }, q = 0, A = 0; A < a.length; A++) if (k) if (a.charAt(A) == "'" && !o("'")) k = false; else s(); else switch (a.charAt(A)) {
            case "d":
              l = m("d");
              break;
            case "D":
              n("D", f, h);
              break;
            case "o":
              u = m("o");
              break;
            case "m":
              j = m("m");
              break;
            case "M":
              j = n("M", i, g);
              break;
            case "y":
              c = m("y");
              break;
            case "@":
              var v = new Date(m("@"));
              c = v.getFullYear();
              j = v.getMonth() + 1;
              l = v.getDate();
              break;
            case "!":
              v = new Date((m("!") - this._ticksTo1970) / 1E4);
              c = v.getFullYear();
              j = v.getMonth() +
                1;
              l = v.getDate();
              break;
            case "'":
              if (o("'")) s(); else k = true;
              break;
            default:
              s()
          }
          if (q < b.length) throw"Extra/unparsed characters found in date: " + b.substring(q);
          if (c == -1) c = (new Date).getFullYear(); else if (c < 100) c += (new Date).getFullYear() - (new Date).getFullYear() % 100 + (c <= e ? 0 : -100);
          if (u > -1) {
            j = 1;
            l = u;
            do {
              e = this._getDaysInMonth(c, j - 1);
              if (l <= e) break;
              j++;
              l -= e
            } while (1)
          }
          v = this._daylightSavingAdjust(new Date(c, j - 1, l));
          if (v.getFullYear() != c || v.getMonth() + 1 != j || v.getDate() != l) throw"Invalid date";
          return v
        },
        ATOM: "yy-mm-dd",
        COOKIE: "D, dd M yy",
        ISO_8601: "yy-mm-dd",
        RFC_822: "D, d M y",
        RFC_850: "DD, dd-M-y",
        RFC_1036: "D, d M y",
        RFC_1123: "D, d M yy",
        RFC_2822: "D, d M yy",
        RSS: "D, d M y",
        TICKS: "!",
        TIMESTAMP: "@",
        W3C: "yy-mm-dd",
        _ticksTo1970: (718685 + Math.floor(492.5) - Math.floor(19.7) + Math.floor(4.925)) * 24 * 60 * 60 * 1E7,
        formatDate: function (a, b, c) {
          if (!b) return "";
          var e = (c ? c.dayNamesShort : null) || this._defaults.dayNamesShort,
            f = (c ? c.dayNames : null) || this._defaults.dayNames,
            h = (c ? c.monthNamesShort : null) || this._defaults.monthNamesShort;
          c = (c ? c.monthNames :
            null) || this._defaults.monthNames;
          var i = function (o) {
            (o = k + 1 < a.length && a.charAt(k + 1) == o) && k++;
            return o
          }, g = function (o, m, n) {
            m = "" + m;
            if (i(o)) for (; m.length < n;) m = "0" + m;
            return m
          }, j = function (o, m, n, s) {
            return i(o) ? s[m] : n[m]
          }, l = "", u = false;
          if (b) for (var k = 0; k < a.length; k++) if (u) if (a.charAt(k) == "'" && !i("'")) u = false; else l += a.charAt(k); else switch (a.charAt(k)) {
            case "d":
              l += g("d", b.getDate(), 2);
              break;
            case "D":
              l += j("D", b.getDay(), e, f);
              break;
            case "o":
              l += g("o", Math.round(((new Date(b.getFullYear(), b.getMonth(), b.getDate())).getTime() -
                (new Date(b.getFullYear(), 0, 0)).getTime()) / 864E5), 3);
              break;
            case "m":
              l += g("m", b.getMonth() + 1, 2);
              break;
            case "M":
              l += j("M", b.getMonth(), h, c);
              break;
            case "y":
              l += i("y") ? b.getFullYear() : (b.getYear() % 100 < 10 ? "0" : "") + b.getYear() % 100;
              break;
            case "@":
              l += b.getTime();
              break;
            case "!":
              l += b.getTime() * 1E4 + this._ticksTo1970;
              break;
            case "'":
              if (i("'")) l += "'"; else u = true;
              break;
            default:
              l += a.charAt(k)
          }
          return l
        },
        _possibleChars: function (a) {
          for (var b = "", c = false, e = function (h) {
            (h = f + 1 < a.length && a.charAt(f + 1) == h) && f++;
            return h
          }, f =
            0; f < a.length; f++) if (c) if (a.charAt(f) == "'" && !e("'")) c = false; else b += a.charAt(f); else switch (a.charAt(f)) {
            case "d":
            case "m":
            case "y":
            case "@":
              b += "0123456789";
              break;
            case "D":
            case "M":
              return null;
            case "'":
              if (e("'")) b += "'"; else c = true;
              break;
            default:
              b += a.charAt(f)
          }
          return b
        },
        _get: function (a, b) {
          return a.settings[b] !== C ? a.settings[b] : this._defaults[b]
        },
        _setDateFromField: function (a, b) {
          if (a.input.val() != a.lastVal) {
            var c = this._get(a, "dateFormat"), e = a.lastVal = a.input ? a.input.val() : null, f, h;
            f = h = this._getDefaultDate(a);
            var i = this._getFormatConfig(a);
            try {
              f = this.parseDate(c, e, i) || h
            } catch (g) {
              this.log(g);
              e = b ? "" : e
            }
            a.selectedDay = f.getDate();
            a.drawMonth = a.selectedMonth = f.getMonth();
            a.drawYear = a.selectedYear = f.getFullYear();
            a.currentDay = e ? f.getDate() : 0;
            a.currentMonth = e ? f.getMonth() : 0;
            a.currentYear = e ? f.getFullYear() : 0;
            this._adjustInstDate(a)
          }
        },
        _getDefaultDate: function (a) {
          return this._restrictMinMax(a, this._determineDate(a, this._get(a, "defaultDate"), new Date))
        },
        _determineDate: function (a, b, c) {
          var e = function (h) {
            var i = new Date;
            i.setDate(i.getDate() + h);
            return i
          }, f = function (h) {
            try {
              return d.datepicker.parseDate(d.datepicker._get(a, "dateFormat"), h, d.datepicker._getFormatConfig(a))
            } catch (i) {
            }
            var g = (h.toLowerCase().match(/^c/) ? d.datepicker._getDate(a) : null) || new Date, j = g.getFullYear(),
              l = g.getMonth();
            g = g.getDate();
            for (var u = /([+-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g, k = u.exec(h); k;) {
              switch (k[2] || "d") {
                case "d":
                case "D":
                  g += parseInt(k[1], 10);
                  break;
                case "w":
                case "W":
                  g += parseInt(k[1], 10) * 7;
                  break;
                case "m":
                case "M":
                  l += parseInt(k[1], 10);
                  g =
                    Math.min(g, d.datepicker._getDaysInMonth(j, l));
                  break;
                case "y":
                case "Y":
                  j += parseInt(k[1], 10);
                  g = Math.min(g, d.datepicker._getDaysInMonth(j, l));
                  break
              }
              k = u.exec(h)
            }
            return new Date(j, l, g)
          };
          if (b = (b = b == null || b === "" ? c : typeof b == "string" ? f(b) : typeof b == "number" ? isNaN(b) ? c : e(b) : new Date(b.getTime())) && b.toString() == "Invalid Date" ? c : b) {
            b.setHours(0);
            b.setMinutes(0);
            b.setSeconds(0);
            b.setMilliseconds(0)
          }
          return this._daylightSavingAdjust(b)
        },
        _daylightSavingAdjust: function (a) {
          if (!a) return null;
          a.setHours(a.getHours() >
          12 ? a.getHours() + 2 : 0);
          return a
        },
        _setDate: function (a, b, c) {
          var e = !b, f = a.selectedMonth, h = a.selectedYear;
          b = this._restrictMinMax(a, this._determineDate(a, b, new Date));
          a.selectedDay = a.currentDay = b.getDate();
          a.drawMonth = a.selectedMonth = a.currentMonth = b.getMonth();
          a.drawYear = a.selectedYear = a.currentYear = b.getFullYear();
          if ((f != a.selectedMonth || h != a.selectedYear) && !c) this._notifyChange(a);
          this._adjustInstDate(a);
          if (a.input) a.input.val(e ? "" : this._formatDate(a))
        },
        _getDate: function (a) {
          return !a.currentYear || a.input &&
          a.input.val() == "" ? null : this._daylightSavingAdjust(new Date(a.currentYear, a.currentMonth, a.currentDay))
        },
        _generateHTML: function (a) {
          var b = new Date;
          b = this._daylightSavingAdjust(new Date(b.getFullYear(), b.getMonth(), b.getDate()));
          var c = this._get(a, "isRTL"), e = this._get(a, "showButtonPanel"), f = this._get(a, "hideIfNoPrevNext"),
            h = this._get(a, "navigationAsDateFormat"), i = this._getNumberOfMonths(a),
            g = this._get(a, "showCurrentAtPos"), j = this._get(a, "stepMonths"), l = i[0] != 1 || i[1] != 1,
            u = this._daylightSavingAdjust(!a.currentDay ?
              new Date(9999, 9, 9) : new Date(a.currentYear, a.currentMonth, a.currentDay)),
            k = this._getMinMaxDate(a, "min"), o = this._getMinMaxDate(a, "max");
          g = a.drawMonth - g;
          var m = a.drawYear;
          if (g < 0) {
            g += 12;
            m--
          }
          if (o) {
            var n = this._daylightSavingAdjust(new Date(o.getFullYear(), o.getMonth() - i[0] * i[1] + 1, o.getDate()));
            for (n = k && n < k ? k : n; this._daylightSavingAdjust(new Date(m, g, 1)) > n;) {
              g--;
              if (g < 0) {
                g = 11;
                m--
              }
            }
          }
          a.drawMonth = g;
          a.drawYear = m;
          n = this._get(a, "prevText");
          n = !h ? n : this.formatDate(n, this._daylightSavingAdjust(new Date(m, g - j, 1)), this._getFormatConfig(a));
          n = this._canAdjustMonth(a, -1, m, g) ? '<a class="ui-datepicker-prev ui-corner-all" onclick="DP_jQuery_' + B + ".datepicker._adjustDate('#" + a.id + "', -" + j + ", 'M');\" title=\"" + n + '"><span class="ui-icon ui-icon-circle-triangle-' + (c ? "e" : "w") + '">' + n + "</span></a>" : f ? "" : '<a class="ui-datepicker-prev ui-corner-all ui-state-disabled" title="' + n + '"><span class="ui-icon ui-icon-circle-triangle-' + (c ? "e" : "w") + '">' + n + "</span></a>";
          var s = this._get(a, "nextText");
          s = !h ? s : this.formatDate(s, this._daylightSavingAdjust(new Date(m,
            g + j, 1)), this._getFormatConfig(a));
          f = this._canAdjustMonth(a, +1, m, g) ? '<a class="ui-datepicker-next ui-corner-all" onclick="DP_jQuery_' + B + ".datepicker._adjustDate('#" + a.id + "', +" + j + ", 'M');\" title=\"" + s + '"><span class="ui-icon ui-icon-circle-triangle-' + (c ? "w" : "e") + '">' + s + "</span></a>" : f ? "" : '<a class="ui-datepicker-next ui-corner-all ui-state-disabled" title="' + s + '"><span class="ui-icon ui-icon-circle-triangle-' + (c ? "w" : "e") + '">' + s + "</span></a>";
          j = this._get(a, "currentText");
          s = this._get(a, "gotoCurrent") &&
          a.currentDay ? u : b;
          j = !h ? j : this.formatDate(j, s, this._getFormatConfig(a));
          h = !a.inline ? '<button type="button" class="ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all" onclick="DP_jQuery_' + B + '.datepicker._hideDatepicker();">' + this._get(a, "closeText") + "</button>" : "";
          e = e ? '<div class="ui-datepicker-buttonpane ui-widget-content">' + (c ? h : "") + (this._isInRange(a, s) ? '<button type="button" class="ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all" onclick="DP_jQuery_' +
            B + ".datepicker._gotoToday('#" + a.id + "');\">" + j + "</button>" : "") + (c ? "" : h) + "</div>" : "";
          h = parseInt(this._get(a, "firstDay"), 10);
          h = isNaN(h) ? 0 : h;
          j = this._get(a, "showWeek");
          s = this._get(a, "dayNames");
          this._get(a, "dayNamesShort");
          var q = this._get(a, "dayNamesMin"), A = this._get(a, "monthNames"), v = this._get(a, "monthNamesShort"),
            p = this._get(a, "beforeShowDay"), D = this._get(a, "showOtherMonths"),
            K = this._get(a, "selectOtherMonths");
          this._get(a, "calculateWeek");
          for (var E = this._getDefaultDate(a), w = "", x = 0; x < i[0]; x++) {
            var O =
              "";
            this.maxRows = 4;
            for (var G = 0; G < i[1]; G++) {
              var P = this._daylightSavingAdjust(new Date(m, g, a.selectedDay)), t = " ui-corner-all", y = "";
              if (l) {
                y += '<div class="ui-datepicker-group';
                if (i[1] > 1) switch (G) {
                  case 0:
                    y += " ui-datepicker-group-first";
                    t = " ui-corner-" + (c ? "right" : "left");
                    break;
                  case i[1] - 1:
                    y += " ui-datepicker-group-last";
                    t = " ui-corner-" + (c ? "left" : "right");
                    break;
                  default:
                    y += " ui-datepicker-group-middle";
                    t = "";
                    break
                }
                y += '">'
              }
              y += '<div class="ui-datepicker-header ui-widget-header ui-helper-clearfix' + t + '">' + (/all|left/.test(t) &&
              x == 0 ? c ? f : n : "") + (/all|right/.test(t) && x == 0 ? c ? n : f : "") + this._generateMonthYearHeader(a, g, m, k, o, x > 0 || G > 0, A, v) + '</div><table class="ui-datepicker-calendar"><thead><tr>';
              var z = j ? '<th class="ui-datepicker-week-col">' + this._get(a, "weekHeader") + "</th>" : "";
              for (t = 0; t < 7; t++) {
                var r = (t + h) % 7;
                z += "<th" + ((t + h + 6) % 7 >= 5 ? ' class="ui-datepicker-week-end"' : "") + '><span title="' + s[r] + '">' + q[r] + "</span></th>"
              }
              y += z + "</tr></thead><tbody>";
              z = this._getDaysInMonth(m, g);
              if (m == a.selectedYear && g == a.selectedMonth) a.selectedDay = Math.min(a.selectedDay,
                z);
              t = (this._getFirstDayOfMonth(m, g) - h + 7) % 7;
              z = Math.ceil((t + z) / 7);
              this.maxRows = z = l ? this.maxRows > z ? this.maxRows : z : z;
              r = this._daylightSavingAdjust(new Date(m, g, 1 - t));
              for (var Q = 0; Q < z; Q++) {
                y += "<tr>";
                var R = !j ? "" : '<td class="ui-datepicker-week-col">' + this._get(a, "calculateWeek")(r) + "</td>";
                for (t = 0; t < 7; t++) {
                  var I = p ? p.apply(a.input ? a.input[0] : null, [r]) : [true, ""], F = r.getMonth() != g,
                    L = F && !K || !I[0] || k && r < k || o && r > o;
                  R += '<td class="' + ((t + h + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + (F ? " ui-datepicker-other-month" : "") + (r.getTime() ==
                  P.getTime() && g == a.selectedMonth && a._keyEvent || E.getTime() == r.getTime() && E.getTime() == P.getTime() ? " " + this._dayOverClass : "") + (L ? " " + this._unselectableClass + " ui-state-disabled" : "") + (F && !D ? "" : " " + I[1] + (r.getTime() == u.getTime() ? " " + this._currentClass : "") + (r.getTime() == b.getTime() ? " ui-datepicker-today" : "")) + '"' + ((!F || D) && I[2] ? ' title="' + I[2] + '"' : "") + (L ? "" : ' onclick="DP_jQuery_' + B + ".datepicker._selectDay('#" + a.id + "'," + r.getMonth() + "," + r.getFullYear() + ', this);return false;"') + ">" + (F && !D ? "&#xa0;" : L ? '<span class="ui-state-default">' +
                    r.getDate() + "</span>" : '<a class="ui-state-default' + (r.getTime() == b.getTime() ? " ui-state-highlight" : "") + (r.getTime() == u.getTime() ? " ui-state-active" : "") + (F ? " ui-priority-secondary" : "") + '" href="#">' + r.getDate() + "</a>") + "</td>";
                  r.setDate(r.getDate() + 1);
                  r = this._daylightSavingAdjust(r)
                }
                y += R + "</tr>"
              }
              g++;
              if (g > 11) {
                g = 0;
                m++
              }
              y += "</tbody></table>" + (l ? "</div>" + (i[0] > 0 && G == i[1] - 1 ? '<div class="ui-datepicker-row-break"></div>' : "") : "");
              O += y
            }
            w += O
          }
          w += e + (d.browser.msie && parseInt(d.browser.version, 10) < 7 && !a.inline ? '<iframe src="javascript:false;" class="ui-datepicker-cover" frameborder="0"></iframe>' :
            "");
          a._keyEvent = false;
          return w
        },
        _generateMonthYearHeader: function (a, b, c, e, f, h, i, g) {
          var j = this._get(a, "changeMonth"), l = this._get(a, "changeYear"), u = this._get(a, "showMonthAfterYear"),
            k = '<div class="ui-datepicker-title">', o = "";
          if (h || !j) o += '<span class="ui-datepicker-month">' + i[b] + "</span>"; else {
            i = e && e.getFullYear() == c;
            var m = f && f.getFullYear() == c;
            o += '<select class="ui-datepicker-month" onchange="DP_jQuery_' + B + ".datepicker._selectMonthYear('#" + a.id + "', this, 'M');\" >";
            for (var n = 0; n < 12; n++) if ((!i || n >= e.getMonth()) &&
              (!m || n <= f.getMonth())) o += '<option value="' + n + '"' + (n == b ? ' selected="selected"' : "") + ">" + g[n] + "</option>";
            o += "</select>"
          }
          u || (k += o + (h || !(j && l) ? "&#xa0;" : ""));
          if (!a.yearshtml) {
            a.yearshtml = "";
            if (h || !l) k += '<span class="ui-datepicker-year">' + c + "</span>"; else {
              g = this._get(a, "yearRange").split(":");
              var s = (new Date).getFullYear();
              i = function (q) {
                q = q.match(/c[+-].*/) ? c + parseInt(q.substring(1), 10) : q.match(/[+-].*/) ? s + parseInt(q, 10) : parseInt(q, 10);
                return isNaN(q) ? s : q
              };
              b = i(g[0]);
              g = Math.max(b, i(g[1] || ""));
              b = e ? Math.max(b,
                e.getFullYear()) : b;
              g = f ? Math.min(g, f.getFullYear()) : g;
              for (a.yearshtml += '<select class="ui-datepicker-year" onchange="DP_jQuery_' + B + ".datepicker._selectMonthYear('#" + a.id + "', this, 'Y');\" >"; b <= g; b++) a.yearshtml += '<option value="' + b + '"' + (b == c ? ' selected="selected"' : "") + ">" + b + "</option>";
              a.yearshtml += "</select>";
              k += a.yearshtml;
              a.yearshtml = null
            }
          }
          k += this._get(a, "yearSuffix");
          if (u) k += (h || !(j && l) ? "&#xa0;" : "") + o;
          k += "</div>";
          return k
        },
        _adjustInstDate: function (a, b, c) {
          var e = a.drawYear + (c == "Y" ? b : 0), f = a.drawMonth +
            (c == "M" ? b : 0);
          b = Math.min(a.selectedDay, this._getDaysInMonth(e, f)) + (c == "D" ? b : 0);
          e = this._restrictMinMax(a, this._daylightSavingAdjust(new Date(e, f, b)));
          a.selectedDay = e.getDate();
          a.drawMonth = a.selectedMonth = e.getMonth();
          a.drawYear = a.selectedYear = e.getFullYear();
          if (c == "M" || c == "Y") this._notifyChange(a)
        },
        _restrictMinMax: function (a, b) {
          var c = this._getMinMaxDate(a, "min");
          a = this._getMinMaxDate(a, "max");
          b = c && b < c ? c : b;
          return b = a && b > a ? a : b
        },
        _notifyChange: function (a) {
          var b = this._get(a, "onChangeMonthYear");
          if (b) b.apply(a.input ?
            a.input[0] : null, [a.selectedYear, a.selectedMonth + 1, a])
        },
        _getNumberOfMonths: function (a) {
          a = this._get(a, "numberOfMonths");
          return a == null ? [1, 1] : typeof a == "number" ? [1, a] : a
        },
        _getMinMaxDate: function (a, b) {
          return this._determineDate(a, this._get(a, b + "Date"), null)
        },
        _getDaysInMonth: function (a, b) {
          return 32 - this._daylightSavingAdjust(new Date(a, b, 32)).getDate()
        },
        _getFirstDayOfMonth: function (a, b) {
          return (new Date(a, b, 1)).getDay()
        },
        _canAdjustMonth: function (a, b, c, e) {
          var f = this._getNumberOfMonths(a);
          c = this._daylightSavingAdjust(new Date(c,
            e + (b < 0 ? b : f[0] * f[1]), 1));
          b < 0 && c.setDate(this._getDaysInMonth(c.getFullYear(), c.getMonth()));
          return this._isInRange(a, c)
        },
        _isInRange: function (a, b) {
          var c = this._getMinMaxDate(a, "min");
          a = this._getMinMaxDate(a, "max");
          return (!c || b.getTime() >= c.getTime()) && (!a || b.getTime() <= a.getTime())
        },
        _getFormatConfig: function (a) {
          var b = this._get(a, "shortYearCutoff");
          b = typeof b != "string" ? b : (new Date).getFullYear() % 100 + parseInt(b, 10);
          return {
            shortYearCutoff: b, dayNamesShort: this._get(a, "dayNamesShort"), dayNames: this._get(a,
              "dayNames"), monthNamesShort: this._get(a, "monthNamesShort"), monthNames: this._get(a, "monthNames")
          }
        },
        _formatDate: function (a, b, c, e) {
          if (!b) {
            a.currentDay = a.selectedDay;
            a.currentMonth = a.selectedMonth;
            a.currentYear = a.selectedYear
          }
          b = b ? typeof b == "object" ? b : this._daylightSavingAdjust(new Date(e, c, b)) : this._daylightSavingAdjust(new Date(a.currentYear, a.currentMonth, a.currentDay));
          return this.formatDate(this._get(a, "dateFormat"), b, this._getFormatConfig(a))
        }
      });
      d.fn.datepicker = function (a) {
        if (!this.length) return this;
        if (!d.datepicker.initialized) {
          d(document).mousedown(d.datepicker._checkExternalClick).find("body").append(d.datepicker.dpDiv);
          d.datepicker.initialized = true
        }
        var b = Array.prototype.slice.call(arguments, 1);
        if (typeof a == "string" && (a == "isDisabled" || a == "getDate" || a == "widget")) return d.datepicker["_" + a + "Datepicker"].apply(d.datepicker, [this[0]].concat(b));
        if (a == "option" && arguments.length == 2 && typeof arguments[1] == "string") return d.datepicker["_" + a + "Datepicker"].apply(d.datepicker, [this[0]].concat(b));
        return this.each(function () {
          typeof a ==
          "string" ? d.datepicker["_" + a + "Datepicker"].apply(d.datepicker, [this].concat(b)) : d.datepicker._attachDatepicker(this, a)
        })
      };
      d.datepicker = new M;
      d.datepicker.initialized = false;
      d.datepicker.uuid = (new Date).getTime();
      d.datepicker.version = "1.8.16";
      window["DP_jQuery_" + B] = d
    })(jQuery);
    ;
    /*
 * jQuery UI Progressbar 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Progressbar
 *
 * Depends:
 *   jquery.ui.core.js
 *   jquery.ui.widget.js
 */
    (function (b, d) {
      b.widget("ui.progressbar", {
        options: {value: 0, max: 100}, min: 0, _create: function () {
          this.element.addClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").attr({
            role: "progressbar",
            "aria-valuemin": this.min,
            "aria-valuemax": this.options.max,
            "aria-valuenow": this._value()
          });
          this.valueDiv = b("<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>").appendTo(this.element);
          this.oldValue = this._value();
          this._refreshValue()
        }, destroy: function () {
          this.element.removeClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").removeAttr("role").removeAttr("aria-valuemin").removeAttr("aria-valuemax").removeAttr("aria-valuenow");
          this.valueDiv.remove();
          b.Widget.prototype.destroy.apply(this, arguments)
        }, value: function (a) {
          if (a === d) return this._value();
          this._setOption("value", a);
          return this
        }, _setOption: function (a, c) {
          if (a === "value") {
            this.options.value = c;
            this._refreshValue();
            this._value() === this.options.max && this._trigger("complete")
          }
          b.Widget.prototype._setOption.apply(this, arguments)
        }, _value: function () {
          var a = this.options.value;
          if (typeof a !== "number") a = 0;
          return Math.min(this.options.max, Math.max(this.min, a))
        }, _percentage: function () {
          return 100 *
            this._value() / this.options.max
        }, _refreshValue: function () {
          var a = this.value(), c = this._percentage();
          if (this.oldValue !== a) {
            this.oldValue = a;
            this._trigger("change")
          }
          this.valueDiv.toggle(a > this.min).toggleClass("ui-corner-right", a === this.options.max).width(c.toFixed(0) + "%");
          this.element.attr("aria-valuenow", a)
        }
      });
      b.extend(b.ui.progressbar, {version: "1.8.16"})
    })(jQuery);
    ;
    /*
 * jQuery UI Effects 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/
 */
    jQuery.effects || function (f, j) {
      function m(c) {
        var a;
        if (c && c.constructor == Array && c.length == 3) return c;
        if (a = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(c)) return [parseInt(a[1], 10), parseInt(a[2], 10), parseInt(a[3], 10)];
        if (a = /rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/.exec(c)) return [parseFloat(a[1]) * 2.55, parseFloat(a[2]) * 2.55, parseFloat(a[3]) * 2.55];
        if (a = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(c)) return [parseInt(a[1],
          16), parseInt(a[2], 16), parseInt(a[3], 16)];
        if (a = /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(c)) return [parseInt(a[1] + a[1], 16), parseInt(a[2] + a[2], 16), parseInt(a[3] + a[3], 16)];
        if (/rgba\(0, 0, 0, 0\)/.exec(c)) return n.transparent;
        return n[f.trim(c).toLowerCase()]
      }

      function s(c, a) {
        var b;
        do {
          b = f.curCSS(c, a);
          if (b != "" && b != "transparent" || f.nodeName(c, "body")) break;
          a = "backgroundColor"
        } while (c = c.parentNode);
        return m(b)
      }

      function o() {
        var c = document.defaultView ? document.defaultView.getComputedStyle(this, null) : this.currentStyle,
          a = {}, b, d;
        if (c && c.length && c[0] && c[c[0]]) for (var e = c.length; e--;) {
          b = c[e];
          if (typeof c[b] == "string") {
            d = b.replace(/\-(\w)/g, function (g, h) {
              return h.toUpperCase()
            });
            a[d] = c[b]
          }
        } else for (b in c) if (typeof c[b] === "string") a[b] = c[b];
        return a
      }

      function p(c) {
        var a, b;
        for (a in c) {
          b = c[a];
          if (b == null || f.isFunction(b) || a in t || /scrollbar/.test(a) || !/color/i.test(a) && isNaN(parseFloat(b))) delete c[a]
        }
        return c
      }

      function u(c, a) {
        var b = {_: 0}, d;
        for (d in a) if (c[d] != a[d]) b[d] = a[d];
        return b
      }

      function k(c, a, b, d) {
        if (typeof c == "object") {
          d =
            a;
          b = null;
          a = c;
          c = a.effect
        }
        if (f.isFunction(a)) {
          d = a;
          b = null;
          a = {}
        }
        if (typeof a == "number" || f.fx.speeds[a]) {
          d = b;
          b = a;
          a = {}
        }
        if (f.isFunction(b)) {
          d = b;
          b = null
        }
        a = a || {};
        b = b || a.duration;
        b = f.fx.off ? 0 : typeof b == "number" ? b : b in f.fx.speeds ? f.fx.speeds[b] : f.fx.speeds._default;
        d = d || a.complete;
        return [c, a, b, d]
      }

      function l(c) {
        if (!c || typeof c === "number" || f.fx.speeds[c]) return true;
        if (typeof c === "string" && !f.effects[c]) return true;
        return false
      }

      f.effects = {};
      f.each(["backgroundColor", "borderBottomColor", "borderLeftColor", "borderRightColor",
        "borderTopColor", "borderColor", "color", "outlineColor"], function (c, a) {
        f.fx.step[a] = function (b) {
          if (!b.colorInit) {
            b.start = s(b.elem, a);
            b.end = m(b.end);
            b.colorInit = true
          }
          b.elem.style[a] = "rgb(" + Math.max(Math.min(parseInt(b.pos * (b.end[0] - b.start[0]) + b.start[0], 10), 255), 0) + "," + Math.max(Math.min(parseInt(b.pos * (b.end[1] - b.start[1]) + b.start[1], 10), 255), 0) + "," + Math.max(Math.min(parseInt(b.pos * (b.end[2] - b.start[2]) + b.start[2], 10), 255), 0) + ")"
        }
      });
      var n = {
        aqua: [0, 255, 255],
        azure: [240, 255, 255],
        beige: [245, 245, 220],
        black: [0,
          0, 0],
        blue: [0, 0, 255],
        brown: [165, 42, 42],
        cyan: [0, 255, 255],
        darkblue: [0, 0, 139],
        darkcyan: [0, 139, 139],
        darkgrey: [169, 169, 169],
        darkgreen: [0, 100, 0],
        darkkhaki: [189, 183, 107],
        darkmagenta: [139, 0, 139],
        darkolivegreen: [85, 107, 47],
        darkorange: [255, 140, 0],
        darkorchid: [153, 50, 204],
        darkred: [139, 0, 0],
        darksalmon: [233, 150, 122],
        darkviolet: [148, 0, 211],
        fuchsia: [255, 0, 255],
        gold: [255, 215, 0],
        green: [0, 128, 0],
        indigo: [75, 0, 130],
        khaki: [240, 230, 140],
        lightblue: [173, 216, 230],
        lightcyan: [224, 255, 255],
        lightgreen: [144, 238, 144],
        lightgrey: [211,
          211, 211],
        lightpink: [255, 182, 193],
        lightyellow: [255, 255, 224],
        lime: [0, 255, 0],
        magenta: [255, 0, 255],
        maroon: [128, 0, 0],
        navy: [0, 0, 128],
        olive: [128, 128, 0],
        orange: [255, 165, 0],
        pink: [255, 192, 203],
        purple: [128, 0, 128],
        violet: [128, 0, 128],
        red: [255, 0, 0],
        silver: [192, 192, 192],
        white: [255, 255, 255],
        yellow: [255, 255, 0],
        transparent: [255, 255, 255]
      }, q = ["add", "remove", "toggle"], t = {
        border: 1,
        borderBottom: 1,
        borderColor: 1,
        borderLeft: 1,
        borderRight: 1,
        borderTop: 1,
        borderWidth: 1,
        margin: 1,
        padding: 1
      };
      f.effects.animateClass = function (c, a, b,
                                         d) {
        if (f.isFunction(b)) {
          d = b;
          b = null
        }
        return this.queue(function () {
          var e = f(this), g = e.attr("style") || " ", h = p(o.call(this)), r, v = e.attr("class");
          f.each(q, function (w, i) {
            c[i] && e[i + "Class"](c[i])
          });
          r = p(o.call(this));
          e.attr("class", v);
          e.animate(u(h, r), {
            queue: false, duration: a, easing: b, complete: function () {
              f.each(q, function (w, i) {
                c[i] && e[i + "Class"](c[i])
              });
              if (typeof e.attr("style") == "object") {
                e.attr("style").cssText = "";
                e.attr("style").cssText = g
              } else e.attr("style", g);
              d && d.apply(this, arguments);
              f.dequeue(this)
            }
          })
        })
      };
      f.fn.extend({
        _addClass: f.fn.addClass, addClass: function (c, a, b, d) {
          return a ? f.effects.animateClass.apply(this, [{add: c}, a, b, d]) : this._addClass(c)
        }, _removeClass: f.fn.removeClass, removeClass: function (c, a, b, d) {
          return a ? f.effects.animateClass.apply(this, [{remove: c}, a, b, d]) : this._removeClass(c)
        }, _toggleClass: f.fn.toggleClass, toggleClass: function (c, a, b, d, e) {
          return typeof a == "boolean" || a === j ? b ? f.effects.animateClass.apply(this, [a ? {add: c} : {remove: c}, b, d, e]) : this._toggleClass(c, a) : f.effects.animateClass.apply(this,
            [{toggle: c}, a, b, d])
        }, switchClass: function (c, a, b, d, e) {
          return f.effects.animateClass.apply(this, [{add: a, remove: c}, b, d, e])
        }
      });
      f.extend(f.effects, {
        version: "1.8.16", save: function (c, a) {
          for (var b = 0; b < a.length; b++) a[b] !== null && c.data("ec.storage." + a[b], c[0].style[a[b]])
        }, restore: function (c, a) {
          for (var b = 0; b < a.length; b++) a[b] !== null && c.css(a[b], c.data("ec.storage." + a[b]))
        }, setMode: function (c, a) {
          if (a == "toggle") a = c.is(":hidden") ? "show" : "hide";
          return a
        }, getBaseline: function (c, a) {
          var b;
          switch (c[0]) {
            case "top":
              b =
                0;
              break;
            case "middle":
              b = 0.5;
              break;
            case "bottom":
              b = 1;
              break;
            default:
              b = c[0] / a.height
          }
          switch (c[1]) {
            case "left":
              c = 0;
              break;
            case "center":
              c = 0.5;
              break;
            case "right":
              c = 1;
              break;
            default:
              c = c[1] / a.width
          }
          return {x: c, y: b}
        }, createWrapper: function (c) {
          if (c.parent().is(".ui-effects-wrapper")) return c.parent();
          var a = {width: c.outerWidth(true), height: c.outerHeight(true), "float": c.css("float")},
            b = f("<div></div>").addClass("ui-effects-wrapper").css({
              fontSize: "100%",
              background: "transparent",
              border: "none",
              margin: 0,
              padding: 0
            }),
            d = document.activeElement;
          c.wrap(b);
          if (c[0] === d || f.contains(c[0], d)) f(d).focus();
          b = c.parent();
          if (c.css("position") == "static") {
            b.css({position: "relative"});
            c.css({position: "relative"})
          } else {
            f.extend(a, {position: c.css("position"), zIndex: c.css("z-index")});
            f.each(["top", "left", "bottom", "right"], function (e, g) {
              a[g] = c.css(g);
              if (isNaN(parseInt(a[g], 10))) a[g] = "auto"
            });
            c.css({position: "relative", top: 0, left: 0, right: "auto", bottom: "auto"})
          }
          return b.css(a).show()
        }, removeWrapper: function (c) {
          var a, b = document.activeElement;
          if (c.parent().is(".ui-effects-wrapper")) {
            a = c.parent().replaceWith(c);
            if (c[0] === b || f.contains(c[0], b)) f(b).focus();
            return a
          }
          return c
        }, setTransition: function (c, a, b, d) {
          d = d || {};
          f.each(a, function (e, g) {
            unit = c.cssUnit(g);
            if (unit[0] > 0) d[g] = unit[0] * b + unit[1]
          });
          return d
        }
      });
      f.fn.extend({
        effect: function (c) {
          var a = k.apply(this, arguments), b = {options: a[1], duration: a[2], callback: a[3]};
          a = b.options.mode;
          var d = f.effects[c];
          if (f.fx.off || !d) return a ? this[a](b.duration, b.callback) : this.each(function () {
            b.callback && b.callback.call(this)
          });
          return d.call(this, b)
        }, _show: f.fn.show, show: function (c) {
          if (l(c)) return this._show.apply(this, arguments); else {
            var a = k.apply(this, arguments);
            a[1].mode = "show";
            return this.effect.apply(this, a)
          }
        }, _hide: f.fn.hide, hide: function (c) {
          if (l(c)) return this._hide.apply(this, arguments); else {
            var a = k.apply(this, arguments);
            a[1].mode = "hide";
            return this.effect.apply(this, a)
          }
        }, __toggle: f.fn.toggle, toggle: function (c) {
          if (l(c) || typeof c === "boolean" || f.isFunction(c)) return this.__toggle.apply(this, arguments); else {
            var a = k.apply(this,
              arguments);
            a[1].mode = "toggle";
            return this.effect.apply(this, a)
          }
        }, cssUnit: function (c) {
          var a = this.css(c), b = [];
          f.each(["em", "px", "%", "pt"], function (d, e) {
            if (a.indexOf(e) > 0) b = [parseFloat(a), e]
          });
          return b
        }
      });
      f.easing.jswing = f.easing.swing;
      f.extend(f.easing, {
        def: "easeOutQuad", swing: function (c, a, b, d, e) {
          return f.easing[f.easing.def](c, a, b, d, e)
        }, easeInQuad: function (c, a, b, d, e) {
          return d * (a /= e) * a + b
        }, easeOutQuad: function (c, a, b, d, e) {
          return -d * (a /= e) * (a - 2) + b
        }, easeInOutQuad: function (c, a, b, d, e) {
          if ((a /= e / 2) < 1) return d /
            2 * a * a + b;
          return -d / 2 * (--a * (a - 2) - 1) + b
        }, easeInCubic: function (c, a, b, d, e) {
          return d * (a /= e) * a * a + b
        }, easeOutCubic: function (c, a, b, d, e) {
          return d * ((a = a / e - 1) * a * a + 1) + b
        }, easeInOutCubic: function (c, a, b, d, e) {
          if ((a /= e / 2) < 1) return d / 2 * a * a * a + b;
          return d / 2 * ((a -= 2) * a * a + 2) + b
        }, easeInQuart: function (c, a, b, d, e) {
          return d * (a /= e) * a * a * a + b
        }, easeOutQuart: function (c, a, b, d, e) {
          return -d * ((a = a / e - 1) * a * a * a - 1) + b
        }, easeInOutQuart: function (c, a, b, d, e) {
          if ((a /= e / 2) < 1) return d / 2 * a * a * a * a + b;
          return -d / 2 * ((a -= 2) * a * a * a - 2) + b
        }, easeInQuint: function (c, a, b,
                                  d, e) {
          return d * (a /= e) * a * a * a * a + b
        }, easeOutQuint: function (c, a, b, d, e) {
          return d * ((a = a / e - 1) * a * a * a * a + 1) + b
        }, easeInOutQuint: function (c, a, b, d, e) {
          if ((a /= e / 2) < 1) return d / 2 * a * a * a * a * a + b;
          return d / 2 * ((a -= 2) * a * a * a * a + 2) + b
        }, easeInSine: function (c, a, b, d, e) {
          return -d * Math.cos(a / e * (Math.PI / 2)) + d + b
        }, easeOutSine: function (c, a, b, d, e) {
          return d * Math.sin(a / e * (Math.PI / 2)) + b
        }, easeInOutSine: function (c, a, b, d, e) {
          return -d / 2 * (Math.cos(Math.PI * a / e) - 1) + b
        }, easeInExpo: function (c, a, b, d, e) {
          return a == 0 ? b : d * Math.pow(2, 10 * (a / e - 1)) + b
        }, easeOutExpo: function (c,
                                  a, b, d, e) {
          return a == e ? b + d : d * (-Math.pow(2, -10 * a / e) + 1) + b
        }, easeInOutExpo: function (c, a, b, d, e) {
          if (a == 0) return b;
          if (a == e) return b + d;
          if ((a /= e / 2) < 1) return d / 2 * Math.pow(2, 10 * (a - 1)) + b;
          return d / 2 * (-Math.pow(2, -10 * --a) + 2) + b
        }, easeInCirc: function (c, a, b, d, e) {
          return -d * (Math.sqrt(1 - (a /= e) * a) - 1) + b
        }, easeOutCirc: function (c, a, b, d, e) {
          return d * Math.sqrt(1 - (a = a / e - 1) * a) + b
        }, easeInOutCirc: function (c, a, b, d, e) {
          if ((a /= e / 2) < 1) return -d / 2 * (Math.sqrt(1 - a * a) - 1) + b;
          return d / 2 * (Math.sqrt(1 - (a -= 2) * a) + 1) + b
        }, easeInElastic: function (c, a, b,
                                    d, e) {
          c = 1.70158;
          var g = 0, h = d;
          if (a == 0) return b;
          if ((a /= e) == 1) return b + d;
          g || (g = e * 0.3);
          if (h < Math.abs(d)) {
            h = d;
            c = g / 4
          } else c = g / (2 * Math.PI) * Math.asin(d / h);
          return -(h * Math.pow(2, 10 * (a -= 1)) * Math.sin((a * e - c) * 2 * Math.PI / g)) + b
        }, easeOutElastic: function (c, a, b, d, e) {
          c = 1.70158;
          var g = 0, h = d;
          if (a == 0) return b;
          if ((a /= e) == 1) return b + d;
          g || (g = e * 0.3);
          if (h < Math.abs(d)) {
            h = d;
            c = g / 4
          } else c = g / (2 * Math.PI) * Math.asin(d / h);
          return h * Math.pow(2, -10 * a) * Math.sin((a * e - c) * 2 * Math.PI / g) + d + b
        }, easeInOutElastic: function (c, a, b, d, e) {
          c = 1.70158;
          var g =
            0, h = d;
          if (a == 0) return b;
          if ((a /= e / 2) == 2) return b + d;
          g || (g = e * 0.3 * 1.5);
          if (h < Math.abs(d)) {
            h = d;
            c = g / 4
          } else c = g / (2 * Math.PI) * Math.asin(d / h);
          if (a < 1) return -0.5 * h * Math.pow(2, 10 * (a -= 1)) * Math.sin((a * e - c) * 2 * Math.PI / g) + b;
          return h * Math.pow(2, -10 * (a -= 1)) * Math.sin((a * e - c) * 2 * Math.PI / g) * 0.5 + d + b
        }, easeInBack: function (c, a, b, d, e, g) {
          if (g == j) g = 1.70158;
          return d * (a /= e) * a * ((g + 1) * a - g) + b
        }, easeOutBack: function (c, a, b, d, e, g) {
          if (g == j) g = 1.70158;
          return d * ((a = a / e - 1) * a * ((g + 1) * a + g) + 1) + b
        }, easeInOutBack: function (c, a, b, d, e, g) {
          if (g == j) g = 1.70158;
          if ((a /= e / 2) < 1) return d / 2 * a * a * (((g *= 1.525) + 1) * a - g) + b;
          return d / 2 * ((a -= 2) * a * (((g *= 1.525) + 1) * a + g) + 2) + b
        }, easeInBounce: function (c, a, b, d, e) {
          return d - f.easing.easeOutBounce(c, e - a, 0, d, e) + b
        }, easeOutBounce: function (c, a, b, d, e) {
          return (a /= e) < 1 / 2.75 ? d * 7.5625 * a * a + b : a < 2 / 2.75 ? d * (7.5625 * (a -= 1.5 / 2.75) * a + 0.75) + b : a < 2.5 / 2.75 ? d * (7.5625 * (a -= 2.25 / 2.75) * a + 0.9375) + b : d * (7.5625 * (a -= 2.625 / 2.75) * a + 0.984375) + b
        }, easeInOutBounce: function (c, a, b, d, e) {
          if (a < e / 2) return f.easing.easeInBounce(c, a * 2, 0, d, e) * 0.5 + b;
          return f.easing.easeOutBounce(c,
            a * 2 - e, 0, d, e) * 0.5 + d * 0.5 + b
        }
      })
    }(jQuery);
    ;
    /*
 * jQuery UI Effects Blind 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Blind
 *
 * Depends:
 *	jquery.effects.core.js
 */
    (function (b) {
      b.effects.blind = function (c) {
        return this.queue(function () {
          var a = b(this), g = ["position", "top", "bottom", "left", "right"],
            f = b.effects.setMode(a, c.options.mode || "hide"), d = c.options.direction || "vertical";
          b.effects.save(a, g);
          a.show();
          var e = b.effects.createWrapper(a).css({overflow: "hidden"}), h = d == "vertical" ? "height" : "width";
          d = d == "vertical" ? e.height() : e.width();
          f == "show" && e.css(h, 0);
          var i = {};
          i[h] = f == "show" ? d : 0;
          e.animate(i, c.duration, c.options.easing, function () {
            f == "hide" && a.hide();
            b.effects.restore(a,
              g);
            b.effects.removeWrapper(a);
            c.callback && c.callback.apply(a[0], arguments);
            a.dequeue()
          })
        })
      }
    })(jQuery);
    ;
    /*
 * jQuery UI Effects Bounce 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Bounce
 *
 * Depends:
 *	jquery.effects.core.js
 */
    (function (e) {
      e.effects.bounce = function (b) {
        return this.queue(function () {
          var a = e(this), l = ["position", "top", "bottom", "left", "right"],
            h = e.effects.setMode(a, b.options.mode || "effect"), d = b.options.direction || "up",
            c = b.options.distance || 20, m = b.options.times || 5, i = b.duration || 250;
          /show|hide/.test(h) && l.push("opacity");
          e.effects.save(a, l);
          a.show();
          e.effects.createWrapper(a);
          var f = d == "up" || d == "down" ? "top" : "left";
          d = d == "up" || d == "left" ? "pos" : "neg";
          c = b.options.distance || (f == "top" ? a.outerHeight({margin: true}) / 3 : a.outerWidth({margin: true}) /
            3);
          if (h == "show") a.css("opacity", 0).css(f, d == "pos" ? -c : c);
          if (h == "hide") c /= m * 2;
          h != "hide" && m--;
          if (h == "show") {
            var g = {opacity: 1};
            g[f] = (d == "pos" ? "+=" : "-=") + c;
            a.animate(g, i / 2, b.options.easing);
            c /= 2;
            m--
          }
          for (g = 0; g < m; g++) {
            var j = {}, k = {};
            j[f] = (d == "pos" ? "-=" : "+=") + c;
            k[f] = (d == "pos" ? "+=" : "-=") + c;
            a.animate(j, i / 2, b.options.easing).animate(k, i / 2, b.options.easing);
            c = h == "hide" ? c * 2 : c / 2
          }
          if (h == "hide") {
            g = {opacity: 0};
            g[f] = (d == "pos" ? "-=" : "+=") + c;
            a.animate(g, i / 2, b.options.easing, function () {
              a.hide();
              e.effects.restore(a, l);
              e.effects.removeWrapper(a);
              b.callback && b.callback.apply(this, arguments)
            })
          } else {
            j = {};
            k = {};
            j[f] = (d == "pos" ? "-=" : "+=") + c;
            k[f] = (d == "pos" ? "+=" : "-=") + c;
            a.animate(j, i / 2, b.options.easing).animate(k, i / 2, b.options.easing, function () {
              e.effects.restore(a, l);
              e.effects.removeWrapper(a);
              b.callback && b.callback.apply(this, arguments)
            })
          }
          a.queue("fx", function () {
            a.dequeue()
          });
          a.dequeue()
        })
      }
    })(jQuery);
    ;
    /*
 * jQuery UI Effects Clip 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Clip
 *
 * Depends:
 *	jquery.effects.core.js
 */
    (function (b) {
      b.effects.clip = function (e) {
        return this.queue(function () {
          var a = b(this), i = ["position", "top", "bottom", "left", "right", "height", "width"],
            f = b.effects.setMode(a, e.options.mode || "hide"), c = e.options.direction || "vertical";
          b.effects.save(a, i);
          a.show();
          var d = b.effects.createWrapper(a).css({overflow: "hidden"});
          d = a[0].tagName == "IMG" ? d : a;
          var g = {size: c == "vertical" ? "height" : "width", position: c == "vertical" ? "top" : "left"};
          c = c == "vertical" ? d.height() : d.width();
          if (f == "show") {
            d.css(g.size, 0);
            d.css(g.position,
              c / 2)
          }
          var h = {};
          h[g.size] = f == "show" ? c : 0;
          h[g.position] = f == "show" ? 0 : c / 2;
          d.animate(h, {
            queue: false, duration: e.duration, easing: e.options.easing, complete: function () {
              f == "hide" && a.hide();
              b.effects.restore(a, i);
              b.effects.removeWrapper(a);
              e.callback && e.callback.apply(a[0], arguments);
              a.dequeue()
            }
          })
        })
      }
    })(jQuery);
    ;
    /*
 * jQuery UI Effects Drop 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Drop
 *
 * Depends:
 *	jquery.effects.core.js
 */
    (function (c) {
      c.effects.drop = function (d) {
        return this.queue(function () {
          var a = c(this), h = ["position", "top", "bottom", "left", "right", "opacity"],
            e = c.effects.setMode(a, d.options.mode || "hide"), b = d.options.direction || "left";
          c.effects.save(a, h);
          a.show();
          c.effects.createWrapper(a);
          var f = b == "up" || b == "down" ? "top" : "left";
          b = b == "up" || b == "left" ? "pos" : "neg";
          var g = d.options.distance || (f == "top" ? a.outerHeight({margin: true}) / 2 : a.outerWidth({margin: true}) / 2);
          if (e == "show") a.css("opacity", 0).css(f, b == "pos" ? -g : g);
          var i = {
            opacity: e ==
            "show" ? 1 : 0
          };
          i[f] = (e == "show" ? b == "pos" ? "+=" : "-=" : b == "pos" ? "-=" : "+=") + g;
          a.animate(i, {
            queue: false, duration: d.duration, easing: d.options.easing, complete: function () {
              e == "hide" && a.hide();
              c.effects.restore(a, h);
              c.effects.removeWrapper(a);
              d.callback && d.callback.apply(this, arguments);
              a.dequeue()
            }
          })
        })
      }
    })(jQuery);
    ;
    /*
 * jQuery UI Effects Explode 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Explode
 *
 * Depends:
 *	jquery.effects.core.js
 */
    (function (j) {
      j.effects.explode = function (a) {
        return this.queue(function () {
          var c = a.options.pieces ? Math.round(Math.sqrt(a.options.pieces)) : 3,
            d = a.options.pieces ? Math.round(Math.sqrt(a.options.pieces)) : 3;
          a.options.mode = a.options.mode == "toggle" ? j(this).is(":visible") ? "hide" : "show" : a.options.mode;
          var b = j(this).show().css("visibility", "hidden"), g = b.offset();
          g.top -= parseInt(b.css("marginTop"), 10) || 0;
          g.left -= parseInt(b.css("marginLeft"), 10) || 0;
          for (var h = b.outerWidth(true), i = b.outerHeight(true), e = 0; e < c; e++) for (var f =
            0; f < d; f++) b.clone().appendTo("body").wrap("<div></div>").css({
            position: "absolute",
            visibility: "visible",
            left: -f * (h / d),
            top: -e * (i / c)
          }).parent().addClass("ui-effects-explode").css({
            position: "absolute",
            overflow: "hidden",
            width: h / d,
            height: i / c,
            left: g.left + f * (h / d) + (a.options.mode == "show" ? (f - Math.floor(d / 2)) * (h / d) : 0),
            top: g.top + e * (i / c) + (a.options.mode == "show" ? (e - Math.floor(c / 2)) * (i / c) : 0),
            opacity: a.options.mode == "show" ? 0 : 1
          }).animate({
            left: g.left + f * (h / d) + (a.options.mode == "show" ? 0 : (f - Math.floor(d / 2)) * (h / d)),
            top: g.top +
            e * (i / c) + (a.options.mode == "show" ? 0 : (e - Math.floor(c / 2)) * (i / c)),
            opacity: a.options.mode == "show" ? 1 : 0
          }, a.duration || 500);
          setTimeout(function () {
            a.options.mode == "show" ? b.css({visibility: "visible"}) : b.css({visibility: "visible"}).hide();
            a.callback && a.callback.apply(b[0]);
            b.dequeue();
            j("div.ui-effects-explode").remove()
          }, a.duration || 500)
        })
      }
    })(jQuery);
    ;
    /*
 * jQuery UI Effects Fade 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Fade
 *
 * Depends:
 *	jquery.effects.core.js
 */
    (function (b) {
      b.effects.fade = function (a) {
        return this.queue(function () {
          var c = b(this), d = b.effects.setMode(c, a.options.mode || "hide");
          c.animate({opacity: d}, {
            queue: false, duration: a.duration, easing: a.options.easing, complete: function () {
              a.callback && a.callback.apply(this, arguments);
              c.dequeue()
            }
          })
        })
      }
    })(jQuery);
    ;
    /*
 * jQuery UI Effects Fold 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Fold
 *
 * Depends:
 *	jquery.effects.core.js
 */
    (function (c) {
      c.effects.fold = function (a) {
        return this.queue(function () {
          var b = c(this), j = ["position", "top", "bottom", "left", "right"],
            d = c.effects.setMode(b, a.options.mode || "hide"), g = a.options.size || 15, h = !!a.options.horizFirst,
            k = a.duration ? a.duration / 2 : c.fx.speeds._default / 2;
          c.effects.save(b, j);
          b.show();
          var e = c.effects.createWrapper(b).css({overflow: "hidden"}), f = d == "show" != h,
            l = f ? ["width", "height"] : ["height", "width"];
          f = f ? [e.width(), e.height()] : [e.height(), e.width()];
          var i = /([0-9]+)%/.exec(g);
          if (i) g = parseInt(i[1],
            10) / 100 * f[d == "hide" ? 0 : 1];
          if (d == "show") e.css(h ? {height: 0, width: g} : {height: g, width: 0});
          h = {};
          i = {};
          h[l[0]] = d == "show" ? f[0] : g;
          i[l[1]] = d == "show" ? f[1] : 0;
          e.animate(h, k, a.options.easing).animate(i, k, a.options.easing, function () {
            d == "hide" && b.hide();
            c.effects.restore(b, j);
            c.effects.removeWrapper(b);
            a.callback && a.callback.apply(b[0], arguments);
            b.dequeue()
          })
        })
      }
    })(jQuery);
    ;
    /*
 * jQuery UI Effects Highlight 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Highlight
 *
 * Depends:
 *	jquery.effects.core.js
 */
    (function (b) {
      b.effects.highlight = function (c) {
        return this.queue(function () {
          var a = b(this), e = ["backgroundImage", "backgroundColor", "opacity"],
            d = b.effects.setMode(a, c.options.mode || "show"), f = {backgroundColor: a.css("backgroundColor")};
          if (d == "hide") f.opacity = 0;
          b.effects.save(a, e);
          a.show().css({backgroundImage: "none", backgroundColor: c.options.color || "#ffff99"}).animate(f, {
            queue: false, duration: c.duration, easing: c.options.easing, complete: function () {
              d == "hide" && a.hide();
              b.effects.restore(a, e);
              d == "show" && !b.support.opacity &&
              this.style.removeAttribute("filter");
              c.callback && c.callback.apply(this, arguments);
              a.dequeue()
            }
          })
        })
      }
    })(jQuery);
    ;
    /*
 * jQuery UI Effects Pulsate 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Pulsate
 *
 * Depends:
 *	jquery.effects.core.js
 */
    (function (d) {
      d.effects.pulsate = function (a) {
        return this.queue(function () {
          var b = d(this), c = d.effects.setMode(b, a.options.mode || "show");
          times = (a.options.times || 5) * 2 - 1;
          duration = a.duration ? a.duration / 2 : d.fx.speeds._default / 2;
          isVisible = b.is(":visible");
          animateTo = 0;
          if (!isVisible) {
            b.css("opacity", 0).show();
            animateTo = 1
          }
          if (c == "hide" && isVisible || c == "show" && !isVisible) times--;
          for (c = 0; c < times; c++) {
            b.animate({opacity: animateTo}, duration, a.options.easing);
            animateTo = (animateTo + 1) % 2
          }
          b.animate({opacity: animateTo}, duration,
            a.options.easing, function () {
              animateTo == 0 && b.hide();
              a.callback && a.callback.apply(this, arguments)
            });
          b.queue("fx", function () {
            b.dequeue()
          }).dequeue()
        })
      }
    })(jQuery);
    ;
    /*
 * jQuery UI Effects Scale 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Scale
 *
 * Depends:
 *	jquery.effects.core.js
 */
    (function (c) {
      c.effects.puff = function (b) {
        return this.queue(function () {
          var a = c(this), e = c.effects.setMode(a, b.options.mode || "hide"),
            g = parseInt(b.options.percent, 10) || 150, h = g / 100, i = {height: a.height(), width: a.width()};
          c.extend(b.options, {
            fade: true,
            mode: e,
            percent: e == "hide" ? g : 100,
            from: e == "hide" ? i : {height: i.height * h, width: i.width * h}
          });
          a.effect("scale", b.options, b.duration, b.callback);
          a.dequeue()
        })
      };
      c.effects.scale = function (b) {
        return this.queue(function () {
          var a = c(this), e = c.extend(true, {}, b.options), g = c.effects.setMode(a,
            b.options.mode || "effect"),
            h = parseInt(b.options.percent, 10) || (parseInt(b.options.percent, 10) == 0 ? 0 : g == "hide" ? 0 : 100),
            i = b.options.direction || "both", f = b.options.origin;
          if (g != "effect") {
            e.origin = f || ["middle", "center"];
            e.restore = true
          }
          f = {height: a.height(), width: a.width()};
          a.from = b.options.from || (g == "show" ? {height: 0, width: 0} : f);
          h = {y: i != "horizontal" ? h / 100 : 1, x: i != "vertical" ? h / 100 : 1};
          a.to = {height: f.height * h.y, width: f.width * h.x};
          if (b.options.fade) {
            if (g == "show") {
              a.from.opacity = 0;
              a.to.opacity = 1
            }
            if (g == "hide") {
              a.from.opacity =
                1;
              a.to.opacity = 0
            }
          }
          e.from = a.from;
          e.to = a.to;
          e.mode = g;
          a.effect("size", e, b.duration, b.callback);
          a.dequeue()
        })
      };
      c.effects.size = function (b) {
        return this.queue(function () {
          var a = c(this), e = ["position", "top", "bottom", "left", "right", "width", "height", "overflow", "opacity"],
            g = ["position", "top", "bottom", "left", "right", "overflow", "opacity"],
            h = ["width", "height", "overflow"], i = ["fontSize"],
            f = ["borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom"],
            k = ["borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight"],
            p = c.effects.setMode(a, b.options.mode || "effect"), n = b.options.restore || false,
            m = b.options.scale || "both", l = b.options.origin, j = {height: a.height(), width: a.width()};
          a.from = b.options.from || j;
          a.to = b.options.to || j;
          if (l) {
            l = c.effects.getBaseline(l, j);
            a.from.top = (j.height - a.from.height) * l.y;
            a.from.left = (j.width - a.from.width) * l.x;
            a.to.top = (j.height - a.to.height) * l.y;
            a.to.left = (j.width - a.to.width) * l.x
          }
          var d = {
            from: {y: a.from.height / j.height, x: a.from.width / j.width},
            to: {y: a.to.height / j.height, x: a.to.width / j.width}
          };
          if (m == "box" || m == "both") {
            if (d.from.y != d.to.y) {
              e = e.concat(f);
              a.from = c.effects.setTransition(a, f, d.from.y, a.from);
              a.to = c.effects.setTransition(a, f, d.to.y, a.to)
            }
            if (d.from.x != d.to.x) {
              e = e.concat(k);
              a.from = c.effects.setTransition(a, k, d.from.x, a.from);
              a.to = c.effects.setTransition(a, k, d.to.x, a.to)
            }
          }
          if (m == "content" || m == "both") if (d.from.y != d.to.y) {
            e = e.concat(i);
            a.from = c.effects.setTransition(a, i, d.from.y, a.from);
            a.to = c.effects.setTransition(a, i, d.to.y, a.to)
          }
          c.effects.save(a, n ? e : g);
          a.show();
          c.effects.createWrapper(a);
          a.css("overflow", "hidden").css(a.from);
          if (m == "content" || m == "both") {
            f = f.concat(["marginTop", "marginBottom"]).concat(i);
            k = k.concat(["marginLeft", "marginRight"]);
            h = e.concat(f).concat(k);
            a.find("*[width]").each(function () {
              child = c(this);
              n && c.effects.save(child, h);
              var o = {height: child.height(), width: child.width()};
              child.from = {height: o.height * d.from.y, width: o.width * d.from.x};
              child.to = {height: o.height * d.to.y, width: o.width * d.to.x};
              if (d.from.y != d.to.y) {
                child.from = c.effects.setTransition(child, f, d.from.y, child.from);
                child.to = c.effects.setTransition(child, f, d.to.y, child.to)
              }
              if (d.from.x != d.to.x) {
                child.from = c.effects.setTransition(child, k, d.from.x, child.from);
                child.to = c.effects.setTransition(child, k, d.to.x, child.to)
              }
              child.css(child.from);
              child.animate(child.to, b.duration, b.options.easing, function () {
                n && c.effects.restore(child, h)
              })
            })
          }
          a.animate(a.to, {
            queue: false, duration: b.duration, easing: b.options.easing, complete: function () {
              a.to.opacity === 0 && a.css("opacity", a.from.opacity);
              p == "hide" && a.hide();
              c.effects.restore(a,
                n ? e : g);
              c.effects.removeWrapper(a);
              b.callback && b.callback.apply(this, arguments);
              a.dequeue()
            }
          })
        })
      }
    })(jQuery);
    ;
    /*
 * jQuery UI Effects Shake 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Shake
 *
 * Depends:
 *	jquery.effects.core.js
 */
    (function (d) {
      d.effects.shake = function (a) {
        return this.queue(function () {
          var b = d(this), j = ["position", "top", "bottom", "left", "right"];
          d.effects.setMode(b, a.options.mode || "effect");
          var c = a.options.direction || "left", e = a.options.distance || 20, l = a.options.times || 3,
            f = a.duration || a.options.duration || 140;
          d.effects.save(b, j);
          b.show();
          d.effects.createWrapper(b);
          var g = c == "up" || c == "down" ? "top" : "left", h = c == "up" || c == "left" ? "pos" : "neg";
          c = {};
          var i = {}, k = {};
          c[g] = (h == "pos" ? "-=" : "+=") + e;
          i[g] = (h == "pos" ? "+=" : "-=") + e * 2;
          k[g] =
            (h == "pos" ? "-=" : "+=") + e * 2;
          b.animate(c, f, a.options.easing);
          for (e = 1; e < l; e++) b.animate(i, f, a.options.easing).animate(k, f, a.options.easing);
          b.animate(i, f, a.options.easing).animate(c, f / 2, a.options.easing, function () {
            d.effects.restore(b, j);
            d.effects.removeWrapper(b);
            a.callback && a.callback.apply(this, arguments)
          });
          b.queue("fx", function () {
            b.dequeue()
          });
          b.dequeue()
        })
      }
    })(jQuery);
    ;
    /*
 * jQuery UI Effects Slide 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Slide
 *
 * Depends:
 *	jquery.effects.core.js
 */
    (function (c) {
      c.effects.slide = function (d) {
        return this.queue(function () {
          var a = c(this), h = ["position", "top", "bottom", "left", "right"],
            f = c.effects.setMode(a, d.options.mode || "show"), b = d.options.direction || "left";
          c.effects.save(a, h);
          a.show();
          c.effects.createWrapper(a).css({overflow: "hidden"});
          var g = b == "up" || b == "down" ? "top" : "left";
          b = b == "up" || b == "left" ? "pos" : "neg";
          var e = d.options.distance || (g == "top" ? a.outerHeight({margin: true}) : a.outerWidth({margin: true}));
          if (f == "show") a.css(g, b == "pos" ? isNaN(e) ? "-" + e : -e : e);
          var i = {};
          i[g] = (f == "show" ? b == "pos" ? "+=" : "-=" : b == "pos" ? "-=" : "+=") + e;
          a.animate(i, {
            queue: false, duration: d.duration, easing: d.options.easing, complete: function () {
              f == "hide" && a.hide();
              c.effects.restore(a, h);
              c.effects.removeWrapper(a);
              d.callback && d.callback.apply(this, arguments);
              a.dequeue()
            }
          })
        })
      }
    })(jQuery);
    ;
    /*
 * jQuery UI Effects Transfer 1.8.16
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Transfer
 *
 * Depends:
 *	jquery.effects.core.js
 */
    (function (e) {
      e.effects.transfer = function (a) {
        return this.queue(function () {
          var b = e(this), c = e(a.options.to), d = c.offset();
          c = {top: d.top, left: d.left, height: c.innerHeight(), width: c.innerWidth()};
          d = b.offset();
          var f = e('<div class="ui-effects-transfer"></div>').appendTo(document.body).addClass(a.options.className).css({
            top: d.top,
            left: d.left,
            height: b.innerHeight(),
            width: b.innerWidth(),
            position: "absolute"
          }).animate(c, a.duration, a.options.easing, function () {
            f.remove();
            a.callback && a.callback.apply(b[0], arguments);
            b.dequeue()
          })
        })
      }
    })(jQuery);
    ;
  }, {}], 3: [function (require, module, exports) {

    (function ($) {
      $.toJSON = function (o) {
        if (typeof(JSON) == 'object' && JSON.stringify)
          return JSON.stringify(o);
        var type = typeof(o);
        if (o === null)
          return "null";
        if (type == "undefined")
          return undefined;
        if (type == "number" || type == "boolean")
          return o + "";
        if (type == "string")
          return $.quoteString(o);
        if (type == 'object') {
          if (typeof o.toJSON == "function")
            return $.toJSON(o.toJSON());
          if (o.constructor === Date) {
            var month = o.getUTCMonth() + 1;
            if (month < 10) month = '0' + month;
            var day = o.getUTCDate();
            if (day < 10) day = '0' + day;
            var year = o.getUTCFullYear();
            var hours = o.getUTCHours();
            if (hours < 10) hours = '0' + hours;
            var minutes = o.getUTCMinutes();
            if (minutes < 10) minutes = '0' + minutes;
            var seconds = o.getUTCSeconds();
            if (seconds < 10) seconds = '0' + seconds;
            var milli = o.getUTCMilliseconds();
            if (milli < 100) milli = '0' + milli;
            if (milli < 10) milli = '0' + milli;
            return '"' + year + '-' + month + '-' + day + 'T' +
              hours + ':' + minutes + ':' + seconds + '.' + milli + 'Z"';
          }
          if (o.constructor === Array) {
            var ret = [];
            for (var i = 0; i < o.length; i++)
              ret.push($.toJSON(o[i]) || "null");
            return "[" + ret.join(",") + "]";
          }
          var pairs = [];
          for (var k in o) {
            var name;
            var type = typeof k;
            if (type == "number")
              name = '"' + k + '"'; else if (type == "string")
              name = $.quoteString(k); else
              continue;
            if (typeof o[k] == "function")
              continue;
            var val = $.toJSON(o[k]);
            pairs.push(name + ":" + val);
          }
          return "{" + pairs.join(", ") + "}";
        }
      };
      $.evalJSON = function (src) {
        if (typeof(JSON) == 'object' && JSON.parse)
          return JSON.parse(src);
        return eval("(" + src + ")");
      };
      $.secureEvalJSON = function (src) {
        if (typeof(JSON) == 'object' && JSON.parse)
          return JSON.parse(src);
        var filtered = src;
        filtered = filtered.replace(/\\["\\\/bfnrtu]/g, '@');
        filtered = filtered.replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']');
        filtered = filtered.replace(/(?:^|:|,)(?:\s*\[)+/g, '');
        if (/^[\],:{}\s]*$/.test(filtered))
          return eval("(" + src + ")"); else
          throw new SyntaxError("Error parsing JSON, source is not valid.");
      };
      $.quoteString = function (string) {
        if (string.match(_escapeable)) {
          return '"' + string.replace(_escapeable, function (a) {
            var c = _meta[a];
            if (typeof c === 'string') return c;
            c = a.charCodeAt();
            return '\\u00' + Math.floor(c / 16).toString(16) + (c % 16).toString(16);
          }) + '"';
        }
        return '"' + string + '"';
      };
      var _escapeable = /["\\\x00-\x1f\x7f-\x9f]/g;
      var _meta = {'\b': '\\b', '\t': '\\t', '\n': '\\n', '\f': '\\f', '\r': '\\r', '"': '\\"', '\\': '\\\\'};
    })(jQuery);
  }, {}], 4: [function (require, module, exports) {
    /**
     * sprintf and vsprintf for jQuery
     * somewhat based on http://jan.moesen.nu/code/javascript/sprintf-and-printf-in-javascript/
     *
     * Copyright (c) 2008 Sabin Iacob (m0n5t3r) <iacobs@m0n5t3r.info>
     * This program is free software: you can redistribute it and/or modify
     * it under the terms of the GNU General Public License as published by
     * the Free Software Foundation, either version 3 of the License, or
     * (at your option) any later version.
     *
     * This program is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     * GNU General Public License for more details.
     *
     * @license http://www.gnu.org/licenses/gpl.html
     * @project jquery.sprintf
     */
    (function ($) {
      var formats = {
        'b': function (val) {
          return parseInt(val, 10).toString(2);
        },
        'c': function (val) {
          return String.fromCharCode(parseInt(val, 10));
        },
        'd': function (val) {
          return parseInt(val, 10);
        },
        'u': function (val) {
          return Math.abs(val);
        },
        'f': function (val, p) {
          p = parseInt(p, 10);
          val = parseFloat(val);
          if (isNaN(p && val)) {
            return NaN;
          }
          return p && val.toFixed(p) || val;
        },
        'o': function (val) {
          return parseInt(val, 10).toString(8);
        },
        's': function (val) {
          return val;
        },
        'x': function (val) {
          return ('' + parseInt(val, 10).toString(16)).toLowerCase();
        },
        'X': function (val) {
          return ('' + parseInt(val, 10).toString(16)).toUpperCase();
        }
      };

      var re = /%(?:(\d+)?(?:\.(\d+))?|\(([^)]+)\))([%bcdufosxX])/g;

      var dispatch = function (data) {
        if (data.length == 1 && typeof data[0] == 'object') { //python-style printf
          data = data[0];
          return function (match, w, p, lbl, fmt, off, str) {
            return formats[fmt](data[lbl]);
          };
        } else { // regular, somewhat incomplete, printf
          var idx = 0;
          return function (match, w, p, lbl, fmt, off, str) {
            if (fmt == '%') {
              return '%';
            }
            return formats[fmt](data[idx++], p);
          };
        }
      };

      $.extend({
        sprintf: function (format) {
          var argv = Array.apply(null, arguments).slice(1);
          return format.replace(re, dispatch(argv));
        },
        vsprintf: function (format, data) {
          return format.replace(re, dispatch(data));
        }
      });
    })(jQuery);

  }, {}], 5: [function (require, module, exports) {
    /* http://keith-wood.name/svg.html
   SVG for jQuery v1.4.3.
   Written by Keith Wood (kbwood{at}iinet.com.au) August 2007.
   Dual licensed under the GPL (http://dev.jquery.com/browser/trunk/jquery/GPL-LICENSE.txt) and
   MIT (http://dev.jquery.com/browser/trunk/jquery/MIT-LICENSE.txt) licenses.
   Please attribute the author if you use it. */
    (function ($) {
      function SVGManager() {
        this._settings = [];
        this._extensions = [];
        this.regional = [];
        this.regional[''] = {errorLoadingText: 'Error loading', notSupportedText: 'This browser does not support SVG'};
        this.local = this.regional[''];
        this._uuid = new Date().getTime();
        this._renesis = detectActiveX('RenesisX.RenesisCtrl')
      }

      function detectActiveX(a) {
        try {
          return !!(window.ActiveXObject && new ActiveXObject(a))
        } catch (e) {
          return false
        }
      }

      var p = 'svgwrapper';
      $.extend(SVGManager.prototype, {
        markerClassName: 'hasSVG',
        svgNS: 'http://www.w3.org/2000/svg',
        xlinkNS: 'http://www.w3.org/1999/xlink',
        _wrapperClass: SVGWrapper,
        _attrNames: {
          class_: 'class',
          in_: 'in',
          alignmentBaseline: 'alignment-baseline',
          baselineShift: 'baseline-shift',
          clipPath: 'clip-path',
          clipRule: 'clip-rule',
          colorInterpolation: 'color-interpolation',
          colorInterpolationFilters: 'color-interpolation-filters',
          colorRendering: 'color-rendering',
          dominantBaseline: 'dominant-baseline',
          enableBackground: 'enable-background',
          fillOpacity: 'fill-opacity',
          fillRule: 'fill-rule',
          floodColor: 'flood-color',
          floodOpacity: 'flood-opacity',
          fontFamily: 'font-family',
          fontSize: 'font-size',
          fontSizeAdjust: 'font-size-adjust',
          fontStretch: 'font-stretch',
          fontStyle: 'font-style',
          fontVariant: 'font-variant',
          fontWeight: 'font-weight',
          glyphOrientationHorizontal: 'glyph-orientation-horizontal',
          glyphOrientationVertical: 'glyph-orientation-vertical',
          horizAdvX: 'horiz-adv-x',
          horizOriginX: 'horiz-origin-x',
          imageRendering: 'image-rendering',
          letterSpacing: 'letter-spacing',
          lightingColor: 'lighting-color',
          markerEnd: 'marker-end',
          markerMid: 'marker-mid',
          markerStart: 'marker-start',
          stopColor: 'stop-color',
          stopOpacity: 'stop-opacity',
          strikethroughPosition: 'strikethrough-position',
          strikethroughThickness: 'strikethrough-thickness',
          strokeDashArray: 'stroke-dasharray',
          strokeDashOffset: 'stroke-dashoffset',
          strokeLineCap: 'stroke-linecap',
          strokeLineJoin: 'stroke-linejoin',
          strokeMiterLimit: 'stroke-miterlimit',
          strokeOpacity: 'stroke-opacity',
          strokeWidth: 'stroke-width',
          textAnchor: 'text-anchor',
          textDecoration: 'text-decoration',
          textRendering: 'text-rendering',
          underlinePosition: 'underline-position',
          underlineThickness: 'underline-thickness',
          vertAdvY: 'vert-adv-y',
          vertOriginY: 'vert-origin-y',
          wordSpacing: 'word-spacing',
          writingMode: 'writing-mode'
        },
        _attachSVG: function (a, b) {
          var c = (a.namespaceURI == this.svgNS ? a : null);
          var a = (c ? null : a);
          if ($(a || c).hasClass(this.markerClassName)) {
            return
          }
          if (typeof b == 'string') {
            b = {loadURL: b}
          } else if (typeof b == 'function') {
            b = {onLoad: b}
          }
          $(a || c).addClass(this.markerClassName);
          try {
            if (!c) {
              c = document.createElementNS(this.svgNS, 'svg');
              c.setAttribute('version', '1.1');
              c.setAttribute('width', a.clientWidth);
              c.setAttribute('height', a.clientHeight);
              a.appendChild(c)
            }
            this._afterLoad(a, c, b || {})
          } catch (e) {
            if ($.browser.msie) {
              if (!a.id) {
                a.id = 'svg' + (this._uuid++)
              }
              this._settings[a.id] = b;
              a.innerHTML = '<embed type="image/svg+xml" width="100%" ' + 'height="100%" src="' + (b.initPath || '') + 'blank.svg"/>'
            } else {
              a.innerHTML = '<p class="svg_error">' + this.local.notSupportedText + '</p>'
            }
          }
        },
        _registerSVG: function () {
          for (var i = 0; i < document.embeds.length; i++) {
            var a = document.embeds[i].parentNode;
            if (!$(a).hasClass($.svg.markerClassName) || $.data(a, p)) {
              continue
            }
            var b = null;
            try {
              b = document.embeds[i].getSVGDocument()
            } catch (e) {
              setTimeout($.svg._registerSVG, 250);
              return
            }
            b = (b ? b.documentElement : null);
            if (b) {
              $.svg._afterLoad(a, b)
            }
          }
        },
        _afterLoad: function (a, b, c) {
          var c = c || this._settings[a.id];
          this._settings[a ? a.id : ''] = null;
          var d = new this._wrapperClass(b, a);
          $.data(a || b, p, d);
          try {
            if (c.loadURL) {
              d.load(c.loadURL, c)
            }
            if (c.settings) {
              d.configure(c.settings)
            }
            if (c.onLoad && !c.loadURL) {
              c.onLoad.apply(a || b, [d])
            }
          } catch (e) {
            alert(e)
          }
        },
        _getSVG: function (a) {
          a = (typeof a == 'string' ? $(a)[0] : (a.jquery ? a[0] : a));
          return $.data(a, p)
        },
        _destroySVG: function (a) {
          var b = $(a);
          if (!b.hasClass(this.markerClassName)) {
            return
          }
          b.removeClass(this.markerClassName);
          if (a.namespaceURI != this.svgNS) {
            b.empty()
          }
          $.removeData(a, p)
        },
        addExtension: function (a, b) {
          this._extensions.push([a, b])
        }
      });

      function SVGWrapper(a, b) {
        this._svg = a;
        this._container = b;
        for (var i = 0; i < $.svg._extensions.length; i++) {
          var c = $.svg._extensions[i];
          this[c[0]] = new c[1](this)
        }
      }

      $.extend(SVGWrapper.prototype, {
        _width: function () {
          return (this._container ? this._container.clientWidth : this._svg.width)
        }, _height: function () {
          return (this._container ? this._container.clientHeight : this._svg.height)
        }, root: function () {
          return this._svg
        }, configure: function (a, b) {
          if (b) {
            for (var i = this._svg.attributes.length - 1; i >= 0; i--) {
              var c = this._svg.attributes.item(i);
              if (!(c.nodeName == 'onload' || c.nodeName == 'version' || c.nodeName.substring(0, 5) == 'xmlns')) {
                this._svg.attributes.removeNamedItem(c.nodeName)
              }
            }
          }
          for (var d in a) {
            this._svg.setAttribute(d, a[d])
          }
          return this
        }, getElementById: function (a) {
          return this._svg.ownerDocument.getElementById(a)
        }, change: function (a, b) {
          if (a) {
            for (var c in b) {
              if (b[c] == null) {
                a.removeAttribute(c)
              } else {
                a.setAttribute(c, b[c])
              }
            }
          }
          return this
        }, _args: function (b, c, d) {
          c.splice(0, 0, 'parent');
          c.splice(c.length, 0, 'settings');
          var e = {};
          var f = 0;
          if (b[0] != null && b[0].jquery) {
            b[0] = b[0][0]
          }
          if (b[0] != null && !(typeof b[0] == 'object' && b[0].nodeName)) {
            e['parent'] = null;
            f = 1
          }
          for (var i = 0; i < b.length; i++) {
            e[c[i + f]] = b[i]
          }
          if (d) {
            $.each(d, function (i, a) {
              if (typeof e[a] == 'object') {
                e.settings = e[a];
                e[a] = null
              }
            })
          }
          return e
        }, title: function (a, b, c) {
          var d = this._args(arguments, ['text']);
          var e = this._makeNode(d.parent, 'title', d.settings || {});
          e.appendChild(this._svg.ownerDocument.createTextNode(d.text));
          return e
        }, describe: function (a, b, c) {
          var d = this._args(arguments, ['text']);
          var e = this._makeNode(d.parent, 'desc', d.settings || {});
          e.appendChild(this._svg.ownerDocument.createTextNode(d.text));
          return e
        }, defs: function (a, b, c) {
          var d = this._args(arguments, ['id'], ['id']);
          return this._makeNode(d.parent, 'defs', $.extend((d.id ? {id: d.id} : {}), d.settings || {}))
        }, symbol: function (a, b, c, d, e, f, g) {
          var h = this._args(arguments, ['id', 'x1', 'y1', 'width', 'height']);
          return this._makeNode(h.parent, 'symbol', $.extend({
            id: h.id,
            viewBox: h.x1 + ' ' + h.y1 + ' ' + h.width + ' ' + h.height
          }, h.settings || {}))
        }, marker: function (a, b, c, d, e, f, g, h) {
          var i = this._args(arguments, ['id', 'refX', 'refY', 'mWidth', 'mHeight', 'orient'], ['orient']);
          return this._makeNode(i.parent, 'marker', $.extend({
            id: i.id,
            refX: i.refX,
            refY: i.refY,
            markerWidth: i.mWidth,
            markerHeight: i.mHeight,
            orient: i.orient || 'auto'
          }, i.settings || {}))
        }, style: function (a, b, c) {
          var d = this._args(arguments, ['styles']);
          var e = this._makeNode(d.parent, 'style', $.extend({type: 'text/css'}, d.settings || {}));
          e.appendChild(this._svg.ownerDocument.createTextNode(d.styles));
          if ($.browser.opera) {
            $('head').append('<style type="text/css">' + d.styles + '</style>')
          }
          return e
        }, script: function (a, b, c, d) {
          var e = this._args(arguments, ['script', 'type'], ['type']);
          var f = this._makeNode(e.parent, 'script', $.extend({type: e.type || 'text/javascript'}, e.settings || {}));
          f.appendChild(this._svg.ownerDocument.createTextNode(this._escapeXML(e.script)));
          if (!$.browser.mozilla) {
            $.globalEval(e.script)
          }
          return f
        }, linearGradient: function (a, b, c, d, e, f, g, h) {
          var i = this._args(arguments, ['id', 'stops', 'x1', 'y1', 'x2', 'y2'], ['x1']);
          var j = $.extend({id: i.id}, (i.x1 != null ? {x1: i.x1, y1: i.y1, x2: i.x2, y2: i.y2} : {}));
          return this._gradient(i.parent, 'linearGradient', $.extend(j, i.settings || {}), i.stops)
        }, radialGradient: function (a, b, c, d, e, r, f, g, h) {
          var i = this._args(arguments, ['id', 'stops', 'cx', 'cy', 'r', 'fx', 'fy'], ['cx']);
          var j = $.extend({id: i.id}, (i.cx != null ? {cx: i.cx, cy: i.cy, r: i.r, fx: i.fx, fy: i.fy} : {}));
          return this._gradient(i.parent, 'radialGradient', $.extend(j, i.settings || {}), i.stops)
        }, _gradient: function (a, b, c, d) {
          var e = this._makeNode(a, b, c);
          for (var i = 0; i < d.length; i++) {
            var f = d[i];
            this._makeNode(e, 'stop', $.extend({
              offset: f[0],
              stopColor: f[1]
            }, (f[2] != null ? {stopOpacity: f[2]} : {})))
          }
          return e
        }, pattern: function (a, b, x, y, c, d, e, f, g, h, i) {
          var j = this._args(arguments, ['id', 'x', 'y', 'width', 'height', 'vx', 'vy', 'vwidth', 'vheight'], ['vx']);
          var k = $.extend({
            id: j.id,
            x: j.x,
            y: j.y,
            width: j.width,
            height: j.height
          }, (j.vx != null ? {viewBox: j.vx + ' ' + j.vy + ' ' + j.vwidth + ' ' + j.vheight} : {}));
          return this._makeNode(j.parent, 'pattern', $.extend(k, j.settings || {}))
        }, mask: function (a, b, x, y, c, d, e) {
          var f = this._args(arguments, ['id', 'x', 'y', 'width', 'height']);
          return this._makeNode(f.parent, 'mask', $.extend({
            id: f.id,
            x: f.x,
            y: f.y,
            width: f.width,
            height: f.height
          }, f.settings || {}))
        }, createPath: function () {
          return new SVGPath()
        }, createText: function () {
          return new SVGText()
        }, svg: function (a, x, y, b, c, d, e, f, g, h) {
          var i = this._args(arguments, ['x', 'y', 'width', 'height', 'vx', 'vy', 'vwidth', 'vheight'], ['vx']);
          var j = $.extend({
            x: i.x,
            y: i.y,
            width: i.width,
            height: i.height
          }, (i.vx != null ? {viewBox: i.vx + ' ' + i.vy + ' ' + i.vwidth + ' ' + i.vheight} : {}));
          return this._makeNode(i.parent, 'svg', $.extend(j, i.settings || {}))
        }, group: function (a, b, c) {
          var d = this._args(arguments, ['id'], ['id']);
          return this._makeNode(d.parent, 'g', $.extend({id: d.id}, d.settings || {}))
        }, use: function (a, x, y, b, c, d, e) {
          var f = this._args(arguments, ['x', 'y', 'width', 'height', 'ref']);
          if (typeof f.x == 'string') {
            f.ref = f.x;
            f.settings = f.y;
            f.x = f.y = f.width = f.height = null
          }
          var g = this._makeNode(f.parent, 'use', $.extend({
            x: f.x,
            y: f.y,
            width: f.width,
            height: f.height
          }, f.settings || {}));
          g.setAttributeNS($.svg.xlinkNS, 'href', f.ref);
          return g
        }, link: function (a, b, c) {
          var d = this._args(arguments, ['ref']);
          var e = this._makeNode(d.parent, 'a', d.settings);
          e.setAttributeNS($.svg.xlinkNS, 'href', d.ref);
          return e
        }, image: function (a, x, y, b, c, d, e) {
          var f = this._args(arguments, ['x', 'y', 'width', 'height', 'ref']);
          var g = this._makeNode(f.parent, 'image', $.extend({
            x: f.x,
            y: f.y,
            width: f.width,
            height: f.height
          }, f.settings || {}));
          g.setAttributeNS($.svg.xlinkNS, 'href', f.ref);
          return g
        }, path: function (a, b, c) {
          var d = this._args(arguments, ['path']);
          return this._makeNode(d.parent, 'path', $.extend({d: (d.path.path ? d.path.path() : d.path)}, d.settings || {}))
        }, rect: function (a, x, y, b, c, d, e, f) {
          var g = this._args(arguments, ['x', 'y', 'width', 'height', 'rx', 'ry'], ['rx']);
          return this._makeNode(g.parent, 'rect', $.extend({
            x: g.x,
            y: g.y,
            width: g.width,
            height: g.height
          }, (g.rx ? {rx: g.rx, ry: g.ry} : {}), g.settings || {}))
        }, circle: function (a, b, c, r, d) {
          var e = this._args(arguments, ['cx', 'cy', 'r']);
          return this._makeNode(e.parent, 'circle', $.extend({cx: e.cx, cy: e.cy, r: e.r}, e.settings || {}))
        }, ellipse: function (a, b, c, d, e, f) {
          var g = this._args(arguments, ['cx', 'cy', 'rx', 'ry']);
          return this._makeNode(g.parent, 'ellipse', $.extend({
            cx: g.cx,
            cy: g.cy,
            rx: g.rx,
            ry: g.ry
          }, g.settings || {}))
        }, line: function (a, b, c, d, e, f) {
          var g = this._args(arguments, ['x1', 'y1', 'x2', 'y2']);
          return this._makeNode(g.parent, 'line', $.extend({x1: g.x1, y1: g.y1, x2: g.x2, y2: g.y2}, g.settings || {}))
        }, polyline: function (a, b, c) {
          var d = this._args(arguments, ['points']);
          return this._poly(d.parent, 'polyline', d.points, d.settings)
        }, polygon: function (a, b, c) {
          var d = this._args(arguments, ['points']);
          return this._poly(d.parent, 'polygon', d.points, d.settings)
        }, _poly: function (a, b, c, d) {
          var e = '';
          for (var i = 0; i < c.length; i++) {
            e += c[i].join() + ' '
          }
          return this._makeNode(a, b, $.extend({points: $.trim(e)}, d || {}))
        }, text: function (a, x, y, b, c) {
          var d = this._args(arguments, ['x', 'y', 'value']);
          if (typeof d.x == 'string' && arguments.length < 4) {
            d.value = d.x;
            d.settings = d.y;
            d.x = d.y = null
          }
          return this._text(d.parent, 'text', d.value, $.extend({
            x: (d.x && isArray(d.x) ? d.x.join(' ') : d.x),
            y: (d.y && isArray(d.y) ? d.y.join(' ') : d.y)
          }, d.settings || {}))
        }, textpath: function (a, b, c, d) {
          var e = this._args(arguments, ['path', 'value']);
          var f = this._text(e.parent, 'textPath', e.value, e.settings || {});
          f.setAttributeNS($.svg.xlinkNS, 'href', e.path);
          return f
        }, _text: function (a, b, c, d) {
          var e = this._makeNode(a, b, d);
          if (typeof c == 'string') {
            e.appendChild(e.ownerDocument.createTextNode(c))
          } else {
            for (var i = 0; i < c._parts.length; i++) {
              var f = c._parts[i];
              if (f[0] == 'tspan') {
                var g = this._makeNode(e, f[0], f[2]);
                g.appendChild(e.ownerDocument.createTextNode(f[1]));
                e.appendChild(g)
              } else if (f[0] == 'tref') {
                var g = this._makeNode(e, f[0], f[2]);
                g.setAttributeNS($.svg.xlinkNS, 'href', f[1]);
                e.appendChild(g)
              } else if (f[0] == 'textpath') {
                var h = $.extend({}, f[2]);
                h.href = null;
                var g = this._makeNode(e, f[0], h);
                g.setAttributeNS($.svg.xlinkNS, 'href', f[2].href);
                g.appendChild(e.ownerDocument.createTextNode(f[1]));
                e.appendChild(g)
              } else {
                e.appendChild(e.ownerDocument.createTextNode(f[1]))
              }
            }
          }
          return e
        }, other: function (a, b, c) {
          var d = this._args(arguments, ['name']);
          return this._makeNode(d.parent, d.name, d.settings || {})
        }, _makeNode: function (a, b, c) {
          a = a || this._svg;
          var d = this._svg.ownerDocument.createElementNS($.svg.svgNS, b);
          for (var b in c) {
            var e = c[b];
            if (e != null && e != null && (typeof e != 'string' || e != '')) {
              d.setAttribute($.svg._attrNames[b] || b, e)
            }
          }
          a.appendChild(d);
          return d
        }, add: function (b, c) {
          var d = this._args((arguments.length == 1 ? [null, b] : arguments), ['node']);
          var f = this;
          d.parent = d.parent || this._svg;
          try {
            if ($.svg._renesis) {
              throw'Force traversal';
            }
            d.parent.appendChild(d.node.cloneNode(true))
          } catch (e) {
            d.node = (d.node.jquery ? d.node : $(d.node));
            d.node.each(function () {
              var a = f._cloneAsSVG(this);
              if (a) {
                d.parent.appendChild(a)
              }
            })
          }
          return this
        }, _cloneAsSVG: function (a) {
          var b = null;
          if (a.nodeType == 1) {
            b = this._svg.ownerDocument.createElementNS($.svg.svgNS, this._checkName(a.nodeName));
            for (var i = 0; i < a.attributes.length; i++) {
              var c = a.attributes.item(i);
              if (c.nodeName != 'xmlns' && c.nodeValue) {
                if (c.prefix == 'xlink') {
                  b.setAttributeNS($.svg.xlinkNS, c.localName, c.nodeValue)
                } else {
                  b.setAttribute(this._checkName(c.nodeName), c.nodeValue)
                }
              }
            }
            for (var i = 0; i < a.childNodes.length; i++) {
              var d = this._cloneAsSVG(a.childNodes[i]);
              if (d) {
                b.appendChild(d)
              }
            }
          } else if (a.nodeType == 3) {
            if ($.trim(a.nodeValue)) {
              b = this._svg.ownerDocument.createTextNode(a.nodeValue)
            }
          } else if (a.nodeType == 4) {
            if ($.trim(a.nodeValue)) {
              try {
                b = this._svg.ownerDocument.createCDATASection(a.nodeValue)
              } catch (e) {
                b = this._svg.ownerDocument.createTextNode(a.nodeValue.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;'))
              }
            }
          }
          return b
        }, _checkName: function (a) {
          a = (a.substring(0, 1) >= 'A' && a.substring(0, 1) <= 'Z' ? a.toLowerCase() : a);
          return (a.substring(0, 4) == 'svg:' ? a.substring(4) : a)
        }, load: function (h, j) {
          j = (typeof j == 'boolean' ? {addTo: j} : (typeof j == 'function' ? {onLoad: j} : j || {}));
          if (!j.addTo) {
            this.clear(false)
          }
          var k = [this._svg.getAttribute('width'), this._svg.getAttribute('height')];
          var l = this;
          var m = function (a) {
            a = $.svg.local.errorLoadingText + ': ' + a;
            if (j.onLoad) {
              j.onLoad.apply(l._container || l._svg, [l, a])
            } else {
              l.text(null, 10, 20, a)
            }
          };
          var n = function (a) {
            var b = new ActiveXObject('Microsoft.XMLDOM');
            b.validateOnParse = false;
            b.resolveExternals = false;
            b.async = false;
            b.loadXML(a);
            if (b.parseError.errorCode != 0) {
              m(b.parseError.reason);
              return null
            }
            return b
          };
          var o = function (a) {
            if (!a) {
              return
            }
            if (a.documentElement.nodeName != 'svg') {
              var b = a.getElementsByTagName('parsererror');
              var c = (b.length ? b[0].getElementsByTagName('div') : []);
              m(!b.length ? '???' : (c.length ? c[0] : b[0]).firstChild.nodeValue);
              return
            }
            var d = {};
            for (var i = 0; i < a.documentElement.attributes.length; i++) {
              var f = a.documentElement.attributes.item(i);
              if (!(f.nodeName == 'version' || f.nodeName.substring(0, 5) == 'xmlns')) {
                d[f.nodeName] = f.nodeValue
              }
            }
            l.configure(d, true);
            var g = a.documentElement.childNodes;
            for (var i = 0; i < g.length; i++) {
              try {
                if ($.svg._renesis) {
                  throw'Force traversal';
                }
                l._svg.appendChild(g[i].cloneNode(true));
                if (g[i].nodeName == 'script') {
                  $.globalEval(g[i].textContent)
                }
              } catch (e) {
                l.add(null, g[i])
              }
            }
            if (!j.changeSize) {
              l.configure({width: k[0], height: k[1]})
            }
            if (j.onLoad) {
              j.onLoad.apply(l._container || l._svg, [l])
            }
          };
          if (h.match('<svg')) {
            o($.browser.msie ? n(h) : new DOMParser().parseFromString(h, 'text/xml'))
          } else {
            $.ajax({
              url: h, dataType: ($.browser.msie ? 'text' : 'xml'), success: function (a) {
                o($.browser.msie ? n(a) : a)
              }, error: function (a, b, c) {
                m(b + (c ? ' ' + c.message : ''))
              }
            })
          }
          return this
        }, remove: function (a) {
          a = (a.jquery ? a[0] : a);
          a.parentNode.removeChild(a);
          return this
        }, clear: function (a) {
          if (a) {
            this.configure({}, true)
          }
          while (this._svg.firstChild) {
            this._svg.removeChild(this._svg.firstChild)
          }
          return this
        }, toSVG: function (a) {
          a = a || this._svg;
          return (typeof XMLSerializer == 'undefined' ? this._toSVG(a) : new XMLSerializer().serializeToString(a))
        }, _toSVG: function (a) {
          var b = '';
          if (!a) {
            return b
          }
          if (a.nodeType == 3) {
            b = a.nodeValue
          } else if (a.nodeType == 4) {
            b = '<![CDATA[' + a.nodeValue + ']]>'
          } else {
            b = '<' + a.nodeName;
            if (a.attributes) {
              for (var i = 0; i < a.attributes.length; i++) {
                var c = a.attributes.item(i);
                if (!($.trim(c.nodeValue) == '' || c.nodeValue.match(/^\[object/) || c.nodeValue.match(/^function/))) {
                  b += ' ' + (c.namespaceURI == $.svg.xlinkNS ? 'xlink:' : '') + c.nodeName + '="' + c.nodeValue + '"'
                }
              }
            }
            if (a.firstChild) {
              b += '>';
              var d = a.firstChild;
              while (d) {
                b += this._toSVG(d);
                d = d.nextSibling
              }
              b += '</' + a.nodeName + '>'
            } else {
              b += '/>'
            }
          }
          return b
        }, _escapeXML: function (a) {
          a = a.replace(/&/g, '&amp;');
          a = a.replace(/</g, '&lt;');
          a = a.replace(/>/g, '&gt;');
          return a
        }
      });

      function SVGPath() {
        this._path = ''
      }

      $.extend(SVGPath.prototype, {
        reset: function () {
          this._path = '';
          return this
        }, move: function (x, y, a) {
          a = (isArray(x) ? y : a);
          return this._coords((a ? 'm' : 'M'), x, y)
        }, line: function (x, y, a) {
          a = (isArray(x) ? y : a);
          return this._coords((a ? 'l' : 'L'), x, y)
        }, horiz: function (x, a) {
          this._path += (a ? 'h' : 'H') + (isArray(x) ? x.join(' ') : x);
          return this
        }, vert: function (y, a) {
          this._path += (a ? 'v' : 'V') + (isArray(y) ? y.join(' ') : y);
          return this
        }, curveC: function (a, b, c, d, x, y, e) {
          e = (isArray(a) ? b : e);
          return this._coords((e ? 'c' : 'C'), a, b, c, d, x, y)
        }, smoothC: function (a, b, x, y, c) {
          c = (isArray(a) ? b : c);
          return this._coords((c ? 's' : 'S'), a, b, x, y)
        }, curveQ: function (a, b, x, y, c) {
          c = (isArray(a) ? b : c);
          return this._coords((c ? 'q' : 'Q'), a, b, x, y)
        }, smoothQ: function (x, y, a) {
          a = (isArray(x) ? y : a);
          return this._coords((a ? 't' : 'T'), x, y)
        }, _coords: function (a, b, c, d, e, f, g) {
          if (isArray(b)) {
            for (var i = 0; i < b.length; i++) {
              var h = b[i];
              this._path += (i == 0 ? a : ' ') + h[0] + ',' + h[1] + (h.length < 4 ? '' : ' ' + h[2] + ',' + h[3] + (h.length < 6 ? '' : ' ' + h[4] + ',' + h[5]))
            }
          } else {
            this._path += a + b + ',' + c + (d == null ? '' : ' ' + d + ',' + e + (f == null ? '' : ' ' + f + ',' + g))
          }
          return this
        }, arc: function (a, b, c, d, e, x, y, f) {
          f = (isArray(a) ? b : f);
          this._path += (f ? 'a' : 'A');
          if (isArray(a)) {
            for (var i = 0; i < a.length; i++) {
              var g = a[i];
              this._path += (i == 0 ? '' : ' ') + g[0] + ',' + g[1] + ' ' + g[2] + ' ' + (g[3] ? '1' : '0') + ',' + (g[4] ? '1' : '0') + ' ' + g[5] + ',' + g[6]
            }
          } else {
            this._path += a + ',' + b + ' ' + c + ' ' + (d ? '1' : '0') + ',' + (e ? '1' : '0') + ' ' + x + ',' + y
          }
          return this
        }, close: function () {
          this._path += 'z';
          return this
        }, path: function () {
          return this._path
        }
      });
      SVGPath.prototype.moveTo = SVGPath.prototype.move;
      SVGPath.prototype.lineTo = SVGPath.prototype.line;
      SVGPath.prototype.horizTo = SVGPath.prototype.horiz;
      SVGPath.prototype.vertTo = SVGPath.prototype.vert;
      SVGPath.prototype.curveCTo = SVGPath.prototype.curveC;
      SVGPath.prototype.smoothCTo = SVGPath.prototype.smoothC;
      SVGPath.prototype.curveQTo = SVGPath.prototype.curveQ;
      SVGPath.prototype.smoothQTo = SVGPath.prototype.smoothQ;
      SVGPath.prototype.arcTo = SVGPath.prototype.arc;

      function SVGText() {
        this._parts = []
      }

      $.extend(SVGText.prototype, {
        reset: function () {
          this._parts = [];
          return this
        }, string: function (a) {
          this._parts[this._parts.length] = ['text', a];
          return this
        }, span: function (a, b) {
          this._parts[this._parts.length] = ['tspan', a, b];
          return this
        }, ref: function (a, b) {
          this._parts[this._parts.length] = ['tref', a, b];
          return this
        }, path: function (a, b, c) {
          this._parts[this._parts.length] = ['textpath', b, $.extend({href: a}, c || {})];
          return this
        }
      });
      $.fn.svg = function (a) {
        var b = Array.prototype.slice.call(arguments, 1);
        if (typeof a == 'string' && a == 'get') {
          return $.svg['_' + a + 'SVG'].apply($.svg, [this[0]].concat(b))
        }
        return this.each(function () {
          if (typeof a == 'string') {
            $.svg['_' + a + 'SVG'].apply($.svg, [this].concat(b))
          } else {
            $.svg._attachSVG(this, a || {})
          }
        })
      };

      function isArray(a) {
        return (a && a.constructor == Array)
      }

      $.svg = new SVGManager()
    })(jQuery);
  }, {}], 6: [function (require, module, exports) {
    /* http://keith-wood.name/svg.html
   SVG/jQuery DOM compatibility for jQuery v1.4.3.
   Written by Keith Wood (kbwood{at}iinet.com.au) April 2009.
   Dual licensed under the GPL (http://dev.jquery.com/browser/trunk/jquery/GPL-LICENSE.txt) and
   MIT (http://dev.jquery.com/browser/trunk/jquery/MIT-LICENSE.txt) licenses.
   Please attribute the author if you use it. */
    (function ($) {
      $.fn.addClass = function (e) {
        return function (d) {
          d = d || '';
          return this.each(function () {
            if (isSVGElem(this)) {
              var c = this;
              $.each(d.split(/\s+/), function (i, a) {
                var b = (c.className ? c.className.baseVal : c.getAttribute('class'));
                if ($.inArray(a, b.split(/\s+/)) == -1) {
                  b += (b ? ' ' : '') + a;
                  (c.className ? c.className.baseVal = b : c.setAttribute('class', b))
                }
              })
            } else {
              e.apply($(this), [d])
            }
          })
        }
      }($.fn.addClass);
      $.fn.removeClass = function (e) {
        return function (d) {
          d = d || '';
          return this.each(function () {
            if (isSVGElem(this)) {
              var c = this;
              $.each(d.split(/\s+/), function (i, a) {
                var b = (c.className ? c.className.baseVal : c.getAttribute('class'));
                b = $.grep(b.split(/\s+/), function (n, i) {
                  return n != a
                }).join(' ');
                (c.className ? c.className.baseVal = b : c.setAttribute('class', b))
              })
            } else {
              e.apply($(this), [d])
            }
          })
        }
      }($.fn.removeClass);
      $.fn.toggleClass = function (c) {
        return function (a, b) {
          return this.each(function () {
            if (isSVGElem(this)) {
              if (typeof b !== 'boolean') {
                b = !$(this).hasClass(a)
              }
              $(this)[(b ? 'add' : 'remove') + 'Class'](a)
            } else {
              c.apply($(this), [a, b])
            }
          })
        }
      }($.fn.toggleClass);
      $.fn.hasClass = function (d) {
        return function (b) {
          b = b || '';
          var c = false;
          this.each(function () {
            if (isSVGElem(this)) {
              var a = (this.className ? this.className.baseVal : this.getAttribute('class')).split(/\s+/);
              c = ($.inArray(b, a) > -1)
            } else {
              c = (d.apply($(this), [b]))
            }
            return !c
          });
          return c
        }
      }($.fn.hasClass);
      $.fn.attr = function (h) {
        return function (b, c, d) {
          if (typeof b === 'string' && c === undefined) {
            var e = h.apply(this, [b, c, d]);
            if (e && e.baseVal && e.baseVal.numberOfItems != null) {
              c = '';
              e = e.baseVal;
              for (var i = 0; i < e.numberOfItems; i++) {
                var f = e.getItem(i);
                switch (f.type) {
                  case 1:
                    c += ' matrix(' + f.matrix.a + ',' + f.matrix.b + ',' + f.matrix.c + ',' + f.matrix.d + ',' + f.matrix.e + ',' + f.matrix.f + ')';
                    break;
                  case 2:
                    c += ' translate(' + f.matrix.e + ',' + f.matrix.f + ')';
                    break;
                  case 3:
                    c += ' scale(' + f.matrix.a + ',' + f.matrix.d + ')';
                    break;
                  case 4:
                    c += ' rotate(' + f.angle + ')';
                    break;
                  case 5:
                    c += ' skewX(' + f.angle + ')';
                    break;
                  case 6:
                    c += ' skewY(' + f.angle + ')';
                    break
                }
              }
              e = c.substring(1)
            }
            return (e && e.baseVal ? e.baseVal.valueAsString : e)
          }
          var g = b;
          if (typeof b === 'string') {
            g = {};
            g[b] = c
          }
          return this.each(function () {
            if (isSVGElem(this)) {
              for (var n in g) {
                var a = ($.isFunction(g[n]) ? g[n]() : g[n]);
                (d ? this.style[n] = a : this.setAttribute(n, a))
              }
            } else {
              h.apply($(this), [b, c, d])
            }
          })
        }
      }($.fn.attr);
      $.fn.removeAttr = function (b) {
        return function (a) {
          return this.each(function () {
            if (isSVGElem(this)) {
              (this[a] && this[a].baseVal ? this[a].baseVal.value = '' : this.setAttribute(a, ''))
            } else {
              b.apply($(this), [a])
            }
          })
        }
      }($.fn.removeAttr);

      function anySVG(a) {
        for (var i = 0; i < a.length; i++) {
          if (a[i].nodeType == 1 && a[i].namespaceURI == $.svg.svgNS) {
            return true
          }
        }
        return false
      }

      $.expr.relative['+'] = function (d) {
        return function (a, b, c) {
          d(a, b, c || anySVG(a))
        }
      }($.expr.relative['+']);
      $.expr.relative['>'] = function (d) {
        return function (a, b, c) {
          d(a, b, c || anySVG(a))
        }
      }($.expr.relative['>']);
      $.expr.relative[''] = function (d) {
        return function (a, b, c) {
          d(a, b, c || anySVG(a))
        }
      }($.expr.relative['']);
      $.expr.relative['~'] = function (d) {
        return function (a, b, c) {
          d(a, b, c || anySVG(a))
        }
      }($.expr.relative['~']);
      $.expr.find.ID = function (d) {
        return function (a, b, c) {
          return (isSVGElem(b) ? [b.ownerDocument.getElementById(a[1])] : d(a, b, c))
        }
      }($.expr.find.ID);
      var j = document.createElement('div');
      j.appendChild(document.createComment(''));
      if (j.getElementsByTagName('*').length > 0) {
        $.expr.find.TAG = function (a, b) {
          var c = b.getElementsByTagName(a[1]);
          if (a[1] === '*') {
            var d = [];
            for (var i = 0; c[i] || c.item(i); i++) {
              if ((c[i] || c.item(i)).nodeType === 1) {
                d.push(c[i] || c.item(i))
              }
            }
            c = d
          }
          return c
        }
      }
      $.expr.preFilter.CLASS = function (a, b, c, d, f, g) {
        a = ' ' + a[1].replace(/\\/g, '') + ' ';
        if (g) {
          return a
        }
        for (var i = 0, elem = {}; elem != null; i++) {
          elem = b[i];
          if (!elem) {
            try {
              elem = b.item(i)
            } catch (e) {
            }
          }
          if (elem) {
            var h = (!isSVGElem(elem) ? elem.className : (elem.className ? elem.className.baseVal : '') || elem.getAttribute('class'));
            if (f ^ (h && (' ' + h + ' ').indexOf(a) > -1)) {
              if (!c) d.push(elem)
            } else if (c) {
              b[i] = false
            }
          }
        }
        return false
      };
      $.expr.filter.CLASS = function (a, b) {
        var c = (!isSVGElem(a) ? a.className : (a.className ? a.className.baseVal : a.getAttribute('class')));
        return (' ' + c + ' ').indexOf(b) > -1
      };
      $.expr.filter.ATTR = function (g) {
        return function (c, d) {
          var e = null;
          if (isSVGElem(c)) {
            e = d[1];
            $.expr.attrHandle[e] = function (a) {
              var b = a.getAttribute(e);
              return b && b.baseVal || b
            }
          }
          var f = g(c, d);
          if (e) {
            $.expr.attrHandle[e] = null
          }
          return f
        }
      }($.expr.filter.ATTR);

      function isSVGElem(a) {
        return (a.nodeType == 1 && a.namespaceURI == $.svg.svgNS)
      }
    })(jQuery);
  }, {}], 7: [function (require, module, exports) {
    (function () {
      function create(window) {
        window = window || eval("require('js" + "dom')").jsdom().createWindow();

        // assume window is a jsdom instance...
        // jsdom includes an incomplete version of XMLHttpRequest
        try {
          window.XMLHttpRequest = eval("require('xml" + "httprequest')").XMLHttpRequest;
          // trick jQuery into thinking CORS is supported (should be in node-XMLHttpRequest)
          window.XMLHttpRequest.prototype.withCredentials = false;
        }
        catch (e) {
        }

        var location = window.location,
          navigator = window.navigator,
          XMLHttpRequest = window.XMLHttpRequest;

        /*!
 * jQuery JavaScript Library v1.7.1
 * http://jquery.com/
 *
 * Copyright 2011, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2011, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Date: Mon Nov 21 21:11:03 2011 -0500
 */
        (function (window, undefined) {

// Use the correct document accordingly with window argument (sandbox)
          var document = window.document,
            navigator = window.navigator,
            location = window.location;
          var jQuery = (function () {

// Define a local copy of jQuery
            var jQuery = function (selector, context) {
                // The jQuery object is actually just the init constructor 'enhanced'
                return new jQuery.fn.init(selector, context, rootjQuery);
              },

              // Map over jQuery in case of overwrite
              _jQuery = window.jQuery,

              // Map over the $ in case of overwrite
              _$ = window.$,

              // A central reference to the root jQuery(document)
              rootjQuery,

              // A simple way to check for HTML strings or ID strings
              // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
              quickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

              // Check if a string has a non-whitespace character in it
              rnotwhite = /\S/,

              // Used for trimming whitespace
              trimLeft = /^\s+/,
              trimRight = /\s+$/,

              // Match a standalone tag
              rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,

              // JSON RegExp
              rvalidchars = /^[\],:{}\s]*$/,
              rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
              rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
              rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,

              // Useragent RegExp
              rwebkit = /(webkit)[ \/]([\w.]+)/,
              ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,
              rmsie = /(msie) ([\w.]+)/,
              rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,

              // Matches dashed string for camelizing
              rdashAlpha = /-([a-z]|[0-9])/ig,
              rmsPrefix = /^-ms-/,

              // Used by jQuery.camelCase as callback to replace()
              fcamelCase = function (all, letter) {
                return (letter + "").toUpperCase();
              },

              // Keep a UserAgent string for use with jQuery.browser
              userAgent = navigator.userAgent,

              // For matching the engine and version of the browser
              browserMatch,

              // The deferred used on DOM ready
              readyList,

              // The ready event handler
              DOMContentLoaded,

              // Save a reference to some core methods
              toString = Object.prototype.toString,
              hasOwn = Object.prototype.hasOwnProperty,
              push = Array.prototype.push,
              slice = Array.prototype.slice,
              trim = String.prototype.trim,
              indexOf = Array.prototype.indexOf,

              // [[Class]] -> type pairs
              class2type = {};

            jQuery.fn = jQuery.prototype = {
              constructor: jQuery,
              init: function (selector, context, rootjQuery) {
                var match, elem, ret, doc;

                // Handle $(""), $(null), or $(undefined)
                if (!selector) {
                  return this;
                }

                // Handle $(DOMElement)
                if (selector.nodeType) {
                  this.context = this[0] = selector;
                  this.length = 1;
                  return this;
                }

                // The body element only exists once, optimize finding it
                if (selector === "body" && !context && document.body) {
                  this.context = document;
                  this[0] = document.body;
                  this.selector = selector;
                  this.length = 1;
                  return this;
                }

                // Handle HTML strings
                if (typeof selector === "string") {
                  // Are we dealing with HTML string or an ID?
                  if (selector.charAt(0) === "<" && selector.charAt(selector.length - 1) === ">" && selector.length >= 3) {
                    // Assume that strings that start and end with <> are HTML and skip the regex check
                    match = [null, selector, null];

                  } else {
                    match = quickExpr.exec(selector);
                  }

                  // Verify a match, and that no context was specified for #id
                  if (match && (match[1] || !context)) {

                    // HANDLE: $(html) -> $(array)
                    if (match[1]) {
                      context = context instanceof jQuery ? context[0] : context;
                      doc = (context ? context.ownerDocument || context : document);

                      // If a single string is passed in and it's a single tag
                      // just do a createElement and skip the rest
                      ret = rsingleTag.exec(selector);

                      if (ret) {
                        if (jQuery.isPlainObject(context)) {
                          selector = [document.createElement(ret[1])];
                          jQuery.fn.attr.call(selector, context, true);

                        } else {
                          selector = [doc.createElement(ret[1])];
                        }

                      } else {
                        ret = jQuery.buildFragment([match[1]], [doc]);
                        selector = (ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment).childNodes;
                      }

                      return jQuery.merge(this, selector);

                      // HANDLE: $("#id")
                    } else {
                      elem = document.getElementById(match[2]);

                      // Check parentNode to catch when Blackberry 4.6 returns
                      // nodes that are no longer in the document #6963
                      if (elem && elem.parentNode) {
                        // Handle the case where IE and Opera return items
                        // by name instead of ID
                        if (elem.id !== match[2]) {
                          return rootjQuery.find(selector);
                        }

                        // Otherwise, we inject the element directly into the jQuery object
                        this.length = 1;
                        this[0] = elem;
                      }

                      this.context = document;
                      this.selector = selector;
                      return this;
                    }

                    // HANDLE: $(expr, $(...))
                  } else if (!context || context.jquery) {
                    return (context || rootjQuery).find(selector);

                    // HANDLE: $(expr, context)
                    // (which is just equivalent to: $(context).find(expr)
                  } else {
                    return this.constructor(context).find(selector);
                  }

                  // HANDLE: $(function)
                  // Shortcut for document ready
                } else if (jQuery.isFunction(selector)) {
                  return rootjQuery.ready(selector);
                }

                if (selector.selector !== undefined) {
                  this.selector = selector.selector;
                  this.context = selector.context;
                }

                return jQuery.makeArray(selector, this);
              },

              // Start with an empty selector
              selector: "",

              // The current version of jQuery being used
              jquery: "1.7.1",

              // The default length of a jQuery object is 0
              length: 0,

              // The number of elements contained in the matched element set
              size: function () {
                return this.length;
              },

              toArray: function () {
                return slice.call(this, 0);
              },

              // Get the Nth element in the matched element set OR
              // Get the whole matched element set as a clean array
              get: function (num) {
                return num == null ?

                  // Return a 'clean' array
                  this.toArray() :

                  // Return just the object
                  (num < 0 ? this[this.length + num] : this[num]);
              },

              // Take an array of elements and push it onto the stack
              // (returning the new matched element set)
              pushStack: function (elems, name, selector) {
                // Build a new jQuery matched element set
                var ret = this.constructor();

                if (jQuery.isArray(elems)) {
                  push.apply(ret, elems);

                } else {
                  jQuery.merge(ret, elems);
                }

                // Add the old object onto the stack (as a reference)
                ret.prevObject = this;

                ret.context = this.context;

                if (name === "find") {
                  ret.selector = this.selector + (this.selector ? " " : "") + selector;
                } else if (name) {
                  ret.selector = this.selector + "." + name + "(" + selector + ")";
                }

                // Return the newly-formed element set
                return ret;
              },

              // Execute a callback for every element in the matched set.
              // (You can seed the arguments with an array of args, but this is
              // only used internally.)
              each: function (callback, args) {
                return jQuery.each(this, callback, args);
              },

              ready: function (fn) {
                // Attach the listeners
                jQuery.bindReady();

                // Add the callback
                readyList.add(fn);

                return this;
              },

              eq: function (i) {
                i = +i;
                return i === -1 ?
                  this.slice(i) :
                  this.slice(i, i + 1);
              },

              first: function () {
                return this.eq(0);
              },

              last: function () {
                return this.eq(-1);
              },

              slice: function () {
                return this.pushStack(slice.apply(this, arguments),
                  "slice", slice.call(arguments).join(","));
              },

              map: function (callback) {
                return this.pushStack(jQuery.map(this, function (elem, i) {
                  return callback.call(elem, i, elem);
                }));
              },

              end: function () {
                return this.prevObject || this.constructor(null);
              },

              // For internal use only.
              // Behaves like an Array's method, not like a jQuery method.
              push: push,
              sort: [].sort,
              splice: [].splice
            };

// Give the init function the jQuery prototype for later instantiation
            jQuery.fn.init.prototype = jQuery.fn;

            jQuery.extend = jQuery.fn.extend = function () {
              var options, name, src, copy, copyIsArray, clone,
                target = arguments[0] || {},
                i = 1,
                length = arguments.length,
                deep = false;

              // Handle a deep copy situation
              if (typeof target === "boolean") {
                deep = target;
                target = arguments[1] || {};
                // skip the boolean and the target
                i = 2;
              }

              // Handle case when target is a string or something (possible in deep copy)
              if (typeof target !== "object" && !jQuery.isFunction(target)) {
                target = {};
              }

              // extend jQuery itself if only one argument is passed
              if (length === i) {
                target = this;
                --i;
              }

              for (; i < length; i++) {
                // Only deal with non-null/undefined values
                if ((options = arguments[i]) != null) {
                  // Extend the base object
                  for (name in options) {
                    src = target[name];
                    copy = options[name];

                    // Prevent never-ending loop
                    if (target === copy) {
                      continue;
                    }

                    // Recurse if we're merging plain objects or arrays
                    if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                      if (copyIsArray) {
                        copyIsArray = false;
                        clone = src && jQuery.isArray(src) ? src : [];

                      } else {
                        clone = src && jQuery.isPlainObject(src) ? src : {};
                      }

                      // Never move original objects, clone them
                      target[name] = jQuery.extend(deep, clone, copy);

                      // Don't bring in undefined values
                    } else if (copy !== undefined) {
                      target[name] = copy;
                    }
                  }
                }
              }

              // Return the modified object
              return target;
            };

            jQuery.extend({
              noConflict: function (deep) {
                if (window.$ === jQuery) {
                  window.$ = _$;
                }

                if (deep && window.jQuery === jQuery) {
                  window.jQuery = _jQuery;
                }

                return jQuery;
              },

              // Is the DOM ready to be used? Set to true once it occurs.
              isReady: false,

              // A counter to track how many items to wait for before
              // the ready event fires. See #6781
              readyWait: 1,

              // Hold (or release) the ready event
              holdReady: function (hold) {
                if (hold) {
                  jQuery.readyWait++;
                } else {
                  jQuery.ready(true);
                }
              },

              // Handle when the DOM is ready
              ready: function (wait) {
                // Either a released hold or an DOMready/load event and not yet ready
                if ((wait === true && !--jQuery.readyWait) || (wait !== true && !jQuery.isReady)) {
                  // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
                  if (!document.body) {
                    return setTimeout(jQuery.ready, 1);
                  }

                  // Remember that the DOM is ready
                  jQuery.isReady = true;

                  // If a normal DOM Ready event fired, decrement, and wait if need be
                  if (wait !== true && --jQuery.readyWait > 0) {
                    return;
                  }

                  // If there are functions bound, to execute
                  readyList.fireWith(document, [jQuery]);

                  // Trigger any bound ready events
                  if (jQuery.fn.trigger) {
                    jQuery(document).trigger("ready").off("ready");
                  }
                }
              },

              bindReady: function () {
                if (readyList) {
                  return;
                }

                readyList = jQuery.Callbacks("once memory");

                // Catch cases where $(document).ready() is called after the
                // browser event has already occurred.
                if (document.readyState === "complete") {
                  // Handle it asynchronously to allow scripts the opportunity to delay ready
                  return setTimeout(jQuery.ready, 1);
                }

                // Mozilla, Opera and webkit nightlies currently support this event
                if (document.addEventListener) {
                  // Use the handy event callback
                  document.addEventListener("DOMContentLoaded", DOMContentLoaded, false);

                  // A fallback to window.onload, that will always work
                  window.addEventListener("load", jQuery.ready, false);

                  // If IE event model is used
                } else if (document.attachEvent) {
                  // ensure firing before onload,
                  // maybe late but safe also for iframes
                  document.attachEvent("onreadystatechange", DOMContentLoaded);

                  // A fallback to window.onload, that will always work
                  window.attachEvent("onload", jQuery.ready);

                  // If IE and not a frame
                  // continually check to see if the document is ready
                  var toplevel = false;

                  try {
                    toplevel = window.frameElement == null;
                  } catch (e) {
                  }

                  if (document.documentElement.doScroll && toplevel) {
                    doScrollCheck();
                  }
                }
              },

              // See test/unit/core.js for details concerning isFunction.
              // Since version 1.3, DOM methods and functions like alert
              // aren't supported. They return false on IE (#2968).
              isFunction: function (obj) {
                return jQuery.type(obj) === "function";
              },

              isArray: Array.isArray || function (obj) {
                return jQuery.type(obj) === "array";
              },

              // A crude way of determining if an object is a window
              isWindow: function (obj) {
                return obj && typeof obj === "object" && "setInterval" in obj;
              },

              isNumeric: function (obj) {
                return !isNaN(parseFloat(obj)) && isFinite(obj);
              },

              type: function (obj) {
                return obj == null ?
                  String(obj) :
                  class2type[toString.call(obj)] || "object";
              },

              isPlainObject: function (obj) {
                // Must be an Object.
                // Because of IE, we also have to check the presence of the constructor property.
                // Make sure that DOM nodes and window objects don't pass through, as well
                if (!obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
                  return false;
                }

                try {
                  // Not own constructor property must be Object
                  if (obj.constructor &&
                    !hasOwn.call(obj, "constructor") &&
                    !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
                    return false;
                  }
                } catch (e) {
                  // IE8,9 Will throw exceptions on certain host objects #9897
                  return false;
                }

                // Own properties are enumerated firstly, so to speed up,
                // if last one is own, then all properties are own.

                var key;
                for (key in obj) {
                }

                return key === undefined || hasOwn.call(obj, key);
              },

              isEmptyObject: function (obj) {
                for (var name in obj) {
                  return false;
                }
                return true;
              },

              error: function (msg) {
                throw new Error(msg);
              },

              parseJSON: function (data) {
                if (typeof data !== "string" || !data) {
                  return null;
                }

                // Make sure leading/trailing whitespace is removed (IE can't handle it)
                data = jQuery.trim(data);

                // Attempt to parse using the native JSON parser first
                if (window.JSON && window.JSON.parse) {
                  return window.JSON.parse(data);
                }

                // Make sure the incoming data is actual JSON
                // Logic borrowed from http://json.org/json2.js
                if (rvalidchars.test(data.replace(rvalidescape, "@")
                  .replace(rvalidtokens, "]")
                  .replace(rvalidbraces, ""))) {

                  return (new Function("return " + data))();

                }
                jQuery.error("Invalid JSON: " + data);
              },

              // Cross-browser xml parsing
              parseXML: function (data) {
                var xml, tmp;
                try {
                  if (window.DOMParser) { // Standard
                    tmp = new DOMParser();
                    xml = tmp.parseFromString(data, "text/xml");
                  } else { // IE
                    xml = new ActiveXObject("Microsoft.XMLDOM");
                    xml.async = "false";
                    xml.loadXML(data);
                  }
                } catch (e) {
                  xml = undefined;
                }
                if (!xml || !xml.documentElement || xml.getElementsByTagName("parsererror").length) {
                  jQuery.error("Invalid XML: " + data);
                }
                return xml;
              },

              noop: function () {
              },

              // Evaluates a script in a global context
              // Workarounds based on findings by Jim Driscoll
              // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
              globalEval: function (data) {
                if (data && rnotwhite.test(data)) {
                  // We use execScript on Internet Explorer
                  // We use an anonymous function so that context is window
                  // rather than jQuery in Firefox
                  (window.execScript || function (data) {
                    window["eval"].call(window, data);
                  })(data);
                }
              },

              // Convert dashed to camelCase; used by the css and data modules
              // Microsoft forgot to hump their vendor prefix (#9572)
              camelCase: function (string) {
                return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
              },

              nodeName: function (elem, name) {
                return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
              },

              // args is for internal usage only
              each: function (object, callback, args) {
                var name, i = 0,
                  length = object.length,
                  isObj = length === undefined || jQuery.isFunction(object);

                if (args) {
                  if (isObj) {
                    for (name in object) {
                      if (callback.apply(object[name], args) === false) {
                        break;
                      }
                    }
                  } else {
                    for (; i < length;) {
                      if (callback.apply(object[i++], args) === false) {
                        break;
                      }
                    }
                  }

                  // A special, fast, case for the most common use of each
                } else {
                  if (isObj) {
                    for (name in object) {
                      if (callback.call(object[name], name, object[name]) === false) {
                        break;
                      }
                    }
                  } else {
                    for (; i < length;) {
                      if (callback.call(object[i], i, object[i++]) === false) {
                        break;
                      }
                    }
                  }
                }

                return object;
              },

              // Use native String.trim function wherever possible
              trim: trim ?
                function (text) {
                  return text == null ?
                    "" :
                    trim.call(text);
                } :

                // Otherwise use our own trimming functionality
                function (text) {
                  return text == null ?
                    "" :
                    text.toString().replace(trimLeft, "").replace(trimRight, "");
                },

              // results is for internal usage only
              makeArray: function (array, results) {
                var ret = results || [];

                if (array != null) {
                  // The window, strings (and functions) also have 'length'
                  // Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
                  var type = jQuery.type(array);

                  if (array.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow(array)) {
                    push.call(ret, array);
                  } else {
                    jQuery.merge(ret, array);
                  }
                }

                return ret;
              },

              inArray: function (elem, array, i) {
                var len;

                if (array) {
                  if (indexOf) {
                    return indexOf.call(array, elem, i);
                  }

                  len = array.length;
                  i = i ? i < 0 ? Math.max(0, len + i) : i : 0;

                  for (; i < len; i++) {
                    // Skip accessing in sparse arrays
                    if (i in array && array[i] === elem) {
                      return i;
                    }
                  }
                }

                return -1;
              },

              merge: function (first, second) {
                var i = first.length,
                  j = 0;

                if (typeof second.length === "number") {
                  for (var l = second.length; j < l; j++) {
                    first[i++] = second[j];
                  }

                } else {
                  while (second[j] !== undefined) {
                    first[i++] = second[j++];
                  }
                }

                first.length = i;

                return first;
              },

              grep: function (elems, callback, inv) {
                var ret = [], retVal;
                inv = !!inv;

                // Go through the array, only saving the items
                // that pass the validator function
                for (var i = 0, length = elems.length; i < length; i++) {
                  retVal = !!callback(elems[i], i);
                  if (inv !== retVal) {
                    ret.push(elems[i]);
                  }
                }

                return ret;
              },

              // arg is for internal usage only
              map: function (elems, callback, arg) {
                var value, key, ret = [],
                  i = 0,
                  length = elems.length,
                  // jquery objects are treated as arrays
                  isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ((length > 0 && elems[0] && elems[length - 1]) || length === 0 || jQuery.isArray(elems));

                // Go through the array, translating each of the items to their
                if (isArray) {
                  for (; i < length; i++) {
                    value = callback(elems[i], i, arg);

                    if (value != null) {
                      ret[ret.length] = value;
                    }
                  }

                  // Go through every key on the object,
                } else {
                  for (key in elems) {
                    value = callback(elems[key], key, arg);

                    if (value != null) {
                      ret[ret.length] = value;
                    }
                  }
                }

                // Flatten any nested arrays
                return ret.concat.apply([], ret);
              },

              // A global GUID counter for objects
              guid: 1,

              // Bind a function to a context, optionally partially applying any
              // arguments.
              proxy: function (fn, context) {
                if (typeof context === "string") {
                  var tmp = fn[context];
                  context = fn;
                  fn = tmp;
                }

                // Quick check to determine if target is callable, in the spec
                // this throws a TypeError, but we will just return undefined.
                if (!jQuery.isFunction(fn)) {
                  return undefined;
                }

                // Simulated bind
                var args = slice.call(arguments, 2),
                  proxy = function () {
                    return fn.apply(context, args.concat(slice.call(arguments)));
                  };

                // Set the guid of unique handler to the same of original handler, so it can be removed
                proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;

                return proxy;
              },

              // Mutifunctional method to get and set values to a collection
              // The value/s can optionally be executed if it's a function
              access: function (elems, key, value, exec, fn, pass) {
                var length = elems.length;

                // Setting many attributes
                if (typeof key === "object") {
                  for (var k in key) {
                    jQuery.access(elems, k, key[k], exec, fn, value);
                  }
                  return elems;
                }

                // Setting one attribute
                if (value !== undefined) {
                  // Optionally, function values get executed if exec is true
                  exec = !pass && exec && jQuery.isFunction(value);

                  for (var i = 0; i < length; i++) {
                    fn(elems[i], key, exec ? value.call(elems[i], i, fn(elems[i], key)) : value, pass);
                  }

                  return elems;
                }

                // Getting an attribute
                return length ? fn(elems[0], key) : undefined;
              },

              now: function () {
                return (new Date()).getTime();
              },

              // Use of jQuery.browser is frowned upon.
              // More details: http://docs.jquery.com/Utilities/jQuery.browser
              uaMatch: function (ua) {
                ua = ua.toLowerCase();

                var match = rwebkit.exec(ua) ||
                  ropera.exec(ua) ||
                  rmsie.exec(ua) ||
                  ua.indexOf("compatible") < 0 && rmozilla.exec(ua) ||
                  [];

                return {browser: match[1] || "", version: match[2] || "0"};
              },

              sub: function () {
                function jQuerySub(selector, context) {
                  return new jQuerySub.fn.init(selector, context);
                }

                jQuery.extend(true, jQuerySub, this);
                jQuerySub.superclass = this;
                jQuerySub.fn = jQuerySub.prototype = this();
                jQuerySub.fn.constructor = jQuerySub;
                jQuerySub.sub = this.sub;
                jQuerySub.fn.init = function init(selector, context) {
                  if (context && context instanceof jQuery && !(context instanceof jQuerySub)) {
                    context = jQuerySub(context);
                  }

                  return jQuery.fn.init.call(this, selector, context, rootjQuerySub);
                };
                jQuerySub.fn.init.prototype = jQuerySub.fn;
                var rootjQuerySub = jQuerySub(document);
                return jQuerySub;
              },

              browser: {}
            });

// Populate the class2type map
            jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function (i, name) {
              class2type["[object " + name + "]"] = name.toLowerCase();
            });

            browserMatch = jQuery.uaMatch(userAgent);
            if (browserMatch.browser) {
              jQuery.browser[browserMatch.browser] = true;
              jQuery.browser.version = browserMatch.version;
            }

// Deprecated, use jQuery.browser.webkit instead
            if (jQuery.browser.webkit) {
              jQuery.browser.safari = true;
            }

// IE doesn't match non-breaking spaces with \s
            if (rnotwhite.test("\xA0")) {
              trimLeft = /^[\s\xA0]+/;
              trimRight = /[\s\xA0]+$/;
            }

// All jQuery objects should point back to these
            rootjQuery = jQuery(document);

// Cleanup functions for the document ready method
            if (document.addEventListener) {
              DOMContentLoaded = function () {
                document.removeEventListener("DOMContentLoaded", DOMContentLoaded, false);
                jQuery.ready();
              };

            } else if (document.attachEvent) {
              DOMContentLoaded = function () {
                // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
                if (document.readyState === "complete") {
                  document.detachEvent("onreadystatechange", DOMContentLoaded);
                  jQuery.ready();
                }
              };
            }

// The DOM ready check for Internet Explorer
            function doScrollCheck() {
              if (jQuery.isReady) {
                return;
              }

              try {
                // If IE is used, use the trick by Diego Perini
                // http://javascript.nwbox.com/IEContentLoaded/
                document.documentElement.doScroll("left");
              } catch (e) {
                setTimeout(doScrollCheck, 1);
                return;
              }

              // and execute any waiting functions
              jQuery.ready();
            }

            return jQuery;

          })();


// String to Object flags format cache
          var flagsCache = {};

// Convert String-formatted flags into Object-formatted ones and store in cache
          function createFlags(flags) {
            var object = flagsCache[flags] = {},
              i, length;
            flags = flags.split(/\s+/);
            for (i = 0, length = flags.length; i < length; i++) {
              object[flags[i]] = true;
            }
            return object;
          }

          /*
     * Create a callback list using the following parameters:
     *
     *	flags:	an optional list of space-separated flags that will change how
     *			the callback list behaves
     *
     * By default a callback list will act like an event callback list and can be
     * "fired" multiple times.
     *
     * Possible flags:
     *
     *	once:			will ensure the callback list can only be fired once (like a Deferred)
     *
     *	memory:			will keep track of previous values and will call any callback added
     *					after the list has been fired right away with the latest "memorized"
     *					values (like a Deferred)
     *
     *	unique:			will ensure a callback can only be added once (no duplicate in the list)
     *
     *	stopOnFalse:	interrupt callings when a callback returns false
     *
     */
          jQuery.Callbacks = function (flags) {

            // Convert flags from String-formatted to Object-formatted
            // (we check in cache first)
            flags = flags ? (flagsCache[flags] || createFlags(flags)) : {};

            var // Actual callback list
              list = [],
              // Stack of fire calls for repeatable lists
              stack = [],
              // Last fire value (for non-forgettable lists)
              memory,
              // Flag to know if list is currently firing
              firing,
              // First callback to fire (used internally by add and fireWith)
              firingStart,
              // End of the loop when firing
              firingLength,
              // Index of currently firing callback (modified by remove if needed)
              firingIndex,
              // Add one or several callbacks to the list
              add = function (args) {
                var i,
                  length,
                  elem,
                  type,
                  actual;
                for (i = 0, length = args.length; i < length; i++) {
                  elem = args[i];
                  type = jQuery.type(elem);
                  if (type === "array") {
                    // Inspect recursively
                    add(elem);
                  } else if (type === "function") {
                    // Add if not in unique mode and callback is not in
                    if (!flags.unique || !self.has(elem)) {
                      list.push(elem);
                    }
                  }
                }
              },
              // Fire callbacks
              fire = function (context, args) {
                args = args || [];
                memory = !flags.memory || [context, args];
                firing = true;
                firingIndex = firingStart || 0;
                firingStart = 0;
                firingLength = list.length;
                for (; list && firingIndex < firingLength; firingIndex++) {
                  if (list[firingIndex].apply(context, args) === false && flags.stopOnFalse) {
                    memory = true; // Mark as halted
                    break;
                  }
                }
                firing = false;
                if (list) {
                  if (!flags.once) {
                    if (stack && stack.length) {
                      memory = stack.shift();
                      self.fireWith(memory[0], memory[1]);
                    }
                  } else if (memory === true) {
                    self.disable();
                  } else {
                    list = [];
                  }
                }
              },
              // Actual Callbacks object
              self = {
                // Add a callback or a collection of callbacks to the list
                add: function () {
                  if (list) {
                    var length = list.length;
                    add(arguments);
                    // Do we need to add the callbacks to the
                    // current firing batch?
                    if (firing) {
                      firingLength = list.length;
                      // With memory, if we're not firing then
                      // we should call right away, unless previous
                      // firing was halted (stopOnFalse)
                    } else if (memory && memory !== true) {
                      firingStart = length;
                      fire(memory[0], memory[1]);
                    }
                  }
                  return this;
                },
                // Remove a callback from the list
                remove: function () {
                  if (list) {
                    var args = arguments,
                      argIndex = 0,
                      argLength = args.length;
                    for (; argIndex < argLength; argIndex++) {
                      for (var i = 0; i < list.length; i++) {
                        if (args[argIndex] === list[i]) {
                          // Handle firingIndex and firingLength
                          if (firing) {
                            if (i <= firingLength) {
                              firingLength--;
                              if (i <= firingIndex) {
                                firingIndex--;
                              }
                            }
                          }
                          // Remove the element
                          list.splice(i--, 1);
                          // If we have some unicity property then
                          // we only need to do this once
                          if (flags.unique) {
                            break;
                          }
                        }
                      }
                    }
                  }
                  return this;
                },
                // Control if a given callback is in the list
                has: function (fn) {
                  if (list) {
                    var i = 0,
                      length = list.length;
                    for (; i < length; i++) {
                      if (fn === list[i]) {
                        return true;
                      }
                    }
                  }
                  return false;
                },
                // Remove all callbacks from the list
                empty: function () {
                  list = [];
                  return this;
                },
                // Have the list do nothing anymore
                disable: function () {
                  list = stack = memory = undefined;
                  return this;
                },
                // Is it disabled?
                disabled: function () {
                  return !list;
                },
                // Lock the list in its current state
                lock: function () {
                  stack = undefined;
                  if (!memory || memory === true) {
                    self.disable();
                  }
                  return this;
                },
                // Is it locked?
                locked: function () {
                  return !stack;
                },
                // Call all callbacks with the given context and arguments
                fireWith: function (context, args) {
                  if (stack) {
                    if (firing) {
                      if (!flags.once) {
                        stack.push([context, args]);
                      }
                    } else if (!(flags.once && memory)) {
                      fire(context, args);
                    }
                  }
                  return this;
                },
                // Call all the callbacks with the given arguments
                fire: function () {
                  self.fireWith(this, arguments);
                  return this;
                },
                // To know if the callbacks have already been called at least once
                fired: function () {
                  return !!memory;
                }
              };

            return self;
          };


          var // ./assets/brat-client/static reference to slice
            sliceDeferred = [].slice;

          jQuery.extend({

            Deferred: function (func) {
              var doneList = jQuery.Callbacks("once memory"),
                failList = jQuery.Callbacks("once memory"),
                progressList = jQuery.Callbacks("memory"),
                state = "pending",
                lists = {
                  resolve: doneList,
                  reject: failList,
                  notify: progressList
                },
                promise = {
                  done: doneList.add,
                  fail: failList.add,
                  progress: progressList.add,

                  state: function () {
                    return state;
                  },

                  // Deprecated
                  isResolved: doneList.fired,
                  isRejected: failList.fired,

                  then: function (doneCallbacks, failCallbacks, progressCallbacks) {
                    deferred.done(doneCallbacks).fail(failCallbacks).progress(progressCallbacks);
                    return this;
                  },
                  always: function () {
                    deferred.done.apply(deferred, arguments).fail.apply(deferred, arguments);
                    return this;
                  },
                  pipe: function (fnDone, fnFail, fnProgress) {
                    return jQuery.Deferred(function (newDefer) {
                      jQuery.each({
                        done: [fnDone, "resolve"],
                        fail: [fnFail, "reject"],
                        progress: [fnProgress, "notify"]
                      }, function (handler, data) {
                        var fn = data[0],
                          action = data[1],
                          returned;
                        if (jQuery.isFunction(fn)) {
                          deferred[handler](function () {
                            returned = fn.apply(this, arguments);
                            if (returned && jQuery.isFunction(returned.promise)) {
                              returned.promise().then(newDefer.resolve, newDefer.reject, newDefer.notify);
                            } else {
                              newDefer[action + "With"](this === deferred ? newDefer : this, [returned]);
                            }
                          });
                        } else {
                          deferred[handler](newDefer[action]);
                        }
                      });
                    }).promise();
                  },
                  // Get a promise for this deferred
                  // If obj is provided, the promise aspect is added to the object
                  promise: function (obj) {
                    if (obj == null) {
                      obj = promise;
                    } else {
                      for (var key in promise) {
                        obj[key] = promise[key];
                      }
                    }
                    return obj;
                  }
                },
                deferred = promise.promise({}),
                key;

              for (key in lists) {
                deferred[key] = lists[key].fire;
                deferred[key + "With"] = lists[key].fireWith;
              }

              // Handle state
              deferred.done(function () {
                state = "resolved";
              }, failList.disable, progressList.lock).fail(function () {
                state = "rejected";
              }, doneList.disable, progressList.lock);

              // Call given func if any
              if (func) {
                func.call(deferred, deferred);
              }

              // All done!
              return deferred;
            },

            // Deferred helper
            when: function (firstParam) {
              var args = sliceDeferred.call(arguments, 0),
                i = 0,
                length = args.length,
                pValues = new Array(length),
                count = length,
                pCount = length,
                deferred = length <= 1 && firstParam && jQuery.isFunction(firstParam.promise) ?
                  firstParam :
                  jQuery.Deferred(),
                promise = deferred.promise();

              function resolveFunc(i) {
                return function (value) {
                  args[i] = arguments.length > 1 ? sliceDeferred.call(arguments, 0) : value;
                  if (!(--count)) {
                    deferred.resolveWith(deferred, args);
                  }
                };
              }

              function progressFunc(i) {
                return function (value) {
                  pValues[i] = arguments.length > 1 ? sliceDeferred.call(arguments, 0) : value;
                  deferred.notifyWith(promise, pValues);
                };
              }

              if (length > 1) {
                for (; i < length; i++) {
                  if (args[i] && args[i].promise && jQuery.isFunction(args[i].promise)) {
                    args[i].promise().then(resolveFunc(i), deferred.reject, progressFunc(i));
                  } else {
                    --count;
                  }
                }
                if (!count) {
                  deferred.resolveWith(deferred, args);
                }
              } else if (deferred !== firstParam) {
                deferred.resolveWith(deferred, length ? [firstParam] : []);
              }
              return promise;
            }
          });


          jQuery.support = (function () {

            var support,
              all,
              a,
              select,
              opt,
              input,
              marginDiv,
              fragment,
              tds,
              events,
              eventName,
              i,
              isSupported,
              div = document.createElement("div"),
              documentElement = document.documentElement;

            // Preliminary tests
            div.setAttribute("className", "t");
            div.innerHTML = "   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>";

            all = div.getElementsByTagName("*");
            a = div.getElementsByTagName("a")[0];

            // Can't get basic test support
            if (!all || !all.length || !a) {
              return {};
            }

            // First batch of supports tests
            select = document.createElement("select");
            opt = select.appendChild(document.createElement("option"));
            input = div.getElementsByTagName("input")[0];

            support = {
              // IE strips leading whitespace when .innerHTML is used
              leadingWhitespace: (div.firstChild.nodeType === 3),

              // Make sure that tbody elements aren't automatically inserted
              // IE will insert them into empty tables
              tbody: !div.getElementsByTagName("tbody").length,

              // Make sure that link elements get serialized correctly by innerHTML
              // This requires a wrapper element in IE
              htmlSerialize: !!div.getElementsByTagName("link").length,

              // Get the style information from getAttribute
              // (IE uses .cssText instead)
              style: /top/.test(a.getAttribute("style")),

              // Make sure that URLs aren't manipulated
              // (IE normalizes it by default)
              hrefNormalized: (a.getAttribute("href") === "/a"),

              // Make sure that element opacity exists
              // (IE uses filter instead)
              // Use a regex to work around a WebKit issue. See #5145
              opacity: /^0.55/.test(a.style.opacity),

              // Verify style float existence
              // (IE uses styleFloat instead of cssFloat)
              cssFloat: !!a.style.cssFloat,

              // Make sure that if no value is specified for a checkbox
              // that it defaults to "on".
              // (WebKit defaults to "" instead)
              checkOn: (input.value === "on"),

              // Make sure that a selected-by-default option has a working selected property.
              // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
              optSelected: opt.selected,

              // Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
              getSetAttribute: div.className !== "t",

              // Tests for enctype support on a form(#6743)
              enctype: !!document.createElement("form").enctype,

              // Makes sure cloning an html5 element does not cause problems
              // Where outerHTML is undefined, this still works
              html5Clone: document.createElement("nav").cloneNode(true).outerHTML !== "<:nav></:nav>",

              // Will be defined later
              submitBubbles: true,
              changeBubbles: true,
              focusinBubbles: false,
              deleteExpando: true,
              noCloneEvent: true,
              inlineBlockNeedsLayout: false,
              shrinkWrapBlocks: false,
              reliableMarginRight: true
            };

            // Make sure checked status is properly cloned
            input.checked = true;
            support.noCloneChecked = input.cloneNode(true).checked;

            // Make sure that the options inside disabled selects aren't marked as disabled
            // (WebKit marks them as disabled)
            select.disabled = true;
            support.optDisabled = !opt.disabled;

            // Test to see if it's possible to delete an expando from an element
            // Fails in Internet Explorer
            try {
              delete div.test;
            } catch (e) {
              support.deleteExpando = false;
            }

            if (!div.addEventListener && div.attachEvent && div.fireEvent) {
              div.attachEvent("onclick", function () {
                // Cloning a node shouldn't copy over any
                // bound event handlers (IE does this)
                support.noCloneEvent = false;
              });
              div.cloneNode(true).fireEvent("onclick");
            }

            // Check if a radio maintains its value
            // after being appended to the DOM
            input = document.createElement("input");
            input.value = "t";
            input.setAttribute("type", "radio");
            support.radioValue = input.value === "t";

            input.setAttribute("checked", "checked");
            div.appendChild(input);
            fragment = document.createDocumentFragment();
            fragment.appendChild(div.lastChild);

            // WebKit doesn't clone checked state correctly in fragments
            support.checkClone = fragment.cloneNode(true).cloneNode(true).lastChild.checked;

            // Check if a disconnected checkbox will retain its checked
            // value of true after appended to the DOM (IE6/7)
            support.appendChecked = input.checked;

            fragment.removeChild(input);
            fragment.appendChild(div);

            div.innerHTML = "";

            // Check if div with explicit width and no margin-right incorrectly
            // gets computed margin-right based on width of container. For more
            // info see bug #3333
            // Fails in WebKit before Feb 2011 nightlies
            // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
            if (window.getComputedStyle) {
              marginDiv = document.createElement("div");
              marginDiv.style.width = "0";
              marginDiv.style.marginRight = "0";
              div.style.width = "2px";
              div.appendChild(marginDiv);
              support.reliableMarginRight =
                (parseInt((window.getComputedStyle(marginDiv, null) || {marginRight: 0}).marginRight, 10) || 0) === 0;
            }

            // Technique from Juriy Zaytsev
            // http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
            // We only care about the case where non-standard event systems
            // are used, namely in IE. Short-circuiting here helps us to
            // avoid an eval call (in setAttribute) which can cause CSP
            // to go haywire. See: https://developer.mozilla.org/en/Security/CSP
            if (div.attachEvent) {
              for (i in {
                submit: 1,
                change: 1,
                focusin: 1
              }) {
                eventName = "on" + i;
                isSupported = (eventName in div);
                if (!isSupported) {
                  div.setAttribute(eventName, "return;");
                  isSupported = (typeof div[eventName] === "function");
                }
                support[i + "Bubbles"] = isSupported;
              }
            }

            fragment.removeChild(div);

            // Null elements to avoid leaks in IE
            fragment = select = opt = marginDiv = div = input = null;

            // Run tests that need a body at doc ready
            jQuery(function () {
              var container, outer, inner, table, td, offsetSupport,
                conMarginTop, ptlm, vb, style, html,
                body = document.getElementsByTagName("body")[0];

              if (!body) {
                // Return for frameset docs that don't have a body
                return;
              }

              conMarginTop = 1;
              ptlm = "position:absolute;top:0;left:0;width:1px;height:1px;margin:0;";
              vb = "visibility:hidden;border:0;";
              style = "style='" + ptlm + "border:5px solid #000;padding:0;'";
              html = "<div " + style + "><div></div></div>" +
                "<table " + style + " cellpadding='0' cellspacing='0'>" +
                "<tr><td></td></tr></table>";

              container = document.createElement("div");
              container.style.cssText = vb + "width:0;height:0;position:static;top:0;margin-top:" + conMarginTop + "px";
              body.insertBefore(container, body.firstChild);

              // Construct the test element
              div = document.createElement("div");
              container.appendChild(div);

              // Check if table cells still have offsetWidth/Height when they are set
              // to display:none and there are still other visible table cells in a
              // table row; if so, offsetWidth/Height are not reliable for use when
              // determining if an element has been hidden directly using
              // display:none (it is still safe to use offsets if a parent element is
              // hidden; don safety goggles and see bug #4512 for more information).
              // (only IE 8 fails this test)
              div.innerHTML = "<table><tr><td style='padding:0;border:0;display:none'></td><td>t</td></tr></table>";
              tds = div.getElementsByTagName("td");
              isSupported = (tds[0].offsetHeight === 0);

              tds[0].style.display = "";
              tds[1].style.display = "none";

              // Check if empty table cells still have offsetWidth/Height
              // (IE <= 8 fail this test)
              support.reliableHiddenOffsets = isSupported && (tds[0].offsetHeight === 0);

              // Figure out if the W3C box model works as expected
              div.innerHTML = "";
              div.style.width = div.style.paddingLeft = "1px";
              jQuery.boxModel = support.boxModel = div.offsetWidth === 2;

              if (typeof div.style.zoom !== "undefined") {
                // Check if natively block-level elements act like inline-block
                // elements when setting their display to 'inline' and giving
                // them layout
                // (IE < 8 does this)
                div.style.display = "inline";
                div.style.zoom = 1;
                support.inlineBlockNeedsLayout = (div.offsetWidth === 2);

                // Check if elements with layout shrink-wrap their children
                // (IE 6 does this)
                div.style.display = "";
                div.innerHTML = "<div style='width:4px;'></div>";
                support.shrinkWrapBlocks = (div.offsetWidth !== 2);
              }

              div.style.cssText = ptlm + vb;
              div.innerHTML = html;

              outer = div.firstChild;
              inner = outer.firstChild;
              td = outer.nextSibling.firstChild.firstChild;

              offsetSupport = {
                doesNotAddBorder: (inner.offsetTop !== 5),
                doesAddBorderForTableAndCells: (td.offsetTop === 5)
              };

              inner.style.position = "fixed";
              inner.style.top = "20px";

              // safari subtracts parent border width here which is 5px
              offsetSupport.fixedPosition = (inner.offsetTop === 20 || inner.offsetTop === 15);
              inner.style.position = inner.style.top = "";

              outer.style.overflow = "hidden";
              outer.style.position = "relative";

              offsetSupport.subtractsBorderForOverflowNotVisible = (inner.offsetTop === -5);
              offsetSupport.doesNotIncludeMarginInBodyOffset = (body.offsetTop !== conMarginTop);

              body.removeChild(container);
              div = container = null;

              jQuery.extend(support, offsetSupport);
            });

            return support;
          })();


          var rbrace = /^(?:\{.*\}|\[.*\])$/,
            rmultiDash = /([A-Z])/g;

          jQuery.extend({
            cache: {},

            // Please use with caution
            uuid: 0,

            // Unique for each copy of jQuery on the page
            // Non-digits removed to match rinlinejQuery
            expando: "jQuery" + (jQuery.fn.jquery + Math.random()).replace(/\D/g, ""),

            // The following elements throw uncatchable exceptions if you
            // attempt to add expando properties to them.
            noData: {
              "embed": true,
              // Ban all objects except for Flash (which handle expandos)
              "object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
              "applet": true
            },

            hasData: function (elem) {
              elem = elem.nodeType ? jQuery.cache[elem[jQuery.expando]] : elem[jQuery.expando];
              return !!elem && !isEmptyDataObject(elem);
            },

            data: function (elem, name, data, pvt /* Internal Use Only */) {
              if (!jQuery.acceptData(elem)) {
                return;
              }

              var privateCache, thisCache, ret,
                internalKey = jQuery.expando,
                getByName = typeof name === "string",

                // We have to handle DOM nodes and JS objects differently because IE6-7
                // can't GC object references properly across the DOM-JS boundary
                isNode = elem.nodeType,

                // Only DOM nodes need the global jQuery cache; JS object data is
                // attached directly to the object so GC can occur automatically
                cache = isNode ? jQuery.cache : elem,

                // Only defining an ID for JS objects if its cache already exists allows
                // the code to shortcut on the same path as a DOM node with no cache
                id = isNode ? elem[internalKey] : elem[internalKey] && internalKey,
                isEvents = name === "events";

              // Avoid doing any more work than we need to when trying to get data on an
              // object that has no data at all
              if ((!id || !cache[id] || (!isEvents && !pvt && !cache[id].data)) && getByName && data === undefined) {
                return;
              }

              if (!id) {
                // Only DOM nodes need a new unique ID for each element since their data
                // ends up in the global cache
                if (isNode) {
                  elem[internalKey] = id = ++jQuery.uuid;
                } else {
                  id = internalKey;
                }
              }

              if (!cache[id]) {
                cache[id] = {};

                // Avoids exposing jQuery metadata on plain JS objects when the object
                // is serialized using JSON.stringify
                if (!isNode) {
                  cache[id].toJSON = jQuery.noop;
                }
              }

              // An object can be passed to jQuery.data instead of a key/value pair; this gets
              // shallow copied over onto the existing cache
              if (typeof name === "object" || typeof name === "function") {
                if (pvt) {
                  cache[id] = jQuery.extend(cache[id], name);
                } else {
                  cache[id].data = jQuery.extend(cache[id].data, name);
                }
              }

              privateCache = thisCache = cache[id];

              // jQuery data() is stored in a separate object inside the object's internal data
              // cache in order to avoid key collisions between internal data and user-defined
              // data.
              if (!pvt) {
                if (!thisCache.data) {
                  thisCache.data = {};
                }

                thisCache = thisCache.data;
              }

              if (data !== undefined) {
                thisCache[jQuery.camelCase(name)] = data;
              }

              // Users should not attempt to inspect the internal events object using jQuery.data,
              // it is undocumented and subject to change. But does anyone listen? No.
              if (isEvents && !thisCache[name]) {
                return privateCache.events;
              }

              // Check for both converted-to-camel and non-converted data property names
              // If a data property was specified
              if (getByName) {

                // First Try to find as-is property data
                ret = thisCache[name];

                // Test for null|undefined property data
                if (ret == null) {

                  // Try to find the camelCased property
                  ret = thisCache[jQuery.camelCase(name)];
                }
              } else {
                ret = thisCache;
              }

              return ret;
            },

            removeData: function (elem, name, pvt /* Internal Use Only */) {
              if (!jQuery.acceptData(elem)) {
                return;
              }

              var thisCache, i, l,

                // Reference to internal data cache key
                internalKey = jQuery.expando,

                isNode = elem.nodeType,

                // See jQuery.data for more information
                cache = isNode ? jQuery.cache : elem,

                // See jQuery.data for more information
                id = isNode ? elem[internalKey] : internalKey;

              // If there is already no cache entry for this object, there is no
              // purpose in continuing
              if (!cache[id]) {
                return;
              }

              if (name) {

                thisCache = pvt ? cache[id] : cache[id].data;

                if (thisCache) {

                  // Support array or space separated string names for data keys
                  if (!jQuery.isArray(name)) {

                    // try the string as a key before any manipulation
                    if (name in thisCache) {
                      name = [name];
                    } else {

                      // split the camel cased version by spaces unless a key with the spaces exists
                      name = jQuery.camelCase(name);
                      if (name in thisCache) {
                        name = [name];
                      } else {
                        name = name.split(" ");
                      }
                    }
                  }

                  for (i = 0, l = name.length; i < l; i++) {
                    delete thisCache[name[i]];
                  }

                  // If there is no data left in the cache, we want to continue
                  // and let the cache object itself get destroyed
                  if (!(pvt ? isEmptyDataObject : jQuery.isEmptyObject)(thisCache)) {
                    return;
                  }
                }
              }

              // See jQuery.data for more information
              if (!pvt) {
                delete cache[id].data;

                // Don't destroy the parent cache unless the internal data object
                // had been the only thing left in it
                if (!isEmptyDataObject(cache[id])) {
                  return;
                }
              }

              // Browsers that fail expando deletion also refuse to delete expandos on
              // the window, but it will allow it on all other JS objects; other browsers
              // don't care
              // Ensure that `cache` is not a window object #10080
              if (jQuery.support.deleteExpando || !cache.setInterval) {
                delete cache[id];
              } else {
                cache[id] = null;
              }

              // We destroyed the cache and need to eliminate the expando on the node to avoid
              // false lookups in the cache for entries that no longer exist
              if (isNode) {
                // IE does not allow us to delete expando properties from nodes,
                // nor does it have a removeAttribute function on Document nodes;
                // we must handle all of these cases
                if (jQuery.support.deleteExpando) {
                  delete elem[internalKey];
                } else if (elem.removeAttribute) {
                  elem.removeAttribute(internalKey);
                } else {
                  elem[internalKey] = null;
                }
              }
            },

            // For internal use only.
            _data: function (elem, name, data) {
              return jQuery.data(elem, name, data, true);
            },

            // A method for determining if a DOM node can handle the data expando
            acceptData: function (elem) {
              if (elem.nodeName) {
                var match = jQuery.noData[elem.nodeName.toLowerCase()];

                if (match) {
                  return !(match === true || elem.getAttribute("classid") !== match);
                }
              }

              return true;
            }
          });

          jQuery.fn.extend({
            data: function (key, value) {
              var parts, attr, name,
                data = null;

              if (typeof key === "undefined") {
                if (this.length) {
                  data = jQuery.data(this[0]);

                  if (this[0].nodeType === 1 && !jQuery._data(this[0], "parsedAttrs")) {
                    attr = this[0].attributes;
                    for (var i = 0, l = attr.length; i < l; i++) {
                      name = attr[i].name;

                      if (name.indexOf("data-") === 0) {
                        name = jQuery.camelCase(name.substring(5));

                        dataAttr(this[0], name, data[name]);
                      }
                    }
                    jQuery._data(this[0], "parsedAttrs", true);
                  }
                }

                return data;

              } else if (typeof key === "object") {
                return this.each(function () {
                  jQuery.data(this, key);
                });
              }

              parts = key.split(".");
              parts[1] = parts[1] ? "." + parts[1] : "";

              if (value === undefined) {
                data = this.triggerHandler("getData" + parts[1] + "!", [parts[0]]);

                // Try to fetch any internally stored data first
                if (data === undefined && this.length) {
                  data = jQuery.data(this[0], key);
                  data = dataAttr(this[0], key, data);
                }

                return data === undefined && parts[1] ?
                  this.data(parts[0]) :
                  data;

              } else {
                return this.each(function () {
                  var self = jQuery(this),
                    args = [parts[0], value];

                  self.triggerHandler("setData" + parts[1] + "!", args);
                  jQuery.data(this, key, value);
                  self.triggerHandler("changeData" + parts[1] + "!", args);
                });
              }
            },

            removeData: function (key) {
              return this.each(function () {
                jQuery.removeData(this, key);
              });
            }
          });

          function dataAttr(elem, key, data) {
            // If nothing was found internally, try to fetch any
            // data from the HTML5 data-* attribute
            if (data === undefined && elem.nodeType === 1) {

              var name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();

              data = elem.getAttribute(name);

              if (typeof data === "string") {
                try {
                  data = data === "true" ? true :
                    data === "false" ? false :
                      data === "null" ? null :
                        jQuery.isNumeric(data) ? parseFloat(data) :
                          rbrace.test(data) ? jQuery.parseJSON(data) :
                            data;
                } catch (e) {
                }

                // Make sure we set the data so it isn't changed later
                jQuery.data(elem, key, data);

              } else {
                data = undefined;
              }
            }

            return data;
          }

// checks a cache object for emptiness
          function isEmptyDataObject(obj) {
            for (var name in obj) {

              // if the public data object is empty, the private is still empty
              if (name === "data" && jQuery.isEmptyObject(obj[name])) {
                continue;
              }
              if (name !== "toJSON") {
                return false;
              }
            }

            return true;
          }


          function handleQueueMarkDefer(elem, type, src) {
            var deferDataKey = type + "defer",
              queueDataKey = type + "queue",
              markDataKey = type + "mark",
              defer = jQuery._data(elem, deferDataKey);
            if (defer &&
              (src === "queue" || !jQuery._data(elem, queueDataKey)) &&
              (src === "mark" || !jQuery._data(elem, markDataKey))) {
              // Give room for hard-coded callbacks to fire first
              // and eventually mark/queue something else on the element
              setTimeout(function () {
                if (!jQuery._data(elem, queueDataKey) &&
                  !jQuery._data(elem, markDataKey)) {
                  jQuery.removeData(elem, deferDataKey, true);
                  defer.fire();
                }
              }, 0);
            }
          }

          jQuery.extend({

            _mark: function (elem, type) {
              if (elem) {
                type = (type || "fx") + "mark";
                jQuery._data(elem, type, (jQuery._data(elem, type) || 0) + 1);
              }
            },

            _unmark: function (force, elem, type) {
              if (force !== true) {
                type = elem;
                elem = force;
                force = false;
              }
              if (elem) {
                type = type || "fx";
                var key = type + "mark",
                  count = force ? 0 : ((jQuery._data(elem, key) || 1) - 1);
                if (count) {
                  jQuery._data(elem, key, count);
                } else {
                  jQuery.removeData(elem, key, true);
                  handleQueueMarkDefer(elem, type, "mark");
                }
              }
            },

            queue: function (elem, type, data) {
              var q;
              if (elem) {
                type = (type || "fx") + "queue";
                q = jQuery._data(elem, type);

                // Speed up dequeue by getting out quickly if this is just a lookup
                if (data) {
                  if (!q || jQuery.isArray(data)) {
                    q = jQuery._data(elem, type, jQuery.makeArray(data));
                  } else {
                    q.push(data);
                  }
                }
                return q || [];
              }
            },

            dequeue: function (elem, type) {
              type = type || "fx";

              var queue = jQuery.queue(elem, type),
                fn = queue.shift(),
                hooks = {};

              // If the fx queue is dequeued, always remove the progress sentinel
              if (fn === "inprogress") {
                fn = queue.shift();
              }

              if (fn) {
                // Add a progress sentinel to prevent the fx queue from being
                // automatically dequeued
                if (type === "fx") {
                  queue.unshift("inprogress");
                }

                jQuery._data(elem, type + ".run", hooks);
                fn.call(elem, function () {
                  jQuery.dequeue(elem, type);
                }, hooks);
              }

              if (!queue.length) {
                jQuery.removeData(elem, type + "queue " + type + ".run", true);
                handleQueueMarkDefer(elem, type, "queue");
              }
            }
          });

          jQuery.fn.extend({
            queue: function (type, data) {
              if (typeof type !== "string") {
                data = type;
                type = "fx";
              }

              if (data === undefined) {
                return jQuery.queue(this[0], type);
              }
              return this.each(function () {
                var queue = jQuery.queue(this, type, data);

                if (type === "fx" && queue[0] !== "inprogress") {
                  jQuery.dequeue(this, type);
                }
              });
            },
            dequeue: function (type) {
              return this.each(function () {
                jQuery.dequeue(this, type);
              });
            },
            // Based off of the plugin by Clint Helfers, with permission.
            // http://blindsignals.com/index.php/2009/07/jquery-delay/
            delay: function (time, type) {
              time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
              type = type || "fx";

              return this.queue(type, function (next, hooks) {
                var timeout = setTimeout(next, time);
                hooks.stop = function () {
                  clearTimeout(timeout);
                };
              });
            },
            clearQueue: function (type) {
              return this.queue(type || "fx", []);
            },
            // Get a promise resolved when queues of a certain type
            // are emptied (fx is the type by default)
            promise: function (type, object) {
              if (typeof type !== "string") {
                object = type;
                type = undefined;
              }
              type = type || "fx";
              var defer = jQuery.Deferred(),
                elements = this,
                i = elements.length,
                count = 1,
                deferDataKey = type + "defer",
                queueDataKey = type + "queue",
                markDataKey = type + "mark",
                tmp;

              function resolve() {
                if (!(--count)) {
                  defer.resolveWith(elements, [elements]);
                }
              }

              while (i--) {
                if ((tmp = jQuery.data(elements[i], deferDataKey, undefined, true) ||
                  (jQuery.data(elements[i], queueDataKey, undefined, true) ||
                    jQuery.data(elements[i], markDataKey, undefined, true)) &&
                  jQuery.data(elements[i], deferDataKey, jQuery.Callbacks("once memory"), true))) {
                  count++;
                  tmp.add(resolve);
                }
              }
              resolve();
              return defer.promise();
            }
          });


          var rclass = /[\n\t\r]/g,
            rspace = /\s+/,
            rreturn = /\r/g,
            rtype = /^(?:button|input)$/i,
            rfocusable = /^(?:button|input|object|select|textarea)$/i,
            rclickable = /^a(?:rea)?$/i,
            rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
            getSetAttribute = jQuery.support.getSetAttribute,
            nodeHook, boolHook, fixSpecified;

          jQuery.fn.extend({
            attr: function (name, value) {
              return jQuery.access(this, name, value, true, jQuery.attr);
            },

            removeAttr: function (name) {
              return this.each(function () {
                jQuery.removeAttr(this, name);
              });
            },

            prop: function (name, value) {
              return jQuery.access(this, name, value, true, jQuery.prop);
            },

            removeProp: function (name) {
              name = jQuery.propFix[name] || name;
              return this.each(function () {
                // try/catch handles cases where IE balks (such as removing a property on window)
                try {
                  this[name] = undefined;
                  delete this[name];
                } catch (e) {
                }
              });
            },

            addClass: function (value) {
              var classNames, i, l, elem,
                setClass, c, cl;

              if (jQuery.isFunction(value)) {
                return this.each(function (j) {
                  jQuery(this).addClass(value.call(this, j, this.className));
                });
              }

              if (value && typeof value === "string") {
                classNames = value.split(rspace);

                for (i = 0, l = this.length; i < l; i++) {
                  elem = this[i];

                  if (elem.nodeType === 1) {
                    if (!elem.className && classNames.length === 1) {
                      elem.className = value;

                    } else {
                      setClass = " " + elem.className + " ";

                      for (c = 0, cl = classNames.length; c < cl; c++) {
                        if (!~setClass.indexOf(" " + classNames[c] + " ")) {
                          setClass += classNames[c] + " ";
                        }
                      }
                      elem.className = jQuery.trim(setClass);
                    }
                  }
                }
              }

              return this;
            },

            removeClass: function (value) {
              var classNames, i, l, elem, className, c, cl;

              if (jQuery.isFunction(value)) {
                return this.each(function (j) {
                  jQuery(this).removeClass(value.call(this, j, this.className));
                });
              }

              if ((value && typeof value === "string") || value === undefined) {
                classNames = (value || "").split(rspace);

                for (i = 0, l = this.length; i < l; i++) {
                  elem = this[i];

                  if (elem.nodeType === 1 && elem.className) {
                    if (value) {
                      className = (" " + elem.className + " ").replace(rclass, " ");
                      for (c = 0, cl = classNames.length; c < cl; c++) {
                        className = className.replace(" " + classNames[c] + " ", " ");
                      }
                      elem.className = jQuery.trim(className);

                    } else {
                      elem.className = "";
                    }
                  }
                }
              }

              return this;
            },

            toggleClass: function (value, stateVal) {
              var type = typeof value,
                isBool = typeof stateVal === "boolean";

              if (jQuery.isFunction(value)) {
                return this.each(function (i) {
                  jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
                });
              }

              return this.each(function () {
                if (type === "string") {
                  // toggle individual class names
                  var className,
                    i = 0,
                    self = jQuery(this),
                    state = stateVal,
                    classNames = value.split(rspace);

                  while ((className = classNames[i++])) {
                    // check each className given, space seperated list
                    state = isBool ? state : !self.hasClass(className);
                    self[state ? "addClass" : "removeClass"](className);
                  }

                } else if (type === "undefined" || type === "boolean") {
                  if (this.className) {
                    // store className if set
                    jQuery._data(this, "__className__", this.className);
                  }

                  // toggle whole className
                  this.className = this.className || value === false ? "" : jQuery._data(this, "__className__") || "";
                }
              });
            },

            hasClass: function (selector) {
              var className = " " + selector + " ",
                i = 0,
                l = this.length;
              for (; i < l; i++) {
                if (this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) > -1) {
                  return true;
                }
              }

              return false;
            },

            val: function (value) {
              var hooks, ret, isFunction,
                elem = this[0];

              if (!arguments.length) {
                if (elem) {
                  hooks = jQuery.valHooks[elem.nodeName.toLowerCase()] || jQuery.valHooks[elem.type];

                  if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
                    return ret;
                  }

                  ret = elem.value;

                  return typeof ret === "string" ?
                    // handle most common string cases
                    ret.replace(rreturn, "") :
                    // handle cases where value is null/undef or number
                    ret == null ? "" : ret;
                }

                return;
              }

              isFunction = jQuery.isFunction(value);

              return this.each(function (i) {
                var self = jQuery(this), val;

                if (this.nodeType !== 1) {
                  return;
                }

                if (isFunction) {
                  val = value.call(this, i, self.val());
                } else {
                  val = value;
                }

                // Treat null/undefined as ""; convert numbers to string
                if (val == null) {
                  val = "";
                } else if (typeof val === "number") {
                  val += "";
                } else if (jQuery.isArray(val)) {
                  val = jQuery.map(val, function (value) {
                    return value == null ? "" : value + "";
                  });
                }

                hooks = jQuery.valHooks[this.nodeName.toLowerCase()] || jQuery.valHooks[this.type];

                // If set returns undefined, fall back to normal setting
                if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
                  this.value = val;
                }
              });
            }
          });

          jQuery.extend({
            valHooks: {
              option: {
                get: function (elem) {
                  // attributes.value is undefined in Blackberry 4.7 but
                  // uses .value. See #6932
                  var val = elem.attributes.value;
                  return !val || val.specified ? elem.value : elem.text;
                }
              },
              select: {
                get: function (elem) {
                  var value, i, max, option,
                    index = elem.selectedIndex,
                    values = [],
                    options = elem.options,
                    one = elem.type === "select-one";

                  // Nothing was selected
                  if (index < 0) {
                    return null;
                  }

                  // Loop through all the selected options
                  i = one ? index : 0;
                  max = one ? index + 1 : options.length;
                  for (; i < max; i++) {
                    option = options[i];

                    // Don't return options that are disabled or in a disabled optgroup
                    if (option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
                      (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {

                      // Get the specific value for the option
                      value = jQuery(option).val();

                      // We don't need an array for one selects
                      if (one) {
                        return value;
                      }

                      // Multi-Selects return an array
                      values.push(value);
                    }
                  }

                  // Fixes Bug #2551 -- select.val() broken in IE after form.reset()
                  if (one && !values.length && options.length) {
                    return jQuery(options[index]).val();
                  }

                  return values;
                },

                set: function (elem, value) {
                  var values = jQuery.makeArray(value);

                  jQuery(elem).find("option").each(function () {
                    this.selected = jQuery.inArray(jQuery(this).val(), values) >= 0;
                  });

                  if (!values.length) {
                    elem.selectedIndex = -1;
                  }
                  return values;
                }
              }
            },

            attrFn: {
              val: true,
              css: true,
              html: true,
              text: true,
              data: true,
              width: true,
              height: true,
              offset: true
            },

            attr: function (elem, name, value, pass) {
              var ret, hooks, notxml,
                nType = elem.nodeType;

              // don't get/set attributes on text, comment and attribute nodes
              if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return;
              }

              if (pass && name in jQuery.attrFn) {
                return jQuery(elem)[name](value);
              }

              // Fallback to prop when attributes are not supported
              if (typeof elem.getAttribute === "undefined") {
                return jQuery.prop(elem, name, value);
              }

              notxml = nType !== 1 || !jQuery.isXMLDoc(elem);

              // All attributes are lowercase
              // Grab necessary hook if one is defined
              if (notxml) {
                name = name.toLowerCase();
                hooks = jQuery.attrHooks[name] || (rboolean.test(name) ? boolHook : nodeHook);
              }

              if (value !== undefined) {

                if (value === null) {
                  jQuery.removeAttr(elem, name);
                  return;

                } else if (hooks && "set" in hooks && notxml && (ret = hooks.set(elem, value, name)) !== undefined) {
                  return ret;

                } else {
                  elem.setAttribute(name, "" + value);
                  return value;
                }

              } else if (hooks && "get" in hooks && notxml && (ret = hooks.get(elem, name)) !== null) {
                return ret;

              } else {

                ret = elem.getAttribute(name);

                // Non-existent attributes return null, we normalize to undefined
                return ret === null ?
                  undefined :
                  ret;
              }
            },

            removeAttr: function (elem, value) {
              var propName, attrNames, name, l,
                i = 0;

              if (value && elem.nodeType === 1) {
                attrNames = value.toLowerCase().split(rspace);
                l = attrNames.length;

                for (; i < l; i++) {
                  name = attrNames[i];

                  if (name) {
                    propName = jQuery.propFix[name] || name;

                    // See #9699 for explanation of this approach (setting first, then removal)
                    jQuery.attr(elem, name, "");
                    elem.removeAttribute(getSetAttribute ? name : propName);

                    // Set corresponding property to false for boolean attributes
                    if (rboolean.test(name) && propName in elem) {
                      elem[propName] = false;
                    }
                  }
                }
              }
            },

            attrHooks: {
              type: {
                set: function (elem, value) {
                  // We can't allow the type property to be changed (since it causes problems in IE)
                  if (rtype.test(elem.nodeName) && elem.parentNode) {
                    jQuery.error("type property can't be changed");
                  } else if (!jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
                    // Setting the type on a radio button after the value resets the value in IE6-9
                    // Reset value to it's default in case type is set after value
                    // This is for element creation
                    var val = elem.value;
                    elem.setAttribute("type", value);
                    if (val) {
                      elem.value = val;
                    }
                    return value;
                  }
                }
              },
              // Use the value property for back compat
              // Use the nodeHook for button elements in IE6/7 (#1954)
              value: {
                get: function (elem, name) {
                  if (nodeHook && jQuery.nodeName(elem, "button")) {
                    return nodeHook.get(elem, name);
                  }
                  return name in elem ?
                    elem.value :
                    null;
                },
                set: function (elem, value, name) {
                  if (nodeHook && jQuery.nodeName(elem, "button")) {
                    return nodeHook.set(elem, value, name);
                  }
                  // Does not return so that setAttribute is also used
                  elem.value = value;
                }
              }
            },

            propFix: {
              tabindex: "tabIndex",
              readonly: "readOnly",
              "for": "htmlFor",
              "class": "className",
              maxlength: "maxLength",
              cellspacing: "cellSpacing",
              cellpadding: "cellPadding",
              rowspan: "rowSpan",
              colspan: "colSpan",
              usemap: "useMap",
              frameborder: "frameBorder",
              contenteditable: "contentEditable"
            },

            prop: function (elem, name, value) {
              var ret, hooks, notxml,
                nType = elem.nodeType;

              // don't get/set properties on text, comment and attribute nodes
              if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return;
              }

              notxml = nType !== 1 || !jQuery.isXMLDoc(elem);

              if (notxml) {
                // Fix name and attach hooks
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
              }

              if (value !== undefined) {
                if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                  return ret;

                } else {
                  return (elem[name] = value);
                }

              } else {
                if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                  return ret;

                } else {
                  return elem[name];
                }
              }
            },

            propHooks: {
              tabIndex: {
                get: function (elem) {
                  // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
                  // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                  var attributeNode = elem.getAttributeNode("tabindex");

                  return attributeNode && attributeNode.specified ?
                    parseInt(attributeNode.value, 10) :
                    rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ?
                      0 :
                      undefined;
                }
              }
            }
          });

// Add the tabIndex propHook to attrHooks for back-compat (different case is intentional)
          jQuery.attrHooks.tabindex = jQuery.propHooks.tabIndex;

// Hook for boolean attributes
          boolHook = {
            get: function (elem, name) {
              // Align boolean attributes with corresponding properties
              // Fall back to attribute presence where some booleans are not supported
              var attrNode,
                property = jQuery.prop(elem, name);
              return property === true || typeof property !== "boolean" && (attrNode = elem.getAttributeNode(name)) && attrNode.nodeValue !== false ?
                name.toLowerCase() :
                undefined;
            },
            set: function (elem, value, name) {
              var propName;
              if (value === false) {
                // Remove boolean attributes when set to false
                jQuery.removeAttr(elem, name);
              } else {
                // value is true since we know at this point it's type boolean and not false
                // Set boolean attributes to the same name and set the DOM property
                propName = jQuery.propFix[name] || name;
                if (propName in elem) {
                  // Only set the IDL specifically if it already exists on the element
                  elem[propName] = true;
                }

                elem.setAttribute(name, name.toLowerCase());
              }
              return name;
            }
          };

// IE6/7 do not support getting/setting some attributes with get/setAttribute
          if (!getSetAttribute) {

            fixSpecified = {
              name: true,
              id: true
            };

            // Use this for any attribute in IE6/7
            // This fixes almost every IE6/7 issue
            nodeHook = jQuery.valHooks.button = {
              get: function (elem, name) {
                var ret;
                ret = elem.getAttributeNode(name);
                return ret && (fixSpecified[name] ? ret.nodeValue !== "" : ret.specified) ?
                  ret.nodeValue :
                  undefined;
              },
              set: function (elem, value, name) {
                // Set the existing or create a new attribute node
                var ret = elem.getAttributeNode(name);
                if (!ret) {
                  ret = document.createAttribute(name);
                  elem.setAttributeNode(ret);
                }
                return (ret.nodeValue = value + "");
              }
            };

            // Apply the nodeHook to tabindex
            jQuery.attrHooks.tabindex.set = nodeHook.set;

            // Set width and height to auto instead of 0 on empty string( Bug #8150 )
            // This is for removals
            jQuery.each(["width", "height"], function (i, name) {
              jQuery.attrHooks[name] = jQuery.extend(jQuery.attrHooks[name], {
                set: function (elem, value) {
                  if (value === "") {
                    elem.setAttribute(name, "auto");
                    return value;
                  }
                }
              });
            });

            // Set contenteditable to false on removals(#10429)
            // Setting to empty string throws an error as an invalid value
            jQuery.attrHooks.contenteditable = {
              get: nodeHook.get,
              set: function (elem, value, name) {
                if (value === "") {
                  value = "false";
                }
                nodeHook.set(elem, value, name);
              }
            };
          }


// Some attributes require a special call on IE
          if (!jQuery.support.hrefNormalized) {
            jQuery.each(["href", "src", "width", "height"], function (i, name) {
              jQuery.attrHooks[name] = jQuery.extend(jQuery.attrHooks[name], {
                get: function (elem) {
                  var ret = elem.getAttribute(name, 2);
                  return ret === null ? undefined : ret;
                }
              });
            });
          }

          if (!jQuery.support.style) {
            jQuery.attrHooks.style = {
              get: function (elem) {
                // Return undefined in the case of empty string
                // Normalize to lowercase since IE uppercases css property names
                return elem.style.cssText.toLowerCase() || undefined;
              },
              set: function (elem, value) {
                return (elem.style.cssText = "" + value);
              }
            };
          }

// Safari mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
          if (!jQuery.support.optSelected) {
            jQuery.propHooks.selected = jQuery.extend(jQuery.propHooks.selected, {
              get: function (elem) {
                var parent = elem.parentNode;

                if (parent) {
                  parent.selectedIndex;

                  // Make sure that it also works with optgroups, see #5701
                  if (parent.parentNode) {
                    parent.parentNode.selectedIndex;
                  }
                }
                return null;
              }
            });
          }

// IE6/7 call enctype encoding
          if (!jQuery.support.enctype) {
            jQuery.propFix.enctype = "encoding";
          }

// Radios and checkboxes getter/setter
          if (!jQuery.support.checkOn) {
            jQuery.each(["radio", "checkbox"], function () {
              jQuery.valHooks[this] = {
                get: function (elem) {
                  // Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
                  return elem.getAttribute("value") === null ? "on" : elem.value;
                }
              };
            });
          }
          jQuery.each(["radio", "checkbox"], function () {
            jQuery.valHooks[this] = jQuery.extend(jQuery.valHooks[this], {
              set: function (elem, value) {
                if (jQuery.isArray(value)) {
                  return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0);
                }
              }
            });
          });


          var rformElems = /^(?:textarea|input|select)$/i,
            rtypenamespace = /^([^\.]*)?(?:\.(.+))?$/,
            rhoverHack = /\bhover(\.\S+)?\b/,
            rkeyEvent = /^key/,
            rmouseEvent = /^(?:mouse|contextmenu)|click/,
            rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
            rquickIs = /^(\w*)(?:#([\w\-]+))?(?:\.([\w\-]+))?$/,
            quickParse = function (selector) {
              var quick = rquickIs.exec(selector);
              if (quick) {
                //   0  1    2   3
                // [ _, tag, id, class ]
                quick[1] = (quick[1] || "").toLowerCase();
                quick[3] = quick[3] && new RegExp("(?:^|\\s)" + quick[3] + "(?:\\s|$)");
              }
              return quick;
            },
            quickIs = function (elem, m) {
              var attrs = elem.attributes || {};
              return (
                (!m[1] || elem.nodeName.toLowerCase() === m[1]) &&
                (!m[2] || (attrs.id || {}).value === m[2]) &&
                (!m[3] || m[3].test((attrs["class"] || {}).value))
              );
            },
            hoverHack = function (events) {
              return jQuery.event.special.hover ? events : events.replace(rhoverHack, "mouseenter$1 mouseleave$1");
            };

          /*
     * Helper functions for managing events -- not part of the public interface.
     * Props to Dean Edwards' addEvent library for many of the ideas.
     */
          jQuery.event = {

            add: function (elem, types, handler, data, selector) {

              var elemData, eventHandle, events,
                t, tns, type, namespaces, handleObj,
                handleObjIn, quick, handlers, special;

              // Don't attach events to noData or text/comment nodes (allow plain objects tho)
              if (elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data(elem))) {
                return;
              }

              // Caller can pass in an object of custom data in lieu of the handler
              if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
              }

              // Make sure that the handler has a unique ID, used to find/remove it later
              if (!handler.guid) {
                handler.guid = jQuery.guid++;
              }

              // Init the element's event structure and main handler, if this is the first
              events = elemData.events;
              if (!events) {
                elemData.events = events = {};
              }
              eventHandle = elemData.handle;
              if (!eventHandle) {
                elemData.handle = eventHandle = function (e) {
                  // Discard the second event of a jQuery.event.trigger() and
                  // when an event is called after a page has unloaded
                  return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
                    jQuery.event.dispatch.apply(eventHandle.elem, arguments) :
                    undefined;
                };
                // Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
                eventHandle.elem = elem;
              }

              // Handle multiple events separated by a space
              // jQuery(...).bind("mouseover mouseout", fn);
              types = jQuery.trim(hoverHack(types)).split(" ");
              for (t = 0; t < types.length; t++) {

                tns = rtypenamespace.exec(types[t]) || [];
                type = tns[1];
                namespaces = (tns[2] || "").split(".").sort();

                // If event changes its type, use the special event handlers for the changed type
                special = jQuery.event.special[type] || {};

                // If selector defined, determine special event api type, otherwise given type
                type = (selector ? special.delegateType : special.bindType) || type;

                // Update special based on newly reset type
                special = jQuery.event.special[type] || {};

                // handleObj is passed to all event handlers
                handleObj = jQuery.extend({
                  type: type,
                  origType: tns[1],
                  data: data,
                  handler: handler,
                  guid: handler.guid,
                  selector: selector,
                  quick: quickParse(selector),
                  namespace: namespaces.join(".")
                }, handleObjIn);

                // Init the event handler queue if we're the first
                handlers = events[type];
                if (!handlers) {
                  handlers = events[type] = [];
                  handlers.delegateCount = 0;

                  // Only use addEventListener/attachEvent if the special events handler returns false
                  if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                    // Bind the global event handler to the element
                    if (elem.addEventListener) {
                      elem.addEventListener(type, eventHandle, false);

                    } else if (elem.attachEvent) {
                      elem.attachEvent("on" + type, eventHandle);
                    }
                  }
                }

                if (special.add) {
                  special.add.call(elem, handleObj);

                  if (!handleObj.handler.guid) {
                    handleObj.handler.guid = handler.guid;
                  }
                }

                // Add to the element's handler list, delegates in front
                if (selector) {
                  handlers.splice(handlers.delegateCount++, 0, handleObj);
                } else {
                  handlers.push(handleObj);
                }

                // Keep track of which events have ever been used, for event optimization
                jQuery.event.global[type] = true;
              }

              // Nullify elem to prevent memory leaks in IE
              elem = null;
            },

            global: {},

            // Detach an event or set of events from an element
            remove: function (elem, types, handler, selector, mappedTypes) {

              var elemData = jQuery.hasData(elem) && jQuery._data(elem),
                t, tns, type, origType, namespaces, origCount,
                j, events, special, handle, eventType, handleObj;

              if (!elemData || !(events = elemData.events)) {
                return;
              }

              // Once for each type.namespace in types; type may be omitted
              types = jQuery.trim(hoverHack(types || "")).split(" ");
              for (t = 0; t < types.length; t++) {
                tns = rtypenamespace.exec(types[t]) || [];
                type = origType = tns[1];
                namespaces = tns[2];

                // Unbind all events (on this namespace, if provided) for the element
                if (!type) {
                  for (type in events) {
                    jQuery.event.remove(elem, type + types[t], handler, selector, true);
                  }
                  continue;
                }

                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                eventType = events[type] || [];
                origCount = eventType.length;
                namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.)?") + "(\\.|$)") : null;

                // Remove matching events
                for (j = 0; j < eventType.length; j++) {
                  handleObj = eventType[j];

                  if ((mappedTypes || origType === handleObj.origType) &&
                    (!handler || handler.guid === handleObj.guid) &&
                    (!namespaces || namespaces.test(handleObj.namespace)) &&
                    (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                    eventType.splice(j--, 1);

                    if (handleObj.selector) {
                      eventType.delegateCount--;
                    }
                    if (special.remove) {
                      special.remove.call(elem, handleObj);
                    }
                  }
                }

                // Remove generic event handler if we removed something and no more handlers exist
                // (avoids potential for endless recursion during removal of special event handlers)
                if (eventType.length === 0 && origCount !== eventType.length) {
                  if (!special.teardown || special.teardown.call(elem, namespaces) === false) {
                    jQuery.removeEvent(elem, type, elemData.handle);
                  }

                  delete events[type];
                }
              }

              // Remove the expando if it's no longer used
              if (jQuery.isEmptyObject(events)) {
                handle = elemData.handle;
                if (handle) {
                  handle.elem = null;
                }

                // removeData also checks for emptiness and clears the expando if empty
                // so use it instead of delete
                jQuery.removeData(elem, ["events", "handle"], true);
              }
            },

            // Events that are safe to short-circuit if no handlers are attached.
            // Native DOM events should not be added, they may have inline handlers.
            customEvent: {
              "getData": true,
              "setData": true,
              "changeData": true
            },

            trigger: function (event, data, elem, onlyHandlers) {
              // Don't do events on text and comment nodes
              if (elem && (elem.nodeType === 3 || elem.nodeType === 8)) {
                return;
              }

              // Event object or event type
              var type = event.type || event,
                namespaces = [],
                cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType;

              // focus/blur morphs to focusin/out; ensure we're not firing them right now
              if (rfocusMorph.test(type + jQuery.event.triggered)) {
                return;
              }

              if (type.indexOf("!") >= 0) {
                // Exclusive events trigger only for the exact event (no namespaces)
                type = type.slice(0, -1);
                exclusive = true;
              }

              if (type.indexOf(".") >= 0) {
                // Namespaced trigger; create a regexp to match event type in handle()
                namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort();
              }

              if ((!elem || jQuery.event.customEvent[type]) && !jQuery.event.global[type]) {
                // No jQuery handlers for this event type, and it can't have inline handlers
                return;
              }

              // Caller can pass in an Event, Object, or just an event type string
              event = typeof event === "object" ?
                // jQuery.Event object
                event[jQuery.expando] ? event :
                  // Object literal
                  new jQuery.Event(type, event) :
                // Just the event type (string)
                new jQuery.Event(type);

              event.type = type;
              event.isTrigger = true;
              event.exclusive = exclusive;
              event.namespace = namespaces.join(".");
              event.namespace_re = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.)?") + "(\\.|$)") : null;
              ontype = type.indexOf(":") < 0 ? "on" + type : "";

              // Handle a global trigger
              if (!elem) {

                // TODO: Stop taunting the data cache; remove global events and always attach to document
                cache = jQuery.cache;
                for (i in cache) {
                  if (cache[i].events && cache[i].events[type]) {
                    jQuery.event.trigger(event, data, cache[i].handle.elem, true);
                  }
                }
                return;
              }

              // Clean up the event in case it is being reused
              event.result = undefined;
              if (!event.target) {
                event.target = elem;
              }

              // Clone any incoming data and prepend the event, creating the handler arg list
              data = data != null ? jQuery.makeArray(data) : [];
              data.unshift(event);

              // Allow special events to draw outside the lines
              special = jQuery.event.special[type] || {};
              if (special.trigger && special.trigger.apply(elem, data) === false) {
                return;
              }

              // Determine event propagation path in advance, per W3C events spec (#9951)
              // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
              eventPath = [[elem, special.bindType || type]];
              if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {

                bubbleType = special.delegateType || type;
                cur = rfocusMorph.test(bubbleType + type) ? elem : elem.parentNode;
                old = null;
                for (; cur; cur = cur.parentNode) {
                  eventPath.push([cur, bubbleType]);
                  old = cur;
                }

                // Only add window if we got to document (e.g., not plain obj or detached DOM)
                if (old && old === elem.ownerDocument) {
                  eventPath.push([old.defaultView || old.parentWindow || window, bubbleType]);
                }
              }

              // Fire handlers on the event path
              for (i = 0; i < eventPath.length && !event.isPropagationStopped(); i++) {

                cur = eventPath[i][0];
                event.type = eventPath[i][1];

                handle = (jQuery._data(cur, "events") || {})[event.type] && jQuery._data(cur, "handle");
                if (handle) {
                  handle.apply(cur, data);
                }
                // Note that this is a bare JS function and not a jQuery handler
                handle = ontype && cur[ontype];
                if (handle && jQuery.acceptData(cur) && handle.apply(cur, data) === false) {
                  event.preventDefault();
                }
              }
              event.type = type;

              // If nobody prevented the default action, do it now
              if (!onlyHandlers && !event.isDefaultPrevented()) {

                if ((!special._default || special._default.apply(elem.ownerDocument, data) === false) &&
                  !(type === "click" && jQuery.nodeName(elem, "a")) && jQuery.acceptData(elem)) {

                  // Call a native DOM method on the target with the same name name as the event.
                  // Can't use an .isFunction() check here because IE6/7 fails that test.
                  // Don't do default actions on window, that's where global variables be (#6170)
                  // IE<9 dies on focus/blur to hidden element (#1486)
                  if (ontype && elem[type] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !jQuery.isWindow(elem)) {

                    // Don't re-trigger an onFOO event when we call its FOO() method
                    old = elem[ontype];

                    if (old) {
                      elem[ontype] = null;
                    }

                    // Prevent re-triggering of the same event, since we already bubbled it above
                    jQuery.event.triggered = type;
                    elem[type]();
                    jQuery.event.triggered = undefined;

                    if (old) {
                      elem[ontype] = old;
                    }
                  }
                }
              }

              return event.result;
            },

            dispatch: function (event) {

              // Make a writable jQuery.Event from the native event object
              event = jQuery.event.fix(event || window.event);

              var handlers = ((jQuery._data(this, "events") || {})[event.type] || []),
                delegateCount = handlers.delegateCount,
                args = [].slice.call(arguments, 0),
                run_all = !event.exclusive && !event.namespace,
                handlerQueue = [],
                i, j, cur, jqcur, ret, selMatch, matched, matches, handleObj, sel, related;

              // Use the fix-ed jQuery.Event rather than the (read-only) native event
              args[0] = event;
              event.delegateTarget = this;

              // Determine handlers that should run if there are delegated events
              // Avoid disabled elements in IE (#6911) and non-left-click bubbling in Firefox (#3861)
              if (delegateCount && !event.target.disabled && !(event.button && event.type === "click")) {

                // Pregenerate a single jQuery object for reuse with .is()
                jqcur = jQuery(this);
                jqcur.context = this.ownerDocument || this;

                for (cur = event.target; cur != this; cur = cur.parentNode || this) {
                  selMatch = {};
                  matches = [];
                  jqcur[0] = cur;
                  for (i = 0; i < delegateCount; i++) {
                    handleObj = handlers[i];
                    sel = handleObj.selector;

                    if (selMatch[sel] === undefined) {
                      selMatch[sel] = (
                        handleObj.quick ? quickIs(cur, handleObj.quick) : jqcur.is(sel)
                      );
                    }
                    if (selMatch[sel]) {
                      matches.push(handleObj);
                    }
                  }
                  if (matches.length) {
                    handlerQueue.push({elem: cur, matches: matches});
                  }
                }
              }

              // Add the remaining (directly-bound) handlers
              if (handlers.length > delegateCount) {
                handlerQueue.push({elem: this, matches: handlers.slice(delegateCount)});
              }

              // Run delegates first; they may want to stop propagation beneath us
              for (i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++) {
                matched = handlerQueue[i];
                event.currentTarget = matched.elem;

                for (j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++) {
                  handleObj = matched.matches[j];

                  // Triggered event must either 1) be non-exclusive and have no namespace, or
                  // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
                  if (run_all || (!event.namespace && !handleObj.namespace) || event.namespace_re && event.namespace_re.test(handleObj.namespace)) {

                    event.data = handleObj.data;
                    event.handleObj = handleObj;

                    ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler)
                      .apply(matched.elem, args);

                    if (ret !== undefined) {
                      event.result = ret;
                      if (ret === false) {
                        event.preventDefault();
                        event.stopPropagation();
                      }
                    }
                  }
                }
              }

              return event.result;
            },

            // Includes some event props shared by KeyEvent and MouseEvent
            // *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***
            props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

            fixHooks: {},

            keyHooks: {
              props: "char charCode key keyCode".split(" "),
              filter: function (event, original) {

                // Add which for key events
                if (event.which == null) {
                  event.which = original.charCode != null ? original.charCode : original.keyCode;
                }

                return event;
              }
            },

            mouseHooks: {
              props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
              filter: function (event, original) {
                var eventDoc, doc, body,
                  button = original.button,
                  fromElement = original.fromElement;

                // Calculate pageX/Y if missing and clientX/Y available
                if (event.pageX == null && original.clientX != null) {
                  eventDoc = event.target.ownerDocument || document;
                  doc = eventDoc.documentElement;
                  body = eventDoc.body;

                  event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                  event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
                }

                // Add relatedTarget, if necessary
                if (!event.relatedTarget && fromElement) {
                  event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
                }

                // Add which for click: 1 === left; 2 === middle; 3 === right
                // Note: button is not normalized, so don't use it
                if (!event.which && button !== undefined) {
                  event.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
                }

                return event;
              }
            },

            fix: function (event) {
              if (event[jQuery.expando]) {
                return event;
              }

              // Create a writable copy of the event object and normalize some properties
              var i, prop,
                originalEvent = event,
                fixHook = jQuery.event.fixHooks[event.type] || {},
                copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;

              event = jQuery.Event(originalEvent);

              for (i = copy.length; i;) {
                prop = copy[--i];
                event[prop] = originalEvent[prop];
              }

              // Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)
              if (!event.target) {
                event.target = originalEvent.srcElement || document;
              }

              // Target should not be a text node (#504, Safari)
              if (event.target.nodeType === 3) {
                event.target = event.target.parentNode;
              }

              // For mouse/key events; add metaKey if it's not there (#3368, IE6/7/8)
              if (event.metaKey === undefined) {
                event.metaKey = event.ctrlKey;
              }

              return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
            },

            special: {
              ready: {
                // Make sure the ready event is setup
                setup: jQuery.bindReady
              },

              load: {
                // Prevent triggered image.load events from bubbling to window.load
                noBubble: true
              },

              focus: {
                delegateType: "focusin"
              },
              blur: {
                delegateType: "focusout"
              },

              beforeunload: {
                setup: function (data, namespaces, eventHandle) {
                  // We only want to do this special case on windows
                  if (jQuery.isWindow(this)) {
                    this.onbeforeunload = eventHandle;
                  }
                },

                teardown: function (namespaces, eventHandle) {
                  if (this.onbeforeunload === eventHandle) {
                    this.onbeforeunload = null;
                  }
                }
              }
            },

            simulate: function (type, elem, event, bubble) {
              // Piggyback on a donor event to simulate a different one.
              // Fake originalEvent to avoid donor's stopPropagation, but if the
              // simulated event prevents default then we do the same on the donor.
              var e = jQuery.extend(
                new jQuery.Event(),
                event,
                {
                  type: type,
                  isSimulated: true,
                  originalEvent: {}
                }
              );
              if (bubble) {
                jQuery.event.trigger(e, null, elem);
              } else {
                jQuery.event.dispatch.call(elem, e);
              }
              if (e.isDefaultPrevented()) {
                event.preventDefault();
              }
            }
          };

// Some plugins are using, but it's undocumented/deprecated and will be removed.
// The 1.7 special event interface should provide all the hooks needed now.
          jQuery.event.handle = jQuery.event.dispatch;

          jQuery.removeEvent = document.removeEventListener ?
            function (elem, type, handle) {
              if (elem.removeEventListener) {
                elem.removeEventListener(type, handle, false);
              }
            } :
            function (elem, type, handle) {
              if (elem.detachEvent) {
                elem.detachEvent("on" + type, handle);
              }
            };

          jQuery.Event = function (src, props) {
            // Allow instantiation without the 'new' keyword
            if (!(this instanceof jQuery.Event)) {
              return new jQuery.Event(src, props);
            }

            // Event object
            if (src && src.type) {
              this.originalEvent = src;
              this.type = src.type;

              // Events bubbling up the document may have been marked as prevented
              // by a handler lower down the tree; reflect the correct value.
              this.isDefaultPrevented = (src.defaultPrevented || src.returnValue === false ||
                src.getPreventDefault && src.getPreventDefault()) ? returnTrue : returnFalse;

              // Event type
            } else {
              this.type = src;
            }

            // Put explicitly provided properties onto the event object
            if (props) {
              jQuery.extend(this, props);
            }

            // Create a timestamp if incoming event doesn't have one
            this.timeStamp = src && src.timeStamp || jQuery.now();

            // Mark it as fixed
            this[jQuery.expando] = true;
          };

          function returnFalse() {
            return false;
          }

          function returnTrue() {
            return true;
          }

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
          jQuery.Event.prototype = {
            preventDefault: function () {
              this.isDefaultPrevented = returnTrue;

              var e = this.originalEvent;
              if (!e) {
                return;
              }

              // if preventDefault exists run it on the original event
              if (e.preventDefault) {
                e.preventDefault();

                // otherwise set the returnValue property of the original event to false (IE)
              } else {
                e.returnValue = false;
              }
            },
            stopPropagation: function () {
              this.isPropagationStopped = returnTrue;

              var e = this.originalEvent;
              if (!e) {
                return;
              }
              // if stopPropagation exists run it on the original event
              if (e.stopPropagation) {
                e.stopPropagation();
              }
              // otherwise set the cancelBubble property of the original event to true (IE)
              e.cancelBubble = true;
            },
            stopImmediatePropagation: function () {
              this.isImmediatePropagationStopped = returnTrue;
              this.stopPropagation();
            },
            isDefaultPrevented: returnFalse,
            isPropagationStopped: returnFalse,
            isImmediatePropagationStopped: returnFalse
          };

// Create mouseenter/leave events using mouseover/out and event-time checks
          jQuery.each({
            mouseenter: "mouseover",
            mouseleave: "mouseout"
          }, function (orig, fix) {
            jQuery.event.special[orig] = {
              delegateType: fix,
              bindType: fix,

              handle: function (event) {
                var target = this,
                  related = event.relatedTarget,
                  handleObj = event.handleObj,
                  selector = handleObj.selector,
                  ret;

                // For mousenter/leave call the handler if related is outside the target.
                // NB: No relatedTarget if the mouse left/entered the browser window
                if (!related || (related !== target && !jQuery.contains(target, related))) {
                  event.type = handleObj.origType;
                  ret = handleObj.handler.apply(this, arguments);
                  event.type = fix;
                }
                return ret;
              }
            };
          });

// IE submit delegation
          if (!jQuery.support.submitBubbles) {

            jQuery.event.special.submit = {
              setup: function () {
                // Only need this for delegated form submit events
                if (jQuery.nodeName(this, "form")) {
                  return false;
                }

                // Lazy-add a submit handler when a descendant form may potentially be submitted
                jQuery.event.add(this, "click._submit keypress._submit", function (e) {
                  // Node name check avoids a VML-related crash in IE (#9807)
                  var elem = e.target,
                    form = jQuery.nodeName(elem, "input") || jQuery.nodeName(elem, "button") ? elem.form : undefined;
                  if (form && !form._submit_attached) {
                    jQuery.event.add(form, "submit._submit", function (event) {
                      // If form was submitted by the user, bubble the event up the tree
                      if (this.parentNode && !event.isTrigger) {
                        jQuery.event.simulate("submit", this.parentNode, event, true);
                      }
                    });
                    form._submit_attached = true;
                  }
                });
                // return undefined since we don't need an event listener
              },

              teardown: function () {
                // Only need this for delegated form submit events
                if (jQuery.nodeName(this, "form")) {
                  return false;
                }

                // Remove delegated handlers; cleanData eventually reaps submit handlers attached above
                jQuery.event.remove(this, "._submit");
              }
            };
          }

// IE change delegation and checkbox/radio fix
          if (!jQuery.support.changeBubbles) {

            jQuery.event.special.change = {

              setup: function () {

                if (rformElems.test(this.nodeName)) {
                  // IE doesn't fire change on a check/radio until blur; trigger it on click
                  // after a propertychange. Eat the blur-change in special.change.handle.
                  // This still fires onchange a second time for check/radio after blur.
                  if (this.type === "checkbox" || this.type === "radio") {
                    jQuery.event.add(this, "propertychange._change", function (event) {
                      if (event.originalEvent.propertyName === "checked") {
                        this._just_changed = true;
                      }
                    });
                    jQuery.event.add(this, "click._change", function (event) {
                      if (this._just_changed && !event.isTrigger) {
                        this._just_changed = false;
                        jQuery.event.simulate("change", this, event, true);
                      }
                    });
                  }
                  return false;
                }
                // Delegated event; lazy-add a change handler on descendant inputs
                jQuery.event.add(this, "beforeactivate._change", function (e) {
                  var elem = e.target;

                  if (rformElems.test(elem.nodeName) && !elem._change_attached) {
                    jQuery.event.add(elem, "change._change", function (event) {
                      if (this.parentNode && !event.isSimulated && !event.isTrigger) {
                        jQuery.event.simulate("change", this.parentNode, event, true);
                      }
                    });
                    elem._change_attached = true;
                  }
                });
              },

              handle: function (event) {
                var elem = event.target;

                // Swallow native change events from checkbox/radio, we already triggered them above
                if (this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox")) {
                  return event.handleObj.handler.apply(this, arguments);
                }
              },

              teardown: function () {
                jQuery.event.remove(this, "._change");

                return rformElems.test(this.nodeName);
              }
            };
          }

// Create "bubbling" focus and blur events
          if (!jQuery.support.focusinBubbles) {
            jQuery.each({focus: "focusin", blur: "focusout"}, function (orig, fix) {

              // Attach a single capturing handler while someone wants focusin/focusout
              var attaches = 0,
                handler = function (event) {
                  jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
                };

              jQuery.event.special[fix] = {
                setup: function () {
                  if (attaches++ === 0) {
                    document.addEventListener(orig, handler, true);
                  }
                },
                teardown: function () {
                  if (--attaches === 0) {
                    document.removeEventListener(orig, handler, true);
                  }
                }
              };
            });
          }

          jQuery.fn.extend({

            on: function (types, selector, data, fn, /*INTERNAL*/ one) {
              var origFn, type;

              // Types can be a map of types/handlers
              if (typeof types === "object") {
                // ( types-Object, selector, data )
                if (typeof selector !== "string") {
                  // ( types-Object, data )
                  data = selector;
                  selector = undefined;
                }
                for (type in types) {
                  this.on(type, selector, data, types[type], one);
                }
                return this;
              }

              if (data == null && fn == null) {
                // ( types, fn )
                fn = selector;
                data = selector = undefined;
              } else if (fn == null) {
                if (typeof selector === "string") {
                  // ( types, selector, fn )
                  fn = data;
                  data = undefined;
                } else {
                  // ( types, data, fn )
                  fn = data;
                  data = selector;
                  selector = undefined;
                }
              }
              if (fn === false) {
                fn = returnFalse;
              } else if (!fn) {
                return this;
              }

              if (one === 1) {
                origFn = fn;
                fn = function (event) {
                  // Can use an empty set, since event contains the info
                  jQuery().off(event);
                  return origFn.apply(this, arguments);
                };
                // Use same guid so caller can remove using origFn
                fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
              }
              return this.each(function () {
                jQuery.event.add(this, types, fn, data, selector);
              });
            },
            one: function (types, selector, data, fn) {
              return this.on.call(this, types, selector, data, fn, 1);
            },
            off: function (types, selector, fn) {
              if (types && types.preventDefault && types.handleObj) {
                // ( event )  dispatched jQuery.Event
                var handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(
                  handleObj.namespace ? handleObj.type + "." + handleObj.namespace : handleObj.type,
                  handleObj.selector,
                  handleObj.handler
                );
                return this;
              }
              if (typeof types === "object") {
                // ( types-object [, selector] )
                for (var type in types) {
                  this.off(type, selector, types[type]);
                }
                return this;
              }
              if (selector === false || typeof selector === "function") {
                // ( types [, fn] )
                fn = selector;
                selector = undefined;
              }
              if (fn === false) {
                fn = returnFalse;
              }
              return this.each(function () {
                jQuery.event.remove(this, types, fn, selector);
              });
            },

            bind: function (types, data, fn) {
              return this.on(types, null, data, fn);
            },
            unbind: function (types, fn) {
              return this.off(types, null, fn);
            },

            live: function (types, data, fn) {
              jQuery(this.context).on(types, this.selector, data, fn);
              return this;
            },
            die: function (types, fn) {
              jQuery(this.context).off(types, this.selector || "**", fn);
              return this;
            },

            delegate: function (selector, types, data, fn) {
              return this.on(types, selector, data, fn);
            },
            undelegate: function (selector, types, fn) {
              // ( namespace ) or ( selector, types [, fn] )
              return arguments.length == 1 ? this.off(selector, "**") : this.off(types, selector, fn);
            },

            trigger: function (type, data) {
              return this.each(function () {
                jQuery.event.trigger(type, data, this);
              });
            },
            triggerHandler: function (type, data) {
              if (this[0]) {
                return jQuery.event.trigger(type, data, this[0], true);
              }
            },

            toggle: function (fn) {
              // Save reference to arguments for access in closure
              var args = arguments,
                guid = fn.guid || jQuery.guid++,
                i = 0,
                toggler = function (event) {
                  // Figure out which function to execute
                  var lastToggle = (jQuery._data(this, "lastToggle" + fn.guid) || 0) % i;
                  jQuery._data(this, "lastToggle" + fn.guid, lastToggle + 1);

                  // Make sure that clicks stop
                  event.preventDefault();

                  // and execute the function
                  return args[lastToggle].apply(this, arguments) || false;
                };

              // link all the functions, so any of them can unbind this click handler
              toggler.guid = guid;
              while (i < args.length) {
                args[i++].guid = guid;
              }

              return this.click(toggler);
            },

            hover: function (fnOver, fnOut) {
              return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
            }
          });

          jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " +
            "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
            "change select submit keydown keypress keyup error contextmenu").split(" "), function (i, name) {

            // Handle event binding
            jQuery.fn[name] = function (data, fn) {
              if (fn == null) {
                fn = data;
                data = null;
              }

              return arguments.length > 0 ?
                this.on(name, null, data, fn) :
                this.trigger(name);
            };

            if (jQuery.attrFn) {
              jQuery.attrFn[name] = true;
            }

            if (rkeyEvent.test(name)) {
              jQuery.event.fixHooks[name] = jQuery.event.keyHooks;
            }

            if (rmouseEvent.test(name)) {
              jQuery.event.fixHooks[name] = jQuery.event.mouseHooks;
            }
          });


          /*!
     * Sizzle CSS Selector Engine
     *  Copyright 2011, The Dojo Foundation
     *  Released under the MIT, BSD, and GPL Licenses.
     *  More information: http://sizzlejs.com/
     */
          (function () {

            var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
              expando = "sizcache" + (Math.random() + '').replace('.', ''),
              done = 0,
              toString = Object.prototype.toString,
              hasDuplicate = false,
              baseHasDuplicate = true,
              rBackslash = /\\/g,
              rReturn = /\r\n/g,
              rNonWord = /\W/;

// Here we check if the JavaScript engine is using some sort of
// optimization where it does not always call our comparision
// function. If that is the case, discard the hasDuplicate value.
//   Thus far that includes Google Chrome.
            [0, 0].sort(function () {
              baseHasDuplicate = false;
              return 0;
            });

            var Sizzle = function (selector, context, results, seed) {
              results = results || [];
              context = context || document;

              var origContext = context;

              if (context.nodeType !== 1 && context.nodeType !== 9) {
                return [];
              }

              if (!selector || typeof selector !== "string") {
                return results;
              }

              var m, set, checkSet, extra, ret, cur, pop, i,
                prune = true,
                contextXML = Sizzle.isXML(context),
                parts = [],
                soFar = selector;

              // Reset the position of the chunker regexp (start from head)
              do {
                chunker.exec("");
                m = chunker.exec(soFar);

                if (m) {
                  soFar = m[3];

                  parts.push(m[1]);

                  if (m[2]) {
                    extra = m[3];
                    break;
                  }
                }
              } while (m);

              if (parts.length > 1 && origPOS.exec(selector)) {

                if (parts.length === 2 && Expr.relative[parts[0]]) {
                  set = posProcess(parts[0] + parts[1], context, seed);

                } else {
                  set = Expr.relative[parts[0]] ?
                    [context] :
                    Sizzle(parts.shift(), context);

                  while (parts.length) {
                    selector = parts.shift();

                    if (Expr.relative[selector]) {
                      selector += parts.shift();
                    }

                    set = posProcess(selector, set, seed);
                  }
                }

              } else {
                // Take a shortcut and set the context if the root selector is an ID
                // (but not if it'll be faster if the inner selector is an ID)
                if (!seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
                  Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1])) {

                  ret = Sizzle.find(parts.shift(), context, contextXML);
                  context = ret.expr ?
                    Sizzle.filter(ret.expr, ret.set)[0] :
                    ret.set[0];
                }

                if (context) {
                  ret = seed ?
                    {expr: parts.pop(), set: makeArray(seed)} :
                    Sizzle.find(parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML);

                  set = ret.expr ?
                    Sizzle.filter(ret.expr, ret.set) :
                    ret.set;

                  if (parts.length > 0) {
                    checkSet = makeArray(set);

                  } else {
                    prune = false;
                  }

                  while (parts.length) {
                    cur = parts.pop();
                    pop = cur;

                    if (!Expr.relative[cur]) {
                      cur = "";
                    } else {
                      pop = parts.pop();
                    }

                    if (pop == null) {
                      pop = context;
                    }

                    Expr.relative[cur](checkSet, pop, contextXML);
                  }

                } else {
                  checkSet = parts = [];
                }
              }

              if (!checkSet) {
                checkSet = set;
              }

              if (!checkSet) {
                Sizzle.error(cur || selector);
              }

              if (toString.call(checkSet) === "[object Array]") {
                if (!prune) {
                  results.push.apply(results, checkSet);

                } else if (context && context.nodeType === 1) {
                  for (i = 0; checkSet[i] != null; i++) {
                    if (checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i]))) {
                      results.push(set[i]);
                    }
                  }

                } else {
                  for (i = 0; checkSet[i] != null; i++) {
                    if (checkSet[i] && checkSet[i].nodeType === 1) {
                      results.push(set[i]);
                    }
                  }
                }

              } else {
                makeArray(checkSet, results);
              }

              if (extra) {
                Sizzle(extra, origContext, results, seed);
                Sizzle.uniqueSort(results);
              }

              return results;
            };

            Sizzle.uniqueSort = function (results) {
              if (sortOrder) {
                hasDuplicate = baseHasDuplicate;
                results.sort(sortOrder);

                if (hasDuplicate) {
                  for (var i = 1; i < results.length; i++) {
                    if (results[i] === results[i - 1]) {
                      results.splice(i--, 1);
                    }
                  }
                }
              }

              return results;
            };

            Sizzle.matches = function (expr, set) {
              return Sizzle(expr, null, null, set);
            };

            Sizzle.matchesSelector = function (node, expr) {
              return Sizzle(expr, null, null, [node]).length > 0;
            };

            Sizzle.find = function (expr, context, isXML) {
              var set, i, len, match, type, left;

              if (!expr) {
                return [];
              }

              for (i = 0, len = Expr.order.length; i < len; i++) {
                type = Expr.order[i];

                if ((match = Expr.leftMatch[type].exec(expr))) {
                  left = match[1];
                  match.splice(1, 1);

                  if (left.substr(left.length - 1) !== "\\") {
                    match[1] = (match[1] || "").replace(rBackslash, "");
                    set = Expr.find[type](match, context, isXML);

                    if (set != null) {
                      expr = expr.replace(Expr.match[type], "");
                      break;
                    }
                  }
                }
              }

              if (!set) {
                set = typeof context.getElementsByTagName !== "undefined" ?
                  context.getElementsByTagName("*") :
                  [];
              }

              return {set: set, expr: expr};
            };

            Sizzle.filter = function (expr, set, inplace, not) {
              var match, anyFound,
                type, found, item, filter, left,
                i, pass,
                old = expr,
                result = [],
                curLoop = set,
                isXMLFilter = set && set[0] && Sizzle.isXML(set[0]);

              while (expr && set.length) {
                for (type in Expr.filter) {
                  if ((match = Expr.leftMatch[type].exec(expr)) != null && match[2]) {
                    filter = Expr.filter[type];
                    left = match[1];

                    anyFound = false;

                    match.splice(1, 1);

                    if (left.substr(left.length - 1) === "\\") {
                      continue;
                    }

                    if (curLoop === result) {
                      result = [];
                    }

                    if (Expr.preFilter[type]) {
                      match = Expr.preFilter[type](match, curLoop, inplace, result, not, isXMLFilter);

                      if (!match) {
                        anyFound = found = true;

                      } else if (match === true) {
                        continue;
                      }
                    }

                    if (match) {
                      for (i = 0; (item = curLoop[i]) != null; i++) {
                        if (item) {
                          found = filter(item, match, i, curLoop);
                          pass = not ^ found;

                          if (inplace && found != null) {
                            if (pass) {
                              anyFound = true;

                            } else {
                              curLoop[i] = false;
                            }

                          } else if (pass) {
                            result.push(item);
                            anyFound = true;
                          }
                        }
                      }
                    }

                    if (found !== undefined) {
                      if (!inplace) {
                        curLoop = result;
                      }

                      expr = expr.replace(Expr.match[type], "");

                      if (!anyFound) {
                        return [];
                      }

                      break;
                    }
                  }
                }

                // Improper expression
                if (expr === old) {
                  if (anyFound == null) {
                    Sizzle.error(expr);

                  } else {
                    break;
                  }
                }

                old = expr;
              }

              return curLoop;
            };

            Sizzle.error = function (msg) {
              throw new Error("Syntax error, unrecognized expression: " + msg);
            };

            /**
             * Utility function for retreiving the text value of an array of DOM nodes
             * @param {Array|Element} elem
             */
            var getText = Sizzle.getText = function (elem) {
              var i, node,
                nodeType = elem.nodeType,
                ret = "";

              if (nodeType) {
                if (nodeType === 1 || nodeType === 9) {
                  // Use textContent || innerText for elements
                  if (typeof elem.textContent === 'string') {
                    return elem.textContent;
                  } else if (typeof elem.innerText === 'string') {
                    // Replace IE's carriage returns
                    return elem.innerText.replace(rReturn, '');
                  } else {
                    // Traverse it's children
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                      ret += getText(elem);
                    }
                  }
                } else if (nodeType === 3 || nodeType === 4) {
                  return elem.nodeValue;
                }
              } else {

                // If no nodeType, this is expected to be an array
                for (i = 0; (node = elem[i]); i++) {
                  // Do not traverse comment nodes
                  if (node.nodeType !== 8) {
                    ret += getText(node);
                  }
                }
              }
              return ret;
            };

            var Expr = Sizzle.selectors = {
              order: ["ID", "NAME", "TAG"],

              match: {
                ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
                CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
                NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
                ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
                TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
                CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
                POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
                PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
              },

              leftMatch: {},

              attrMap: {
                "class": "className",
                "for": "htmlFor"
              },

              attrHandle: {
                href: function (elem) {
                  return elem.getAttribute("href");
                },
                type: function (elem) {
                  return elem.getAttribute("type");
                }
              },

              relative: {
                "+": function (checkSet, part) {
                  var isPartStr = typeof part === "string",
                    isTag = isPartStr && !rNonWord.test(part),
                    isPartStrNotTag = isPartStr && !isTag;

                  if (isTag) {
                    part = part.toLowerCase();
                  }

                  for (var i = 0, l = checkSet.length, elem; i < l; i++) {
                    if ((elem = checkSet[i])) {
                      while ((elem = elem.previousSibling) && elem.nodeType !== 1) {
                      }

                      checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
                        elem || false :
                        elem === part;
                    }
                  }

                  if (isPartStrNotTag) {
                    Sizzle.filter(part, checkSet, true);
                  }
                },

                ">": function (checkSet, part) {
                  var elem,
                    isPartStr = typeof part === "string",
                    i = 0,
                    l = checkSet.length;

                  if (isPartStr && !rNonWord.test(part)) {
                    part = part.toLowerCase();

                    for (; i < l; i++) {
                      elem = checkSet[i];

                      if (elem) {
                        var parent = elem.parentNode;
                        checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
                      }
                    }

                  } else {
                    for (; i < l; i++) {
                      elem = checkSet[i];

                      if (elem) {
                        checkSet[i] = isPartStr ?
                          elem.parentNode :
                          elem.parentNode === part;
                      }
                    }

                    if (isPartStr) {
                      Sizzle.filter(part, checkSet, true);
                    }
                  }
                },

                "": function (checkSet, part, isXML) {
                  var nodeCheck,
                    doneName = done++,
                    checkFn = dirCheck;

                  if (typeof part === "string" && !rNonWord.test(part)) {
                    part = part.toLowerCase();
                    nodeCheck = part;
                    checkFn = dirNodeCheck;
                  }

                  checkFn("parentNode", part, doneName, checkSet, nodeCheck, isXML);
                },

                "~": function (checkSet, part, isXML) {
                  var nodeCheck,
                    doneName = done++,
                    checkFn = dirCheck;

                  if (typeof part === "string" && !rNonWord.test(part)) {
                    part = part.toLowerCase();
                    nodeCheck = part;
                    checkFn = dirNodeCheck;
                  }

                  checkFn("previousSibling", part, doneName, checkSet, nodeCheck, isXML);
                }
              },

              find: {
                ID: function (match, context, isXML) {
                  if (typeof context.getElementById !== "undefined" && !isXML) {
                    var m = context.getElementById(match[1]);
                    // Check parentNode to catch when Blackberry 4.6 returns
                    // nodes that are no longer in the document #6963
                    return m && m.parentNode ? [m] : [];
                  }
                },

                NAME: function (match, context) {
                  if (typeof context.getElementsByName !== "undefined") {
                    var ret = [],
                      results = context.getElementsByName(match[1]);

                    for (var i = 0, l = results.length; i < l; i++) {
                      if (results[i].getAttribute("name") === match[1]) {
                        ret.push(results[i]);
                      }
                    }

                    return ret.length === 0 ? null : ret;
                  }
                },

                TAG: function (match, context) {
                  if (typeof context.getElementsByTagName !== "undefined") {
                    return context.getElementsByTagName(match[1]);
                  }
                }
              },
              preFilter: {
                CLASS: function (match, curLoop, inplace, result, not, isXML) {
                  match = " " + match[1].replace(rBackslash, "") + " ";

                  if (isXML) {
                    return match;
                  }

                  for (var i = 0, elem; (elem = curLoop[i]) != null; i++) {
                    if (elem) {
                      if (not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n\r]/g, " ").indexOf(match) >= 0)) {
                        if (!inplace) {
                          result.push(elem);
                        }

                      } else if (inplace) {
                        curLoop[i] = false;
                      }
                    }
                  }

                  return false;
                },

                ID: function (match) {
                  return match[1].replace(rBackslash, "");
                },

                TAG: function (match, curLoop) {
                  return match[1].replace(rBackslash, "").toLowerCase();
                },

                CHILD: function (match) {
                  if (match[1] === "nth") {
                    if (!match[2]) {
                      Sizzle.error(match[0]);
                    }

                    match[2] = match[2].replace(/^\+|\s*/g, '');

                    // parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
                    var test = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(
                      match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
                      !/\D/.test(match[2]) && "0n+" + match[2] || match[2]);

                    // calculate the numbers (first)n+(last) including if they are negative
                    match[2] = (test[1] + (test[2] || 1)) - 0;
                    match[3] = test[3] - 0;
                  }
                  else if (match[2]) {
                    Sizzle.error(match[0]);
                  }

                  // TODO: Move to normal caching system
                  match[0] = done++;

                  return match;
                },

                ATTR: function (match, curLoop, inplace, result, not, isXML) {
                  var name = match[1] = match[1].replace(rBackslash, "");

                  if (!isXML && Expr.attrMap[name]) {
                    match[1] = Expr.attrMap[name];
                  }

                  // Handle if an un-quoted value was used
                  match[4] = (match[4] || match[5] || "").replace(rBackslash, "");

                  if (match[2] === "~=") {
                    match[4] = " " + match[4] + " ";
                  }

                  return match;
                },

                PSEUDO: function (match, curLoop, inplace, result, not) {
                  if (match[1] === "not") {
                    // If we're dealing with a complex expression, or a simple one
                    if ((chunker.exec(match[3]) || "").length > 1 || /^\w/.test(match[3])) {
                      match[3] = Sizzle(match[3], null, null, curLoop);

                    } else {
                      var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);

                      if (!inplace) {
                        result.push.apply(result, ret);
                      }

                      return false;
                    }

                  } else if (Expr.match.POS.test(match[0]) || Expr.match.CHILD.test(match[0])) {
                    return true;
                  }

                  return match;
                },

                POS: function (match) {
                  match.unshift(true);

                  return match;
                }
              },

              filters: {
                enabled: function (elem) {
                  return elem.disabled === false && elem.type !== "hidden";
                },

                disabled: function (elem) {
                  return elem.disabled === true;
                },

                checked: function (elem) {
                  return elem.checked === true;
                },

                selected: function (elem) {
                  // Accessing this property makes selected-by-default
                  // options in Safari work properly
                  if (elem.parentNode) {
                    elem.parentNode.selectedIndex;
                  }

                  return elem.selected === true;
                },

                parent: function (elem) {
                  return !!elem.firstChild;
                },

                empty: function (elem) {
                  return !elem.firstChild;
                },

                has: function (elem, i, match) {
                  return !!Sizzle(match[3], elem).length;
                },

                header: function (elem) {
                  return (/h\d/i).test(elem.nodeName);
                },

                text: function (elem) {
                  var attr = elem.getAttribute("type"), type = elem.type;
                  // IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
                  // use getAttribute instead to test this case
                  return elem.nodeName.toLowerCase() === "input" && "text" === type && (attr === type || attr === null);
                },

                radio: function (elem) {
                  return elem.nodeName.toLowerCase() === "input" && "radio" === elem.type;
                },

                checkbox: function (elem) {
                  return elem.nodeName.toLowerCase() === "input" && "checkbox" === elem.type;
                },

                file: function (elem) {
                  return elem.nodeName.toLowerCase() === "input" && "file" === elem.type;
                },

                password: function (elem) {
                  return elem.nodeName.toLowerCase() === "input" && "password" === elem.type;
                },

                submit: function (elem) {
                  var name = elem.nodeName.toLowerCase();
                  return (name === "input" || name === "button") && "submit" === elem.type;
                },

                image: function (elem) {
                  return elem.nodeName.toLowerCase() === "input" && "image" === elem.type;
                },

                reset: function (elem) {
                  var name = elem.nodeName.toLowerCase();
                  return (name === "input" || name === "button") && "reset" === elem.type;
                },

                button: function (elem) {
                  var name = elem.nodeName.toLowerCase();
                  return name === "input" && "button" === elem.type || name === "button";
                },

                input: function (elem) {
                  return (/input|select|textarea|button/i).test(elem.nodeName);
                },

                focus: function (elem) {
                  return elem === elem.ownerDocument.activeElement;
                }
              },
              setFilters: {
                first: function (elem, i) {
                  return i === 0;
                },

                last: function (elem, i, match, array) {
                  return i === array.length - 1;
                },

                even: function (elem, i) {
                  return i % 2 === 0;
                },

                odd: function (elem, i) {
                  return i % 2 === 1;
                },

                lt: function (elem, i, match) {
                  return i < match[3] - 0;
                },

                gt: function (elem, i, match) {
                  return i > match[3] - 0;
                },

                nth: function (elem, i, match) {
                  return match[3] - 0 === i;
                },

                eq: function (elem, i, match) {
                  return match[3] - 0 === i;
                }
              },
              filter: {
                PSEUDO: function (elem, match, i, array) {
                  var name = match[1],
                    filter = Expr.filters[name];

                  if (filter) {
                    return filter(elem, i, match, array);

                  } else if (name === "contains") {
                    return (elem.textContent || elem.innerText || getText([elem]) || "").indexOf(match[3]) >= 0;

                  } else if (name === "not") {
                    var not = match[3];

                    for (var j = 0, l = not.length; j < l; j++) {
                      if (not[j] === elem) {
                        return false;
                      }
                    }

                    return true;

                  } else {
                    Sizzle.error(name);
                  }
                },

                CHILD: function (elem, match) {
                  var first, last,
                    doneName, parent, cache,
                    count, diff,
                    type = match[1],
                    node = elem;

                  switch (type) {
                    case "only":
                    case "first":
                      while ((node = node.previousSibling)) {
                        if (node.nodeType === 1) {
                          return false;
                        }
                      }

                      if (type === "first") {
                        return true;
                      }

                      node = elem;

                    case "last":
                      while ((node = node.nextSibling)) {
                        if (node.nodeType === 1) {
                          return false;
                        }
                      }

                      return true;

                    case "nth":
                      first = match[2];
                      last = match[3];

                      if (first === 1 && last === 0) {
                        return true;
                      }

                      doneName = match[0];
                      parent = elem.parentNode;

                      if (parent && (parent[expando] !== doneName || !elem.nodeIndex)) {
                        count = 0;

                        for (node = parent.firstChild; node; node = node.nextSibling) {
                          if (node.nodeType === 1) {
                            node.nodeIndex = ++count;
                          }
                        }

                        parent[expando] = doneName;
                      }

                      diff = elem.nodeIndex - last;

                      if (first === 0) {
                        return diff === 0;

                      } else {
                        return (diff % first === 0 && diff / first >= 0);
                      }
                  }
                },

                ID: function (elem, match) {
                  return elem.nodeType === 1 && elem.getAttribute("id") === match;
                },

                TAG: function (elem, match) {
                  return (match === "*" && elem.nodeType === 1) || !!elem.nodeName && elem.nodeName.toLowerCase() === match;
                },

                CLASS: function (elem, match) {
                  return (" " + (elem.className || elem.getAttribute("class")) + " ")
                    .indexOf(match) > -1;
                },

                ATTR: function (elem, match) {
                  var name = match[1],
                    result = Sizzle.attr ?
                      Sizzle.attr(elem, name) :
                      Expr.attrHandle[name] ?
                        Expr.attrHandle[name](elem) :
                        elem[name] != null ?
                          elem[name] :
                          elem.getAttribute(name),
                    value = result + "",
                    type = match[2],
                    check = match[4];

                  return result == null ?
                    type === "!=" :
                    !type && Sizzle.attr ?
                      result != null :
                      type === "=" ?
                        value === check :
                        type === "*=" ?
                          value.indexOf(check) >= 0 :
                          type === "~=" ?
                            (" " + value + " ").indexOf(check) >= 0 :
                            !check ?
                              value && result !== false :
                              type === "!=" ?
                                value !== check :
                                type === "^=" ?
                                  value.indexOf(check) === 0 :
                                  type === "$=" ?
                                    value.substr(value.length - check.length) === check :
                                    type === "|=" ?
                                      value === check || value.substr(0, check.length + 1) === check + "-" :
                                      false;
                },

                POS: function (elem, match, i, array) {
                  var name = match[2],
                    filter = Expr.setFilters[name];

                  if (filter) {
                    return filter(elem, i, match, array);
                  }
                }
              }
            };

            var origPOS = Expr.match.POS,
              fescape = function (all, num) {
                return "\\" + (num - 0 + 1);
              };

            for (var type in Expr.match) {
              Expr.match[type] = new RegExp(Expr.match[type].source + (/(?![^\[]*\])(?![^\(]*\))/.source));
              Expr.leftMatch[type] = new RegExp(/(^(?:.|\r|\n)*?)/.source + Expr.match[type].source.replace(/\\(\d+)/g, fescape));
            }

            var makeArray = function (array, results) {
              array = Array.prototype.slice.call(array, 0);

              if (results) {
                results.push.apply(results, array);
                return results;
              }

              return array;
            };

// Perform a simple check to determine if the browser is capable of
// converting a NodeList to an array using builtin methods.
// Also verifies that the returned array holds DOM nodes
// (which is not the case in the Blackberry browser)
            try {
              Array.prototype.slice.call(document.documentElement.childNodes, 0)[0].nodeType;

// Provide a fallback method if it does not work
            } catch (e) {
              makeArray = function (array, results) {
                var i = 0,
                  ret = results || [];

                if (toString.call(array) === "[object Array]") {
                  Array.prototype.push.apply(ret, array);

                } else {
                  if (typeof array.length === "number") {
                    for (var l = array.length; i < l; i++) {
                      ret.push(array[i]);
                    }

                  } else {
                    for (; array[i]; i++) {
                      ret.push(array[i]);
                    }
                  }
                }

                return ret;
              };
            }

            var sortOrder, siblingCheck;

            if (document.documentElement.compareDocumentPosition) {
              sortOrder = function (a, b) {
                if (a === b) {
                  hasDuplicate = true;
                  return 0;
                }

                if (!a.compareDocumentPosition || !b.compareDocumentPosition) {
                  return a.compareDocumentPosition ? -1 : 1;
                }

                return a.compareDocumentPosition(b) & 4 ? -1 : 1;
              };

            } else {
              sortOrder = function (a, b) {
                // The nodes are identical, we can exit early
                if (a === b) {
                  hasDuplicate = true;
                  return 0;

                  // Fallback to using sourceIndex (in IE) if it's available on both nodes
                } else if (a.sourceIndex && b.sourceIndex) {
                  return a.sourceIndex - b.sourceIndex;
                }

                var al, bl,
                  ap = [],
                  bp = [],
                  aup = a.parentNode,
                  bup = b.parentNode,
                  cur = aup;

                // If the nodes are siblings (or identical) we can do a quick check
                if (aup === bup) {
                  return siblingCheck(a, b);

                  // If no parents were found then the nodes are disconnected
                } else if (!aup) {
                  return -1;

                } else if (!bup) {
                  return 1;
                }

                // Otherwise they're somewhere else in the tree so we need
                // to build up a full list of the parentNodes for comparison
                while (cur) {
                  ap.unshift(cur);
                  cur = cur.parentNode;
                }

                cur = bup;

                while (cur) {
                  bp.unshift(cur);
                  cur = cur.parentNode;
                }

                al = ap.length;
                bl = bp.length;

                // Start walking down the tree looking for a discrepancy
                for (var i = 0; i < al && i < bl; i++) {
                  if (ap[i] !== bp[i]) {
                    return siblingCheck(ap[i], bp[i]);
                  }
                }

                // We ended someplace up the tree so do a sibling check
                return i === al ?
                  siblingCheck(a, bp[i], -1) :
                  siblingCheck(ap[i], b, 1);
              };

              siblingCheck = function (a, b, ret) {
                if (a === b) {
                  return ret;
                }

                var cur = a.nextSibling;

                while (cur) {
                  if (cur === b) {
                    return -1;
                  }

                  cur = cur.nextSibling;
                }

                return 1;
              };
            }

// Check to see if the browser returns elements by name when
// querying by getElementById (and provide a workaround)
            (function () {
              // We're going to inject a fake input element with a specified name
              var form = document.createElement("div"),
                id = "script" + (new Date()).getTime(),
                root = document.documentElement;

              form.innerHTML = "<a name='" + id + "'/>";

              // Inject it into the root element, check its status, and remove it quickly
              root.insertBefore(form, root.firstChild);

              // The workaround has to do additional checks after a getElementById
              // Which slows things down for other browsers (hence the branching)
              if (document.getElementById(id)) {
                Expr.find.ID = function (match, context, isXML) {
                  if (typeof context.getElementById !== "undefined" && !isXML) {
                    var m = context.getElementById(match[1]);

                    return m ?
                      m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ?
                        [m] :
                        undefined :
                      [];
                  }
                };

                Expr.filter.ID = function (elem, match) {
                  var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");

                  return elem.nodeType === 1 && node && node.nodeValue === match;
                };
              }

              root.removeChild(form);

              // release memory in IE
              root = form = null;
            })();

            (function () {
              // Check to see if the browser returns only elements
              // when doing getElementsByTagName("*")

              // Create a fake element
              var div = document.createElement("div");
              div.appendChild(document.createComment(""));

              // Make sure no comments are found
              if (div.getElementsByTagName("*").length > 0) {
                Expr.find.TAG = function (match, context) {
                  var results = context.getElementsByTagName(match[1]);

                  // Filter out possible comments
                  if (match[1] === "*") {
                    var tmp = [];

                    for (var i = 0; results[i]; i++) {
                      if (results[i].nodeType === 1) {
                        tmp.push(results[i]);
                      }
                    }

                    results = tmp;
                  }

                  return results;
                };
              }

              // Check to see if an attribute returns normalized href attributes
              div.innerHTML = "<a href='#'></a>";

              if (div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
                div.firstChild.getAttribute("href") !== "#") {

                Expr.attrHandle.href = function (elem) {
                  return elem.getAttribute("href", 2);
                };
              }

              // release memory in IE
              div = null;
            })();

            if (document.querySelectorAll) {
              (function () {
                var oldSizzle = Sizzle,
                  div = document.createElement("div"),
                  id = "__sizzle__";

                div.innerHTML = "<p class='TEST'></p>";

                // Safari can't handle uppercase or unicode characters when
                // in quirks mode.
                if (div.querySelectorAll && div.querySelectorAll(".TEST").length === 0) {
                  return;
                }

                Sizzle = function (query, context, extra, seed) {
                  context = context || document;

                  // Only use querySelectorAll on non-XML documents
                  // (ID selectors don't work in non-HTML documents)
                  if (!seed && !Sizzle.isXML(context)) {
                    // See if we find a selector to speed up
                    var match = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec(query);

                    if (match && (context.nodeType === 1 || context.nodeType === 9)) {
                      // Speed-up: Sizzle("TAG")
                      if (match[1]) {
                        return makeArray(context.getElementsByTagName(query), extra);

                        // Speed-up: Sizzle(".CLASS")
                      } else if (match[2] && Expr.find.CLASS && context.getElementsByClassName) {
                        return makeArray(context.getElementsByClassName(match[2]), extra);
                      }
                    }

                    if (context.nodeType === 9) {
                      // Speed-up: Sizzle("body")
                      // The body element only exists once, optimize finding it
                      if (query === "body" && context.body) {
                        return makeArray([context.body], extra);

                        // Speed-up: Sizzle("#ID")
                      } else if (match && match[3]) {
                        var elem = context.getElementById(match[3]);

                        // Check parentNode to catch when Blackberry 4.6 returns
                        // nodes that are no longer in the document #6963
                        if (elem && elem.parentNode) {
                          // Handle the case where IE and Opera return items
                          // by name instead of ID
                          if (elem.id === match[3]) {
                            return makeArray([elem], extra);
                          }

                        } else {
                          return makeArray([], extra);
                        }
                      }

                      try {
                        return makeArray(context.querySelectorAll(query), extra);
                      } catch (qsaError) {
                      }

                      // qSA works strangely on Element-rooted queries
                      // We can work around this by specifying an extra ID on the root
                      // and working up from there (Thanks to Andrew Dupont for the technique)
                      // IE 8 doesn't work on object elements
                    } else if (context.nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
                      var oldContext = context,
                        old = context.getAttribute("id"),
                        nid = old || id,
                        hasParent = context.parentNode,
                        relativeHierarchySelector = /^\s*[+~]/.test(query);

                      if (!old) {
                        context.setAttribute("id", nid);
                      } else {
                        nid = nid.replace(/'/g, "\\$&");
                      }
                      if (relativeHierarchySelector && hasParent) {
                        context = context.parentNode;
                      }

                      try {
                        if (!relativeHierarchySelector || hasParent) {
                          return makeArray(context.querySelectorAll("[id='" + nid + "'] " + query), extra);
                        }

                      } catch (pseudoError) {
                      } finally {
                        if (!old) {
                          oldContext.removeAttribute("id");
                        }
                      }
                    }
                  }

                  return oldSizzle(query, context, extra, seed);
                };

                for (var prop in oldSizzle) {
                  Sizzle[prop] = oldSizzle[prop];
                }

                // release memory in IE
                div = null;
              })();
            }

            (function () {
              var html = document.documentElement,
                matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;

              if (matches) {
                // Check to see if it's possible to do matchesSelector
                // on a disconnected node (IE 9 fails this)
                var disconnectedMatch = !matches.call(document.createElement("div"), "div"),
                  pseudoWorks = false;

                try {
                  // This should fail with an exception
                  // Gecko does not error, returns false instead
                  matches.call(document.documentElement, "[test!='']:sizzle");

                } catch (pseudoError) {
                  pseudoWorks = true;
                }

                Sizzle.matchesSelector = function (node, expr) {
                  // Make sure that attribute selectors are quoted
                  expr = expr.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");

                  if (!Sizzle.isXML(node)) {
                    try {
                      if (pseudoWorks || !Expr.match.PSEUDO.test(expr) && !/!=/.test(expr)) {
                        var ret = matches.call(node, expr);

                        // IE 9's matchesSelector returns false on disconnected nodes
                        if (ret || !disconnectedMatch ||
                          // As well, disconnected nodes are said to be in a document
                          // fragment in IE 9, so check for that
                          node.document && node.document.nodeType !== 11) {
                          return ret;
                        }
                      }
                    } catch (e) {
                    }
                  }

                  return Sizzle(expr, null, null, [node]).length > 0;
                };
              }
            })();

            (function () {
              var div = document.createElement("div");

              div.innerHTML = "<div class='test e'></div><div class='test'></div>";

              // Opera can't find a second classname (in 9.6)
              // Also, make sure that getElementsByClassName actually exists
              if (!div.getElementsByClassName || div.getElementsByClassName("e").length === 0) {
                return;
              }

              // Safari caches class attributes, doesn't catch changes (in 3.2)
              div.lastChild.className = "e";

              if (div.getElementsByClassName("e").length === 1) {
                return;
              }

              Expr.order.splice(1, 0, "CLASS");
              Expr.find.CLASS = function (match, context, isXML) {
                if (typeof context.getElementsByClassName !== "undefined" && !isXML) {
                  return context.getElementsByClassName(match[1]);
                }
              };

              // release memory in IE
              div = null;
            })();

            function dirNodeCheck(dir, cur, doneName, checkSet, nodeCheck, isXML) {
              for (var i = 0, l = checkSet.length; i < l; i++) {
                var elem = checkSet[i];

                if (elem) {
                  var match = false;

                  elem = elem[dir];

                  while (elem) {
                    if (elem[expando] === doneName) {
                      match = checkSet[elem.sizset];
                      break;
                    }

                    if (elem.nodeType === 1 && !isXML) {
                      elem[expando] = doneName;
                      elem.sizset = i;
                    }

                    if (elem.nodeName.toLowerCase() === cur) {
                      match = elem;
                      break;
                    }

                    elem = elem[dir];
                  }

                  checkSet[i] = match;
                }
              }
            }

            function dirCheck(dir, cur, doneName, checkSet, nodeCheck, isXML) {
              for (var i = 0, l = checkSet.length; i < l; i++) {
                var elem = checkSet[i];

                if (elem) {
                  var match = false;

                  elem = elem[dir];

                  while (elem) {
                    if (elem[expando] === doneName) {
                      match = checkSet[elem.sizset];
                      break;
                    }

                    if (elem.nodeType === 1) {
                      if (!isXML) {
                        elem[expando] = doneName;
                        elem.sizset = i;
                      }

                      if (typeof cur !== "string") {
                        if (elem === cur) {
                          match = true;
                          break;
                        }

                      } else if (Sizzle.filter(cur, [elem]).length > 0) {
                        match = elem;
                        break;
                      }
                    }

                    elem = elem[dir];
                  }

                  checkSet[i] = match;
                }
              }
            }

            if (document.documentElement.contains) {
              Sizzle.contains = function (a, b) {
                return a !== b && (a.contains ? a.contains(b) : true);
              };

            } else if (document.documentElement.compareDocumentPosition) {
              Sizzle.contains = function (a, b) {
                return !!(a.compareDocumentPosition(b) & 16);
              };

            } else {
              Sizzle.contains = function () {
                return false;
              };
            }

            Sizzle.isXML = function (elem) {
              // documentElement is verified for cases where it doesn't yet exist
              // (such as loading iframes in IE - #4833)
              var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;

              return documentElement ? documentElement.nodeName !== "HTML" : false;
            };

            var posProcess = function (selector, context, seed) {
              var match,
                tmpSet = [],
                later = "",
                root = context.nodeType ? [context] : context;

              // Position selectors must be done after the filter
              // And so must :not(positional) so we move all PSEUDOs to the end
              while ((match = Expr.match.PSEUDO.exec(selector))) {
                later += match[0];
                selector = selector.replace(Expr.match.PSEUDO, "");
              }

              selector = Expr.relative[selector] ? selector + "*" : selector;

              for (var i = 0, l = root.length; i < l; i++) {
                Sizzle(selector, root[i], tmpSet, seed);
              }

              return Sizzle.filter(later, tmpSet);
            };

// EXPOSE
// Override sizzle attribute retrieval
            Sizzle.attr = jQuery.attr;
            Sizzle.selectors.attrMap = {};
            jQuery.find = Sizzle;
            jQuery.expr = Sizzle.selectors;
            jQuery.expr[":"] = jQuery.expr.filters;
            jQuery.unique = Sizzle.uniqueSort;
            jQuery.text = Sizzle.getText;
            jQuery.isXMLDoc = Sizzle.isXML;
            jQuery.contains = Sizzle.contains;


          })();


          var runtil = /Until$/,
            rparentsprev = /^(?:parents|prevUntil|prevAll)/,
            // Note: This RegExp should be improved, or likely pulled from Sizzle
            rmultiselector = /,/,
            isSimple = /^.[^:#\[\.,]*$/,
            slice = Array.prototype.slice,
            POS = jQuery.expr.match.POS,
            // methods guaranteed to produce a unique set when starting from a unique set
            guaranteedUnique = {
              children: true,
              contents: true,
              next: true,
              prev: true
            };

          jQuery.fn.extend({
            find: function (selector) {
              var self = this,
                i, l;

              if (typeof selector !== "string") {
                return jQuery(selector).filter(function () {
                  for (i = 0, l = self.length; i < l; i++) {
                    if (jQuery.contains(self[i], this)) {
                      return true;
                    }
                  }
                });
              }

              var ret = this.pushStack("", "find", selector),
                length, n, r;

              for (i = 0, l = this.length; i < l; i++) {
                length = ret.length;
                jQuery.find(selector, this[i], ret);

                if (i > 0) {
                  // Make sure that the results are unique
                  for (n = length; n < ret.length; n++) {
                    for (r = 0; r < length; r++) {
                      if (ret[r] === ret[n]) {
                        ret.splice(n--, 1);
                        break;
                      }
                    }
                  }
                }
              }

              return ret;
            },

            has: function (target) {
              var targets = jQuery(target);
              return this.filter(function () {
                for (var i = 0, l = targets.length; i < l; i++) {
                  if (jQuery.contains(this, targets[i])) {
                    return true;
                  }
                }
              });
            },

            not: function (selector) {
              return this.pushStack(winnow(this, selector, false), "not", selector);
            },

            filter: function (selector) {
              return this.pushStack(winnow(this, selector, true), "filter", selector);
            },

            is: function (selector) {
              return !!selector && (
                typeof selector === "string" ?
                  // If this is a positional selector, check membership in the returned set
                  // so $("p:first").is("p:last") won't return true for a doc with two "p".
                  POS.test(selector) ?
                    jQuery(selector, this.context).index(this[0]) >= 0 :
                    jQuery.filter(selector, this).length > 0 :
                  this.filter(selector).length > 0);
            },

            closest: function (selectors, context) {
              var ret = [], i, l, cur = this[0];

              // Array (deprecated as of jQuery 1.7)
              if (jQuery.isArray(selectors)) {
                var level = 1;

                while (cur && cur.ownerDocument && cur !== context) {
                  for (i = 0; i < selectors.length; i++) {

                    if (jQuery(cur).is(selectors[i])) {
                      ret.push({selector: selectors[i], elem: cur, level: level});
                    }
                  }

                  cur = cur.parentNode;
                  level++;
                }

                return ret;
              }

              // String
              var pos = POS.test(selectors) || typeof selectors !== "string" ?
                jQuery(selectors, context || this.context) :
                0;

              for (i = 0, l = this.length; i < l; i++) {
                cur = this[i];

                while (cur) {
                  if (pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors)) {
                    ret.push(cur);
                    break;

                  } else {
                    cur = cur.parentNode;
                    if (!cur || !cur.ownerDocument || cur === context || cur.nodeType === 11) {
                      break;
                    }
                  }
                }
              }

              ret = ret.length > 1 ? jQuery.unique(ret) : ret;

              return this.pushStack(ret, "closest", selectors);
            },

            // Determine the position of an element within
            // the matched set of elements
            index: function (elem) {

              // No argument, return index in parent
              if (!elem) {
                return (this[0] && this[0].parentNode) ? this.prevAll().length : -1;
              }

              // index in selector
              if (typeof elem === "string") {
                return jQuery.inArray(this[0], jQuery(elem));
              }

              // Locate the position of the desired element
              return jQuery.inArray(
                // If it receives a jQuery object, the first element is used
                elem.jquery ? elem[0] : elem, this);
            },

            add: function (selector, context) {
              var set = typeof selector === "string" ?
                jQuery(selector, context) :
                jQuery.makeArray(selector && selector.nodeType ? [selector] : selector),
                all = jQuery.merge(this.get(), set);

              return this.pushStack(isDisconnected(set[0]) || isDisconnected(all[0]) ?
                all :
                jQuery.unique(all));
            },

            andSelf: function () {
              return this.add(this.prevObject);
            }
          });

// A painfully simple check to see if an element is disconnected
// from a document (should be improved, where feasible).
          function isDisconnected(node) {
            return !node || !node.parentNode || node.parentNode.nodeType === 11;
          }

          jQuery.each({
            parent: function (elem) {
              var parent = elem.parentNode;
              return parent && parent.nodeType !== 11 ? parent : null;
            },
            parents: function (elem) {
              return jQuery.dir(elem, "parentNode");
            },
            parentsUntil: function (elem, i, until) {
              return jQuery.dir(elem, "parentNode", until);
            },
            next: function (elem) {
              return jQuery.nth(elem, 2, "nextSibling");
            },
            prev: function (elem) {
              return jQuery.nth(elem, 2, "previousSibling");
            },
            nextAll: function (elem) {
              return jQuery.dir(elem, "nextSibling");
            },
            prevAll: function (elem) {
              return jQuery.dir(elem, "previousSibling");
            },
            nextUntil: function (elem, i, until) {
              return jQuery.dir(elem, "nextSibling", until);
            },
            prevUntil: function (elem, i, until) {
              return jQuery.dir(elem, "previousSibling", until);
            },
            siblings: function (elem) {
              return jQuery.sibling(elem.parentNode.firstChild, elem);
            },
            children: function (elem) {
              return jQuery.sibling(elem.firstChild);
            },
            contents: function (elem) {
              return jQuery.nodeName(elem, "iframe") ?
                elem.contentDocument || elem.contentWindow.document :
                jQuery.makeArray(elem.childNodes);
            }
          }, function (name, fn) {
            jQuery.fn[name] = function (until, selector) {
              var ret = jQuery.map(this, fn, until);

              if (!runtil.test(name)) {
                selector = until;
              }

              if (selector && typeof selector === "string") {
                ret = jQuery.filter(selector, ret);
              }

              ret = this.length > 1 && !guaranteedUnique[name] ? jQuery.unique(ret) : ret;

              if ((this.length > 1 || rmultiselector.test(selector)) && rparentsprev.test(name)) {
                ret = ret.reverse();
              }

              return this.pushStack(ret, name, slice.call(arguments).join(","));
            };
          });

          jQuery.extend({
            filter: function (expr, elems, not) {
              if (not) {
                expr = ":not(" + expr + ")";
              }

              return elems.length === 1 ?
                jQuery.find.matchesSelector(elems[0], expr) ? [elems[0]] : [] :
                jQuery.find.matches(expr, elems);
            },

            dir: function (elem, dir, until) {
              var matched = [],
                cur = elem[dir];

              while (cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery(cur).is(until))) {
                if (cur.nodeType === 1) {
                  matched.push(cur);
                }
                cur = cur[dir];
              }
              return matched;
            },

            nth: function (cur, result, dir, elem) {
              result = result || 1;
              var num = 0;

              for (; cur; cur = cur[dir]) {
                if (cur.nodeType === 1 && ++num === result) {
                  break;
                }
              }

              return cur;
            },

            sibling: function (n, elem) {
              var r = [];

              for (; n; n = n.nextSibling) {
                if (n.nodeType === 1 && n !== elem) {
                  r.push(n);
                }
              }

              return r;
            }
          });

// Implement the identical functionality for filter and not
          function winnow(elements, qualifier, keep) {

            // Can't pass null or undefined to indexOf in Firefox 4
            // Set to 0 to skip string check
            qualifier = qualifier || 0;

            if (jQuery.isFunction(qualifier)) {
              return jQuery.grep(elements, function (elem, i) {
                var retVal = !!qualifier.call(elem, i, elem);
                return retVal === keep;
              });

            } else if (qualifier.nodeType) {
              return jQuery.grep(elements, function (elem, i) {
                return (elem === qualifier) === keep;
              });

            } else if (typeof qualifier === "string") {
              var filtered = jQuery.grep(elements, function (elem) {
                return elem.nodeType === 1;
              });

              if (isSimple.test(qualifier)) {
                return jQuery.filter(qualifier, filtered, !keep);
              } else {
                qualifier = jQuery.filter(qualifier, filtered);
              }
            }

            return jQuery.grep(elements, function (elem, i) {
              return (jQuery.inArray(elem, qualifier) >= 0) === keep;
            });
          }


          function createSafeFragment(document) {
            var list = nodeNames.split("|"),
              safeFrag = document.createDocumentFragment();

            if (safeFrag.createElement) {
              while (list.length) {
                safeFrag.createElement(
                  list.pop()
                );
              }
            }
            return safeFrag;
          }

          var nodeNames = "abbr|article|aside|audio|canvas|datalist|details|figcaption|figure|footer|" +
            "header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
            rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
            rleadingWhitespace = /^\s+/,
            rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
            rtagName = /<([\w:]+)/,
            rtbody = /<tbody/i,
            rhtml = /<|&#?\w+;/,
            rnoInnerhtml = /<(?:script|style)/i,
            rnocache = /<(?:script|object|embed|option|style)/i,
            rnoshimcache = new RegExp("<(?:" + nodeNames + ")", "i"),
            // checked="checked" or checked
            rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
            rscriptType = /\/(java|ecma)script/i,
            rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)/,
            wrapMap = {
              option: [1, "<select multiple='multiple'>", "</select>"],
              legend: [1, "<fieldset>", "</fieldset>"],
              thead: [1, "<table>", "</table>"],
              tr: [2, "<table><tbody>", "</tbody></table>"],
              td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
              col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
              area: [1, "<map>", "</map>"],
              _default: [0, "", ""]
            },
            safeFragment = createSafeFragment(document);

          wrapMap.optgroup = wrapMap.option;
          wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
          wrapMap.th = wrapMap.td;

// IE can't serialize <link> and <script> tags normally
          if (!jQuery.support.htmlSerialize) {
            wrapMap._default = [1, "div<div>", "</div>"];
          }

          jQuery.fn.extend({
            text: function (text) {
              if (jQuery.isFunction(text)) {
                return this.each(function (i) {
                  var self = jQuery(this);

                  self.text(text.call(this, i, self.text()));
                });
              }

              if (typeof text !== "object" && text !== undefined) {
                return this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(text));
              }

              return jQuery.text(this);
            },

            wrapAll: function (html) {
              if (jQuery.isFunction(html)) {
                return this.each(function (i) {
                  jQuery(this).wrapAll(html.call(this, i));
                });
              }

              if (this[0]) {
                // The elements to wrap the target around
                var wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

                if (this[0].parentNode) {
                  wrap.insertBefore(this[0]);
                }

                wrap.map(function () {
                  var elem = this;

                  while (elem.firstChild && elem.firstChild.nodeType === 1) {
                    elem = elem.firstChild;
                  }

                  return elem;
                }).append(this);
              }

              return this;
            },

            wrapInner: function (html) {
              if (jQuery.isFunction(html)) {
                return this.each(function (i) {
                  jQuery(this).wrapInner(html.call(this, i));
                });
              }

              return this.each(function () {
                var self = jQuery(this),
                  contents = self.contents();

                if (contents.length) {
                  contents.wrapAll(html);

                } else {
                  self.append(html);
                }
              });
            },

            wrap: function (html) {
              var isFunction = jQuery.isFunction(html);

              return this.each(function (i) {
                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
              });
            },

            unwrap: function () {
              return this.parent().each(function () {
                if (!jQuery.nodeName(this, "body")) {
                  jQuery(this).replaceWith(this.childNodes);
                }
              }).end();
            },

            append: function () {
              return this.domManip(arguments, true, function (elem) {
                if (this.nodeType === 1) {
                  this.appendChild(elem);
                }
              });
            },

            prepend: function () {
              return this.domManip(arguments, true, function (elem) {
                if (this.nodeType === 1) {
                  this.insertBefore(elem, this.firstChild);
                }
              });
            },

            before: function () {
              if (this[0] && this[0].parentNode) {
                return this.domManip(arguments, false, function (elem) {
                  this.parentNode.insertBefore(elem, this);
                });
              } else if (arguments.length) {
                var set = jQuery.clean(arguments);
                set.push.apply(set, this.toArray());
                return this.pushStack(set, "before", arguments);
              }
            },

            after: function () {
              if (this[0] && this[0].parentNode) {
                return this.domManip(arguments, false, function (elem) {
                  this.parentNode.insertBefore(elem, this.nextSibling);
                });
              } else if (arguments.length) {
                var set = this.pushStack(this, "after", arguments);
                set.push.apply(set, jQuery.clean(arguments));
                return set;
              }
            },

            // keepData is for internal use only--do not document
            remove: function (selector, keepData) {
              for (var i = 0, elem; (elem = this[i]) != null; i++) {
                if (!selector || jQuery.filter(selector, [elem]).length) {
                  if (!keepData && elem.nodeType === 1) {
                    jQuery.cleanData(elem.getElementsByTagName("*"));
                    jQuery.cleanData([elem]);
                  }

                  if (elem.parentNode) {
                    elem.parentNode.removeChild(elem);
                  }
                }
              }

              return this;
            },

            empty: function () {
              for (var i = 0, elem; (elem = this[i]) != null; i++) {
                // Remove element nodes and prevent memory leaks
                if (elem.nodeType === 1) {
                  jQuery.cleanData(elem.getElementsByTagName("*"));
                }

                // Remove any remaining nodes
                while (elem.firstChild) {
                  elem.removeChild(elem.firstChild);
                }
              }

              return this;
            },

            clone: function (dataAndEvents, deepDataAndEvents) {
              dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
              deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

              return this.map(function () {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
              });
            },

            html: function (value) {
              if (value === undefined) {
                return this[0] && this[0].nodeType === 1 ?
                  this[0].innerHTML.replace(rinlinejQuery, "") :
                  null;

                // See if we can take a shortcut and just use innerHTML
              } else if (typeof value === "string" && !rnoInnerhtml.test(value) &&
                (jQuery.support.leadingWhitespace || !rleadingWhitespace.test(value)) &&
                !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {

                value = value.replace(rxhtmlTag, "<$1></$2>");

                try {
                  for (var i = 0, l = this.length; i < l; i++) {
                    // Remove element nodes and prevent memory leaks
                    if (this[i].nodeType === 1) {
                      jQuery.cleanData(this[i].getElementsByTagName("*"));
                      this[i].innerHTML = value;
                    }
                  }

                  // If using innerHTML throws an exception, use the fallback method
                } catch (e) {
                  this.empty().append(value);
                }

              } else if (jQuery.isFunction(value)) {
                this.each(function (i) {
                  var self = jQuery(this);

                  self.html(value.call(this, i, self.html()));
                });

              } else {
                this.empty().append(value);
              }

              return this;
            },

            replaceWith: function (value) {
              if (this[0] && this[0].parentNode) {
                // Make sure that the elements are removed from the DOM before they are inserted
                // this can help fix replacing a parent with child elements
                if (jQuery.isFunction(value)) {
                  return this.each(function (i) {
                    var self = jQuery(this), old = self.html();
                    self.replaceWith(value.call(this, i, old));
                  });
                }

                if (typeof value !== "string") {
                  value = jQuery(value).detach();
                }

                return this.each(function () {
                  var next = this.nextSibling,
                    parent = this.parentNode;

                  jQuery(this).remove();

                  if (next) {
                    jQuery(next).before(value);
                  } else {
                    jQuery(parent).append(value);
                  }
                });
              } else {
                return this.length ?
                  this.pushStack(jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value) :
                  this;
              }
            },

            detach: function (selector) {
              return this.remove(selector, true);
            },

            domManip: function (args, table, callback) {
              var results, first, fragment, parent,
                value = args[0],
                scripts = [];

              // We can't cloneNode fragments that contain checked, in WebKit
              if (!jQuery.support.checkClone && arguments.length === 3 && typeof value === "string" && rchecked.test(value)) {
                return this.each(function () {
                  jQuery(this).domManip(args, table, callback, true);
                });
              }

              if (jQuery.isFunction(value)) {
                return this.each(function (i) {
                  var self = jQuery(this);
                  args[0] = value.call(this, i, table ? self.html() : undefined);
                  self.domManip(args, table, callback);
                });
              }

              if (this[0]) {
                parent = value && value.parentNode;

                // If we're in a fragment, just use that instead of building a new one
                if (jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length) {
                  results = {fragment: parent};

                } else {
                  results = jQuery.buildFragment(args, this, scripts);
                }

                fragment = results.fragment;

                if (fragment.childNodes.length === 1) {
                  first = fragment = fragment.firstChild;
                } else {
                  first = fragment.firstChild;
                }

                if (first) {
                  table = table && jQuery.nodeName(first, "tr");

                  for (var i = 0, l = this.length, lastIndex = l - 1; i < l; i++) {
                    callback.call(
                      table ?
                        root(this[i], first) :
                        this[i],
                      // Make sure that we do not leak memory by inadvertently discarding
                      // the original fragment (which might have attached data) instead of
                      // using it; in addition, use the original fragment object for the last
                      // item instead of first because it can end up being emptied incorrectly
                      // in certain situations (Bug #8070).
                      // Fragments from the fragment cache must always be cloned and never used
                      // in place.
                      results.cacheable || (l > 1 && i < lastIndex) ?
                        jQuery.clone(fragment, true, true) :
                        fragment
                    );
                  }
                }

                if (scripts.length) {
                  jQuery.each(scripts, evalScript);
                }
              }

              return this;
            }
          });

          function root(elem, cur) {
            return jQuery.nodeName(elem, "table") ?
              (elem.getElementsByTagName("tbody")[0] ||
                elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
              elem;
          }

          function cloneCopyEvent(src, dest) {

            if (dest.nodeType !== 1 || !jQuery.hasData(src)) {
              return;
            }

            var type, i, l,
              oldData = jQuery._data(src),
              curData = jQuery._data(dest, oldData),
              events = oldData.events;

            if (events) {
              delete curData.handle;
              curData.events = {};

              for (type in events) {
                for (i = 0, l = events[type].length; i < l; i++) {
                  jQuery.event.add(dest, type + (events[type][i].namespace ? "." : "") + events[type][i].namespace, events[type][i], events[type][i].data);
                }
              }
            }

            // make the cloned public data object a copy from the original
            if (curData.data) {
              curData.data = jQuery.extend({}, curData.data);
            }
          }

          function cloneFixAttributes(src, dest) {
            var nodeName;

            // We do not need to do anything for non-Elements
            if (dest.nodeType !== 1) {
              return;
            }

            // clearAttributes removes the attributes, which we don't want,
            // but also removes the attachEvent events, which we *do* want
            if (dest.clearAttributes) {
              dest.clearAttributes();
            }

            // mergeAttributes, in contrast, only merges back on the
            // original attributes, not the events
            if (dest.mergeAttributes) {
              dest.mergeAttributes(src);
            }

            nodeName = dest.nodeName.toLowerCase();

            // IE6-8 fail to clone children inside object elements that use
            // the proprietary classid attribute value (rather than the type
            // attribute) to identify the type of content to display
            if (nodeName === "object") {
              dest.outerHTML = src.outerHTML;

            } else if (nodeName === "input" && (src.type === "checkbox" || src.type === "radio")) {
              // IE6-8 fails to persist the checked state of a cloned checkbox
              // or radio button. Worse, IE6-7 fail to give the cloned element
              // a checked appearance if the defaultChecked value isn't also set
              if (src.checked) {
                dest.defaultChecked = dest.checked = src.checked;
              }

              // IE6-7 get confused and end up setting the value of a cloned
              // checkbox/radio button to an empty string instead of "on"
              if (dest.value !== src.value) {
                dest.value = src.value;
              }

              // IE6-8 fails to return the selected option to the default selected
              // state when cloning options
            } else if (nodeName === "option") {
              dest.selected = src.defaultSelected;

              // IE6-8 fails to set the defaultValue to the correct value when
              // cloning other types of input fields
            } else if (nodeName === "input" || nodeName === "textarea") {
              dest.defaultValue = src.defaultValue;
            }

            // Event data gets referenced instead of copied if the expando
            // gets copied too
            dest.removeAttribute(jQuery.expando);
          }

          jQuery.buildFragment = function (args, nodes, scripts) {
            var fragment, cacheable, cacheresults, doc,
              first = args[0];

            // nodes may contain either an explicit document object,
            // a jQuery collection or context object.
            // If nodes[0] contains a valid object to assign to doc
            if (nodes && nodes[0]) {
              doc = nodes[0].ownerDocument || nodes[0];
            }

            // Ensure that an attr object doesn't incorrectly stand in as a document object
            // Chrome and Firefox seem to allow this to occur and will throw exception
            // Fixes #8950
            if (!doc.createDocumentFragment) {
              doc = document;
            }

            // Only cache "small" (1/2 KB) HTML strings that are associated with the main document
            // Cloning options loses the selected state, so don't cache them
            // IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
            // Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
            // Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501
            if (args.length === 1 && typeof first === "string" && first.length < 512 && doc === document &&
              first.charAt(0) === "<" && !rnocache.test(first) &&
              (jQuery.support.checkClone || !rchecked.test(first)) &&
              (jQuery.support.html5Clone || !rnoshimcache.test(first))) {

              cacheable = true;

              cacheresults = jQuery.fragments[first];
              if (cacheresults && cacheresults !== 1) {
                fragment = cacheresults;
              }
            }

            if (!fragment) {
              fragment = doc.createDocumentFragment();
              jQuery.clean(args, doc, fragment, scripts);
            }

            if (cacheable) {
              jQuery.fragments[first] = cacheresults ? fragment : 1;
            }

            return {fragment: fragment, cacheable: cacheable};
          };

          jQuery.fragments = {};

          jQuery.each({
            appendTo: "append",
            prependTo: "prepend",
            insertBefore: "before",
            insertAfter: "after",
            replaceAll: "replaceWith"
          }, function (name, original) {
            jQuery.fn[name] = function (selector) {
              var ret = [],
                insert = jQuery(selector),
                parent = this.length === 1 && this[0].parentNode;

              if (parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1) {
                insert[original](this[0]);
                return this;

              } else {
                for (var i = 0, l = insert.length; i < l; i++) {
                  var elems = (i > 0 ? this.clone(true) : this).get();
                  jQuery(insert[i])[original](elems);
                  ret = ret.concat(elems);
                }

                return this.pushStack(ret, name, insert.selector);
              }
            };
          });

          function getAll(elem) {
            if (typeof elem.getElementsByTagName !== "undefined") {
              return elem.getElementsByTagName("*");

            } else if (typeof elem.querySelectorAll !== "undefined") {
              return elem.querySelectorAll("*");

            } else {
              return [];
            }
          }

// Used in clean, fixes the defaultChecked property
          function fixDefaultChecked(elem) {
            if (elem.type === "checkbox" || elem.type === "radio") {
              elem.defaultChecked = elem.checked;
            }
          }

// Finds all inputs and passes them to fixDefaultChecked
          function findInputs(elem) {
            var nodeName = (elem.nodeName || "").toLowerCase();
            if (nodeName === "input") {
              fixDefaultChecked(elem);
              // Skip scripts, get other children
            } else if (nodeName !== "script" && typeof elem.getElementsByTagName !== "undefined") {
              jQuery.grep(elem.getElementsByTagName("input"), fixDefaultChecked);
            }
          }

// Derived From: http://www.iecss.com/shimprove/javascript/shimprove.1-0-1.js
          function shimCloneNode(elem) {
            var div = document.createElement("div");
            safeFragment.appendChild(div);

            div.innerHTML = elem.outerHTML;
            return div.firstChild;
          }

          jQuery.extend({
            clone: function (elem, dataAndEvents, deepDataAndEvents) {
              var srcElements,
                destElements,
                i,
                // IE<=8 does not properly clone detached, unknown element nodes
                clone = jQuery.support.html5Clone || !rnoshimcache.test("<" + elem.nodeName) ?
                  elem.cloneNode(true) :
                  shimCloneNode(elem);

              if ((!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
                (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                // IE copies events bound via attachEvent when using cloneNode.
                // Calling detachEvent on the clone will also remove the events
                // from the original. In order to get around this, we use some
                // proprietary methods to clear the events. Thanks to MooTools
                // guys for this hotness.

                cloneFixAttributes(elem, clone);

                // Using Sizzle here is crazy slow, so we use getElementsByTagName instead
                srcElements = getAll(elem);
                destElements = getAll(clone);

                // Weird iteration because IE will replace the length property
                // with an element if you are cloning the body and one of the
                // elements on the page has a name or id of "length"
                for (i = 0; srcElements[i]; ++i) {
                  // Ensure that the destination node is not null; Fixes #9587
                  if (destElements[i]) {
                    cloneFixAttributes(srcElements[i], destElements[i]);
                  }
                }
              }

              // Copy the events from the original to the clone
              if (dataAndEvents) {
                cloneCopyEvent(elem, clone);

                if (deepDataAndEvents) {
                  srcElements = getAll(elem);
                  destElements = getAll(clone);

                  for (i = 0; srcElements[i]; ++i) {
                    cloneCopyEvent(srcElements[i], destElements[i]);
                  }
                }
              }

              srcElements = destElements = null;

              // Return the cloned set
              return clone;
            },

            clean: function (elems, context, fragment, scripts) {
              var checkScriptType;

              context = context || document;

              // !context.createElement fails in IE with an error but returns typeof 'object'
              if (typeof context.createElement === "undefined") {
                context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
              }

              var ret = [], j;

              for (var i = 0, elem; (elem = elems[i]) != null; i++) {
                if (typeof elem === "number") {
                  elem += "";
                }

                if (!elem) {
                  continue;
                }

                // Convert html string into DOM nodes
                if (typeof elem === "string") {
                  if (!rhtml.test(elem)) {
                    elem = context.createTextNode(elem);
                  } else {
                    // Fix "XHTML"-style tags in all browsers
                    elem = elem.replace(rxhtmlTag, "<$1></$2>");

                    // Trim whitespace, otherwise indexOf won't work as expected
                    var tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase(),
                      wrap = wrapMap[tag] || wrapMap._default,
                      depth = wrap[0],
                      div = context.createElement("div");

                    // Append wrapper element to unknown element safe doc fragment
                    if (context === document) {
                      // Use the fragment we've already created for this document
                      safeFragment.appendChild(div);
                    } else {
                      // Use a fragment created with the owner document
                      createSafeFragment(context).appendChild(div);
                    }

                    // Go to html and back, then peel off extra wrappers
                    div.innerHTML = wrap[1] + elem + wrap[2];

                    // Move to the right depth
                    while (depth--) {
                      div = div.lastChild;
                    }

                    // Remove IE's autoinserted <tbody> from table fragments
                    if (!jQuery.support.tbody) {

                      // String was a <table>, *may* have spurious <tbody>
                      var hasBody = rtbody.test(elem),
                        tbody = tag === "table" && !hasBody ?
                          div.firstChild && div.firstChild.childNodes :

                          // String was a bare <thead> or <tfoot>
                          wrap[1] === "<table>" && !hasBody ?
                            div.childNodes :
                            [];

                      for (j = tbody.length - 1; j >= 0; --j) {
                        if (jQuery.nodeName(tbody[j], "tbody") && !tbody[j].childNodes.length) {
                          tbody[j].parentNode.removeChild(tbody[j]);
                        }
                      }
                    }

                    // IE completely kills leading whitespace when innerHTML is used
                    if (!jQuery.support.leadingWhitespace && rleadingWhitespace.test(elem)) {
                      div.insertBefore(context.createTextNode(rleadingWhitespace.exec(elem)[0]), div.firstChild);
                    }

                    elem = div.childNodes;
                  }
                }

                // Resets defaultChecked for any radios and checkboxes
                // about to be appended to the DOM in IE 6/7 (#8060)
                var len;
                if (!jQuery.support.appendChecked) {
                  if (elem[0] && typeof (len = elem.length) === "number") {
                    for (j = 0; j < len; j++) {
                      findInputs(elem[j]);
                    }
                  } else {
                    findInputs(elem);
                  }
                }

                if (elem.nodeType) {
                  ret.push(elem);
                } else {
                  ret = jQuery.merge(ret, elem);
                }
              }

              if (fragment) {
                checkScriptType = function (elem) {
                  return !elem.type || rscriptType.test(elem.type);
                };
                for (i = 0; ret[i]; i++) {
                  if (scripts && jQuery.nodeName(ret[i], "script") && (!ret[i].type || ret[i].type.toLowerCase() === "text/javascript")) {
                    scripts.push(ret[i].parentNode ? ret[i].parentNode.removeChild(ret[i]) : ret[i]);

                  } else {
                    if (ret[i].nodeType === 1) {
                      var jsTags = jQuery.grep(ret[i].getElementsByTagName("script"), checkScriptType);

                      ret.splice.apply(ret, [i + 1, 0].concat(jsTags));
                    }
                    fragment.appendChild(ret[i]);
                  }
                }
              }

              return ret;
            },

            cleanData: function (elems) {
              var data, id,
                cache = jQuery.cache,
                special = jQuery.event.special,
                deleteExpando = jQuery.support.deleteExpando;

              for (var i = 0, elem; (elem = elems[i]) != null; i++) {
                if (elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()]) {
                  continue;
                }

                id = elem[jQuery.expando];

                if (id) {
                  data = cache[id];

                  if (data && data.events) {
                    for (var type in data.events) {
                      if (special[type]) {
                        jQuery.event.remove(elem, type);

                        // This is a shortcut to avoid jQuery.event.remove's overhead
                      } else {
                        jQuery.removeEvent(elem, type, data.handle);
                      }
                    }

                    // Null the DOM reference to avoid IE6/7/8 leak (#7054)
                    if (data.handle) {
                      data.handle.elem = null;
                    }
                  }

                  if (deleteExpando) {
                    delete elem[jQuery.expando];

                  } else if (elem.removeAttribute) {
                    elem.removeAttribute(jQuery.expando);
                  }

                  delete cache[id];
                }
              }
            }
          });

          function evalScript(i, elem) {
            if (elem.src) {
              jQuery.ajax({
                url: elem.src,
                async: false,
                dataType: "script"
              });
            } else {
              jQuery.globalEval((elem.text || elem.textContent || elem.innerHTML || "").replace(rcleanScript, "/*$0*/"));
            }

            if (elem.parentNode) {
              elem.parentNode.removeChild(elem);
            }
          }


          var ralpha = /alpha\([^)]*\)/i,
            ropacity = /opacity=([^)]*)/,
            // fixed for IE9, see #8346
            rupper = /([A-Z]|^ms)/g,
            rnumpx = /^-?\d+(?:px)?$/i,
            rnum = /^-?\d/,
            rrelNum = /^([\-+])=([\-+.\de]+)/,

            cssShow = {position: "absolute", visibility: "hidden", display: "block"},
            cssWidth = ["Left", "Right"],
            cssHeight = ["Top", "Bottom"],
            curCSS,

            getComputedStyle,
            currentStyle;

          jQuery.fn.css = function (name, value) {
            // Setting 'undefined' is a no-op
            if (arguments.length === 2 && value === undefined) {
              return this;
            }

            return jQuery.access(this, name, value, true, function (elem, name, value) {
              return value !== undefined ?
                jQuery.style(elem, name, value) :
                jQuery.css(elem, name);
            });
          };

          jQuery.extend({
            // Add in style property hooks for overriding the default
            // behavior of getting and setting a style property
            cssHooks: {
              opacity: {
                get: function (elem, computed) {
                  if (computed) {
                    // We should always get a number back from opacity
                    var ret = curCSS(elem, "opacity", "opacity");
                    return ret === "" ? "1" : ret;

                  } else {
                    return elem.style.opacity;
                  }
                }
              }
            },

            // Exclude the following css properties to add px
            cssNumber: {
              "fillOpacity": true,
              "fontWeight": true,
              "lineHeight": true,
              "opacity": true,
              "orphans": true,
              "widows": true,
              "zIndex": true,
              "zoom": true
            },

            // Add in properties whose names you wish to fix before
            // setting or getting the value
            cssProps: {
              // normalize float css property
              "float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
            },

            // Get and set the style property on a DOM Node
            style: function (elem, name, value, extra) {
              // Don't set styles on text and comment nodes
              if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
              }

              // Make sure that we're working with the right name
              var ret, type, origName = jQuery.camelCase(name),
                style = elem.style, hooks = jQuery.cssHooks[origName];

              name = jQuery.cssProps[origName] || origName;

              // Check if we're setting a value
              if (value !== undefined) {
                type = typeof value;

                // convert relative number strings (+= or -=) to relative numbers. #7345
                if (type === "string" && (ret = rrelNum.exec(value))) {
                  value = (+(ret[1] + 1) * +ret[2]) + parseFloat(jQuery.css(elem, name));
                  // Fixes bug #9237
                  type = "number";
                }

                // Make sure that NaN and null values aren't set. See: #7116
                if (value == null || type === "number" && isNaN(value)) {
                  return;
                }

                // If a number was passed in, add 'px' to the (except for certain CSS properties)
                if (type === "number" && !jQuery.cssNumber[origName]) {
                  value += "px";
                }

                // If a hook was provided, use that value, otherwise just set the specified value
                if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value)) !== undefined) {
                  // Wrapped to prevent IE from throwing errors when 'invalid' values are provided
                  // Fixes bug #5509
                  try {
                    style[name] = value;
                  } catch (e) {
                  }
                }

              } else {
                // If a hook was provided get the non-computed value from there
                if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                  return ret;
                }

                // Otherwise just get the value from the style object
                return style[name];
              }
            },

            css: function (elem, name, extra) {
              var ret, hooks;

              // Make sure that we're working with the right name
              name = jQuery.camelCase(name);
              hooks = jQuery.cssHooks[name];
              name = jQuery.cssProps[name] || name;

              // cssFloat needs a special treatment
              if (name === "cssFloat") {
                name = "float";
              }

              // If a hook was provided get the computed value from there
              if (hooks && "get" in hooks && (ret = hooks.get(elem, true, extra)) !== undefined) {
                return ret;

                // Otherwise, if a way to get the computed value exists, use that
              } else if (curCSS) {
                return curCSS(elem, name);
              }
            },

            // A method for quickly swapping in/out CSS properties to get correct calculations
            swap: function (elem, options, callback) {
              var old = {};

              // Remember the old values, and insert the new ones
              for (var name in options) {
                old[name] = elem.style[name];
                elem.style[name] = options[name];
              }

              callback.call(elem);

              // Revert the old values
              for (name in options) {
                elem.style[name] = old[name];
              }
            }
          });

// DEPRECATED, Use jQuery.css() instead
          jQuery.curCSS = jQuery.css;

          jQuery.each(["height", "width"], function (i, name) {
            jQuery.cssHooks[name] = {
              get: function (elem, computed, extra) {
                var val;

                if (computed) {
                  if (elem.offsetWidth !== 0) {
                    return getWH(elem, name, extra);
                  } else {
                    jQuery.swap(elem, cssShow, function () {
                      val = getWH(elem, name, extra);
                    });
                  }

                  return val;
                }
              },

              set: function (elem, value) {
                if (rnumpx.test(value)) {
                  // ignore negative width and height values #1599
                  value = parseFloat(value);

                  if (value >= 0) {
                    return value + "px";
                  }

                } else {
                  return value;
                }
              }
            };
          });

          if (!jQuery.support.opacity) {
            jQuery.cssHooks.opacity = {
              get: function (elem, computed) {
                // IE uses filters for opacity
                return ropacity.test((computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "") ?
                  (parseFloat(RegExp.$1) / 100) + "" :
                  computed ? "1" : "";
              },

              set: function (elem, value) {
                var style = elem.style,
                  currentStyle = elem.currentStyle,
                  opacity = jQuery.isNumeric(value) ? "alpha(opacity=" + value * 100 + ")" : "",
                  filter = currentStyle && currentStyle.filter || style.filter || "";

                // IE has trouble with opacity if it does not have layout
                // Force it by setting the zoom level
                style.zoom = 1;

                // if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
                if (value >= 1 && jQuery.trim(filter.replace(ralpha, "")) === "") {

                  // Setting style.filter to null, "" & " " still leave "filter:" in the cssText
                  // if "filter:" is present at all, clearType is disabled, we want to avoid this
                  // style.removeAttribute is IE Only, but so apparently is this code path...
                  style.removeAttribute("filter");

                  // if there there is no filter style applied in a css rule, we are done
                  if (currentStyle && !currentStyle.filter) {
                    return;
                  }
                }

                // otherwise, set new filter values
                style.filter = ralpha.test(filter) ?
                  filter.replace(ralpha, opacity) :
                  filter + " " + opacity;
              }
            };
          }

          jQuery(function () {
            // This hook cannot be added until DOM ready because the support test
            // for it is not run until after DOM ready
            if (!jQuery.support.reliableMarginRight) {
              jQuery.cssHooks.marginRight = {
                get: function (elem, computed) {
                  // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                  // Work around by temporarily setting element display to inline-block
                  var ret;
                  jQuery.swap(elem, {"display": "inline-block"}, function () {
                    if (computed) {
                      ret = curCSS(elem, "margin-right", "marginRight");
                    } else {
                      ret = elem.style.marginRight;
                    }
                  });
                  return ret;
                }
              };
            }
          });

          if (document.defaultView && document.defaultView.getComputedStyle) {
            getComputedStyle = function (elem, name) {
              var ret, defaultView, computedStyle;

              name = name.replace(rupper, "-$1").toLowerCase();

              if ((defaultView = elem.ownerDocument.defaultView) &&
                (computedStyle = defaultView.getComputedStyle(elem, null))) {
                ret = computedStyle.getPropertyValue(name);
                if (ret === "" && !jQuery.contains(elem.ownerDocument.documentElement, elem)) {
                  ret = jQuery.style(elem, name);
                }
              }

              return ret;
            };
          }

          if (document.documentElement.currentStyle) {
            currentStyle = function (elem, name) {
              var left, rsLeft, uncomputed,
                ret = elem.currentStyle && elem.currentStyle[name],
                style = elem.style;

              // Avoid setting ret to empty string here
              // so we don't default to auto
              if (ret === null && style && (uncomputed = style[name])) {
                ret = uncomputed;
              }

              // From the awesome hack by Dean Edwards
              // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

              // If we're not dealing with a regular pixel number
              // but a number that has a weird ending, we need to convert it to pixels
              if (!rnumpx.test(ret) && rnum.test(ret)) {

                // Remember the original values
                left = style.left;
                rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;

                // Put in the new values to get a computed value out
                if (rsLeft) {
                  elem.runtimeStyle.left = elem.currentStyle.left;
                }
                style.left = name === "fontSize" ? "1em" : (ret || 0);
                ret = style.pixelLeft + "px";

                // Revert the changed values
                style.left = left;
                if (rsLeft) {
                  elem.runtimeStyle.left = rsLeft;
                }
              }

              return ret === "" ? "auto" : ret;
            };
          }

          curCSS = getComputedStyle || currentStyle;

          function getWH(elem, name, extra) {

            // Start with offset property
            var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
              which = name === "width" ? cssWidth : cssHeight,
              i = 0,
              len = which.length;

            if (val > 0) {
              if (extra !== "border") {
                for (; i < len; i++) {
                  if (!extra) {
                    val -= parseFloat(jQuery.css(elem, "padding" + which[i])) || 0;
                  }
                  if (extra === "margin") {
                    val += parseFloat(jQuery.css(elem, extra + which[i])) || 0;
                  } else {
                    val -= parseFloat(jQuery.css(elem, "border" + which[i] + "Width")) || 0;
                  }
                }
              }

              return val + "px";
            }

            // Fall back to computed then uncomputed css if necessary
            val = curCSS(elem, name, name);
            if (val < 0 || val == null) {
              val = elem.style[name] || 0;
            }
            // Normalize "", auto, and prepare for extra
            val = parseFloat(val) || 0;

            // Add padding, border, margin
            if (extra) {
              for (; i < len; i++) {
                val += parseFloat(jQuery.css(elem, "padding" + which[i])) || 0;
                if (extra !== "padding") {
                  val += parseFloat(jQuery.css(elem, "border" + which[i] + "Width")) || 0;
                }
                if (extra === "margin") {
                  val += parseFloat(jQuery.css(elem, extra + which[i])) || 0;
                }
              }
            }

            return val + "px";
          }

          if (jQuery.expr && jQuery.expr.filters) {
            jQuery.expr.filters.hidden = function (elem) {
              var width = elem.offsetWidth,
                height = elem.offsetHeight;

              return (width === 0 && height === 0) || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css(elem, "display")) === "none");
            };

            jQuery.expr.filters.visible = function (elem) {
              return !jQuery.expr.filters.hidden(elem);
            };
          }


          var r20 = /%20/g,
            rbracket = /\[\]$/,
            rCRLF = /\r?\n/g,
            rhash = /#.*$/,
            rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
            rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
            // #7653, #8125, #8152: local protocol detection
            rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
            rnoContent = /^(?:GET|HEAD)$/,
            rprotocol = /^\/\//,
            rquery = /\?/,
            rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
            rselectTextarea = /^(?:select|textarea)/i,
            rspacesAjax = /\s+/,
            rts = /([?&])_=[^&]*/,
            rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,

            // Keep a copy of the old load method
            _load = jQuery.fn.load,

            /* Prefilters
     * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
     * 2) These are called:
     *    - BEFORE asking for a transport
     *    - AFTER param serialization (s.data is a string if s.processData is true)
     * 3) key is the dataType
     * 4) the catchall symbol "*" can be used
     * 5) execution will start with transport dataType and THEN continue down to "*" if needed
     */
            prefilters = {},

            /* Transports bindings
     * 1) key is the dataType
     * 2) the catchall symbol "*" can be used
     * 3) selection will start with transport dataType and THEN go to "*" if needed
     */
            transports = {},

            // Document location
            ajaxLocation,

            // Document location segments
            ajaxLocParts,

            // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
            allTypes = ["*/"] + ["*"];

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
          try {
            ajaxLocation = location.href;
          } catch (e) {
            // Use the href attribute of an A element
            // since IE will modify it given document.location
            ajaxLocation = document.createElement("a");
            ajaxLocation.href = "";
            ajaxLocation = ajaxLocation.href;
          }

// Segment location into parts
          ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
          function addToPrefiltersOrTransports(structure) {

            // dataTypeExpression is optional and defaults to "*"
            return function (dataTypeExpression, func) {

              if (typeof dataTypeExpression !== "string") {
                func = dataTypeExpression;
                dataTypeExpression = "*";
              }

              if (jQuery.isFunction(func)) {
                var dataTypes = dataTypeExpression.toLowerCase().split(rspacesAjax),
                  i = 0,
                  length = dataTypes.length,
                  dataType,
                  list,
                  placeBefore;

                // For each dataType in the dataTypeExpression
                for (; i < length; i++) {
                  dataType = dataTypes[i];
                  // We control if we're asked to add before
                  // any existing element
                  placeBefore = /^\+/.test(dataType);
                  if (placeBefore) {
                    dataType = dataType.substr(1) || "*";
                  }
                  list = structure[dataType] = structure[dataType] || [];
                  // then we add to the structure accordingly
                  list[placeBefore ? "unshift" : "push"](func);
                }
              }
            };
          }

// Base inspection function for prefilters and transports
          function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR,
                                                 dataType /* internal */, inspected /* internal */) {

            dataType = dataType || options.dataTypes[0];
            inspected = inspected || {};

            inspected[dataType] = true;

            var list = structure[dataType],
              i = 0,
              length = list ? list.length : 0,
              executeOnly = (structure === prefilters),
              selection;

            for (; i < length && (executeOnly || !selection); i++) {
              selection = list[i](options, originalOptions, jqXHR);
              // If we got redirected to another dataType
              // we try there if executing only and not done already
              if (typeof selection === "string") {
                if (!executeOnly || inspected[selection]) {
                  selection = undefined;
                } else {
                  options.dataTypes.unshift(selection);
                  selection = inspectPrefiltersOrTransports(
                    structure, options, originalOptions, jqXHR, selection, inspected);
                }
              }
            }
            // If we're only executing or nothing was selected
            // we try the catchall dataType if not done already
            if ((executeOnly || !selection) && !inspected["*"]) {
              selection = inspectPrefiltersOrTransports(
                structure, options, originalOptions, jqXHR, "*", inspected);
            }
            // unnecessary when only executing (prefilters)
            // but it'll be ignored by the caller in that case
            return selection;
          }

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
          function ajaxExtend(target, src) {
            var key, deep,
              flatOptions = jQuery.ajaxSettings.flatOptions || {};
            for (key in src) {
              if (src[key] !== undefined) {
                (flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];
              }
            }
            if (deep) {
              jQuery.extend(true, target, deep);
            }
          }

          jQuery.fn.extend({
            load: function (url, params, callback) {
              if (typeof url !== "string" && _load) {
                return _load.apply(this, arguments);

                // Don't do a request if no elements are being requested
              } else if (!this.length) {
                return this;
              }

              var off = url.indexOf(" ");
              if (off >= 0) {
                var selector = url.slice(off, url.length);
                url = url.slice(0, off);
              }

              // Default to a GET request
              var type = "GET";

              // If the second parameter was provided
              if (params) {
                // If it's a function
                if (jQuery.isFunction(params)) {
                  // We assume that it's the callback
                  callback = params;
                  params = undefined;

                  // Otherwise, build a param string
                } else if (typeof params === "object") {
                  params = jQuery.param(params, jQuery.ajaxSettings.traditional);
                  type = "POST";
                }
              }

              var self = this;

              // Request the remote document
              jQuery.ajax({
                url: url,
                type: type,
                dataType: "html",
                data: params,
                // Complete callback (responseText is used internally)
                complete: function (jqXHR, status, responseText) {
                  // Store the response as specified by the jqXHR object
                  responseText = jqXHR.responseText;
                  // If successful, inject the HTML into all the matched elements
                  if (jqXHR.isResolved()) {
                    // #4825: Get the actual response in case
                    // a dataFilter is present in ajaxSettings
                    jqXHR.done(function (r) {
                      responseText = r;
                    });
                    // See if a selector was specified
                    self.html(selector ?
                      // Create a dummy div to hold the results
                      jQuery("<div>")
                      // inject the contents of the document in, removing the scripts
                      // to avoid any 'Permission Denied' errors in IE
                        .append(responseText.replace(rscript, ""))

                        // Locate the specified elements
                        .find(selector) :

                      // If not, just inject the full result
                      responseText);
                  }

                  if (callback) {
                    self.each(callback, [responseText, status, jqXHR]);
                  }
                }
              });

              return this;
            },

            serialize: function () {
              return jQuery.param(this.serializeArray());
            },

            serializeArray: function () {
              return this.map(function () {
                return this.elements ? jQuery.makeArray(this.elements) : this;
              })
                .filter(function () {
                  return this.name && !this.disabled &&
                    (this.checked || rselectTextarea.test(this.nodeName) ||
                      rinput.test(this.type));
                })
                .map(function (i, elem) {
                  var val = jQuery(this).val();

                  return val == null ?
                    null :
                    jQuery.isArray(val) ?
                      jQuery.map(val, function (val, i) {
                        return {name: elem.name, value: val.replace(rCRLF, "\r\n")};
                      }) :
                      {name: elem.name, value: val.replace(rCRLF, "\r\n")};
                }).get();
            }
          });

// Attach a bunch of functions for handling common AJAX events
          jQuery.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "), function (i, o) {
            jQuery.fn[o] = function (f) {
              return this.on(o, f);
            };
          });

          jQuery.each(["get", "post"], function (i, method) {
            jQuery[method] = function (url, data, callback, type) {
              // shift arguments if data argument was omitted
              if (jQuery.isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
              }

              return jQuery.ajax({
                type: method,
                url: url,
                data: data,
                success: callback,
                dataType: type
              });
            };
          });

          jQuery.extend({

            getScript: function (url, callback) {
              return jQuery.get(url, undefined, callback, "script");
            },

            getJSON: function (url, data, callback) {
              return jQuery.get(url, data, callback, "json");
            },

            // Creates a full fledged settings object into target
            // with both ajaxSettings and settings fields.
            // If target is omitted, writes into ajaxSettings.
            ajaxSetup: function (target, settings) {
              if (settings) {
                // Building a settings object
                ajaxExtend(target, jQuery.ajaxSettings);
              } else {
                // Extending ajaxSettings
                settings = target;
                target = jQuery.ajaxSettings;
              }
              ajaxExtend(target, settings);
              return target;
            },

            ajaxSettings: {
              url: ajaxLocation,
              isLocal: rlocalProtocol.test(ajaxLocParts[1]),
              global: true,
              type: "GET",
              contentType: "application/x-www-form-urlencoded",
              processData: true,
              async: true,
              /*
             timeout: 0,
             data: null,
             dataType: null,
             username: null,
             password: null,
             cache: null,
             traditional: false,
             headers: {},
             */

              accepts: {
                xml: "application/xml, text/xml",
                html: "text/html",
                text: "text/plain",
                json: "application/json, text/javascript",
                "*": allTypes
              },

              contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
              },

              responseFields: {
                xml: "responseXML",
                text: "responseText"
              },

              // List of data converters
              // 1) key format is "source_type destination_type" (a single space in-between)
              // 2) the catchall symbol "*" can be used for source_type
              converters: {

                // Convert anything to text
                "* text": window.String,

                // Text to html (true = no transformation)
                "text html": true,

                // Evaluate text as a json expression
                "text json": jQuery.parseJSON,

                // Parse text as xml
                "text xml": jQuery.parseXML
              },

              // For options that shouldn't be deep extended:
              // you can add your own custom options here if
              // and when you create one that shouldn't be
              // deep extended (see ajaxExtend)
              flatOptions: {
                context: true,
                url: true
              }
            },

            ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
            ajaxTransport: addToPrefiltersOrTransports(transports),

            // Main method
            ajax: function (url, options) {

              // If url is an object, simulate pre-1.5 signature
              if (typeof url === "object") {
                options = url;
                url = undefined;
              }

              // Force options to be an object
              options = options || {};

              var // Create the final options object
                s = jQuery.ajaxSetup({}, options),
                // Callbacks context
                callbackContext = s.context || s,
                // Context for global events
                // It's the callbackContext if one was provided in the options
                // and if it's a DOM node or a jQuery collection
                globalEventContext = callbackContext !== s &&
                (callbackContext.nodeType || callbackContext instanceof jQuery) ?
                  jQuery(callbackContext) : jQuery.event,
                // Deferreds
                deferred = jQuery.Deferred(),
                completeDeferred = jQuery.Callbacks("once memory"),
                // Status-dependent callbacks
                statusCode = s.statusCode || {},
                // ifModified key
                ifModifiedKey,
                // Headers (they are sent all at once)
                requestHeaders = {},
                requestHeadersNames = {},
                // Response headers
                responseHeadersString,
                responseHeaders,
                // transport
                transport,
                // timeout handle
                timeoutTimer,
                // Cross-domain detection vars
                parts,
                // The jqXHR state
                state = 0,
                // To know if global events are to be dispatched
                fireGlobals,
                // Loop variable
                i,
                // Fake xhr
                jqXHR = {

                  readyState: 0,

                  // Caches the header
                  setRequestHeader: function (name, value) {
                    if (!state) {
                      var lname = name.toLowerCase();
                      name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                      requestHeaders[name] = value;
                    }
                    return this;
                  },

                  // Raw string
                  getAllResponseHeaders: function () {
                    return state === 2 ? responseHeadersString : null;
                  },

                  // Builds headers hashtable if needed
                  getResponseHeader: function (key) {
                    var match;
                    if (state === 2) {
                      if (!responseHeaders) {
                        responseHeaders = {};
                        while ((match = rheaders.exec(responseHeadersString))) {
                          responseHeaders[match[1].toLowerCase()] = match[2];
                        }
                      }
                      match = responseHeaders[key.toLowerCase()];
                    }
                    return match === undefined ? null : match;
                  },

                  // Overrides response content-type header
                  overrideMimeType: function (type) {
                    if (!state) {
                      s.mimeType = type;
                    }
                    return this;
                  },

                  // Cancel the request
                  abort: function (statusText) {
                    statusText = statusText || "abort";
                    if (transport) {
                      transport.abort(statusText);
                    }
                    done(0, statusText);
                    return this;
                  }
                };

              // Callback for when everything is done
              // It is defined here because jslint complains if it is declared
              // at the end of the function (which would be more logical and readable)
              function done(status, nativeStatusText, responses, headers) {

                // Called once
                if (state === 2) {
                  return;
                }

                // State is "done" now
                state = 2;

                // Clear timeout if it exists
                if (timeoutTimer) {
                  clearTimeout(timeoutTimer);
                }

                // Dereference transport for early garbage collection
                // (no matter how long the jqXHR object will be used)
                transport = undefined;

                // Cache response headers
                responseHeadersString = headers || "";

                // Set readyState
                jqXHR.readyState = status > 0 ? 4 : 0;

                var isSuccess,
                  success,
                  error,
                  statusText = nativeStatusText,
                  response = responses ? ajaxHandleResponses(s, jqXHR, responses) : undefined,
                  lastModified,
                  etag;

                // If successful, handle type chaining
                if (status >= 200 && status < 300 || status === 304) {

                  // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                  if (s.ifModified) {

                    if ((lastModified = jqXHR.getResponseHeader("Last-Modified"))) {
                      jQuery.lastModified[ifModifiedKey] = lastModified;
                    }
                    if ((etag = jqXHR.getResponseHeader("Etag"))) {
                      jQuery.etag[ifModifiedKey] = etag;
                    }
                  }

                  // If not modified
                  if (status === 304) {

                    statusText = "notmodified";
                    isSuccess = true;

                    // If we have data
                  } else {

                    try {
                      success = ajaxConvert(s, response);
                      statusText = "success";
                      isSuccess = true;
                    } catch (e) {
                      // We have a parsererror
                      statusText = "parsererror";
                      error = e;
                    }
                  }
                } else {
                  // We extract error from statusText
                  // then normalize statusText and status for non-aborts
                  error = statusText;
                  if (!statusText || status) {
                    statusText = "error";
                    if (status < 0) {
                      status = 0;
                    }
                  }
                }

                // Set data for the fake xhr object
                jqXHR.status = status;
                jqXHR.statusText = "" + (nativeStatusText || statusText);

                // Success/Error
                if (isSuccess) {
                  deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
                } else {
                  deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
                }

                // Status-dependent callbacks
                jqXHR.statusCode(statusCode);
                statusCode = undefined;

                if (fireGlobals) {
                  globalEventContext.trigger("ajax" + (isSuccess ? "Success" : "Error"),
                    [jqXHR, s, isSuccess ? success : error]);
                }

                // Complete
                completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

                if (fireGlobals) {
                  globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
                  // Handle the global AJAX counter
                  if (!(--jQuery.active)) {
                    jQuery.event.trigger("ajaxStop");
                  }
                }
              }

              // Attach deferreds
              deferred.promise(jqXHR);
              jqXHR.success = jqXHR.done;
              jqXHR.error = jqXHR.fail;
              jqXHR.complete = completeDeferred.add;

              // Status-dependent callbacks
              jqXHR.statusCode = function (map) {
                if (map) {
                  var tmp;
                  if (state < 2) {
                    for (tmp in map) {
                      statusCode[tmp] = [statusCode[tmp], map[tmp]];
                    }
                  } else {
                    tmp = map[jqXHR.status];
                    jqXHR.then(tmp, tmp);
                  }
                }
                return this;
              };

              // Remove hash character (#7531: and string promotion)
              // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
              // We also use the url parameter if available
              s.url = ((url || s.url) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//");

              // Extract dataTypes list
              s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().split(rspacesAjax);

              // Determine if a cross-domain request is in order
              if (s.crossDomain == null) {
                parts = rurl.exec(s.url.toLowerCase());
                s.crossDomain = !!(parts &&
                  (parts[1] != ajaxLocParts[1] || parts[2] != ajaxLocParts[2] ||
                    (parts[3] || (parts[1] === "http:" ? 80 : 443)) !=
                    (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? 80 : 443)))
                );
              }

              // Convert data if not already a string
              if (s.data && s.processData && typeof s.data !== "string") {
                s.data = jQuery.param(s.data, s.traditional);
              }

              // Apply prefilters
              inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

              // If request was aborted inside a prefiler, stop there
              if (state === 2) {
                return false;
              }

              // We can fire global events as of now if asked to
              fireGlobals = s.global;

              // Uppercase the type
              s.type = s.type.toUpperCase();

              // Determine if request has content
              s.hasContent = !rnoContent.test(s.type);

              // Watch for a new set of requests
              if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger("ajaxStart");
              }

              // More options handling for requests with no content
              if (!s.hasContent) {

                // If data is available, append data to url
                if (s.data) {
                  s.url += (rquery.test(s.url) ? "&" : "?") + s.data;
                  // #9682: remove data so that it's not used in an eventual retry
                  delete s.data;
                }

                // Get ifModifiedKey before adding the anti-cache parameter
                ifModifiedKey = s.url;

                // Add anti-cache in url if needed
                if (s.cache === false) {

                  var ts = jQuery.now(),
                    // try replacing _= if it is there
                    ret = s.url.replace(rts, "$1_=" + ts);

                  // if nothing was replaced, add timestamp to the end
                  s.url = ret + ((ret === s.url) ? (rquery.test(s.url) ? "&" : "?") + "_=" + ts : "");
                }
              }

              // Set the correct header, if data is being sent
              if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader("Content-Type", s.contentType);
              }

              // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
              if (s.ifModified) {
                ifModifiedKey = ifModifiedKey || s.url;
                if (jQuery.lastModified[ifModifiedKey]) {
                  jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[ifModifiedKey]);
                }
                if (jQuery.etag[ifModifiedKey]) {
                  jqXHR.setRequestHeader("If-None-Match", jQuery.etag[ifModifiedKey]);
                }
              }

              // Set the Accepts header for the server, depending on the dataType
              jqXHR.setRequestHeader(
                "Accept",
                s.dataTypes[0] && s.accepts[s.dataTypes[0]] ?
                  s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") :
                  s.accepts["*"]
              );

              // Check for headers option
              for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i]);
              }

              // Allow custom headers/mimetypes and early abort
              if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
                // Abort if not done already
                jqXHR.abort();
                return false;

              }

              // Install callbacks on deferreds
              for (i in {success: 1, error: 1, complete: 1}) {
                jqXHR[i](s[i]);
              }

              // Get transport
              transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

              // If no transport, we auto-abort
              if (!transport) {
                done(-1, "No Transport");
              } else {
                jqXHR.readyState = 1;
                // Send global event
                if (fireGlobals) {
                  globalEventContext.trigger("ajaxSend", [jqXHR, s]);
                }
                // Timeout
                if (s.async && s.timeout > 0) {
                  timeoutTimer = setTimeout(function () {
                    jqXHR.abort("timeout");
                  }, s.timeout);
                }

                try {
                  state = 1;
                  transport.send(requestHeaders, done);
                } catch (e) {
                  // Propagate exception as error if not done
                  if (state < 2) {
                    done(-1, e);
                    // Simply rethrow otherwise
                  } else {
                    throw e;
                  }
                }
              }

              return jqXHR;
            },

            // Serialize an array of form elements or a set of
            // key/values into a query string
            param: function (a, traditional) {
              var s = [],
                add = function (key, value) {
                  // If value is a function, invoke it and return its value
                  value = jQuery.isFunction(value) ? value() : value;
                  s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
                };

              // Set traditional to true for jQuery <= 1.3.2 behavior.
              if (traditional === undefined) {
                traditional = jQuery.ajaxSettings.traditional;
              }

              // If an array was passed in, assume that it is an array of form elements.
              if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
                // Serialize the form elements
                jQuery.each(a, function () {
                  add(this.name, this.value);
                });

              } else {
                // If traditional, encode the "old" way (the way 1.3.2 or older
                // did it), otherwise encode params recursively.
                for (var prefix in a) {
                  buildParams(prefix, a[prefix], traditional, add);
                }
              }

              // Return the resulting serialization
              return s.join("&").replace(r20, "+");
            }
          });

          function buildParams(prefix, obj, traditional, add) {
            if (jQuery.isArray(obj)) {
              // Serialize array item.
              jQuery.each(obj, function (i, v) {
                if (traditional || rbracket.test(prefix)) {
                  // Treat each array item as a scalar.
                  add(prefix, v);

                } else {
                  // If array item is non-scalar (array or object), encode its
                  // numeric index to resolve deserialization ambiguity issues.
                  // Note that rack (as of 1.0.0) can't currently deserialize
                  // nested arrays properly, and attempting to do so may cause
                  // a server error. Possible fixes are to modify rack's
                  // deserialization algorithm or to provide an option or flag
                  // to force array serialization to be shallow.
                  buildParams(prefix + "[" + (typeof v === "object" || jQuery.isArray(v) ? i : "") + "]", v, traditional, add);
                }
              });

            } else if (!traditional && obj != null && typeof obj === "object") {
              // Serialize object item.
              for (var name in obj) {
                buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
              }

            } else {
              // Serialize scalar item.
              add(prefix, obj);
            }
          }

// This is still on the jQuery object... for now
// Want to move this to jQuery.ajax some day
          jQuery.extend({

            // Counter for holding the number of active queries
            active: 0,

            // Last-Modified header cache for next request
            lastModified: {},
            etag: {}

          });

          /* Handles responses to an ajax request:
     * - sets all responseXXX fields accordingly
     * - finds the right dataType (mediates between content-type and expected dataType)
     * - returns the corresponding response
     */
          function ajaxHandleResponses(s, jqXHR, responses) {

            var contents = s.contents,
              dataTypes = s.dataTypes,
              responseFields = s.responseFields,
              ct,
              type,
              finalDataType,
              firstDataType;

            // Fill responseXXX fields
            for (type in responseFields) {
              if (type in responses) {
                jqXHR[responseFields[type]] = responses[type];
              }
            }

            // Remove auto dataType and get content-type in the process
            while (dataTypes[0] === "*") {
              dataTypes.shift();
              if (ct === undefined) {
                ct = s.mimeType || jqXHR.getResponseHeader("content-type");
              }
            }

            // Check if we're dealing with a known content-type
            if (ct) {
              for (type in contents) {
                if (contents[type] && contents[type].test(ct)) {
                  dataTypes.unshift(type);
                  break;
                }
              }
            }

            // Check to see if we have a response for the expected dataType
            if (dataTypes[0] in responses) {
              finalDataType = dataTypes[0];
            } else {
              // Try convertible dataTypes
              for (type in responses) {
                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                  finalDataType = type;
                  break;
                }
                if (!firstDataType) {
                  firstDataType = type;
                }
              }
              // Or just use first one
              finalDataType = finalDataType || firstDataType;
            }

            // If we found a dataType
            // We add the dataType to the list if needed
            // and return the corresponding response
            if (finalDataType) {
              if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType);
              }
              return responses[finalDataType];
            }
          }

// Chain conversions given the request and the original response
          function ajaxConvert(s, response) {

            // Apply the dataFilter if provided
            if (s.dataFilter) {
              response = s.dataFilter(response, s.dataType);
            }

            var dataTypes = s.dataTypes,
              converters = {},
              i,
              key,
              length = dataTypes.length,
              tmp,
              // Current and previous dataTypes
              current = dataTypes[0],
              prev,
              // Conversion expression
              conversion,
              // Conversion function
              conv,
              // Conversion functions (transitive conversion)
              conv1,
              conv2;

            // For each dataType in the chain
            for (i = 1; i < length; i++) {

              // Create converters map
              // with lowercased keys
              if (i === 1) {
                for (key in s.converters) {
                  if (typeof key === "string") {
                    converters[key.toLowerCase()] = s.converters[key];
                  }
                }
              }

              // Get the dataTypes
              prev = current;
              current = dataTypes[i];

              // If current is auto dataType, update it to prev
              if (current === "*") {
                current = prev;
                // If no auto and dataTypes are actually different
              } else if (prev !== "*" && prev !== current) {

                // Get the converter
                conversion = prev + " " + current;
                conv = converters[conversion] || converters["* " + current];

                // If there is no direct converter, search transitively
                if (!conv) {
                  conv2 = undefined;
                  for (conv1 in converters) {
                    tmp = conv1.split(" ");
                    if (tmp[0] === prev || tmp[0] === "*") {
                      conv2 = converters[tmp[1] + " " + current];
                      if (conv2) {
                        conv1 = converters[conv1];
                        if (conv1 === true) {
                          conv = conv2;
                        } else if (conv2 === true) {
                          conv = conv1;
                        }
                        break;
                      }
                    }
                  }
                }
                // If we found no converter, dispatch an error
                if (!(conv || conv2)) {
                  jQuery.error("No conversion from " + conversion.replace(" ", " to "));
                }
                // If found converter is not an equivalence
                if (conv !== true) {
                  // Convert with 1 or 2 converters accordingly
                  response = conv ? conv(response) : conv2(conv1(response));
                }
              }
            }
            return response;
          }


          var jsc = jQuery.now(),
            jsre = /(\=)\?(&|$)|\?\?/i;

// Default jsonp settings
          jQuery.ajaxSetup({
            jsonp: "callback",
            jsonpCallback: function () {
              return jQuery.expando + "_" + (jsc++);
            }
          });

// Detect, normalize options and install callbacks for jsonp requests
          jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {

            var inspectData = s.contentType === "application/x-www-form-urlencoded" &&
              (typeof s.data === "string");

            if (s.dataTypes[0] === "jsonp" ||
              s.jsonp !== false && (jsre.test(s.url) ||
                inspectData && jsre.test(s.data))) {

              var responseContainer,
                jsonpCallback = s.jsonpCallback =
                  jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback,
                previous = window[jsonpCallback],
                url = s.url,
                data = s.data,
                replace = "$1" + jsonpCallback + "$2";

              if (s.jsonp !== false) {
                url = url.replace(jsre, replace);
                if (s.url === url) {
                  if (inspectData) {
                    data = data.replace(jsre, replace);
                  }
                  if (s.data === data) {
                    // Add callback manually
                    url += (/\?/.test(url) ? "&" : "?") + s.jsonp + "=" + jsonpCallback;
                  }
                }
              }

              s.url = url;
              s.data = data;

              // Install callback
              window[jsonpCallback] = function (response) {
                responseContainer = [response];
              };

              // Clean-up function
              jqXHR.always(function () {
                // Set callback back to previous value
                window[jsonpCallback] = previous;
                // Call if it was a function and we have a response
                if (responseContainer && jQuery.isFunction(previous)) {
                  window[jsonpCallback](responseContainer[0]);
                }
              });

              // Use data converter to retrieve json after script execution
              s.converters["script json"] = function () {
                if (!responseContainer) {
                  jQuery.error(jsonpCallback + " was not called");
                }
                return responseContainer[0];
              };

              // force json dataType
              s.dataTypes[0] = "json";

              // Delegate to script
              return "script";
            }
          });


// Install script dataType
          jQuery.ajaxSetup({
            accepts: {
              script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
            },
            contents: {
              script: /javascript|ecmascript/
            },
            converters: {
              "text script": function (text) {
                jQuery.globalEval(text);
                return text;
              }
            }
          });

// Handle cache's special case and global
          jQuery.ajaxPrefilter("script", function (s) {
            if (s.cache === undefined) {
              s.cache = false;
            }
            if (s.crossDomain) {
              s.type = "GET";
              s.global = false;
            }
          });

// Bind script tag hack transport
          jQuery.ajaxTransport("script", function (s) {

            // This transport only deals with cross domain requests
            if (s.crossDomain) {

              var script,
                head = document.head || document.getElementsByTagName("head")[0] || document.documentElement;

              return {

                send: function (_, callback) {

                  script = document.createElement("script");

                  script.async = "async";

                  if (s.scriptCharset) {
                    script.charset = s.scriptCharset;
                  }

                  script.src = s.url;

                  // Attach handlers for all browsers
                  script.onload = script.onreadystatechange = function (_, isAbort) {

                    if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {

                      // Handle memory leak in IE
                      script.onload = script.onreadystatechange = null;

                      // Remove the script
                      if (head && script.parentNode) {
                        head.removeChild(script);
                      }

                      // Dereference the script
                      script = undefined;

                      // Callback if not abort
                      if (!isAbort) {
                        callback(200, "success");
                      }
                    }
                  };
                  // Use insertBefore instead of appendChild  to circumvent an IE6 bug.
                  // This arises when a base node is used (#2709 and #4378).
                  head.insertBefore(script, head.firstChild);
                },

                abort: function () {
                  if (script) {
                    script.onload(0, 1);
                  }
                }
              };
            }
          });


          var // #5280: Internet Explorer will keep connections alive if we don't abort on unload
            xhrOnUnloadAbort = window.ActiveXObject ? function () {
              // Abort all pending requests
              for (var key in xhrCallbacks) {
                xhrCallbacks[key](0, 1);
              }
            } : false,
            xhrId = 0,
            xhrCallbacks;

// Functions to create xhrs
          function createStandardXHR() {
            try {
              return new window.XMLHttpRequest();
            } catch (e) {
            }
          }

          function createActiveXHR() {
            try {
              return new window.ActiveXObject("Microsoft.XMLHTTP");
            } catch (e) {
            }
          }

// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
          jQuery.ajaxSettings.xhr = window.ActiveXObject ?
            /* Microsoft failed to properly
         * implement the XMLHttpRequest in IE7 (can't request local files),
         * so we use the ActiveXObject when it is available
         * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
         * we need a fallback.
         */
            function () {
              return !this.isLocal && createStandardXHR() || createActiveXHR();
            } :
            // For all other browsers, use the standard XMLHttpRequest object
            createStandardXHR;

// Determine support properties
          (function (xhr) {
            jQuery.extend(jQuery.support, {
              ajax: !!xhr,
              cors: !!xhr && ("withCredentials" in xhr)
            });
          })(jQuery.ajaxSettings.xhr());

// Create transport if the browser can provide an xhr
          if (jQuery.support.ajax) {

            jQuery.ajaxTransport(function (s) {
              // Cross domain only allowed if supported through XMLHttpRequest
              if (!s.crossDomain || jQuery.support.cors) {

                var callback;

                return {
                  send: function (headers, complete) {

                    // Get a new xhr
                    var xhr = s.xhr(),
                      handle,
                      i;

                    // Open the socket
                    // Passing null username, generates a login popup on Opera (#2865)
                    if (s.username) {
                      xhr.open(s.type, s.url, s.async, s.username, s.password);
                    } else {
                      xhr.open(s.type, s.url, s.async);
                    }

                    // Apply custom fields if provided
                    if (s.xhrFields) {
                      for (i in s.xhrFields) {
                        xhr[i] = s.xhrFields[i];
                      }
                    }

                    // Override mime type if needed
                    if (s.mimeType && xhr.overrideMimeType) {
                      xhr.overrideMimeType(s.mimeType);
                    }

                    // X-Requested-With header
                    // For cross-domain requests, seeing as conditions for a preflight are
                    // akin to a jigsaw puzzle, we simply never set it to be sure.
                    // (it can always be set on a per-request basis or even using ajaxSetup)
                    // For same-domain requests, won't change header if already provided.
                    if (!s.crossDomain && !headers["X-Requested-With"]) {
                      headers["X-Requested-With"] = "XMLHttpRequest";
                    }

                    // Need an extra try/catch for cross domain requests in Firefox 3
                    try {
                      for (i in headers) {
                        xhr.setRequestHeader(i, headers[i]);
                      }
                    } catch (_) {
                    }

                    // Do send the request
                    // This may raise an exception which is actually
                    // handled in jQuery.ajax (so no try/catch here)
                    xhr.send((s.hasContent && s.data) || null);

                    // Listener
                    callback = function (_, isAbort) {

                      var status,
                        statusText,
                        responseHeaders,
                        responses,
                        xml;

                      // Firefox throws exceptions when accessing properties
                      // of an xhr when a network error occured
                      // http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
                      try {

                        // Was never called and is aborted or complete
                        if (callback && (isAbort || xhr.readyState === 4)) {

                          // Only called once
                          callback = undefined;

                          // Do not keep as active anymore
                          if (handle) {
                            xhr.onreadystatechange = jQuery.noop;
                            if (xhrOnUnloadAbort) {
                              delete xhrCallbacks[handle];
                            }
                          }

                          // If it's an abort
                          if (isAbort) {
                            // Abort it manually if needed
                            if (xhr.readyState !== 4) {
                              xhr.abort();
                            }
                          } else {
                            status = xhr.status;
                            responseHeaders = xhr.getAllResponseHeaders();
                            responses = {};
                            xml = xhr.responseXML;

                            // Construct response list
                            if (xml && xml.documentElement /* #4958 */) {
                              responses.xml = xml;
                            }
                            responses.text = xhr.responseText;

                            // Firefox throws an exception when accessing
                            // statusText for faulty cross-domain requests
                            try {
                              statusText = xhr.statusText;
                            } catch (e) {
                              // We normalize with Webkit giving an empty statusText
                              statusText = "";
                            }

                            // Filter status for non standard behaviors

                            // If the request is local and we have data: assume a success
                            // (success with no data won't get notified, that's the best we
                            // can do given current implementations)
                            if (!status && s.isLocal && !s.crossDomain) {
                              status = responses.text ? 200 : 404;
                              // IE - #1450: sometimes returns 1223 when it should be 204
                            } else if (status === 1223) {
                              status = 204;
                            }
                          }
                        }
                      } catch (firefoxAccessException) {
                        if (!isAbort) {
                          complete(-1, firefoxAccessException);
                        }
                      }

                      // Call complete if needed
                      if (responses) {
                        complete(status, statusText, responses, responseHeaders);
                      }
                    };

                    // if we're in sync mode or it's in cache
                    // and has been retrieved directly (IE6 & IE7)
                    // we need to manually fire the callback
                    if (!s.async || xhr.readyState === 4) {
                      callback();
                    } else {
                      handle = ++xhrId;
                      if (xhrOnUnloadAbort) {
                        // Create the active xhrs callbacks list if needed
                        // and attach the unload handler
                        if (!xhrCallbacks) {
                          xhrCallbacks = {};
                          jQuery(window).unload(xhrOnUnloadAbort);
                        }
                        // Add to list of active xhrs callbacks
                        xhrCallbacks[handle] = callback;
                      }
                      xhr.onreadystatechange = callback;
                    }
                  },

                  abort: function () {
                    if (callback) {
                      callback(0, 1);
                    }
                  }
                };
              }
            });
          }


          var elemdisplay = {},
            iframe, iframeDoc,
            rfxtypes = /^(?:toggle|show|hide)$/,
            rfxnum = /^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,
            timerId,
            fxAttrs = [
              // height animations
              ["height", "marginTop", "marginBottom", "paddingTop", "paddingBottom"],
              // width animations
              ["width", "marginLeft", "marginRight", "paddingLeft", "paddingRight"],
              // opacity animations
              ["opacity"]
            ],
            fxNow;

          jQuery.fn.extend({
            show: function (speed, easing, callback) {
              var elem, display;

              if (speed || speed === 0) {
                return this.animate(genFx("show", 3), speed, easing, callback);

              } else {
                for (var i = 0, j = this.length; i < j; i++) {
                  elem = this[i];

                  if (elem.style) {
                    display = elem.style.display;

                    // Reset the inline display of this element to learn if it is
                    // being hidden by cascaded rules or not
                    if (!jQuery._data(elem, "olddisplay") && display === "none") {
                      display = elem.style.display = "";
                    }

                    // Set elements which have been overridden with display: none
                    // in a stylesheet to whatever the default browser style is
                    // for such an element
                    if (display === "" && jQuery.css(elem, "display") === "none") {
                      jQuery._data(elem, "olddisplay", defaultDisplay(elem.nodeName));
                    }
                  }
                }

                // Set the display of most of the elements in a second loop
                // to avoid the constant reflow
                for (i = 0; i < j; i++) {
                  elem = this[i];

                  if (elem.style) {
                    display = elem.style.display;

                    if (display === "" || display === "none") {
                      elem.style.display = jQuery._data(elem, "olddisplay") || "";
                    }
                  }
                }

                return this;
              }
            },

            hide: function (speed, easing, callback) {
              if (speed || speed === 0) {
                return this.animate(genFx("hide", 3), speed, easing, callback);

              } else {
                var elem, display,
                  i = 0,
                  j = this.length;

                for (; i < j; i++) {
                  elem = this[i];
                  if (elem.style) {
                    display = jQuery.css(elem, "display");

                    if (display !== "none" && !jQuery._data(elem, "olddisplay")) {
                      jQuery._data(elem, "olddisplay", display);
                    }
                  }
                }

                // Set the display of the elements in a second loop
                // to avoid the constant reflow
                for (i = 0; i < j; i++) {
                  if (this[i].style) {
                    this[i].style.display = "none";
                  }
                }

                return this;
              }
            },

            // Save the old toggle function
            _toggle: jQuery.fn.toggle,

            toggle: function (fn, fn2, callback) {
              var bool = typeof fn === "boolean";

              if (jQuery.isFunction(fn) && jQuery.isFunction(fn2)) {
                this._toggle.apply(this, arguments);

              } else if (fn == null || bool) {
                this.each(function () {
                  var state = bool ? fn : jQuery(this).is(":hidden");
                  jQuery(this)[state ? "show" : "hide"]();
                });

              } else {
                this.animate(genFx("toggle", 3), fn, fn2, callback);
              }

              return this;
            },

            fadeTo: function (speed, to, easing, callback) {
              return this.filter(":hidden").css("opacity", 0).show().end()
                .animate({opacity: to}, speed, easing, callback);
            },

            animate: function (prop, speed, easing, callback) {
              var optall = jQuery.speed(speed, easing, callback);

              if (jQuery.isEmptyObject(prop)) {
                return this.each(optall.complete, [false]);
              }

              // Do not change referenced properties as per-property easing will be lost
              prop = jQuery.extend({}, prop);

              function doAnimation() {
                // XXX 'this' does not always have a nodeName when running the
                // test suite

                if (optall.queue === false) {
                  jQuery._mark(this);
                }

                var opt = jQuery.extend({}, optall),
                  isElement = this.nodeType === 1,
                  hidden = isElement && jQuery(this).is(":hidden"),
                  name, val, p, e,
                  parts, start, end, unit,
                  method;

                // will store per property easing and be used to determine when an animation is complete
                opt.animatedProperties = {};

                for (p in prop) {

                  // property name normalization
                  name = jQuery.camelCase(p);
                  if (p !== name) {
                    prop[name] = prop[p];
                    delete prop[p];
                  }

                  val = prop[name];

                  // easing resolution: per property > opt.specialEasing > opt.easing > 'swing' (default)
                  if (jQuery.isArray(val)) {
                    opt.animatedProperties[name] = val[1];
                    val = prop[name] = val[0];
                  } else {
                    opt.animatedProperties[name] = opt.specialEasing && opt.specialEasing[name] || opt.easing || 'swing';
                  }

                  if (val === "hide" && hidden || val === "show" && !hidden) {
                    return opt.complete.call(this);
                  }

                  if (isElement && (name === "height" || name === "width")) {
                    // Make sure that nothing sneaks out
                    // Record all 3 overflow attributes because IE does not
                    // change the overflow attribute when overflowX and
                    // overflowY are set to the same value
                    opt.overflow = [this.style.overflow, this.style.overflowX, this.style.overflowY];

                    // Set display property to inline-block for height/width
                    // animations on inline elements that are having width/height animated
                    if (jQuery.css(this, "display") === "inline" &&
                      jQuery.css(this, "float") === "none") {

                      // inline-level elements accept inline-block;
                      // block-level elements need to be inline with layout
                      if (!jQuery.support.inlineBlockNeedsLayout || defaultDisplay(this.nodeName) === "inline") {
                        this.style.display = "inline-block";

                      } else {
                        this.style.zoom = 1;
                      }
                    }
                  }
                }

                if (opt.overflow != null) {
                  this.style.overflow = "hidden";
                }

                for (p in prop) {
                  e = new jQuery.fx(this, opt, p);
                  val = prop[p];

                  if (rfxtypes.test(val)) {

                    // Tracks whether to show or hide based on private
                    // data attached to the element
                    method = jQuery._data(this, "toggle" + p) || (val === "toggle" ? hidden ? "show" : "hide" : 0);
                    if (method) {
                      jQuery._data(this, "toggle" + p, method === "show" ? "hide" : "show");
                      e[method]();
                    } else {
                      e[val]();
                    }

                  } else {
                    parts = rfxnum.exec(val);
                    start = e.cur();

                    if (parts) {
                      end = parseFloat(parts[2]);
                      unit = parts[3] || (jQuery.cssNumber[p] ? "" : "px");

                      // We need to compute starting value
                      if (unit !== "px") {
                        jQuery.style(this, p, (end || 1) + unit);
                        start = ((end || 1) / e.cur()) * start;
                        jQuery.style(this, p, start + unit);
                      }

                      // If a +=/-= token was provided, we're doing a relative animation
                      if (parts[1]) {
                        end = ((parts[1] === "-=" ? -1 : 1) * end) + start;
                      }

                      e.custom(start, end, unit);

                    } else {
                      e.custom(start, val, "");
                    }
                  }
                }

                // For JS strict compliance
                return true;
              }

              return optall.queue === false ?
                this.each(doAnimation) :
                this.queue(optall.queue, doAnimation);
            },

            stop: function (type, clearQueue, gotoEnd) {
              if (typeof type !== "string") {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
              }
              if (clearQueue && type !== false) {
                this.queue(type || "fx", []);
              }

              return this.each(function () {
                var index,
                  hadTimers = false,
                  timers = jQuery.timers,
                  data = jQuery._data(this);

                // clear marker counters if we know they won't be
                if (!gotoEnd) {
                  jQuery._unmark(true, this);
                }

                function stopQueue(elem, data, index) {
                  var hooks = data[index];
                  jQuery.removeData(elem, index, true);
                  hooks.stop(gotoEnd);
                }

                if (type == null) {
                  for (index in data) {
                    if (data[index] && data[index].stop && index.indexOf(".run") === index.length - 4) {
                      stopQueue(this, data, index);
                    }
                  }
                } else if (data[index = type + ".run"] && data[index].stop) {
                  stopQueue(this, data, index);
                }

                for (index = timers.length; index--;) {
                  if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                    if (gotoEnd) {

                      // force the next step to be the last
                      timers[index](true);
                    } else {
                      timers[index].saveState();
                    }
                    hadTimers = true;
                    timers.splice(index, 1);
                  }
                }

                // start the next in the queue if the last step wasn't forced
                // timers currently will call their complete callbacks, which will dequeue
                // but only if they were gotoEnd
                if (!(gotoEnd && hadTimers)) {
                  jQuery.dequeue(this, type);
                }
              });
            }

          });

// Animations created synchronously will run synchronously
          function createFxNow() {
            setTimeout(clearFxNow, 0);
            return (fxNow = jQuery.now());
          }

          function clearFxNow() {
            fxNow = undefined;
          }

// Generate parameters to create a standard animation
          function genFx(type, num) {
            var obj = {};

            jQuery.each(fxAttrs.concat.apply([], fxAttrs.slice(0, num)), function () {
              obj[this] = type;
            });

            return obj;
          }

// Generate shortcuts for custom animations
          jQuery.each({
            slideDown: genFx("show", 1),
            slideUp: genFx("hide", 1),
            slideToggle: genFx("toggle", 1),
            fadeIn: {opacity: "show"},
            fadeOut: {opacity: "hide"},
            fadeToggle: {opacity: "toggle"}
          }, function (name, props) {
            jQuery.fn[name] = function (speed, easing, callback) {
              return this.animate(props, speed, easing, callback);
            };
          });

          jQuery.extend({
            speed: function (speed, easing, fn) {
              var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
                complete: fn || !fn && easing ||
                jQuery.isFunction(speed) && speed,
                duration: speed,
                easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
              };

              opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
                opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;

              // normalize opt.queue - true/undefined/null -> "fx"
              if (opt.queue == null || opt.queue === true) {
                opt.queue = "fx";
              }

              // Queueing
              opt.old = opt.complete;

              opt.complete = function (noUnmark) {
                if (jQuery.isFunction(opt.old)) {
                  opt.old.call(this);
                }

                if (opt.queue) {
                  jQuery.dequeue(this, opt.queue);
                } else if (noUnmark !== false) {
                  jQuery._unmark(this);
                }
              };

              return opt;
            },

            easing: {
              linear: function (p, n, firstNum, diff) {
                return firstNum + diff * p;
              },
              swing: function (p, n, firstNum, diff) {
                return ((-Math.cos(p * Math.PI) / 2) + 0.5) * diff + firstNum;
              }
            },

            timers: [],

            fx: function (elem, options, prop) {
              this.options = options;
              this.elem = elem;
              this.prop = prop;

              options.orig = options.orig || {};
            }

          });

          jQuery.fx.prototype = {
            // Simple function for setting a style value
            update: function () {
              if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
              }

              (jQuery.fx.step[this.prop] || jQuery.fx.step._default)(this);
            },

            // Get the current size
            cur: function () {
              if (this.elem[this.prop] != null && (!this.elem.style || this.elem.style[this.prop] == null)) {
                return this.elem[this.prop];
              }

              var parsed,
                r = jQuery.css(this.elem, this.prop);
              // Empty strings, null, undefined and "auto" are converted to 0,
              // complex values such as "rotate(1rad)" are returned as is,
              // simple values such as "10px" are parsed to Float.
              return isNaN(parsed = parseFloat(r)) ? !r || r === "auto" ? 0 : r : parsed;
            },

            // Start an animation from one number to another
            custom: function (from, to, unit) {
              var self = this,
                fx = jQuery.fx;

              this.startTime = fxNow || createFxNow();
              this.end = to;
              this.now = this.start = from;
              this.pos = this.state = 0;
              this.unit = unit || this.unit || (jQuery.cssNumber[this.prop] ? "" : "px");

              function t(gotoEnd) {
                return self.step(gotoEnd);
              }

              t.queue = this.options.queue;
              t.elem = this.elem;
              t.saveState = function () {
                if (self.options.hide && jQuery._data(self.elem, "fxshow" + self.prop) === undefined) {
                  jQuery._data(self.elem, "fxshow" + self.prop, self.start);
                }
              };

              if (t() && jQuery.timers.push(t) && !timerId) {
                timerId = setInterval(fx.tick, fx.interval);
              }
            },

            // Simple 'show' function
            show: function () {
              var dataShow = jQuery._data(this.elem, "fxshow" + this.prop);

              // Remember where we started, so that we can go back to it later
              this.options.orig[this.prop] = dataShow || jQuery.style(this.elem, this.prop);
              this.options.show = true;

              // Begin the animation
              // Make sure that we start at a small width/height to avoid any flash of content
              if (dataShow !== undefined) {
                // This show is picking up where a previous hide or show left off
                this.custom(this.cur(), dataShow);
              } else {
                this.custom(this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur());
              }

              // Start by showing the element
              jQuery(this.elem).show();
            },

            // Simple 'hide' function
            hide: function () {
              // Remember where we started, so that we can go back to it later
              this.options.orig[this.prop] = jQuery._data(this.elem, "fxshow" + this.prop) || jQuery.style(this.elem, this.prop);
              this.options.hide = true;

              // Begin the animation
              this.custom(this.cur(), 0);
            },

            // Each step of an animation
            step: function (gotoEnd) {
              var p, n, complete,
                t = fxNow || createFxNow(),
                done = true,
                elem = this.elem,
                options = this.options;

              if (gotoEnd || t >= options.duration + this.startTime) {
                this.now = this.end;
                this.pos = this.state = 1;
                this.update();

                options.animatedProperties[this.prop] = true;

                for (p in options.animatedProperties) {
                  if (options.animatedProperties[p] !== true) {
                    done = false;
                  }
                }

                if (done) {
                  // Reset the overflow
                  if (options.overflow != null && !jQuery.support.shrinkWrapBlocks) {

                    jQuery.each(["", "X", "Y"], function (index, value) {
                      elem.style["overflow" + value] = options.overflow[index];
                    });
                  }

                  // Hide the element if the "hide" operation was done
                  if (options.hide) {
                    jQuery(elem).hide();
                  }

                  // Reset the properties, if the item has been hidden or shown
                  if (options.hide || options.show) {
                    for (p in options.animatedProperties) {
                      jQuery.style(elem, p, options.orig[p]);
                      jQuery.removeData(elem, "fxshow" + p, true);
                      // Toggle data is no longer needed
                      jQuery.removeData(elem, "toggle" + p, true);
                    }
                  }

                  // Execute the complete function
                  // in the event that the complete function throws an exception
                  // we must ensure it won't be called twice. #5684

                  complete = options.complete;
                  if (complete) {

                    options.complete = false;
                    complete.call(elem);
                  }
                }

                return false;

              } else {
                // classical easing cannot be used with an Infinity duration
                if (options.duration == Infinity) {
                  this.now = t;
                } else {
                  n = t - this.startTime;
                  this.state = n / options.duration;

                  // Perform the easing function, defaults to swing
                  this.pos = jQuery.easing[options.animatedProperties[this.prop]](this.state, n, 0, 1, options.duration);
                  this.now = this.start + ((this.end - this.start) * this.pos);
                }
                // Perform the next step of the animation
                this.update();
              }

              return true;
            }
          };

          jQuery.extend(jQuery.fx, {
            tick: function () {
              var timer,
                timers = jQuery.timers,
                i = 0;

              for (; i < timers.length; i++) {
                timer = timers[i];
                // Checks the timer has not already been removed
                if (!timer() && timers[i] === timer) {
                  timers.splice(i--, 1);
                }
              }

              if (!timers.length) {
                jQuery.fx.stop();
              }
            },

            interval: 13,

            stop: function () {
              clearInterval(timerId);
              timerId = null;
            },

            speeds: {
              slow: 600,
              fast: 200,
              // Default speed
              _default: 400
            },

            step: {
              opacity: function (fx) {
                jQuery.style(fx.elem, "opacity", fx.now);
              },

              _default: function (fx) {
                if (fx.elem.style && fx.elem.style[fx.prop] != null) {
                  fx.elem.style[fx.prop] = fx.now + fx.unit;
                } else {
                  fx.elem[fx.prop] = fx.now;
                }
              }
            }
          });

// Adds width/height step functions
// Do not set anything below 0
          jQuery.each(["width", "height"], function (i, prop) {
            jQuery.fx.step[prop] = function (fx) {
              jQuery.style(fx.elem, prop, Math.max(0, fx.now) + fx.unit);
            };
          });

          if (jQuery.expr && jQuery.expr.filters) {
            jQuery.expr.filters.animated = function (elem) {
              return jQuery.grep(jQuery.timers, function (fn) {
                return elem === fn.elem;
              }).length;
            };
          }

// Try to restore the default display value of an element
          function defaultDisplay(nodeName) {

            if (!elemdisplay[nodeName]) {

              var body = document.body,
                elem = jQuery("<" + nodeName + ">").appendTo(body),
                display = elem.css("display");
              elem.remove();

              // If the simple way fails,
              // get element's real default display by attaching it to a temp iframe
              if (display === "none" || display === "") {
                // No iframe to use yet, so create it
                if (!iframe) {
                  iframe = document.createElement("iframe");
                  iframe.frameBorder = iframe.width = iframe.height = 0;
                }

                body.appendChild(iframe);

                // Create a cacheable copy of the iframe document on first call.
                // IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
                // document to it; WebKit & Firefox won't allow reusing the iframe document.
                if (!iframeDoc || !iframe.createElement) {
                  iframeDoc = (iframe.contentWindow || iframe.contentDocument).document;
                  iframeDoc.write((document.compatMode === "CSS1Compat" ? "<!doctype html>" : "") + "<html><body>");
                  iframeDoc.close();
                }

                elem = iframeDoc.createElement(nodeName);

                iframeDoc.body.appendChild(elem);

                display = jQuery.css(elem, "display");
                body.removeChild(iframe);
              }

              // Store the correct default display
              elemdisplay[nodeName] = display;
            }

            return elemdisplay[nodeName];
          }


          var rtable = /^t(?:able|d|h)$/i,
            rroot = /^(?:body|html)$/i;

          if ("getBoundingClientRect" in document.documentElement) {
            jQuery.fn.offset = function (options) {
              var elem = this[0], box;

              if (options) {
                return this.each(function (i) {
                  jQuery.offset.setOffset(this, options, i);
                });
              }

              if (!elem || !elem.ownerDocument) {
                return null;
              }

              if (elem === elem.ownerDocument.body) {
                return jQuery.offset.bodyOffset(elem);
              }

              try {
                box = elem.getBoundingClientRect();
              } catch (e) {
              }

              var doc = elem.ownerDocument,
                docElem = doc.documentElement;

              // Make sure we're not dealing with a disconnected DOM node
              if (!box || !jQuery.contains(docElem, elem)) {
                return box ? {top: box.top, left: box.left} : {top: 0, left: 0};
              }

              var body = doc.body,
                win = getWindow(doc),
                clientTop = docElem.clientTop || body.clientTop || 0,
                clientLeft = docElem.clientLeft || body.clientLeft || 0,
                scrollTop = win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop || body.scrollTop,
                scrollLeft = win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft,
                top = box.top + scrollTop - clientTop,
                left = box.left + scrollLeft - clientLeft;

              return {top: top, left: left};
            };

          } else {
            jQuery.fn.offset = function (options) {
              var elem = this[0];

              if (options) {
                return this.each(function (i) {
                  jQuery.offset.setOffset(this, options, i);
                });
              }

              if (!elem || !elem.ownerDocument) {
                return null;
              }

              if (elem === elem.ownerDocument.body) {
                return jQuery.offset.bodyOffset(elem);
              }

              var computedStyle,
                offsetParent = elem.offsetParent,
                prevOffsetParent = elem,
                doc = elem.ownerDocument,
                docElem = doc.documentElement,
                body = doc.body,
                defaultView = doc.defaultView,
                prevComputedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle,
                top = elem.offsetTop,
                left = elem.offsetLeft;

              while ((elem = elem.parentNode) && elem !== body && elem !== docElem) {
                if (jQuery.support.fixedPosition && prevComputedStyle.position === "fixed") {
                  break;
                }

                computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;
                top -= elem.scrollTop;
                left -= elem.scrollLeft;

                if (elem === offsetParent) {
                  top += elem.offsetTop;
                  left += elem.offsetLeft;

                  if (jQuery.support.doesNotAddBorder && !(jQuery.support.doesAddBorderForTableAndCells && rtable.test(elem.nodeName))) {
                    top += parseFloat(computedStyle.borderTopWidth) || 0;
                    left += parseFloat(computedStyle.borderLeftWidth) || 0;
                  }

                  prevOffsetParent = offsetParent;
                  offsetParent = elem.offsetParent;
                }

                if (jQuery.support.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== "visible") {
                  top += parseFloat(computedStyle.borderTopWidth) || 0;
                  left += parseFloat(computedStyle.borderLeftWidth) || 0;
                }

                prevComputedStyle = computedStyle;
              }

              if (prevComputedStyle.position === "relative" || prevComputedStyle.position === "static") {
                top += body.offsetTop;
                left += body.offsetLeft;
              }

              if (jQuery.support.fixedPosition && prevComputedStyle.position === "fixed") {
                top += Math.max(docElem.scrollTop, body.scrollTop);
                left += Math.max(docElem.scrollLeft, body.scrollLeft);
              }

              return {top: top, left: left};
            };
          }

          jQuery.offset = {

            bodyOffset: function (body) {
              var top = body.offsetTop,
                left = body.offsetLeft;

              if (jQuery.support.doesNotIncludeMarginInBodyOffset) {
                top += parseFloat(jQuery.css(body, "marginTop")) || 0;
                left += parseFloat(jQuery.css(body, "marginLeft")) || 0;
              }

              return {top: top, left: left};
            },

            setOffset: function (elem, options, i) {
              var position = jQuery.css(elem, "position");

              // set position first, in-case top/left are set even on static elem
              if (position === "static") {
                elem.style.position = "relative";
              }

              var curElem = jQuery(elem),
                curOffset = curElem.offset(),
                curCSSTop = jQuery.css(elem, "top"),
                curCSSLeft = jQuery.css(elem, "left"),
                calculatePosition = (position === "absolute" || position === "fixed") && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
                props = {}, curPosition = {}, curTop, curLeft;

              // need to be able to calculate position if either top or left is auto and position is either absolute or fixed
              if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
              } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
              }

              if (jQuery.isFunction(options)) {
                options = options.call(elem, i, curOffset);
              }

              if (options.top != null) {
                props.top = (options.top - curOffset.top) + curTop;
              }
              if (options.left != null) {
                props.left = (options.left - curOffset.left) + curLeft;
              }

              if ("using" in options) {
                options.using.call(elem, props);
              } else {
                curElem.css(props);
              }
            }
          };


          jQuery.fn.extend({

            position: function () {
              if (!this[0]) {
                return null;
              }

              var elem = this[0],

                // Get *real* offsetParent
                offsetParent = this.offsetParent(),

                // Get correct offsets
                offset = this.offset(),
                parentOffset = rroot.test(offsetParent[0].nodeName) ? {top: 0, left: 0} : offsetParent.offset();

              // Subtract element margins
              // note: when an element has margin: auto the offsetLeft and marginLeft
              // are the same in Safari causing offset.left to incorrectly be 0
              offset.top -= parseFloat(jQuery.css(elem, "marginTop")) || 0;
              offset.left -= parseFloat(jQuery.css(elem, "marginLeft")) || 0;

              // Add offsetParent borders
              parentOffset.top += parseFloat(jQuery.css(offsetParent[0], "borderTopWidth")) || 0;
              parentOffset.left += parseFloat(jQuery.css(offsetParent[0], "borderLeftWidth")) || 0;

              // Subtract the two offsets
              return {
                top: offset.top - parentOffset.top,
                left: offset.left - parentOffset.left
              };
            },

            offsetParent: function () {
              return this.map(function () {
                var offsetParent = this.offsetParent || document.body;
                while (offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static")) {
                  offsetParent = offsetParent.offsetParent;
                }
                return offsetParent;
              });
            }
          });


// Create scrollLeft and scrollTop methods
          jQuery.each(["Left", "Top"], function (i, name) {
            var method = "scroll" + name;

            jQuery.fn[method] = function (val) {
              var elem, win;

              if (val === undefined) {
                elem = this[0];

                if (!elem) {
                  return null;
                }

                win = getWindow(elem);

                // Return the scroll offset
                return win ? ("pageXOffset" in win) ? win[i ? "pageYOffset" : "pageXOffset"] :
                  jQuery.support.boxModel && win.document.documentElement[method] ||
                  win.document.body[method] :
                  elem[method];
              }

              // Set the scroll offset
              return this.each(function () {
                win = getWindow(this);

                if (win) {
                  win.scrollTo(
                    !i ? val : jQuery(win).scrollLeft(),
                    i ? val : jQuery(win).scrollTop()
                  );

                } else {
                  this[method] = val;
                }
              });
            };
          });

          function getWindow(elem) {
            return jQuery.isWindow(elem) ?
              elem :
              elem.nodeType === 9 ?
                elem.defaultView || elem.parentWindow :
                false;
          }


// Create width, height, innerHeight, innerWidth, outerHeight and outerWidth methods
          jQuery.each(["Height", "Width"], function (i, name) {

            var type = name.toLowerCase();

            // innerHeight and innerWidth
            jQuery.fn["inner" + name] = function () {
              var elem = this[0];
              return elem ?
                elem.style ?
                  parseFloat(jQuery.css(elem, type, "padding")) :
                  this[type]() :
                null;
            };

            // outerHeight and outerWidth
            jQuery.fn["outer" + name] = function (margin) {
              var elem = this[0];
              return elem ?
                elem.style ?
                  parseFloat(jQuery.css(elem, type, margin ? "margin" : "border")) :
                  this[type]() :
                null;
            };

            jQuery.fn[type] = function (size) {
              // Get window width or height
              var elem = this[0];
              if (!elem) {
                return size == null ? null : this;
              }

              if (jQuery.isFunction(size)) {
                return this.each(function (i) {
                  var self = jQuery(this);
                  self[type](size.call(this, i, self[type]()));
                });
              }

              if (jQuery.isWindow(elem)) {
                // Everyone else use document.documentElement or document.body depending on Quirks vs Standards mode
                // 3rd condition allows Nokia support, as it supports the docElem prop but not CSS1Compat
                var docElemProp = elem.document.documentElement["client" + name],
                  body = elem.document.body;
                return elem.document.compatMode === "CSS1Compat" && docElemProp ||
                  body && body["client" + name] || docElemProp;

                // Get document width or height
              } else if (elem.nodeType === 9) {
                // Either scroll[Width/Height] or offset[Width/Height], whichever is greater
                return Math.max(
                  elem.documentElement["client" + name],
                  elem.body["scroll" + name], elem.documentElement["scroll" + name],
                  elem.body["offset" + name], elem.documentElement["offset" + name]
                );

                // Get or set width or height on the element
              } else if (size === undefined) {
                var orig = jQuery.css(elem, type),
                  ret = parseFloat(orig);

                return jQuery.isNumeric(ret) ? ret : orig;

                // Set the width or height on the element (default to pixels if value is unitless)
              } else {
                return this.css(type, typeof size === "string" ? size : size + "px");
              }
            };

          });


// Expose jQuery to the global object
          window.jQuery = window.$ = jQuery;

// Expose jQuery as an AMD module, but only for AMD loaders that
// understand the issues with loading multiple versions of jQuery
// in a page that all might call define(). The loader will indicate
// they have special allowances for multiple jQuery versions by
// specifying define.amd.jQuery = true. Register as a named module,
// since jQuery can be concatenated with other files that may use define,
// but not use a proper concatenation script that understands anonymous
// AMD modules. A named AMD is safest and most robust way to register.
// Lowercase jquery is used because AMD module names are derived from
// file names, and jQuery is normally delivered in a lowercase file name.
// Do this after creating the global so that if an AMD module wants to call
// noConflict to hide this version of jQuery, it will work.
          if (typeof define === "function" && define.amd && define.amd.jQuery) {
            define("jquery", [], function () {
              return jQuery;
            });
          }


        })(window);

        window.jQuery.noConflict();
        return window.jQuery;
      }

      module.exports = create('undefined' === typeof window ? undefined : window);
      module.exports.create = create;
    }());

  }, {}], 8: [function (require, module, exports) {
    /*
 * Copyright 2012 Small Batch, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
    ;(function (window, document, undefined) {
      function i(a) {
        return function () {
          return this[a]
        }
      }

      var j;

      function n(a, b) {
        var c = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : [];
        return function () {
          c.push.apply(c, arguments);
          return b.apply(a, c)
        }
      };

      function o(a, b) {
        this.K = a;
        this.c = b
      }

      o.prototype.createElement = function (a, b, c) {
        a = this.K.createElement(a);
        if (b) for (var d in b) if (b.hasOwnProperty(d)) d == "style" ? q(this, a, b[d]) : a.setAttribute(d, b[d]);
        c && a.appendChild(this.K.createTextNode(c));
        return a
      };

      function r(a, b, c) {
        a = a.K.getElementsByTagName(b)[0];
        if (!a) a = document.documentElement;
        if (a && a.lastChild) {
          a.insertBefore(c, a.lastChild);
          return true
        }
        return false
      }

      function aa(a, b) {
        function c() {
          document.body ? b() : setTimeout(c, 0)
        }

        c()
      }

      function s(a, b) {
        if (b.parentNode) {
          b.parentNode.removeChild(b);
          return true
        }
        return false
      }

      function t(a, b) {
        return a.createElement("link", {rel: "stylesheet", href: b})
      }

      function u(a, b) {
        return a.createElement("script", {src: b})
      }

      function v(a, b, c) {
        a = b.className.split(/\s+/);
        for (var d = 0, e = a.length; d < e; d++) if (a[d] == c) return;
        a.push(c);
        b.className = a.join(" ").replace(/^\s+/, "")
      }

      function w(a, b, c) {
        a = b.className.split(/\s+/);
        for (var d = [], e = 0, f = a.length; e < f; e++) a[e] != c && d.push(a[e]);
        b.className = d.join(" ").replace(/^\s+/, "").replace(/\s+$/, "")
      }

      function x(a, b, c) {
        a = b.className.split(/\s+/);
        b = 0;
        for (var d = a.length; b < d; b++) if (a[b] == c) return true;
        return false
      }

      function q(a, b, c) {
        if (a.c.getName() == "MSIE") b.style.cssText = c; else b.setAttribute("style", c)
      };

      function y(a, b, c, d, e, f, g, h) {
        this.Ba = a;
        this.Ha = b;
        this.oa = c;
        this.na = d;
        this.Ea = e;
        this.Da = f;
        this.ma = g;
        this.Ia = h
      }

      j = y.prototype;
      j.getName = i("Ba");
      j.xa = i("Ha");
      j.Y = i("oa");
      j.ua = i("na");
      j.va = i("Ea");
      j.wa = i("Da");
      j.ta = i("ma");
      j.w = i("Ia");

      function z(a, b) {
        this.c = a;
        this.k = b
      }

      var ba = new y("Unknown", "Unknown", "Unknown", "Unknown", "Unknown", "Unknown", undefined, false);
      z.prototype.parse = function () {
        return this.c.indexOf("MSIE") != -1 ? ca(this) : this.c.indexOf("Opera") != -1 ? da(this) : this.c.indexOf("AppleWebKit") != -1 ? ea(this) : this.c.indexOf("Gecko") != -1 ? fa(this) : ba
      };

      function A(a) {
        var b = C(a, a.c, /(iPod|iPad|iPhone|Android)/, 1);
        if (b != "") return b;
        a = C(a, a.c, /(Linux|Mac_PowerPC|Macintosh|Windows)/, 1);
        if (a != "") {
          if (a == "Mac_PowerPC") a = "Macintosh";
          return a
        }
        return "Unknown"
      }

      function D(a) {
        var b = C(a, a.c, /(OS X|Windows NT|Android) ([^;)]+)/, 2);
        if (b) return b;
        if (b = C(a, a.c, /(iPhone )?OS ([\d_]+)/, 2)) return b;
        if (a = C(a, a.c, /Linux ([i\d]+)/, 1)) return a;
        return "Unknown"
      }

      function ca(a) {
        var b = C(a, a.c, /(MSIE [\d\w\.]+)/, 1);
        if (b != "") {
          var c = b.split(" ");
          b = c[0];
          c = c[1];
          return new y(b, c, b, c, A(a), D(a), E(a, a.k), F(a, c) >= 6)
        }
        return new y("MSIE", "Unknown", "MSIE", "Unknown", A(a), D(a), E(a, a.k), false)
      }

      function da(a) {
        var b = "Unknown", c = "Unknown", d = C(a, a.c, /(Presto\/[\d\w\.]+)/, 1);
        if (d != "") {
          c = d.split("/");
          b = c[0];
          c = c[1]
        } else {
          if (a.c.indexOf("Gecko") != -1) b = "Gecko";
          d = C(a, a.c, /rv:([^\)]+)/, 1);
          if (d != "") c = d
        }
        if (a.c.indexOf("Version/") != -1) {
          d = C(a, a.c, /Version\/([\d\.]+)/, 1);
          if (d != "") return new y("Opera", d, b, c, A(a), D(a), E(a, a.k), F(a, d) >= 10)
        }
        d = C(a, a.c, /Opera[\/ ]([\d\.]+)/, 1);
        if (d != "") return new y("Opera", d, b, c, A(a), D(a), E(a, a.k), F(a, d) >= 10);
        return new y("Opera", "Unknown", b, c, A(a), D(a), E(a, a.k), false)
      }

      function ea(a) {
        var b = A(a), c = D(a), d = C(a, a.c, /AppleWebKit\/([\d\.\+]+)/, 1);
        if (d == "") d = "Unknown";
        var e = "Unknown";
        if (a.c.indexOf("Chrome") != -1) e = "Chrome"; else if (a.c.indexOf("Safari") != -1) e = "Safari"; else if (a.c.indexOf("AdobeAIR") != -1) e = "AdobeAIR";
        var f = "Unknown";
        if (a.c.indexOf("Version/") != -1) f = C(a, a.c, /Version\/([\d\.\w]+)/, 1); else if (e == "Chrome") f = C(a, a.c, /Chrome\/([\d\.]+)/, 1); else if (e == "AdobeAIR") f = C(a, a.c, /AdobeAIR\/([\d\.]+)/, 1);
        var g = false;
        if (e == "AdobeAIR") {
          g = C(a, f, /\d+\.(\d+)/, 1);
          g = F(a, f) > 2 ||
            F(a, f) == 2 && parseInt(g, 10) >= 5
        } else {
          g = C(a, d, /\d+\.(\d+)/, 1);
          g = F(a, d) >= 526 || F(a, d) >= 525 && parseInt(g, 10) >= 13
        }
        return new y(e, f, "AppleWebKit", d, b, c, E(a, a.k), g)
      }

      function fa(a) {
        var b = "Unknown", c = "Unknown", d = false;
        if (a.c.indexOf("Firefox") != -1) {
          b = "Firefox";
          var e = C(a, a.c, /Firefox\/([\d\w\.]+)/, 1);
          if (e != "") {
            d = C(a, e, /\d+\.(\d+)/, 1);
            c = e;
            d = e != "" && F(a, e) >= 3 && parseInt(d, 10) >= 5
          }
        } else if (a.c.indexOf("Mozilla") != -1) b = "Mozilla";
        e = C(a, a.c, /rv:([^\)]+)/, 1);
        if (e == "") e = "Unknown"; else if (!d) {
          d = F(a, e);
          var f = parseInt(C(a, e, /\d+\.(\d+)/, 1), 10), g = parseInt(C(a, e, /\d+\.\d+\.(\d+)/, 1), 10);
          d = d > 1 || d == 1 && f > 9 || d == 1 && f == 9 && g >= 2 || e.match(/1\.9\.1b[123]/) != null || e.match(/1\.9\.1\.[\d\.]+/) !=
            null
        }
        return new y(b, c, "Gecko", e, A(a), D(a), E(a, a.k), d)
      }

      function F(a, b) {
        a = C(a, b, /(\d+)/, 1);
        if (a != "") return parseInt(a, 10);
        return -1
      }

      function C(a, b, c, d) {
        if ((a = b.match(c)) && a[d]) return a[d];
        return ""
      }

      function E(a, b) {
        if (b.documentMode) return b.documentMode
      };

      function ga(a, b, c, d) {
        this.a = a;
        this.g = b;
        this.U = c;
        this.j = d || ha;
        this.h = new G("-")
      }

      var ha = "wf";

      function H(a) {
        v(a.a, a.g, a.h.e(a.j, "loading"));
        I(a, "loading")
      }

      function J(a) {
        w(a.a, a.g, a.h.e(a.j, "loading"));
        x(a.a, a.g, a.h.e(a.j, "active")) || v(a.a, a.g, a.h.e(a.j, "inactive"));
        I(a, "inactive")
      }

      function ia(a) {
        w(a.a, a.g, a.h.e(a.j, "loading"));
        w(a.a, a.g, a.h.e(a.j, "inactive"));
        v(a.a, a.g, a.h.e(a.j, "active"));
        I(a, "active")
      }

      function I(a, b, c, d) {
        a.U[b] && a.U[b](c, d)
      };

      function ja() {
        this.fa = {}
      }

      function ka(a, b) {
        var c = [];
        for (var d in b) if (b.hasOwnProperty(d)) {
          var e = a.fa[d];
          e && c.push(e(b[d]))
        }
        return c
      };

      function L(a, b, c, d, e) {
        this.a = a;
        this.A = b;
        this.n = c;
        this.u = d;
        this.D = e;
        this.V = 0;
        this.ja = this.ea = false
      }

      L.prototype.watch = function (a, b, c, d, e) {
        for (var f = a.length, g = 0; g < f; g++) {
          var h = a[g];
          b[h] || (b[h] = ["n4"]);
          this.V += b[h].length
        }
        if (e) this.ea = e;
        for (g = 0; g < f; g++) {
          h = a[g];
          e = b[h];
          for (var l = c[h], k = 0, m = e.length; k < m; k++) {
            var B = e[k], p = this.A, K = h;
            v(p.a, p.g, p.h.e(p.j, K, B, "loading"));
            I(p, "fontloading", K, B);
            p = n(this, this.qa);
            K = n(this, this.ra);
            (new d(p, K, this.a, this.n, this.u, this.D, h, B, l)).start()
          }
        }
      };
      L.prototype.qa = function (a, b) {
        var c = this.A;
        w(c.a, c.g, c.h.e(c.j, a, b, "loading"));
        w(c.a, c.g, c.h.e(c.j, a, b, "inactive"));
        v(c.a, c.g, c.h.e(c.j, a, b, "active"));
        I(c, "fontactive", a, b);
        this.ja = true;
        M(this)
      };
      L.prototype.ra = function (a, b) {
        var c = this.A;
        w(c.a, c.g, c.h.e(c.j, a, b, "loading"));
        x(c.a, c.g, c.h.e(c.j, a, b, "active")) || v(c.a, c.g, c.h.e(c.j, a, b, "inactive"));
        I(c, "fontinactive", a, b);
        M(this)
      };

      function M(a) {
        if (--a.V == 0 && a.ea) a.ja ? ia(a.A) : J(a.A)
      };

      function N(a, b, c, d, e, f, g, h, l) {
        this.H = a;
        this.$ = b;
        this.a = c;
        this.n = d;
        this.u = e;
        this.D = f;
        this.Aa = new la;
        this.v = new O;
        this.L = g;
        this.B = h;
        this.sa = l || ma;
        this.O = na(this, oa);
        this.P = na(this, pa);
        this.ca = this.O;
        this.da = this.P;
        this.Q = P(this, oa);
        this.R = P(this, pa)
      }

      var oa = "arial,'URW Gothic L',sans-serif", pa = "Georgia,'Century Schoolbook L',serif", ma = "BESbswy";
      N.prototype.start = function () {
        this.ia = this.D();
        this.J()
      };
      N.prototype.J = function () {
        var a = this.n.p(this.Q), b = this.n.p(this.R);
        if ((this.O != a || this.P != b) && this.ca == a && this.da == b) Q(this, this.H); else if (this.D() - this.ia >= 5E3) Q(this, this.$); else {
          this.ca = a;
          this.da = b;
          qa(this)
        }
      };

      function qa(a) {
        a.u(function (b, c) {
          return function () {
            c.call(b)
          }
        }(a, a.J), 25)
      }

      function Q(a, b) {
        s(a.a, a.Q);
        s(a.a, a.R);
        b(a.L, a.B)
      }

      function na(a, b) {
        b = P(a, b, true);
        var c = a.n.p(b);
        s(a.a, b);
        return c
      }

      function P(a, b, c) {
        b = a.a.createElement("span", {style: R(a, b, a.B, c)}, a.sa);
        r(a.a, "body", b);
        return b
      }

      function R(a, b, c, d) {
        c = a.v.expand(c);
        return "position:absolute;top:-999px;left:-999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;font-family:" + (d ? "" : a.Aa.quote(a.L) + ",") + b + ";" + c
      };

      function S(a, b, c, d, e) {
        this.a = a;
        this.X = b;
        this.g = c;
        this.u = d;
        this.c = e;
        this.M = this.N = 0
      }

      S.prototype.q = function (a, b) {
        this.X.fa[a] = b
      };
      S.prototype.load = function (a) {
        var b = new ga(this.a, this.g, a);
        this.c.w() ? ra(this, b, a) : J(b)
      };
      S.prototype.ya = function (a, b, c, d) {
        var e = a.Z ? a.Z() : N;
        if (d) a.load(n(this, this.Ca, b, c, e)); else {
          a = --this.N == 0;
          this.M--;
          if (a) this.M == 0 ? J(b) : H(b);
          c.watch([], {}, {}, e, a)
        }
      };
      S.prototype.Ca = function (a, b, c, d, e, f) {
        var g = --this.N == 0;
        g && H(a);
        this.u(n(this, function (h, l, k, m, B, p) {
          h.watch(l, k || {}, m || {}, B, p)
        }, b, d, e, f, c, g))
      };

      function ra(a, b, c) {
        c = ka(a.X, c);
        a.M = a.N = c.length;
        for (var d = new L(a.a, b, {
          p: function (h) {
            return h.offsetWidth
          }
        }, a.u, function () {
          return (new Date).getTime()
        }), e = 0, f = c.length; e < f; e++) {
          var g = c[e];
          g.z(a.c, n(a, a.ya, g, b, d))
        }
      };

      function G(a) {
        this.za = a || sa
      }

      var sa = "-";
      G.prototype.e = function () {
        for (var a = [], b = 0; b < arguments.length; b++) a.push(arguments[b].replace(/[\W_]+/g, "").toLowerCase());
        return a.join(this.za)
      };

      function la() {
        this.ha = "'"
      }

      la.prototype.quote = function (a) {
        var b = [];
        a = a.split(/,\s*/);
        for (var c = 0; c < a.length; c++) {
          var d = a[c].replace(/['"]/g, "");
          d.indexOf(" ") == -1 ? b.push(d) : b.push(this.ha + d + this.ha)
        }
        return b.join(",")
      };

      function O() {
        this.G = ta;
        this.o = ua
      }

      var ta = ["font-style", "font-weight"], ua = {
        "font-style": [["n", "normal"], ["i", "italic"], ["o", "oblique"]],
        "font-weight": [["1", "100"], ["2", "200"], ["3", "300"], ["4", "400"], ["5", "500"], ["6", "600"], ["7", "700"], ["8", "800"], ["9", "900"], ["4", "normal"], ["7", "bold"]]
      };

      function T(a, b, c) {
        this.aa = a;
        this.Fa = b;
        this.o = c
      }

      T.prototype.compact = function (a, b) {
        for (var c = 0; c < this.o.length; c++) if (b == this.o[c][1]) {
          a[this.aa] = this.o[c][0];
          return
        }
      };
      T.prototype.expand = function (a, b) {
        for (var c = 0; c < this.o.length; c++) if (b == this.o[c][0]) {
          a[this.aa] = this.Fa + ":" + this.o[c][1];
          return
        }
      };
      O.prototype.compact = function (a) {
        var b = ["n", "4"];
        a = a.split(";");
        for (var c = 0, d = a.length; c < d; c++) {
          var e = a[c].replace(/\s+/g, "").split(":");
          if (e.length == 2) {
            var f = e[1];
            a:{
              e = e[0];
              for (var g = 0; g < this.G.length; g++) if (e == this.G[g]) {
                e = new T(g, e, this.o[e]);
                break a
              }
              e = null
            }
            e && e.compact(b, f)
          }
        }
        return b.join("")
      };
      O.prototype.expand = function (a) {
        if (a.length != 2) return null;
        for (var b = [null, null], c = 0, d = this.G.length; c < d; c++) {
          var e = this.G[c], f = a.substr(c, 1);
          (new T(c, e, this.o[e])).expand(b, f)
        }
        return b[0] && b[1] ? b.join(";") + ";" : null
      };
      window.WebFont = function () {
        var a = (new z(navigator.userAgent, document)).parse();
        return new S(new o(document, a), new ja, document.documentElement, function (b, c) {
          setTimeout(b, c)
        }, a)
      }();
      window.WebFont.load = window.WebFont.load;
      window.WebFont.addModule = window.WebFont.q;
      y.prototype.getName = y.prototype.getName;
      y.prototype.getVersion = y.prototype.xa;
      y.prototype.getEngine = y.prototype.Y;
      y.prototype.getEngineVersion = y.prototype.ua;
      y.prototype.getPlatform = y.prototype.va;
      y.prototype.getPlatformVersion = y.prototype.wa;
      y.prototype.getDocumentMode = y.prototype.ta;
      y.prototype.isSupportingWebFont = y.prototype.w;

      function U(a, b) {
        this.a = a;
        this.d = b
      }

      var va = {regular: "n4", bold: "n7", italic: "i4", bolditalic: "i7", r: "n4", b: "n7", i: "i4", bi: "i7"};
      U.prototype.z = function (a, b) {
        return b(a.w())
      };
      U.prototype.load = function (a) {
        r(this.a, "head", t(this.a, ("https:" == document.location.protocol ? "https:" : "http:") + "//webfonts.fontslive.com/css/" + this.d.key + ".css"));
        var b;
        b = this.d.families;
        var c, d, e;
        c = [];
        d = {};
        for (var f = 0, g = b.length; f < g; f++) {
          e = void 0;
          var h = void 0;
          h = void 0;
          h = b[f].split(":");
          e = h[0];
          h = h[1] ? wa(this, h[1]) : ["n4"];
          e = {W: e, T: h};
          c.push(e.W);
          d[e.W] = e.T
        }
        b = {pa: c, T: d};
        a(b.pa, b.T)
      };

      function wa(a, b) {
        a = b.split(",");
        b = [];
        for (var c = 0, d = a.length; c < d; c++) {
          var e = a[c];
          if (e) {
            var f = va[e];
            b.push(f ? f : e)
          }
        }
        return b
      }

      window.WebFont.q("ascender", function (a) {
        var b = (new z(navigator.userAgent, document)).parse();
        return new U(new o(document, b), a)
      });

      function V(a, b, c, d, e, f, g, h, l) {
        V.Ga.call(this, a, b, c, d, e, f, g, h, l);
        a = ["Times New Roman", "Lucida Sans Unicode", "Courier New", "Tahoma", "Arial", "Microsoft Sans Serif", "Times", "Lucida Console", "Sans", "Serif", "Monospace"];
        b = a.length;
        c = {};
        d = P(this, a[0], true);
        c[this.n.p(d)] = true;
        for (e = 1; e < b; e++) {
          f = a[e];
          q(this.a, d, R(this, f, this.B, true));
          c[this.n.p(d)] = true;
          if (this.B[1] != "4") {
            q(this.a, d, R(this, f, this.B[0] + "4", true));
            c[this.n.p(d)] = true
          }
        }
        s(this.a, d);
        this.t = c;
        this.la = false
      }

      (function (a, b) {
        function c() {
        }

        c.prototype = a.prototype;
        b.prototype = new c;
        b.Ga = a;
        b.Ja = a.prototype
      })(N, V);
      var xa = {Arimo: true, Cousine: true, Tinos: true};
      V.prototype.J = function () {
        var a = this.n.p(this.Q), b = this.n.p(this.R);
        if (!this.la && a == b && this.t[a]) {
          this.t = {};
          this.la = this.t[a] = true
        }
        if ((this.O != a || this.P != b) && !this.t[a] && !this.t[b]) Q(this, this.H); else if (this.D() - this.ia >= 5E3) this.t[a] && this.t[b] && xa[this.L] ? Q(this, this.H) : Q(this, this.$); else qa(this)
      };

      function ya(a) {
        this.I = a ? a : ("https:" == window.location.protocol ? "https:" : "http:") + za;
        this.f = [];
        this.S = []
      }

      var za = "//fonts.googleapis.com/css";
      ya.prototype.e = function () {
        if (this.f.length == 0) throw new Error("No fonts to load !");
        if (this.I.indexOf("kit=") != -1) return this.I;
        for (var a = this.f.length, b = [], c = 0; c < a; c++) b.push(this.f[c].replace(/ /g, "+"));
        a = this.I + "?family=" + b.join("%7C");
        if (this.S.length > 0) a += "&subset=" + this.S.join(",");
        return a
      };

      function Aa(a) {
        this.f = a;
        this.ga = [];
        this.ka = {};
        this.F = {};
        this.v = new O
      }

      var Ba = {
        ultralight: "n2",
        light: "n3",
        regular: "n4",
        bold: "n7",
        italic: "i4",
        bolditalic: "i7",
        ul: "n2",
        l: "n3",
        r: "n4",
        b: "n7",
        i: "i4",
        bi: "i7"
      }, Ca = {
        latin: ma,
        cyrillic: "&#1081;&#1103;&#1046;",
        greek: "&#945;&#946;&#931;",
        khmer: "&#x1780;&#x1781;&#x1782;",
        Hanuman: "&#x1780;&#x1781;&#x1782;"
      };
      Aa.prototype.parse = function () {
        for (var a = this.f.length, b = 0; b < a; b++) {
          var c = this.f[b].split(":"), d = c[0], e = ["n4"];
          if (c.length >= 2) {
            var f = c[1], g = [];
            if (f) {
              f = f.split(",");
              for (var h = f.length, l = 0; l < h; l++) {
                var k;
                k = f[l];
                if (k.match(/^[\w ]+$/)) {
                  var m = Ba[k];
                  if (m) k = m; else {
                    m = k.match(/^(\d*)(\w*)$/);
                    k = m[1];
                    m = m[2];
                    k = (k = this.v.expand([m ? m : "n", k ? k.substr(0, 1) : "4"].join(""))) ? this.v.compact(k) : null
                  }
                } else k = "";
                k && g.push(k)
              }
            }
            if (g.length > 0) e = g;
            if (c.length == 3) {
              c = c[2];
              g = [];
              c = c ? c.split(",") : g;
              if (c.length > 0) if (c = Ca[c[0]]) this.F[d] =
                c
            }
          }
          if (!this.F[d]) if (c = Ca[d]) this.F[d] = c;
          this.ga.push(d);
          this.ka[d] = e
        }
      };

      function W(a, b, c) {
        this.c = a;
        this.a = b;
        this.d = c
      }

      W.prototype.z = function (a, b) {
        b(a.w())
      };
      W.prototype.Z = function () {
        if (this.c.Y() == "AppleWebKit") return V;
        return N
      };
      W.prototype.load = function (a) {
        var b = this.a;
        this.c.getName() == "MSIE" && this.d.blocking != true ? aa(b, n(this, this.ba, a)) : this.ba(a)
      };
      W.prototype.ba = function (a) {
        for (var b = this.a, c = new ya(this.d.api), d = this.d.families, e = d.length, f = 0; f < e; f++) {
          var g = d[f].split(":");
          g.length == 3 && c.S.push(g.pop());
          c.f.push(g.join(":"))
        }
        d = new Aa(d);
        d.parse();
        r(b, "head", t(b, c.e()));
        a(d.ga, d.ka, d.F)
      };
      window.WebFont.q("google", function (a) {
        var b = (new z(navigator.userAgent, document)).parse();
        return new W(b, new o(document, b), a)
      });

      function X(a, b) {
        this.a = a;
        this.d = b
      }

      X.prototype.load = function (a) {
        for (var b = this.d.urls || [], c = this.d.families || [], d = 0, e = b.length; d < e; d++) r(this.a, "head", t(this.a, b[d]));
        a(c)
      };
      X.prototype.z = function (a, b) {
        return b(a.w())
      };
      window.WebFont.q("custom", function (a) {
        var b = (new z(navigator.userAgent, document)).parse();
        return new X(new o(document, b), a)
      });

      function Y(a, b, c) {
        this.m = a;
        this.a = b;
        this.d = c;
        this.f = [];
        this.s = {};
        this.v = new O
      }

      Y.prototype.C = function (a) {
        return ("https:" == this.m.location.protocol ? "https:" : "http:") + (this.d.api || "//f.fontdeck.com/s/css/js/") + this.m.document.location.hostname + "/" + a + ".js"
      };
      Y.prototype.z = function (a, b) {
        a = this.d.id;
        var c = this;
        if (a) {
          this.m.__webfontfontdeckmodule__ || (this.m.__webfontfontdeckmodule__ = {});
          this.m.__webfontfontdeckmodule__[a] = function (d, e) {
            for (var f = 0, g = e.fonts.length; f < g; ++f) {
              var h = e.fonts[f];
              c.f.push(h.name);
              c.s[h.name] = [c.v.compact("font-weight:" + h.weight + ";font-style:" + h.style)]
            }
            b(d)
          };
          r(this.a, "head", u(this.a, this.C(a)))
        } else b(true)
      };
      Y.prototype.load = function (a) {
        a(this.f, this.s)
      };
      window.WebFont.q("fontdeck", function (a) {
        var b = (new z(navigator.userAgent, document)).parse();
        return new Y(window, new o(document, b), a)
      });

      function Z(a, b, c, d, e) {
        this.m = a;
        this.c = b;
        this.a = c;
        this.k = d;
        this.d = e;
        this.f = [];
        this.s = {}
      }

      Z.prototype.z = function (a, b) {
        var c = this, d = c.d.projectId;
        if (d) {
          var e = u(c.a, c.C(d));
          e.id = "__MonotypeAPIScript__" + d;
          e.onreadystatechange = function (f) {
            if (e.readyState === "loaded" || e.readyState === "complete") {
              e.onreadystatechange = null;
              e.onload(f)
            }
          };
          e.onload = function () {
            if (c.m["__mti_fntLst" + d]) {
              var f = c.m["__mti_fntLst" + d]();
              if (f && f.length) {
                var g;
                for (g = 0; g < f.length; g++) c.f.push(f[g].fontfamily)
              }
            }
            b(a.w())
          };
          r(this.a, "head", e)
        } else b(true)
      };
      Z.prototype.C = function (a) {
        var b = this.protocol(), c = (this.d.api || "fast.fonts.com/jsapi").replace(/^.*http(s?):(\/\/)?/, "");
        return b + "//" + c + "/" + a + ".js"
      };
      Z.prototype.load = function (a) {
        a(this.f, this.s)
      };
      Z.prototype.protocol = function () {
        var a = ["http:", "https:"], b = a[0];
        if (this.k && this.k.location && this.k.location.protocol) {
          var c = 0;
          for (c = 0; c < a.length; c++) if (this.k.location.protocol === a[c]) return this.k.location.protocol
        }
        return b
      };
      window.WebFont.q("monotype", function (a) {
        var b = (new z(navigator.userAgent, document)).parse();
        return new Z(window, b, new o(document, b), document, a)
      });

      function $(a, b, c) {
        this.m = a;
        this.a = b;
        this.d = c;
        this.f = [];
        this.s = {}
      }

      $.prototype.C = function (a) {
        var b = "https:" == window.location.protocol ? "https:" : "http:";
        return (this.d.api || b + "//use.typekit.com") + "/" + a + ".js"
      };
      $.prototype.z = function (a, b) {
        var c = this.d.id, d = this.d, e = this;
        if (c) {
          this.m.__webfonttypekitmodule__ || (this.m.__webfonttypekitmodule__ = {});
          this.m.__webfonttypekitmodule__[c] = function (f) {
            f(a, d, function (g, h, l) {
              e.f = h;
              e.s = l;
              b(g)
            })
          };
          r(this.a, "head", u(this.a, this.C(c)))
        } else b(true)
      };
      $.prototype.load = function (a) {
        a(this.f, this.s)
      };
      window.WebFont.q("typekit", function (a) {
        var b = (new z(navigator.userAgent, document)).parse();
        return new $(window, new o(document, b), a)
      });
      window.WebFontConfig && window.WebFont.load(window.WebFontConfig);
    })(this, document);

  }, {}], 9: [function (require, module, exports) {
// -*- Mode: JavaScript; tab-width: 2; indent-tabs-mode: nil; -*-
// vim:set ft=javascript ts=2 sw=2 sts=2 cindent:
    var Ajax = (function ($, window, undefined) {
      var Ajax = function (dispatcher) {
        var that = this;
        var pending = 0;
        var count = 0;
        var pendingList = {};

        // merge data will get merged into the response data
        // before calling the callback
        var ajaxCall = function (data, callback, merge) {
          merge = merge || {};
          dispatcher.post('spin');
          pending++;
          var id = count++;

          // special value: `merge.keep = true` prevents obsolescence
          pendingList[id] = merge.keep || false;
          delete merge.keep;

          // If no protocol version is explicitly set, set it to current
          if (data['protocol'] === undefined) {
            // TODO: Extract the protocol version somewhere global
            data['protocol'] = 1;
          }

          //var url = "test-json/";
          var url = "test-json-simple/";
          var method = "GET";
          switch (data.action) {
            case "whoami":
              url += "user.json";
              break;
            case "getDocument":
              url += "document.json";
              break;
            case "loadConf":
              url += "config.json";
              break;
            case "getCollectionInformation":
              url += "collection.json";
              break;
            case "login":
              url += "login.json";
              break;
            case "createArc":
              url += "addRelation.json";
              //TODO method = "POST";
              break;
            case "arcOpenDialog":
              url += "addRelation2.json";
              break;
            case "createSpan":
              url += "createToken.json";
              //TODO method = "POST";
              break;
            default:
              url += "empty.json";
          }
          $.ajax({
            //Removed by Renaud on 2016-03-10
            /*url: 'ajax.cgi',
           data: data,
           type: 'POST',*/
            //
            data: data,
            url: url,
            type: method,
            success: function (response) {
              pending--;
              // If no exception is set, verify the server results
              if (response.exception == undefined && response.action !== data.action) {
                console.error('Action ' + data.action +
                  ' returned the results of action ' + response.action);
                response.exception = true;
                dispatcher.post('messages', [[['Protocol error: Action' + data.action + ' returned the results of action ' + response.action + ' maybe the server is unable to run, please run tools/troubleshooting.sh from your installation to diagnose it', 'error', -1]]]);
              }

              // If the request is obsolete, do nothing; if not...
              if (pendingList.hasOwnProperty(id)) {
                dispatcher.post('messages', [response.messages]);
                if (response.exception == 'configurationError'
                  || response.exception == 'protocolVersionMismatch') {
                  // this is a no-rescue critical failure.
                  // Stop *everything*.
                  pendingList = {};
                  dispatcher.post('screamingHalt');
                  // If we had a protocol mismatch, prompt the user for a reload
                  if (response.exception == 'protocolVersionMismatch') {
                    if (confirm('The server is running a different version ' +
                      'from brat than your client, possibly due to a ' +
                      'server upgrade. Would you like to reload the ' +
                      'current page to update your client to the latest ' +
                      'version?')) {
                      window.location.reload(true);
                    } else {
                      dispatcher.post('messages', [[['Fatal Error: Protocol ' +
                      'version mismatch, please contact the administrator',
                        'error', -1]]]);
                    }
                  }
                  return;
                }

                delete pendingList[id];

                // if .exception is just Boolean true, do not process
                // the callback; if it is anything else, the
                // callback is responsible for handling it
                if (response.exception == true) {
                  $('#waiter').dialog('close');
                } else if (callback) {
                  $.extend(response, merge);
                  dispatcher.post(0, callback, [response]);
                }
              }
              dispatcher.post('unspin');
            },
            error: function (response, textStatus, errorThrown) {
              pending--;
              dispatcher.post('unspin');
              $('#waiter').dialog('close');
              dispatcher.post('messages', [[['Error: Action' + data.action + ' failed on error ' + response.statusText, 'error']]]);
              console.error(textStatus + ':', errorThrown, response);
            }
          });
          return id;
        };

        var isReloadOkay = function () {
          // do not reload while data is pending
          return pending == 0;
        };

        var makeObsolete = function (all) {
          if (all) {
            pendingList = {};
          } else {
            $.each(pendingList, function (id, keep) {
              if (!keep) delete pendingList[id];
            });
          }
        }

        dispatcher.on('isReloadOkay', isReloadOkay).on('makeAjaxObsolete', makeObsolete).on('ajax', ajaxCall);
      };

      return Ajax;
    })(jQuery, window);

    module.exports = Ajax;

  }, {}], 10: [function (require, module, exports) {
// -*- Mode: JavaScript; tab-width: 2; indent-tabs-mode: nil; -*-
// vim:set ft=javascript ts=2 sw=2 sts=2 cindent:
    var AnnotatorUI = (function ($, window, undefined) {
      var AnnotatorUI = function (dispatcher, svg) {
        var that = this;
        var arcDragOrigin = null;
        var arcDragOriginBox = null;
        var arcDragOriginGroup = null;
        var arcDragArc = null;
        var arcDragJustStarted = false;
        var sourceData = null;
        var data = null;
        var searchConfig = null;
        var spanOptions = null;
        var rapidSpanOptions = null;
        var arcOptions = null;
        var spanKeymap = null;
        var keymap = null;
        var coll = null;
        var doc = null;
        var reselectedSpan = null;
        var selectedFragment = null;
        var editedSpan = null;
        var editedFragment = null;
        var repeatingArcTypes = [];
        var spanTypes = null;
        var entityAttributeTypes = null;
        var eventAttributeTypes = null;
        var allAttributeTypes = null; // TODO: temp workaround, remove
        var relationTypesHash = null;
        var showValidAttributes; // callback function
        var showValidNormalizations; // callback function
        var dragStartedAt = null;
        var selRect = null;
        var lastStartRec = null;
        var lastEndRec = null;

        var draggedArcHeight = 30;
        var spanTypesToShowBeforeCollapse = 30;
        var maxNormSearchHistory = 10;

        // TODO: this is an ugly hack, remove (see comment with assignment)
        var lastRapidAnnotationEvent = null;
        // TODO: another avoidable global; try to work without
        var rapidAnnotationDialogVisible = false;

        // amount by which to lighten (adjust "L" in HSL space) span
        // colors for type selection box BG display. 0=no lightening,
        // 1=white BG (no color)
        var spanBoxTextBgColorLighten = 0.4;

        // for double-click selection simulation hack
        var lastDoubleClickedChunkId = null;

        // for normalization: URLs bases by norm DB name
        var normDbUrlByDbName = {};
        var normDbUrlBaseByDbName = {};
        // for normalization: appropriate DBs per type
        var normDbsByType = {};
        // for normalization
        var oldSpanNormIdValue = '';
        var lastNormSearches = [];

        that.user = null;
        var svgElement = $(svg._svg);
        var svgId = svgElement.parent().attr('id');

        var stripNumericSuffix = function (s) {
          // utility function, originally for stripping numerix suffixes
          // from arc types (e.g. "Theme2" -> "Theme"). For values
          // without suffixes (including non-strings), returns given value.
          if (typeof(s) != "string") {
            return s; // can't strip
          }
          var m = s.match(/^(.*?)(\d*)$/);
          return m[1]; // always matches
        }

        var hideForm = function () {
          keymap = null;
          rapidAnnotationDialogVisible = false;
        };

        var clearSelection = function () {
          window.getSelection().removeAllRanges();
          if (selRect != null) {
            for (var s = 0; s != selRect.length; s++) {
              selRect[s].parentNode.removeChild(selRect[s]);
            }
            selRect = null;
            lastStartRec = null;
            lastEndRec = null;
          }
        };

        var makeSelRect = function (rx, ry, rw, rh, col) {
          var selRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
          selRect.setAttributeNS(null, "width", rw);
          selRect.setAttributeNS(null, "height", rh);
          selRect.setAttributeNS(null, "x", rx);
          selRect.setAttributeNS(null, "y", ry);
          selRect.setAttributeNS(null, "fill", col == undefined ? "lightblue" : col);
          return selRect;
        };

        var onKeyDown = function (evt) {
          var code = evt.which;

          if (code === $.ui.keyCode.ESCAPE) {
            stopArcDrag();
            if (reselectedSpan) {
              $(reselectedSpan.rect).removeClass('reselect');
              reselectedSpan = null;
              svgElement.removeClass('reselect');
            }
            return;
          }

          // in rapid annotation mode, prioritize the keys 0..9 for the
          // ordered choices in the quick annotation dialog.
          if (Configuration.rapidModeOn && rapidAnnotationDialogVisible &&
            "0".charCodeAt() <= code && code <= "9".charCodeAt()) {
            var idx = String.fromCharCode(code);
            var $input = $('#rapid_span_' + idx);
            if ($input.length) {
              $input.click();
            }
          }

          if (!keymap) return;

          // disable shortcuts when working with elements that you could
          // conceivably type in
          var target = evt.target;
          var nodeName = target.nodeName.toLowerCase();
          var nodeType = target.type && target.type.toLowerCase();
          if (nodeName == 'input' && (nodeType == 'text' || nodeType == 'password')) return;
          if (nodeName == 'textarea' || nodeName == 'select') return;

          var prefix = '';
          if (evt.altKey) {
            prefix = "A-";
          }
          if (evt.ctrlKey) {
            prefix = "C-";
          }
          if (evt.shiftKey) {
            prefix = "S-";
          }
          var binding = keymap[prefix + code];
          if (!binding) binding = keymap[prefix + String.fromCharCode(code)];
          if (binding) {
            var boundInput = $('#' + binding)[0];
            if (boundInput && !boundInput.disabled) {
              boundInput.click();
              evt.preventDefault();
              return false;
            }
          }
        };

        var onDblClick = function (evt) {
          // must be logged in
          //Removed by Renaud on 2016-03-10
          //if (that.user === null) return;
          // must not be reselecting a span or an arc
          if (reselectedSpan || arcDragOrigin) return;

          var target = $(evt.target);
          var id;

          // do we edit an arc?
          if (id = target.attr('data-arc-role')) {
            // TODO
            clearSelection();
            var originSpanId = target.attr('data-arc-origin');
            var targetSpanId = target.attr('data-arc-target');
            var type = target.attr('data-arc-role');
            var originSpan = data.spans[originSpanId];
            var targetSpan = data.spans[targetSpanId];
            arcOptions = {
              action: 'createArc',
              origin: originSpanId,
              target: targetSpanId,
              old_target: targetSpanId,
              type: type,
              old_type: type,
              collection: coll,
              'document': doc
            };
            var eventDescId = target.attr('data-arc-ed');
            if (eventDescId) {
              var eventDesc = data.eventDescs[eventDescId];
              if (eventDesc.equiv) {
                arcOptions['left'] = eventDesc.leftSpans.join(',');
                arcOptions['right'] = eventDesc.rightSpans.join(',');
              }
            }
            $('#arc_origin').text(Util.spanDisplayForm(spanTypes, originSpan.type) + ' ("' + originSpan.text + '")');
            $('#arc_target').text(Util.spanDisplayForm(spanTypes, targetSpan.type) + ' ("' + targetSpan.text + '")');
            var arcId = eventDescId || [originSpanId, type, targetSpanId];
            fillArcTypesAndDisplayForm(evt, originSpan.type, targetSpan.type, type, arcId);
            // for precise timing, log dialog display to user.
            dispatcher.post('logAction', ['arcEditSelected']);

            // if not an arc, then do we edit a span?
          } else if (id = target.attr('data-span-id')) {
            clearSelection();
            editedSpan = data.spans[id];
            editedFragment = target.attr('data-fragment-id');
            var offsets = [];
            $.each(editedSpan.fragments, function (fragmentNo, fragment) {
              offsets.push([fragment.from, fragment.to]);
            });
            spanOptions = {
              action: 'createSpan',
              offsets: offsets,
              type: editedSpan.type,
              id: id,
            };
            fillSpanTypesAndDisplayForm(evt, editedSpan.text, editedSpan);
            // for precise timing, log annotation display to user.
            dispatcher.post('logAction', ['spanEditSelected']);
          }

          // if not an arc or a span, is this a double-click on text?
          else if (id = target.attr('data-chunk-id')) {
            // remember what was clicked (this is in preparation for
            // simulating double-click selection on browsers that do
            // not support it.
            lastDoubleClickedChunkId = id;
          }
        };

        var startArcDrag = function (originId) {
          clearSelection();
          svgElement.addClass('unselectable');
          svgPosition = svgElement.offset();
          arcDragOrigin = originId;
          arcDragArc = svg.path(svg.createPath(), {
            markerEnd: 'url(#drag_arrow)',
            'class': 'drag_stroke',
            fill: 'none',
          });
          arcDragOriginGroup = $(data.spans[arcDragOrigin].group);
          arcDragOriginGroup.addClass('highlight');
          arcDragOriginBox = Util.realBBox(data.spans[arcDragOrigin].headFragment);
          arcDragOriginBox.center = arcDragOriginBox.x + arcDragOriginBox.width / 2;

          arcDragJustStarted = true;
        };

        var getValidArcTypesForDrag = function (targetId, targetType) {
          var arcType = stripNumericSuffix(arcOptions && arcOptions.type);
          if (!arcDragOrigin || targetId == arcDragOrigin) return null;

          var originType = data.spans[arcDragOrigin].type;
          var spanType = spanTypes[originType];
          var result = [];
          if (spanType && spanType.arcs) {
            $.each(spanType.arcs, function (arcNo, arc) {
              if (arcType && arcType != arc.type) return;

              if ($.inArray(targetType, arc.targets) != -1) {
                result.push(arc.type);
              }
            });
          }
          return result;
        };

        var onMouseDown = function (evt) {
          dragStartedAt = evt; // XXX do we really need the whole evt?
          //Removed by Renaud on 2016-03-10
          //if (!that.user || arcDragOrigin) return;
          if (arcDragOrigin) return;
          var target = $(evt.target);
          var id;
          // is it arc drag start?
          if (id = target.attr('data-span-id')) {
            arcOptions = null;
            startArcDrag(id);
            return false;
          }
        };

        var onMouseMove = function (evt) {
          if (arcDragOrigin) {
            if (arcDragJustStarted) {
              // show the possible targets
              var span = data.spans[arcDragOrigin] || {};
              var spanDesc = spanTypes[span.type] || {};

              // separate out possible numeric suffix from type for highight
              // (instead of e.g. "Theme3", need to look for "Theme")
              var noNumArcType = stripNumericSuffix(arcOptions && arcOptions.type);
              // var targetClasses = [];
              var $targets = $();
              $.each(spanDesc.arcs || [], function (possibleArcNo, possibleArc) {
                if ((arcOptions && possibleArc.type == noNumArcType) || !(arcOptions && arcOptions.old_target)) {
                  $.each(possibleArc.targets || [], function (possibleTargetNo, possibleTarget) {
                    // speedup for #642: relevant browsers should support
                    // this function: http://www.quirksmode.org/dom/w3c_core.html#t11
                    // so we get off jQuery and get down to the metal:
                    // targetClasses.push('.span_' + possibleTarget);
                    $targets = $targets.add(svgElement[0].getElementsByClassName('span_' + possibleTarget));
                  });
                }
              });
              //$(targetClasses.join(',')).not('[data-span-id="' + arcDragOrigin + '"]').addClass('reselectTarget');
              //TODO next one should be working but doesn't. Renaud on 2016-03-10
              $targets.not('[data-span-id="' + arcDragOrigin + '"]').addClass('reselectTarget');
            }
            clearSelection();
            var mx = evt.pageX - svgPosition.left;
            var my = evt.pageY - svgPosition.top + 5; // TODO FIXME why +5?!?
            var y = Math.min(arcDragOriginBox.y, my) - draggedArcHeight;
            var dx = (arcDragOriginBox.center - mx) / 4;
            var path = svg.createPath().move(arcDragOriginBox.center, arcDragOriginBox.y).curveC(arcDragOriginBox.center - dx, y,
              mx + dx, y,
              mx, my);
            arcDragArc.setAttribute('d', path.path());
          } else {
            // A. Scerri FireFox chunk

            // if not, then is it span selection? (ctrl key cancels)
            var sel = window.getSelection();
            var chunkIndexFrom = sel.anchorNode && $(sel.anchorNode.parentNode).attr('data-chunk-id');
            var chunkIndexTo = sel.focusNode && $(sel.focusNode.parentNode).attr('data-chunk-id');
            // fallback for firefox (at least):
            // it's unclear why, but for firefox the anchor and focus
            // node parents are always undefined, the the anchor and
            // focus nodes themselves do (often) have the necessary
            // chunk ID. However, anchor offsets are almost always
            // wrong, so we'll just make a guess at what the user might
            // be interested in tagging instead of using what's given.
            var anchorOffset = null;
            var focusOffset = null;
            if (chunkIndexFrom === undefined && chunkIndexTo === undefined &&
              $(sel.anchorNode).attr('data-chunk-id') &&
              $(sel.focusNode).attr('data-chunk-id')) {
              // Lets take the actual selection range and work with that
              // Note for visual line up and more accurate positions a vertical offset of 8 and horizontal of 2 has been used!
              var range = sel.getRangeAt(0);
              var svgOffset = $(svg._svg).offset();
              var flip = false;
              var tries = 0;
              // First try and match the start offset with a position, if not try it against the other end
              while (tries < 2) {
                var sp = svg._svg.createSVGPoint();
                sp.x = (flip ? evt.pageX : dragStartedAt.pageX) - svgOffset.left;
                sp.y = (flip ? evt.pageY : dragStartedAt.pageY) - (svgOffset.top + 8);
                var startsAt = range.startContainer;
                anchorOffset = startsAt.getCharNumAtPosition(sp);
                chunkIndexFrom = startsAt && $(startsAt).attr('data-chunk-id');
                if (anchorOffset != -1) {
                  break;
                }
                flip = true;
                tries++;
              }

              // Now grab the end offset
              sp.x = (flip ? dragStartedAt.pageX : evt.pageX) - svgOffset.left;
              sp.y = (flip ? dragStartedAt.pageY : evt.pageY) - (svgOffset.top + 8);
              var endsAt = range.endContainer;
              focusOffset = endsAt.getCharNumAtPosition(sp);

              // If we cannot get a start and end offset stop here
              if (anchorOffset == -1 || focusOffset == -1) {
                return;
              }
              // If we are in the same container it does the selection back to front when dragged right to left, across different containers the start is the start and the end if the end!
              if (range.startContainer == range.endContainer && anchorOffset > focusOffset) {
                var t = anchorOffset;
                anchorOffset = focusOffset;
                focusOffset = t;
                flip = false;
              }
              chunkIndexTo = endsAt && $(endsAt).attr('data-chunk-id');

              // Now take the start and end character rectangles
              startRec = startsAt.getExtentOfChar(anchorOffset);
              startRec.y += 2;
              endRec = endsAt.getExtentOfChar(focusOffset);
              endRec.y += 2;

              // If nothing has changed then stop here
              if (lastStartRec != null && lastStartRec.x == startRec.x && lastStartRec.y == startRec.y && lastEndRec != null && lastEndRec.x == endRec.x && lastEndRec.y == endRec.y) {
                return;
              }

              if (selRect == null) {
                var rx = startRec.x;
                var ry = startRec.y;
                var rw = (endRec.x + endRec.width) - startRec.x;
                if (rw < 0) {
                  rx += rw;
                  rw = -rw;
                }
                var rh = Math.max(startRec.height, endRec.height);

                selRect = new Array();
                var activeSelRect = makeSelRect(rx, ry, rw, rh);
                selRect.push(activeSelRect);
                startsAt.parentNode.parentNode.parentNode.insertBefore(activeSelRect, startsAt.parentNode.parentNode);
              } else {
                if (startRec.x != lastStartRec.x && endRec.x != lastEndRec.x && (startRec.y != lastStartRec.y || endRec.y != lastEndRec.y)) {
                  if (startRec.y < lastStartRec.y) {
                    selRect[0].setAttributeNS(null, "width", lastStartRec.width);
                    lastEndRec = lastStartRec;
                  } else if (endRec.y > lastEndRec.y) {
                    selRect[selRect.length - 1].setAttributeNS(null, "x",
                      parseFloat(selRect[selRect.length - 1].getAttributeNS(null, "x"))
                      + parseFloat(selRect[selRect.length - 1].getAttributeNS(null, "width"))
                      - lastEndRec.width);
                    selRect[selRect.length - 1].setAttributeNS(null, "width", 0);
                    lastStartRec = lastEndRec;
                  }
                }

                // Start has moved
                var flip = !(startRec.x == lastStartRec.x && startRec.y == lastStartRec.y);
                // If the height of the start or end changed we need to check whether
                // to remove multi line highlights no longer needed if the user went back towards their start line
                // and whether to create new ones if we moved to a newline
                if (((endRec.y != lastEndRec.y)) || ((startRec.y != lastStartRec.y))) {
                  // First check if we have to remove the first highlights because we are moving towards the end on a different line
                  var ss = 0;
                  for (; ss != selRect.length; ss++) {
                    if (startRec.y <= parseFloat(selRect[ss].getAttributeNS(null, "y"))) {
                      break;
                    }
                  }
                  // Next check for any end highlights if we are moving towards the start on a different line
                  var es = selRect.length - 1;
                  for (; es != -1; es--) {
                    if (endRec.y >= parseFloat(selRect[es].getAttributeNS(null, "y"))) {
                      break;
                    }
                  }
                  // TODO put this in loops above, for efficiency the array slicing could be done separate still in single call
                  var trunc = false;
                  if (ss < selRect.length) {
                    for (var s2 = 0; s2 != ss; s2++) {
                      selRect[s2].parentNode.removeChild(selRect[s2]);
                      es--;
                      trunc = true;
                    }
                    selRect = selRect.slice(ss);
                  }
                  if (es > -1) {
                    for (var s2 = selRect.length - 1; s2 != es; s2--) {
                      selRect[s2].parentNode.removeChild(selRect[s2]);
                      trunc = true;
                    }
                    selRect = selRect.slice(0, es + 1);
                  }

                  // If we have truncated the highlights we need to readjust the last one
                  if (trunc) {
                    var activeSelRect = flip ? selRect[0] : selRect[selRect.length - 1];
                    if (flip) {
                      var rw = 0;
                      if (startRec.y == endRec.y) {
                        rw = (endRec.x + endRec.width) - startRec.x;
                      } else {
                        rw = (parseFloat(activeSelRect.getAttributeNS(null, "x"))
                          + parseFloat(activeSelRect.getAttributeNS(null, "width")))
                          - startRec.x;
                      }
                      activeSelRect.setAttributeNS(null, "x", startRec.x);
                      activeSelRect.setAttributeNS(null, "y", startRec.y);
                      activeSelRect.setAttributeNS(null, "width", rw);
                    } else {
                      var rw = (endRec.x + endRec.width) - parseFloat(activeSelRect.getAttributeNS(null, "x"));
                      activeSelRect.setAttributeNS(null, "width", rw);
                    }
                  } else {
                    // We didnt truncate anything but we have moved to a new line so we need to create a new highlight
                    var lastSel = flip ? selRect[0] : selRect[selRect.length - 1];
                    var startBox = startsAt.parentNode.getBBox();
                    var endBox = endsAt.parentNode.getBBox();

                    if (flip) {
                      lastSel.setAttributeNS(null, "width",
                        (parseFloat(lastSel.getAttributeNS(null, "x"))
                          + parseFloat(lastSel.getAttributeNS(null, "width")))
                        - endBox.x);
                      lastSel.setAttributeNS(null, "x", endBox.x);
                    } else {
                      lastSel.setAttributeNS(null, "width",
                        (startBox.x + startBox.width)
                        - parseFloat(lastSel.getAttributeNS(null, "x")));
                    }
                    var rx = 0;
                    var ry = 0;
                    var rw = 0;
                    var rh = 0;
                    if (flip) {
                      rx = startRec.x;
                      ry = startRec.y;
                      rw = $(svg._svg).width() - startRec.x;
                      rh = startRec.height;
                    } else {
                      rx = endBox.x;
                      ry = endRec.y;
                      rw = (endRec.x + endRec.width) - endBox.x;
                      rh = endRec.height;
                    }
                    var newRect = makeSelRect(rx, ry, rw, rh);
                    if (flip) {
                      selRect.unshift(newRect);
                    } else {
                      selRect.push(newRect);
                    }

                    // Place new highlight in appropriate slot in SVG graph
                    startsAt.parentNode.parentNode.parentNode.insertBefore(newRect, startsAt.parentNode.parentNode);
                  }
                } else {
                  // The user simply moved left or right along the same line so just adjust the current highlight
                  var activeSelRect = flip ? selRect[0] : selRect[selRect.length - 1];
                  // If the start moved shift the highlight and adjust width
                  if (flip) {
                    var rw = (parseFloat(activeSelRect.getAttributeNS(null, "x"))
                      + parseFloat(activeSelRect.getAttributeNS(null, "width")))
                      - startRec.x;
                    activeSelRect.setAttributeNS(null, "x", startRec.x);
                    activeSelRect.setAttributeNS(null, "y", startRec.y);
                    activeSelRect.setAttributeNS(null, "width", rw);
                  } else {
                    // If the end moved then simple change the width
                    var rw = (endRec.x + endRec.width)
                      - parseFloat(activeSelRect.getAttributeNS(null, "x"));
                    activeSelRect.setAttributeNS(null, "width", rw);
                  }
                }
              }
              lastStartRec = startRec;
              lastEndRec = endRec;
            }
          }
          arcDragJustStarted = false;
        };

        var adjustToCursor = function (evt, element, centerX, centerY) {
          var screenHeight = $(window).height() - 8; // TODO HACK - no idea why -8 is needed
          var screenWidth = $(window).width() - 8;
          var elementHeight = element.height();
          var elementWidth = element.width();
          var cssSettings = {};
          var eLeft;
          var eTop;
          if (centerX) {
            eLeft = evt.clientX - elementWidth / 2;
          } else {
            eLeft = evt.clientX;
          }
          if (centerY) {
            eTop = evt.clientY - elementHeight / 2;
          } else {
            eTop = evt.clientY;
          }
          // Try to make sure the element doesn't go off-screen.
          // If this isn't possible (the element is larger than the screen),
          // alight top-left corner of screen and dialog as a compromise.
          if (screenWidth > elementWidth) {
            eLeft = Math.min(Math.max(eLeft, 0), screenWidth - elementWidth);
          } else {
            eLeft = 0;
          }
          if (screenHeight > elementHeight) {
            eTop = Math.min(Math.max(eTop, 0), screenHeight - elementHeight);
          } else {
            eTop = 0;
          }
          element.css({top: eTop, left: eLeft});
        };

        var updateCheckbox = function ($input) {
          var $widget = $input.button('widget');
          var $textspan = $widget.find('.ui-button-text');
          $textspan.html(($input[0].checked ? '&#x2611; ' : '&#x2610; ') + $widget.attr('data-bare'));
        };

        var fillSpanTypesAndDisplayForm = function (evt, spanText, span) {
          keymap = spanKeymap;

          // Figure out whether we should show or hide one of the two
          // main halves of the selection frame (entities / events).
          // This depends on the type of the current span, if any, and
          // the availability of types to select.
          var hideFrame;
          if (span) {
            // existing span; only show relevant half
            if (span.generalType == 'entity') {
              hideFrame = 'event';
            } else {
              hideFrame = 'entity';
            }
            spanForm.dialog('option', {title: 'Edit Annotation'});
          } else {
            // new span; show everything that's available
            if ($('#event_types').find('input').length == 0) {
              hideFrame = 'event';
            } else if ($('#entity_types').find('input').length == 0) {
              hideFrame = 'entity';
            } else {
              hideFrame = 'none';
            }
            spanForm.dialog('option', {title: 'New Annotation'});
          }
          if (hideFrame == 'event') {
            $('#span_event_section').hide()
            $('#span_entity_section').show().removeClass('wrapper_half_left').addClass('wrapper_full_width');
          } else if (hideFrame == 'entity') {
            $('#span_entity_section').hide()
            $('#span_event_section').show().removeClass('wrapper_half_right').addClass('wrapper_full_width');
          } else {
            // show both entity and event halves
            $('#span_entity_section').show().removeClass('wrapper_full_width').addClass('wrapper_half_left');
            $('#span_event_section').show().removeClass('wrapper_full_width').addClass('wrapper_half_right');
          }

          // only show "delete" button if there's an existing annotation to delete
          if (span) {
            $('#del_span_button').show();
          } else {
            $('#del_span_button').hide();
          }

          $('#span_selected').text(spanText);
          var encodedText = encodeURIComponent(spanText);
          $.each(searchConfig, function (searchNo, search) {
            $('#span_' + search[0]).attr('href', search[1].replace('%s', encodedText));
          });

          // enable all inputs by default (see setSpanTypeSelectability)
          $('#span_form input:not([unused])').removeAttr('disabled');

          // close span types if there's over spanTypesToShowBeforeCollapse
          if ($('#entity_types .item').length > spanTypesToShowBeforeCollapse) {
            $('#entity_types .open').removeClass('open');
          }
          if ($('#event_types .item').length > spanTypesToShowBeforeCollapse) {
            $('#event_types .open').removeClass('open');
          }

          var showAllAttributes = false;
          if (span) {
            var hash = new URLHash(coll, doc, {focus: [[span.id]]}).getHash();
            $('#span_highlight_link').attr('href', hash).show();
            var el = $('#span_' + span.type);
            if (el.length) {
              el[0].checked = true;
            } else {
              $('#span_form input:radio:checked').each(function (radioNo, radio) {
                radio.checked = false;
              });
            }

            // open the span type
            $('#span_' + span.type).parents('.collapsible').each(function () {
              toggleCollapsible($(this).parent().prev(), true);
            });

            // count the repeating arc types
            var arcTypeCount = {};
            repeatingArcTypes = [];
            $.each(span.outgoing, function (arcNo, arc) {
              // parse out possible number suffixes to allow e.g. splitting
              // on "Theme" for args ("Theme1", "Theme2").
              var splitArcType = arc.type.match(/^(.*?)(\d*)$/);
              var noNumArcType = splitArcType[1];
              if ((arcTypeCount[noNumArcType] = (arcTypeCount[noNumArcType] || 0) + 1) == 2) {
                repeatingArcTypes.push(noNumArcType);
              }
            });
            if (repeatingArcTypes.length) {
              $('#span_form_split').show();
            } else {
              $('#span_form_split').hide();
            }
          } else {
            $('#span_highlight_link').hide();
            var firstRadio = $('#span_form input:radio:not([unused]):first')[0];
            if (firstRadio) {
              firstRadio.checked = true;
            } else {
              dispatcher.post('hideForm');
              dispatcher.post('messages', [[['No valid span types defined', 'error']]]);
              return;
            }
            $('#span_form_split').hide();
            $('#span_notes').val('');
            showAllAttributes = true;
          }
          if (span && !reselectedSpan) {
            $('#span_form_reselect, #span_form_delete, #span_form_add_fragment').show();
            keymap[$.ui.keyCode.DELETE] = 'span_form_delete';
            keymap[$.ui.keyCode.INSERT] = 'span_form_reselect';
            keymap['S-' + $.ui.keyCode.ENTER] = 'span_form_add_fragment';
            $('#span_notes').val(span.annotatorNotes || '');
          } else {
            $('#span_form_reselect, #span_form_delete, #span_form_add_fragment').hide();
            keymap[$.ui.keyCode.DELETE] = null;
            keymap[$.ui.keyCode.INSERT] = null;
            keymap['S-' + $.ui.keyCode.ENTER] = null;
          }
          if (span && !reselectedSpan && span.offsets.length > 1) {
            $('#span_form_reselect_fragment, #span_form_delete_fragment').show();
            keymap['S-' + $.ui.keyCode.DELETE] = 'span_form_delete_fragment';
            keymap['S-' + $.ui.keyCode.INSERT] = 'span_form_reselect_fragment';
          } else {
            $('#span_form_reselect_fragment, #span_form_delete_fragment').hide();
            keymap['S-' + $.ui.keyCode.DELETE] = null;
            keymap['S-' + $.ui.keyCode.INSERT] = null;
          }
          // TODO: lots of redundancy in the next two blocks, clean up
          if (!span) {
            // no existing annotation, reset attributes
            var attrCategoryAndTypes = [['entity', entityAttributeTypes],
              ['event', eventAttributeTypes]];
            $.each(attrCategoryAndTypes, function (ctNo, ct) {
              var category = ct[0];
              var attributeTypes = ct[1];
              $.each(attributeTypes, function (attrNo, attr) {
                $input = $('#' + category + '_attr_' + Util.escapeQuotes(attr.type));
                if (attr.unused) {
                  $input.val('');
                } else if (attr.bool) {
                  $input[0].checked = false;
                  updateCheckbox($input);
                  $input.button('refresh');
                } else {
                  $input.val('').change();
                }
              });
            });
          } else if (!reselectedSpan) {
            // existing annotation, fill attribute values from span
            var attributeTypes;
            var category;
            if (span.generalType == 'entity') {
              attributeTypes = entityAttributeTypes;
              category = 'entity';
            } else if (span.generalType == 'trigger') {
              attributeTypes = eventAttributeTypes;
              // TODO: unify category/generalType values ('trigger' vs. 'event')
              category = 'event';
            } else {
              console.error('Unrecognized generalType:', span.generalType);
            }
            $.each(attributeTypes, function (attrNo, attr) {
              $input = $('#' + category + '_attr_' + Util.escapeQuotes(attr.type));
              var val = span.attributes[attr.type];
              if (attr.unused) {
                $input.val(val || '');
              } else if (attr.bool) {
                $input[0].checked = val;
                updateCheckbox($input);
                $input.button('refresh');
              } else {
                $input.val(val || '').change();
              }
            });
          }

          var showValidNormalizationsFor = function (type) {
            // set DB selector to the first appropriate for the type.
            // TODO: actually disable inappropriate ones.
            // TODO: support specific IDs, not just DB specifiers
            var firstDb = type && normDbsByType[type] ? normDbsByType[type][0] : null;
            if (firstDb) {
              $('#span_norm_db').val(firstDb);
            }
          }

          showValidNormalizations = function () {
            // set norm DB selector according to the first selected type
            var firstSelected = $('#entity_and_event_wrapper input:radio:checked')[0];
            var selectedType = firstSelected ? firstSelected.value : null;
            showValidNormalizationsFor(selectedType);
          }

          // fill normalizations (if any)
          if (!reselectedSpan) {
            // clear first
            clearNormalizationUI();

            var $normDb = $('#span_norm_db');
            var $normId = $('#span_norm_id');
            var $normText = $('#span_norm_txt');

            // fill if found (NOTE: only shows last on multiple)
            var normFilled = false;
            $.each(span ? span.normalizations : [], function (normNo, norm) {
              var refDb = norm[0], refId = norm[1], refText = norm[2];
              $normDb.val(refDb);
              // could the DB selector be set? (i.e. is refDb configured?)
              if ($normDb.val() == refDb) {
                // DB is OK, set the rest also
                $normId.val(refId);
                oldSpanNormIdValue = refId;
                $normText.val(refText);
                // TODO: check if ID is valid
                $normId.addClass('valid_value')
                normFilled = true;
              } else {
                // can't set the DB selector; assume DB is not configured,
                // warn and leave blank (will remove norm when dialog is OK'd)
                dispatcher.post('messages', [[['Warning: ' + refDb + ' not configured, removing normalization.', 'warning']]]);
              }
            });

            // if there is no existing normalization, show valid ones
            if (!normFilled) {
              showValidNormalizations();
            }

            // update links
            updateNormalizationRefLink();
            updateNormalizationDbLink();
          }

          var showAttributesFor = function (attrTypes, category, type) {
            var validAttrs = type ? spanTypes[type].attributes : [];
            var shownCount = 0;
            $.each(attrTypes, function (attrNo, attr) {
              var $input = $('#' + category + '_attr_' + Util.escapeQuotes(attr.type));
              var showAttr = showAllAttributes || $.inArray(attr.type, validAttrs) != -1;
              if (showAttr) {
                $input.button('widget').show();
                shownCount++;
              } else {
                $input.button('widget').hide();
              }
            });
            return shownCount;
          }

          showValidAttributes = function () {
            var type = $('#span_form input:radio:checked').val();
            var entityAttrCount = showAttributesFor(entityAttributeTypes, 'entity', type);
            var eventAttrCount = showAttributesFor(eventAttributeTypes, 'event', type);

            showAllAttributes = false;
            // show attribute frames only if at least one attribute is
            // shown, and set size classes appropriately
            if (eventAttrCount > 0) {
              $('#event_attributes').show();
              $('#event_attribute_label').show();
              $('#event_types').removeClass('scroll_wrapper_full').addClass('scroll_wrapper_upper');
            } else {
              $('#event_attributes').hide();
              $('#event_attribute_label').hide();
              $('#event_types').removeClass('scroll_wrapper_upper').addClass('scroll_wrapper_full');
            }
            if (entityAttrCount > 0) {
              $('#entity_attributes').show();
              $('#entity_attribute_label').show();
              $('#entity_types').removeClass('scroll_wrapper_full').addClass('scroll_wrapper_upper');
            } else {
              $('#entity_attributes').hide();
              $('#entity_attribute_label').hide();
              $('#entity_types').removeClass('scroll_wrapper_upper').addClass('scroll_wrapper_full');
            }
          }
          showValidAttributes();

          // TODO XXX: if seemed quite unexpected/unintuitive that the
          // form was re-displayed while the document still shows the
          // annotation in its old location in the background (check it).
          // The fix of skipping confirm is not really good either, though.
          if (reselectedSpan) { // && !Configuration.confirmModeOn) {
            submitReselect();
          } else {
            dispatcher.post('showForm', [spanForm, spanOptions]);
            $('#span_form-ok').focus();
            adjustToCursor(evt, spanForm.parent());
          }
        };

        var submitReselect = function () {
          $(reselectedSpan.rect).removeClass('reselect');
          reselectedSpan = null;
          spanForm.submit();
        };

        var rapidFillSpanTypesAndDisplayForm = function (start, end, text, types) {
          // variant of fillSpanTypesAndDisplayForm for rapid annotation mode
          keymap = spanKeymap;
          $('#rapid_span_selected').text(text);

          // fill types
          var $spanTypeDiv = $('#rapid_span_types_div');
          // remove previously filled, if any
          $spanTypeDiv.empty();
          $.each(types, function (typeNo, typeAndProb) {
            // TODO: this duplicates a part of addSpanTypesToDivInner, unify
            var type = typeAndProb[0];
            var prob = typeAndProb[1];
            var $numlabel = $('<span class="accesskey">' + (typeNo + 1) + '</span><span>:</span>');
            var $input = $('<input type="radio" name="rapid_span_type"/>').attr('id', 'rapid_span_' + (typeNo + 1)).attr('value', type);
            var spanBgColor = spanTypes[type] && spanTypes[type].bgColor || '#ffffff';
            spanBgColor = Util.adjustColorLightness(spanBgColor, spanBoxTextBgColorLighten);
            // use preferred label instead of type name if available
            var name = spanTypes[type] && spanTypes[type].name || type;
            var $label = $('<label class="span_type_label"/>').attr('for', 'rapid_span_' + (typeNo + 1)).text(name + ' (' + (100.0 * prob).toFixed(1) + '%)');
            $label.css('background-color', spanBgColor);
            // TODO: check for unnecessary extra wrapping here
            var $content = $('<div class="item_content"/>').append($numlabel).append($input).append($label);
            $spanTypeDiv.append($content);
            // highlight configured hotkey (if any) in text.
            // NOTE: this bit doesn't actually set up the hotkey.
            var hotkeyType = 'span_' + type;
            // TODO: this is clumsy; there should be a better way
            var typeHotkey = null;
            $.each(keymap, function (key, keyType) {
              if (keyType == hotkeyType) {
                typeHotkey = key;
                return false;
              }
            });
            if (typeHotkey) {
              var name = $label.html();
              var replace = true;
              name = name.replace(new RegExp("(&[^;]*?)?(" + typeHotkey + ")", 'gi'),
                function (all, entity, letter) {
                  if (replace && !entity) {
                    replace = false;
                    var hotkey = typeHotkey.toLowerCase() == letter
                      ? typeHotkey.toLowerCase()
                      : typeHotkey.toUpperCase();
                    return '<span class="accesskey">' + Util.escapeHTML(hotkey) + '</span>';
                  }
                  return all;
                });
              $label.html(name);
            }
            // Limit the number of suggestions to the number of numeric keys
            if (typeNo >= 8) {
              return false;
            }
          });
          // fill in some space and the special "Other" option, with key "0" (zero)
          $spanTypeDiv.append($('<div class="item_content">&#160;</div>')); // non-breaking space
          var $numlabel = $('<span class="accesskey">0</span><span>:</span>');
          var $input = $('<input type="radio" name="rapid_span_type" id="rapid_span_0" value=""/>');
          var $label = $('<label class="span_type_label" for="rapid_span_0" style="background-color:lightgray">Other...</label>');
          var $content = $('<div class="item_content"/>').append($numlabel).append($input).append($label);
          $spanTypeDiv.append($content);

          // set up click event handlers
          rapidSpanForm.find('#rapid_span_types input:radio').click(rapidSpanFormSubmitRadio);

          var firstRadio = $('#rapid_span_form input:radio:first')[0];
          if (firstRadio) {
            firstRadio.checked = true;
          } else {
            dispatcher.post('hideForm');
            dispatcher.post('messages', [[['No valid span types defined', 'error']]]);
            return;
          }
          dispatcher.post('showForm', [rapidSpanForm]);
          rapidAnnotationDialogVisible = true;
          $('#rapid_span_form-ok').focus();
          // TODO: avoid using global for stored click event
//         adjustToCursor(lastRapidAnnotationEvent, rapidSpanForm.parent(),
//                        true, true);
          // TODO: avoid coordinate hack to position roughly at first
          // available selection
          lastRapidAnnotationEvent.clientX -= 55;
          lastRapidAnnotationEvent.clientY -= 115;
          adjustToCursor(lastRapidAnnotationEvent, rapidSpanForm.parent(),
            false, false);
        };

        var clearSpanNotes = function (evt) {
          $('#span_notes').val('');
        }
        $('#clear_notes_button').button();
        $('#clear_notes_button').click(clearSpanNotes);

        var clearSpanNorm = function (evt) {
          clearNormalizationUI();
        }
        $('#clear_norm_button').button();
        $('#clear_norm_button').click(clearSpanNorm);

        // invoked on response to ajax request for id lookup
        var setSpanNormText = function (response) {
          if (response.exception) {
            // TODO: better response to failure
            dispatcher.post('messages', [[['Lookup error', 'warning', -1]]]);
            return false;
          }
          // set input style according to whether we have a valid value
          var $idinput = $('#span_norm_id');
          // TODO: make sure the key echo in the response matches the
          // current value of the $idinput
          $idinput.removeClass('valid_value').removeClass('invalid_value');
          if (response.value === null) {
            $idinput.addClass('invalid_value');
            hideNormalizationRefLink();
          } else {
            $idinput.addClass('valid_value');
            updateNormalizationRefLink();
          }
          $('#span_norm_txt').val(response.value);
        }

        // on any change to the normalization DB, clear everything and
        // update link
        var spanNormDbUpdate = function (evt) {
          clearNormalizationUI();
          updateNormalizationDbLink();
        }
        $('#span_norm_db').change(spanNormDbUpdate);

        // on any change to the normalization ID, update the text of the
        // reference
        var spanNormIdUpdate = function (evt) {
          var key = $(this).val();
          var db = $('#span_norm_db').val();
          if (key != oldSpanNormIdValue) {
            if (key.match(/^\s*$/)) {
              // don't query empties, just clear instead
              clearNormalizationUI();
            } else {
              dispatcher.post('ajax', [{
                action: 'normGetName',
                database: db,
                key: key,
                collection: coll
              }, 'normGetNameResult']);
            }
            oldSpanNormIdValue = key;
          }
        }
        // see http://stackoverflow.com/questions/1948332/detect-all-changes-to-a-input-type-text-immediately-using-jquery
        $('#span_norm_id').bind('propertychange keyup input paste', spanNormIdUpdate);
        // nice-looking select for normalization
        $('#span_norm_db').addClass('ui-widget ui-state-default ui-button-text');

        var normSearchDialog = $('#norm_search_dialog');
        initForm(normSearchDialog, {
          width: 800,
          width: 600,
          resizable: true,
          alsoResize: '#norm_search_result_select',
          open: function (evt) {
            keymap = {};
          },
          close: function (evt) {
            // assume that we always want to return to the span dialog
            // on normalization dialog close
            dispatcher.post('showForm', [spanForm]);
          },
        });

// BRAT STAND ALONE LIBRARY BEGIN
        /*
      $('#norm_search_query').autocomplete({
        source: function(request, callback) {
          var query = $.ui.autocomplete.escapeRegex(request.term);
          var pattern = new RegExp('\\b' + query, 'i');
          callback($.grep(lastNormSearches, function(search) {
            return pattern.test(search.value) || pattern.test(search.id);
          }));
        },
        minLength: 0,
        select: function(evt, ui) {
          evt.stopPropagation();
          normSubmit(ui.item.id, ui.item.value);
        },
        focus: function(evt, ui) {
          // do nothing
        },
      }).data('autocomplete')._renderItem = function($ul, item) {
        return $('<li></li>').
          data('item.autocomplete', item).
          append('<a>' + Util.escapeHTML(item.value) + '<div class="autocomplete-id">' + Util.escapeHTML(item.id) + "</div></a>").
          appendTo($ul);
      };
*/
// BRAT STAND ALONE LIBRARY END

        var normSubmit = function (selectedId, selectedTxt) {
          // we got a value; act if it was a submit
          $('#span_norm_id').val(selectedId);
          // don't forget to update this reference value
          oldSpanNormIdValue = selectedId;
          $('#span_norm_txt').val(selectedTxt);
          updateNormalizationRefLink();
          // update history
          var nextLastNormSearches = [
            {
              value: selectedTxt,
              id: selectedId,
            },
          ];
          $.each(lastNormSearches, function (searchNo, search) {
            if (search.id != selectedId || search.value != selectedTxt) {
              nextLastNormSearches.push(search);
            }
          });
          lastNormSearches = nextLastNormSearches;
          lastNormSearches.slice(0, maxNormSearchHistory);
          // Switch dialogs. NOTE: assuming we closed the spanForm when
          // bringing up the normSearchDialog.
          normSearchDialog.dialog('close');
        };
        var normSearchSubmit = function (evt) {
          if (normSearchSubmittable) {
            var selectedId = $('#norm_search_id').val();
            var selectedTxt = $('#norm_search_query').val();

            normSubmit(selectedId, selectedTxt);
          } else {
            performNormSearch();
          }
          return false;
        }
        var normSearchSubmittable = false;
        var setNormSearchSubmit = function (enable) {
          $('#norm_search_dialog-ok').button(enable ? 'enable' : 'disable');
          normSearchSubmittable = enable;
        };
        normSearchDialog.submit(normSearchSubmit);
        var chooseNormId = function (evt) {
          var $element = $(evt.target).closest('tr');
          $('#norm_search_result_select tr').removeClass('selected');
          $element.addClass('selected');
          $('#norm_search_query').val($element.attr('data-txt'));
          $('#norm_search_id').val($element.attr('data-id'));
          setNormSearchSubmit(true);
        }
        var chooseNormIdAndSubmit = function (evt) {
          chooseNormId(evt);
          normSearchSubmit(evt);
        }
        var setSpanNormSearchResults = function (response) {
          if (response.exception) {
            // TODO: better response to failure
            dispatcher.post('messages', [[['Lookup error', 'warning', -1]]]);
            return false;
          }

          if (response.items.length == 0) {
            // no results
            $('#norm_search_result_select thead').empty();
            $('#norm_search_result_select tbody').empty();
            dispatcher.post('messages', [[['No matches to search.', 'comment']]]);
            return false;
          }

          // TODO: avoid code duplication with showFileBrowser()

          var html = ['<tr>'];
          $.each(response.header, function (headNo, head) {
            html.push('<th>' + Util.escapeHTML(head[0]) + '</th>');
          });
          html.push('</tr>');
          $('#norm_search_result_select thead').html(html.join(''));

          html = [];
          var len = response.header.length;
          $.each(response.items, function (itemNo, item) {
            // NOTE: assuming ID is always the first datum in the item
            // and that the preferred text is always the second
            // TODO: Util.escapeQuotes would be expected to be
            // sufficient here, but that appears to give "DOM Exception
            // 11" in cases (try e.g. $x.html('<p a="A&B"/>'). Why? Is
            // this workaround OK?
            html.push('<tr' +
              ' data-id="' + Util.escapeHTMLandQuotes(item[0]) + '"' +
              ' data-txt="' + Util.escapeHTMLandQuotes(item[1]) + '"' +
              '>');
            for (var i = 0; i < len; i++) {
              html.push('<td>' + Util.escapeHTML(item[i]) + '</td>');
            }
            html.push('</tr>');
          });
          $('#norm_search_result_select tbody').html(html.join(''));

          $('#norm_search_result_select tbody').find('tr').click(chooseNormId).dblclick(chooseNormIdAndSubmit);

          // TODO: sorting on click on header (see showFileBrowser())
        }
        var performNormSearch = function () {
          var val = $('#norm_search_query').val();
          var db = $('#span_norm_db').val();
          dispatcher.post('ajax', [{
            action: 'normSearch',
            database: db,
            name: val,
            collection: coll
          }, 'normSearchResult']);
        }
        $('#norm_search_button').click(performNormSearch);
        $('#norm_search_query').focus(function () {
          setNormSearchSubmit(false);
        });
        var showNormSearchDialog = function () {
          // if we already have non-empty ID and normalized string,
          // use these as default; otherwise take default search string
          // from annotated span and clear ID entry
          if (!$('#span_norm_id').val().match(/^\s*$/) &&
            !$('#span_norm_txt').val().match(/^\s*$/)) {
            $('#norm_search_id').val($('#span_norm_id').val());
            $('#norm_search_query').val($('#span_norm_txt').val());
          } else {
            $('#norm_search_id').val('');
            $('#norm_search_query').val($('#span_selected').text());
          }
          // blank the table
          $('#norm_search_result_select thead').empty();
          $('#norm_search_result_select tbody').empty();
          // TODO: support for two (or more) dialogs open at the same time
          // so we don't need to hide this before showing normSearchDialog
          dispatcher.post('hideForm');
          $('#norm_search_button').val('Search ' + $('#span_norm_db').val());
          setNormSearchSubmit(false);
          dispatcher.post('showForm', [normSearchDialog]);
          $('#norm_search_query').focus().select();
        }
        $('#span_norm_txt').click(showNormSearchDialog);
        $('#norm_search_button').button();

        var arcFormSubmitRadio = function (evt) {
          // TODO: check for confirm_mode?
          arcFormSubmit(evt, $(evt.target));
        }

        var arcFormSubmit = function (evt, typeRadio) {
          typeRadio = typeRadio || $('#arc_form input:radio:checked');
          var type = typeRadio.val();
          dispatcher.post('hideForm', [arcForm]);

          arcOptions.type = type;
          arcOptions.comment = $('#arc_notes').val();
          dispatcher.post('ajax', [arcOptions, 'edited']);
          return false;
        };

        var fillArcTypesAndDisplayForm = function (evt, originType, targetType, arcType, arcId) {
          var noArcs = true;
          keymap = {};

          // separate out possible numeric suffix from type
          var noNumArcType;
          if (arcType) {
            var splitType = arcType.match(/^(.*?)(\d*)$/);
            noNumArcType = splitType[1];
          }

          var isEquiv =
            relationTypesHash &&
            relationTypesHash[noNumArcType] &&
            relationTypesHash[noNumArcType].properties &&
            relationTypesHash[noNumArcType].properties.symmetric &&
            relationTypesHash[noNumArcType].properties.transitive;

          var $scroller = $();
          if (spanTypes[originType]) {
            var arcTypes = spanTypes[originType].arcs;
            $scroller = $('#arc_roles .scroller').empty();

            // lay them out into the form
            $.each(arcTypes || [], function (arcTypeNo, arcDesc) {
              if (arcDesc.targets && arcDesc.targets.indexOf(targetType) != -1) {
                var arcTypeName = arcDesc.type;

                var isThisEquiv =
                  relationTypesHash &&
                  relationTypesHash[arcTypeName] &&
                  relationTypesHash[arcTypeName].properties &&
                  relationTypesHash[arcTypeName].properties.symmetric &&
                  relationTypesHash[arcTypeName].properties.transitive;

                // do not allow equiv<->non-equiv change options
                if (arcType && isEquiv != isThisEquiv) return;

                var displayName = ((arcDesc.labels && arcDesc.labels[0]) ||
                  arcTypeName);
                var $checkbox = $('<input id="arc_' + arcTypeName + '" type="radio" name="arc_type" value="' + arcTypeName + '"/>');
                var $label = $('<label class="arc_type_label" for="arc_' + arcTypeName + '"/>').text(displayName);
                var $div = $('<div/>').append($checkbox).append($label);
                $scroller.append($div);
                if (arcDesc.hotkey) {
                  keymap[arcDesc.hotkey] = '#arc_' + arcTypeName;
                  var name = $label.html();
                  var replace = true;
                  name = name.replace(new RegExp("(&[^;]*?)?(" + arcDesc.hotkey + ")", 'gi'),
                    function (all, entity, letter) {
                      if (replace && !entity) {
                        replace = false;
                        var hotkey = arcDesc.hotkey.toLowerCase() == letter
                          ? arcDesc.hotkey.toLowerCase()
                          : arcDesc.hotkey.toUpperCase();
                        return '<span class="accesskey">' + Util.escapeHTML(hotkey) + '</span>';
                      }
                      return all;
                    });
                  $label.html(name);
                }

                noArcs = false;
              }
            });
          }

          if (noArcs) {
            if (arcId) {
              // let the user delete or whatever, even on bad config
              // (note that what's shown to the user is w/o possible num suffix)
              var $checkbox = $('<input id="arc_' + arcType + '" type="hidden" name="arc_type" value="' + noNumArcType + '"/>');
              $scroller.append($checkbox);
            } else {
              // can't make a new arc
              dispatcher.post('messages',
                [[["No choices for " +
                Util.spanDisplayForm(spanTypes, originType) +
                " -> " +
                Util.spanDisplayForm(spanTypes, targetType),
                  'warning']]]);
              return;
            }
          }

          var reversalPossible = false;
          if (arcId) {
            // something was selected
            var focus = arcId instanceof Array ? arcId : [arcId];
            var hash = new URLHash(coll, doc, {focus: [focus]}).getHash();
            $('#arc_highlight_link').attr('href', hash).show(); // TODO incorrect
            var el = $('#arc_' + arcType)[0];
            if (el) {
              el.checked = true;
            } else {
              // try w/o numeric suffix
              el = $('#arc_' + noNumArcType)[0];
              if (el) {
                el.checked = true;
              }
            }

            $('#arc_form_reselect, #arc_form_delete').show();
            keymap[$.ui.keyCode.DELETE] = 'arc_form_delete';
            keymap[$.ui.keyCode.INSERT] = 'arc_form_reselect';

            var backTargetType = spanTypes[targetType];
            if (backTargetType) {
              $.each(backTargetType.arcs || [], function (backArcTypeNo, backArcDesc) {
                if ($.inArray(originType, backArcDesc.targets || []) != -1) {
                  reversalPossible = true;
                  return false; // terminate the loop
                }
              });
            }

            arcForm.dialog('option', {title: 'Edit Annotation'});
          } else {
            // new arc
            $('#arc_highlight_link').hide();
            el = $('#arc_form input:radio:first')[0];
            if (el) {
              el.checked = true;
            }

            $('#arc_form_reselect, #arc_form_delete, #arc_form_reverse').hide();

            arcForm.dialog('option', {title: 'New Annotation'});
          }
          if (reversalPossible) {
            $('#arc_form_reverse').show();
            keymap['S-' + $.ui.keyCode.INSERT] = 'arc_form_reverse';
          } else {
            $('#arc_form_reverse').hide();
          }

          if (!Configuration.confirmModeOn) {
            arcForm.find('#arc_roles input:radio').click(arcFormSubmitRadio);
          }

          var arcAnnotatorNotes;
          var isBinaryRelation = arcId && !(arcId instanceof Array);
          if (isBinaryRelation) {
            // only for relation arcs
            var ed = data.eventDescs[arcId];
            arcAnnotatorNotes = ed && ed.annotatorNotes;
          }
          if (arcAnnotatorNotes) {
            $('#arc_notes').val(arcAnnotatorNotes);
          } else {
            $('#arc_notes').val('');
          }

          // disable notes for arc types that don't support storage (#945)
          if (!isBinaryRelation || isEquiv) {
            // disable the actual input
            $('#arc_notes').attr('disabled', 'disabled');
            // add to fieldset for style
            $('#arc_notes_fieldset').attr('disabled', 'disabled');
          } else {
            $('#arc_notes').removeAttr('disabled')
            $('#arc_notes_fieldset').removeAttr('disabled')
          }

          dispatcher.post('showForm', [arcForm]);
          $('#arc_form-ok').focus();
          adjustToCursor(evt, arcForm.parent());
        };

        var reverseArc = function (evt) {
          var eventDataId = $(evt.target).attr('data-arc-ed');
          dispatcher.post('hideForm');
          arcOptions.action = 'reverseArc';
          delete arcOptions.old_target;
          delete arcOptions.old_type;
          dispatcher.post('ajax', [arcOptions, 'edited']);
        };

        var deleteArc = function (evt) {
          if (Configuration.confirmModeOn && !confirm("Are you sure you want to delete this annotation?")) {
            return;
          }
          var eventDataId = $(evt.target).attr('data-arc-ed');
          dispatcher.post('hideForm');
          arcOptions.action = 'deleteArc';
          dispatcher.post('ajax', [arcOptions, 'edited']);
        };

        var reselectArc = function (evt) {
          dispatcher.post('hideForm');
          svgElement.addClass('reselect');
          $('g[data-from="' + arcOptions.origin + '"][data-to="' + arcOptions.target + '"]').addClass('reselect');
          startArcDrag(arcOptions.origin);
        };

        var arcForm = $('#arc_form');
        dispatcher.post('initForm', [arcForm, {
          width: 500,
          buttons: [{
            id: 'arc_form_reverse',
            text: "Reverse",
            click: reverseArc
          }, {
            id: 'arc_form_delete',
            text: "Delete",
            click: deleteArc
          }, {
            id: 'arc_form_reselect',
            text: 'Reselect',
            click: reselectArc
          }],
          alsoResize: '#arc_roles',
          close: function (evt) {
            keymap = null;
          }
        }]);
        arcForm.submit(arcFormSubmit);
        // set button tooltips (@amadanmath: can this be done in init?)
        $('#arc_form_reselect').attr('title', 'Re-select the annotation this connects into.');
        $('#arc_form_delete').attr('title', 'Delete this annotation.');

        var stopArcDrag = function (target) {
          if (arcDragOrigin) {
            if (!target) {
              target = $('.badTarget');
            }
            target.removeClass('badTarget');
            arcDragOriginGroup.removeClass('highlight');
            if (target) {
              target.parent().removeClass('highlight');
            }
            if (arcDragArc) {
              svg.remove(arcDragArc);
              arcDrag = null;
            }
            arcDragOrigin = null;
            if (arcOptions) {
              $('g[data-from="' + arcOptions.origin + '"][data-to="' + arcOptions.target + '"]').removeClass('reselect');
            }
            svgElement.removeClass('reselect');
          }
          svgElement.removeClass('unselectable');
          $('.reselectTarget').removeClass('reselectTarget');
        };

        var onMouseUp = function (evt) {
          //Removed by Renaud on 2016-03-10
          //if (that.user === null) return;

          var target = $(evt.target);

          // three things that are clickable in SVG
          var targetSpanId = target.data('span-id');
          var targetChunkId = target.data('chunk-id');
          var targetArcRole = target.data('arc-role');
          if (!(targetSpanId !== undefined || targetChunkId !== undefined || targetArcRole !== undefined)) {
            // misclick
            clearSelection();
            stopArcDrag(target);
            return;
          }

          // is it arc drag end?
          if (arcDragOrigin) {
            var origin = arcDragOrigin;
            var targetValid = target.hasClass('reselectTarget');
            stopArcDrag(target);
            if ((id = target.attr('data-span-id')) && origin != id && targetValid) {
              var originSpan = data.spans[origin];
              var targetSpan = data.spans[id];
              if (arcOptions && arcOptions.old_target) {
                arcOptions.target = targetSpan.id;
                dispatcher.post('ajax', [arcOptions, 'edited']);
              } else {
                arcOptions = {
                  action: 'createArc',
                  origin: originSpan.id,
                  target: targetSpan.id,
                  collection: coll,
                  'document': doc
                };
                $('#arc_origin').text(Util.spanDisplayForm(spanTypes, originSpan.type) + ' ("' + originSpan.text + '")');
                $('#arc_target').text(Util.spanDisplayForm(spanTypes, targetSpan.type) + ' ("' + targetSpan.text + '")');
                fillArcTypesAndDisplayForm(evt, originSpan.type, targetSpan.type);
                // for precise timing, log dialog display to user.
                dispatcher.post('logAction', ['arcSelected']);
              }
            }
          } else if (!evt.ctrlKey) {
            // if not, then is it span selection? (ctrl key cancels)
            var sel = window.getSelection();
            var chunkIndexFrom = sel.anchorNode && $(sel.anchorNode.parentNode).attr('data-chunk-id');
            var chunkIndexTo = sel.focusNode && $(sel.focusNode.parentNode).attr('data-chunk-id');

            // fallback for firefox (at least):
            // it's unclear why, but for firefox the anchor and focus
            // node parents are always undefined, the the anchor and
            // focus nodes themselves do (often) have the necessary
            // chunk ID. However, anchor offsets are almost always
            // wrong, so we'll just make a guess at what the user might
            // be interested in tagging instead of using what's given.
            var anchorOffset = null;
            var focusOffset = null;
            if (chunkIndexFrom === undefined && chunkIndexTo === undefined &&
              $(sel.anchorNode).attr('data-chunk-id') &&
              $(sel.focusNode).attr('data-chunk-id')) {
              // A. Scerri FireFox chunk

              var range = sel.getRangeAt(0);
              var svgOffset = $(svg._svg).offset();
              var flip = false;
              var tries = 0;
              while (tries < 2) {
                var sp = svg._svg.createSVGPoint();
                sp.x = (flip ? evt.pageX : dragStartedAt.pageX) - svgOffset.left;
                sp.y = (flip ? evt.pageY : dragStartedAt.pageY) - (svgOffset.top + 8);
                var startsAt = range.startContainer;
                anchorOffset = startsAt.getCharNumAtPosition(sp);
                chunkIndexFrom = startsAt && $(startsAt).attr('data-chunk-id');
                if (anchorOffset != -1) {
                  break;
                }
                flip = true;
                tries++;
              }
              sp.x = (flip ? dragStartedAt.pageX : evt.pageX) - svgOffset.left;
              sp.y = (flip ? dragStartedAt.pageY : evt.pageY) - (svgOffset.top + 8);
              var endsAt = range.endContainer;
              focusOffset = endsAt.getCharNumAtPosition(sp);

              if (range.startContainer == range.endContainer && anchorOffset > focusOffset) {
                var t = anchorOffset;
                anchorOffset = focusOffset;
                focusOffset = t;
                flip = false;
              }
              if (focusOffset != -1) {
                focusOffset++;
              }
              chunkIndexTo = endsAt && $(endsAt).attr('data-chunk-id');

              //console.log('fallback from', data.chunks[chunkIndexFrom], anchorOffset);
              //console.log('fallback to', data.chunks[chunkIndexTo], focusOffset);
            } else {
              // normal case, assume the exact offsets are usable
              anchorOffset = sel.anchorOffset;
              focusOffset = sel.focusOffset;
            }

            if (chunkIndexFrom !== undefined && chunkIndexTo !== undefined) {
              var chunkFrom = data.chunks[chunkIndexFrom];
              var chunkTo = data.chunks[chunkIndexTo];
              var selectedFrom = chunkFrom.from + anchorOffset;
              var selectedTo = chunkTo.from + focusOffset;
              sel.removeAllRanges();

              if (selectedFrom > selectedTo) {
                var tmp = selectedFrom;
                selectedFrom = selectedTo;
                selectedTo = tmp;
              }
              // trim
              while (selectedFrom < selectedTo && " \n\t".indexOf(data.text.substr(selectedFrom, 1)) !== -1) selectedFrom++;
              while (selectedFrom < selectedTo && " \n\t".indexOf(data.text.substr(selectedTo - 1, 1)) !== -1) selectedTo--;

              // shift+click allows zero-width spans
              if (selectedFrom === selectedTo && !evt.shiftKey) {
                // simple click (zero-width span)
                return;
              }

              var newOffset = [selectedFrom, selectedTo];
              if (reselectedSpan) {
                var newOffsets = reselectedSpan.offsets.slice(0); // clone
                spanOptions.old_offsets = JSON.stringify(reselectedSpan.offsets);
                if (selectedFragment !== null) {
                  if (selectedFragment !== false) {
                    newOffsets.splice(selectedFragment, 1);
                  }
                  newOffsets.push(newOffset);
                  newOffsets.sort(Util.cmpArrayOnFirstElement);
                  spanOptions.offsets = newOffsets;
                } else {
                  spanOptions.offsets = [newOffset];
                }
              } else {
                spanOptions = {
                  action: 'createSpan',
                  offsets: [newOffset]
                }
              }

              /* In relation to #786, removed the cross-sentence checking code
            var crossSentence = true;
            $.each(sourceData.sentence_offsets, function(sentNo, startEnd) {
              if (selectedTo <= startEnd[1]) {
                // this is the sentence

                if (selectedFrom >= startEnd[0]) {
                  crossSentence = false;
                }
                return false;
              }
            });

            if (crossSentence) {
              // attempt to annotate across sentence boundaries; not supported
              dispatcher.post('messages', [[['Error: cannot annotate across a sentence break', 'error']]]);
              if (reselectedSpan) {
                $(reselectedSpan.rect).removeClass('reselect');
              }
              reselectedSpan = null;
              svgElement.removeClass('reselect');
            } else
*/
              if (!Configuration.rapidModeOn || reselectedSpan != null) {
                // normal span select in standard annotation mode
                // or reselect: show selector
                var spanText = data.text.substring(selectedFrom, selectedTo);
                fillSpanTypesAndDisplayForm(evt, spanText, reselectedSpan);
                // for precise timing, log annotation display to user.
                dispatcher.post('logAction', ['spanSelected']);
              } else {
                // normal span select in rapid annotation mode: call
                // server for span type candidates
                var spanText = data.text.substring(selectedFrom, selectedTo);
                // TODO: we're currently storing the event to position the
                // span form using adjustToCursor() (which takes an event),
                // but this is clumsy and suboptimal (user may have scrolled
                // during the ajax invocation); think of a better way.
                lastRapidAnnotationEvent = evt;
                dispatcher.post('ajax', [{
                  action: 'suggestSpanTypes',
                  collection: coll,
                  'document': doc,
                  start: selectedFrom,
                  end: selectedTo,
                  text: spanText,
                  model: $('#rapid_model').val(),
                }, 'suggestedSpanTypes']);
              }
            }
          }
        };

        var receivedSuggestedSpanTypes = function (sugg) {
          if (sugg.exception) {
            // failed in one way or another; assume rapid mode cannot be
            // used.
            dispatcher.post('messages', [[['Rapid annotation mode error; returning to normal mode.', 'warning', -1]]]);
            setAnnotationSpeed(2);
            dispatcher.post('configurationUpdated');
            return false;
          }

          // make sure the suggestions are for the current collection and document
          if (sugg.collection != coll || sugg.document != doc) {
            dispatcher.post('messages', [[['Error: collection/document mismatch for span suggestions', 'error']]]);
            return false;
          }
          // initialize for submission
          // TODO: is this a reasonable place to do this?
          rapidSpanOptions = {
            offsets: [[sugg.start, sugg.end]],
          };
          rapidFillSpanTypesAndDisplayForm(sugg.start, sugg.end, sugg.text, sugg.types);
        };

        var toggleCollapsible = function ($el, state) {
          var opening = state !== undefined ? state : !$el.hasClass('open');
          var $collapsible = $el.parent().find('.collapsible:first');
          if (opening) {
            $collapsible.addClass('open');
            $el.addClass('open');
          } else {
            $collapsible.removeClass('open');
            $el.removeClass('open');
          }
        };

        var collapseHandler = function (evt) {
          toggleCollapsible($(evt.target));
        }

        var spanFormSubmitRadio = function (evt) {
          if (Configuration.confirmModeOn) {
            showValidAttributes();
            showValidNormalizations();
            $('#span_form-ok').focus();
          } else {
            spanFormSubmit(evt, $(evt.target));
          }
        }

        var rapidSpanFormSubmitRadio = function (evt) {
          rapidSpanFormSubmit(evt, $(evt.target));
        }

        var rememberData = function (_data) {
          if (_data && !_data.exception) {
            data = _data;
          }
        };

        var addSpanTypesToDivInner = function ($parent, types, category) {
          if (!types) return;

          $.each(types, function (typeNo, type) {
            if (type === null) {
              $parent.append('<hr/>');
            } else {
              var name = type.name;
              var $input = $('<input type="radio" name="span_type"/>').attr('id', 'span_' + type.type).attr('value', type.type);
              if (category) {
                $input.attr('category', category);
              }
              // use a light version of the span color as BG
              var spanBgColor = spanTypes[type.type] && spanTypes[type.type].bgColor || '#ffffff';
              spanBgColor = Util.adjustColorLightness(spanBgColor, spanBoxTextBgColorLighten);
              var $label = $('<label class="span_type_label"/>').attr('for', 'span_' + type.type).text(name);
              if (type.unused) {
                $input.attr({
                  disabled: 'disabled',
                  unused: 'unused'
                });
                $label.css('font-weight', 'bold');
              } else {
                $label.css('background-color', spanBgColor);
              }
              var $collapsible = $('<div class="collapsible open"/>');
              var $content = $('<div class="item_content"/>').append($input).append($label).append($collapsible);
              var $collapser = $('<div class="collapser open"/>');
              var $div = $('<div class="item"/>');
              if (type.children.length) {
                $div.append($collapser)
              }
              $div.append($content);
              addSpanTypesToDivInner($collapsible, type.children, category);
              $parent.append($div);
              if (type.hotkey) {
                spanKeymap[type.hotkey] = 'span_' + type.type;
                var name = $label.html();
                var replace = true;
                name = name.replace(new RegExp("(&[^;]*?)?(" + type.hotkey + ")", 'gi'),
                  function (all, entity, letter) {
                    if (replace && !entity) {
                      replace = false;
                      var hotkey = type.hotkey.toLowerCase() == letter
                        ? type.hotkey.toLowerCase()
                        : type.hotkey.toUpperCase();
                      return '<span class="accesskey">' + Util.escapeHTML(hotkey) + '</span>';
                    }
                    return all;
                  });
                $label.html(name);
              }
            }
          });
        };
        var addSpanTypesToDiv = function ($top, types, heading) {
          $scroller = $('<div class="scroller"/>');
          $legend = $('<legend/>').text(heading);
          $fieldset = $('<fieldset/>').append($legend).append($scroller);
          $top.append($fieldset);
          addSpanTypesToDivInner($scroller, types);
        };
        var addAttributeTypesToDiv = function ($top, types, category) {
          $.each(types, function (attrNo, attr) {
            var escapedType = Util.escapeQuotes(attr.type);
            var attrId = category + '_attr_' + escapedType;
            if (attr.unused) {
              var $input = $('<input type="hidden" id="' + attrId + '" value=""/>');
              $top.append($input);
            } else if (attr.bool) {
              var escapedName = Util.escapeQuotes(attr.name);
              var $input = $('<input type="checkbox" id="' + attrId +
                '" value="' + escapedType +
                '" category="' + category + '"/>');
              var $label = $('<label class="attribute_type_label" for="' + attrId +
                '" data-bare="' + escapedName + '">&#x2610; ' +
                escapedName + '</label>');
              $top.append($input).append($label);
              $input.button();
              $input.change(onBooleanAttrChange);
            } else {
              var $div = $('<div class="ui-button ui-button-text-only attribute_type_label"/>');
              var $select = $('<select id="' + attrId + '" class="ui-widget ui-state-default ui-button-text" category="' + category + '"/>');
              var $option = $('<option class="ui-state-default" value=""/>').text(attr.name + ': ?');
              $select.append($option);
              $.each(attr.values, function (valType, value) {
                $option = $('<option class="ui-state-active" value="' + Util.escapeQuotes(valType) + '"/>').text(attr.name + ': ' + (value.name || valType));
                $select.append($option);
              });
              $div.append($select);
              $top.append($div);
              $select.change(onMultiAttrChange);
            }
          });
        }

        var setSpanTypeSelectability = function (category) {
          // TODO: this implementation is incomplete: we should ideally
          // disable not only categories of types (events or entities),
          // but the specific set of types that are incompatible with
          // the current attribute settings.

          // just assume all attributes are event attributes
          // TODO: support for entity attributes
          // TODO2: the above comment is almost certainly false, check and remove
          $('#span_form input:not([unused])').removeAttr('disabled');
          var $toDisable;
          if (category == "event") {
            $toDisable = $('#span_form input[category="entity"]');
          } else if (category == "entity") {
            $toDisable = $('#span_form input[category="event"]');
          } else {
            console.error('Unrecognized attribute category:', category);
            $toDisable = $();
          }
          var $checkedToDisable = $toDisable.filter(':checked');
          $toDisable.attr('disabled', true);
          // the disable may leave the dialog in a state where nothing
          // is checked, which would cause error on "OK". In this case,
          // check the first valid choice.
          if ($checkedToDisable.length) {
            var $toCheck = $('#span_form input[category="' + category + '"]:first');
            // so weird, attr('checked', 'checked') fails sometimes, so
            // replaced with more "metal" version
            $toCheck[0].checked = true
          }
        }

        var onMultiAttrChange = function (evt) {
          if ($(this).val() == '') {
            $('#span_form input:not([unused])').removeAttr('disabled');
          } else {
            var attrCategory = evt.target.getAttribute('category');
            setSpanTypeSelectability(attrCategory);
            if (evt.target.selectedIndex) {
              $(evt.target).addClass('ui-state-active');
            } else {
              $(evt.target).removeClass('ui-state-active');
            }
          }
        }

        var onBooleanAttrChange = function (evt) {
          var attrCategory = evt.target.getAttribute('category');
          setSpanTypeSelectability(attrCategory);
          updateCheckbox($(evt.target));
        };

        var rememberSpanSettings = function (response) {
          spanKeymap = {};

          // TODO: check for exceptions in response

          // fill in entity and event types
          var $entityScroller = $('#entity_types div.scroller').empty();
          addSpanTypesToDivInner($entityScroller, response.entity_types, 'entity');
          var $eventScroller = $('#event_types div.scroller').empty();
          addSpanTypesToDivInner($eventScroller, response.event_types, 'event');

          // fill in attributes
          var $entattrs = $('#entity_attributes div.scroller').empty();
          addAttributeTypesToDiv($entattrs, entityAttributeTypes, 'entity');

          var $eveattrs = $('#event_attributes div.scroller').empty();
          addAttributeTypesToDiv($eveattrs, eventAttributeTypes, 'event');

          // fill search options in span dialog
          searchConfig = response.search_config;
          var $searchlinks = $('#span_search_links').empty();
          var $searchlinks2 = $('#viewspan_search_links').empty();
          var firstLink = true;
          var linkFilled = false;
          if (searchConfig) {
            $.each(searchConfig, function (searchNo, search) {
              if (!firstLink) {
                $searchlinks.append(',\n')
                $searchlinks2.append(',\n')
              }
              firstLink = false;
              $searchlinks.append('<a target="_blank" id="span_' + search[0] + '" href="#">' + search[0] + '</a>');
              $searchlinks2.append('<a target="_blank" id="viewspan_' + search[0] + '" href="#">' + search[0] + '</a>');
              linkFilled = true;
            });
          }
          if (linkFilled) {
            $('#span_search_fieldset').show();
            $('#viewspan_search_fieldset').show();
          } else {
            $('#span_search_fieldset').hide();
            $('#viewspan_search_fieldset').hide();
          }

          spanForm.find('#entity_types input:radio').click(spanFormSubmitRadio);
          spanForm.find('#event_types input:radio').click(spanFormSubmitRadio);
          spanForm.find('.collapser').click(collapseHandler);
        };

        var tagCurrentDocument = function (taggerId) {
          var tagOptions = {
            action: 'tag',
            collection: coll,
            'document': doc,
            tagger: taggerId,
          };
          dispatcher.post('ajax', [tagOptions, 'edited']);
        }

        var setupTaggerUI = function (response) {
          var taggers = response.ner_taggers || [];
          $taggerButtons = $('#tagger_buttons').empty();
          $.each(taggers, function (taggerNo, tagger) {
            // expect a tuple with ID, name, model, and URL
            var taggerId = tagger[0];
            var taggerName = tagger[1];
            var taggerModel = tagger[2];
            if (!taggerId || !taggerName || !taggerModel) {
              dispatcher.post('messages', [[['Invalid tagger specification received from server', 'error']]]);
              return true; // continue
            }
            var $row = $('<div class="optionRow"/>');
            var $label = $('<span class="optionLabel">' + Util.escapeHTML(taggerName) + '</span>');
            var $button = $('<input id="tag_' + Util.escapeHTML(taggerId) + '_button" type="button" value="' + Util.escapeHTML(taggerModel) + '" tabindex="-1" title="Automatically tag the current document."/>');
            $row.append($label).append($button);
            $taggerButtons.append($row);
            $button.click(function (evt) {
              tagCurrentDocument(taggerId);
            });
          });
          $taggerButtons.find('input').button();
          // if nothing was set up, hide the whole fieldset and show
          // a message to this effect, else the other way around
          if ($taggerButtons.find('input').length == 0) {
            $('#auto_tagging_fieldset').hide();
            $('#no_tagger_message').show();
          } else {
            $('#auto_tagging_fieldset').show();
            $('#no_tagger_message').hide();
          }
        }

        // recursively traverses type hierarchy (entity_types or
        // event_types) and stores normalizations in normDbsByType.
        var rememberNormDbsForType = function (types) {
          if (!types) return;

          $.each(types, function (typeNo, type) {
            if (type === null) {
              // spacer, no-op
            } else {
              normDbsByType[type.type] = type.normalizations || [];
              if (type.children.length) {
                rememberNormDbsForType(type.children);
              }
            }
          });
        };

        var setupNormalizationUI = function (response) {
          var norm_resources = response.normalization_config || [];
          var $norm_select = $('#span_norm_db');
          // clear possible existing
          $norm_select.empty();
          // fill in new
          html = [];
          $.each(norm_resources, function (normNo, norm) {
            var normName = norm[0], normUrl = norm[1], normUrlBase = norm[2];
            var serverDb = norm[3];
            html.push('<option value="' + Util.escapeHTML(normName) + '">' +
              Util.escapeHTML(normName) + '</option>');
            // remember the urls for updates
            normDbUrlByDbName[normName] = normUrl;
            normDbUrlBaseByDbName[normName] = normUrlBase;
          });
          // remember per-type appropriate DBs
          normDbsByType = {};
          rememberNormDbsForType(response.entity_types);
          rememberNormDbsForType(response.event_types);
          // set up HTML
          $norm_select.html(html.join(''));
          // if we have nothing, just hide the whole thing
          if (!norm_resources.length) {
            $('#norm_fieldset').hide();
          } else {
            $('#norm_fieldset').show();
          }
        }

        // hides the reference link in the normalization UI
        var hideNormalizationRefLink = function () {
          $('#span_norm_ref_link').hide();
        }

        // updates the reference link in the normalization UI according
        // to the current value of the normalization DB and ID.
        var updateNormalizationRefLink = function () {
          var $normId = $('#span_norm_id');
          var $normLink = $('#span_norm_ref_link');
          var normId = $normId.val();
          var $normDb = $('#span_norm_db');
          var normDb = $normDb.val();
          if (!normId || !normDb || normId.match(/^\s*$/)) {
            $normLink.hide();
          } else {
            var base = normDbUrlBaseByDbName[normDb];
            // assume hidden unless everything goes through
            $normLink.hide();
            if (!base) {
              // base URL is now optional, just skip link generation if not set
              ;
            } else if (base.indexOf('%s') == -1) {
              dispatcher.post('messages', [[['Base URL "' + base + '" for ' + normDb + ' does not contain "%s"', 'error']]]);
            } else {
              // TODO: protect against strange chars in ID
              link = base.replace('%s', normId);
              $normLink.attr('href', link);
              $normLink.show();
            }
          }
        }

        // updates the DB search link in the normalization UI according
        // to the current value of the normalization DB.
        var updateNormalizationDbLink = function () {
          var $dbLink = $('#span_norm_db_link');
          var $normDb = $('#span_norm_db');
          var normDb = $normDb.val();
          if (!normDb) return; // no normalisation configured
          var link = normDbUrlByDbName[normDb];
          if (!link || link.match(/^\s*$/)) {
            dispatcher.post('messages', [[['No URL for ' + normDb, 'error']]]);
            $dbLink.hide();
          } else {
            // TODO: protect against weirdness in DB link
            $dbLink.attr('href', link);
            $dbLink.show();
          }
        }

        // resets user-settable normalization-related UI elements to a
        // blank state (does not blank #span_norm_db <select>).
        var clearNormalizationUI = function () {
          var $normId = $('#span_norm_id');
          var $normText = $('#span_norm_txt');
          $normId.val('');
          oldSpanNormIdValue = '';
          $normId.removeClass('valid_value').removeClass('invalid_value');
          $normText.val('');
          updateNormalizationRefLink();
        }

        // returns the normalizations currently filled in the span
        // dialog, or empty list if there are none
        var spanNormalizations = function () {
          // Note that only no or one normalization is supported in the
          // UI at the moment.
          var normalizations = [];
          var normDb = $('#span_norm_db').val();
          var normId = $('#span_norm_id').val();
          var normText = $('#span_norm_txt').val();
          // empty ID -> no normalization
          if (!normId.match(/^\s*$/)) {
            normalizations.push([normDb, normId, normText]);
          }
          return normalizations;
        }

        // returns attributes that are valid for the selected type in
        // the span dialog
        var spanAttributes = function (typeRadio) {
          typeRadio = typeRadio || $('#span_form input:radio:checked');
          var attributes = {};
          var attributeTypes;
          var category = typeRadio.attr('category');
          if (category == 'entity') {
            attributeTypes = entityAttributeTypes;
          } else if (category == 'event') {
            attributeTypes = eventAttributeTypes;
          } else {
            console.error('Unrecognized type category:', category);
          }
          $.each(attributeTypes, function (attrNo, attr) {
            var $input = $('#' + category + '_attr_' + Util.escapeQuotes(attr.type));
            if (attr.bool) {
              attributes[attr.type] = $input[0].checked;
            } else if ($input[0].selectedIndex) {
              attributes[attr.type] = $input.val();
            }
          });
          return attributes;
        }

        var spanAndAttributeTypesLoaded = function (_spanTypes,
                                                    _entityAttributeTypes,
                                                    _eventAttributeTypes,
                                                    _relationTypesHash) {
          spanTypes = _spanTypes;
          entityAttributeTypes = _entityAttributeTypes;
          eventAttributeTypes = _eventAttributeTypes;
          relationTypesHash = _relationTypesHash;
          // for easier access
          allAttributeTypes = $.extend({},
            entityAttributeTypes,
            eventAttributeTypes);
        };

        var gotCurrent = function (_coll, _doc, _args) {
          coll = _coll;
          doc = _doc;
          args = _args;
        };

        var undoStack = [];
        var edited = function (response) {
          var x = response.exception;
          if (x) {
            if (x == 'annotationIsReadOnly') {
              dispatcher.post('messages', [[["This document is read-only and can't be edited.", 'error']]]);
            } else if (x == 'spanOffsetOverlapError') {
              // createSpan with overlapping frag offsets; reset offsets
              // @amadanmath: who holds the list of offsets for a span?
              // how to reset this?
            } else {
              dispatcher.post('messages', [[['Unknown error ' + x, 'error']]]);
            }
            if (reselectedSpan) {
              $(reselectedSpan.rect).removeClass('reselect');
              reselectedSpan = null;
            }
            svgElement.removeClass('reselect');
            $('#waiter').dialog('close');
          } else {
            if (response.edited == undefined) {
              console.warn('Warning: server response to edit has', response.edited, 'value for "edited"');
            } else {
              args.edited = response.edited;
            }
            var sourceData = response.annotations;
            sourceData.document = doc;
            sourceData.collection = coll;
            // this "prevent" is to protect against reloading (from the
            // server) the very data that we just received as part of the
            // response to the edit.
            if (response.undo != undefined) {
              undoStack.push([coll, sourceData.document, response.undo]);
            }
            dispatcher.post('preventReloadByURL');
            dispatcher.post('setArguments', [args]);
            dispatcher.post('renderData', [sourceData]);
          }
        };


        // TODO: why are these globals defined here instead of at the top?
        var spanForm = $('#span_form');
        var rapidSpanForm = $('#rapid_span_form');

        var deleteSpan = function () {
          if (Configuration.confirmModeOn && !confirm("Are you sure you want to delete this annotation?")) {
            return;
          }
          $.extend(spanOptions, {
            action: 'deleteSpan',
            collection: coll,
            'document': doc,
          });
          spanOptions.offsets = JSON.stringify(spanOptions.offsets);
          dispatcher.post('ajax', [spanOptions, 'edited']);
          dispatcher.post('hideForm');
          $('#waiter').dialog('open');
        };

        var reselectSpan = function () {
          dispatcher.post('hideForm');
          svgElement.addClass('reselect');
          $(editedSpan.rect).addClass('reselect');
          reselectedSpan = editedSpan;
          selectedFragment = null;
        };

        var splitForm = $('#split_form');
        splitForm.submit(function (evt) {
          var splitRoles = [];
          $('#split_roles input:checked').each(function () {
            splitRoles.push($(this).val());
          });
          $.extend(spanOptions, {
            action: 'splitSpan',
            'args': $.toJSON(splitRoles),
            collection: coll,
            'document': doc,
          });
          spanOptions.offsets = JSON.stringify(spanOptions.offsets);
          dispatcher.post('hideForm');
          dispatcher.post('ajax', [spanOptions, 'edited']);
          return false;
        });
        dispatcher.post('initForm', [splitForm, {
          alsoResize: '.scroll_fset',
          width: 400
        }]);
        var splitSpan = function () {
          dispatcher.post('hideForm');
          var $roles = $('#split_roles').empty();
          var numRoles = repeatingArcTypes.length;
          var roles = $.each(repeatingArcTypes, function () {
            var $role = $('<input id="split_on_' + Util.escapeQuotes(this) +
              '" type="checkbox" name="' + Util.escapeQuotes(this) +
              '" value="' + Util.escapeQuotes(this) + '"/>');
            if (numRoles == 1) {
              // a single role will be selected automatically
              $role.click();
            }
            var $label = $('<label for="split_on_' + Util.escapeQuotes(this) +
              '">' + Util.escapeQuotes(this) + '</label>');
            $roles.append($role).append($label);
          });
          var $roleButtons = $roles.find('input').button();

          dispatcher.post('showForm', [splitForm]);
        };

        var addFragment = function () {
          dispatcher.post('hideForm');
          svgElement.addClass('reselect');
          $(editedSpan.rect).addClass('reselect');
          reselectedSpan = editedSpan;
          selectedFragment = false;
        };

        var reselectFragment = function () {
          addFragment();
          selectedFragment = editedFragment;
        };

        var deleteFragment = function () {
          if (Configuration.confirmModeOn && !confirm("Are you sure you want to delete this fragment?")) {
            return;
          }
          var offsets = editedSpan.offsets;
          spanOptions.old_offsets = JSON.stringify(offsets);
          offsets.splice(editedFragment, 1);

          $.extend(spanOptions, {
            collection: coll,
            'document': doc,
            offsets: JSON.stringify(offsets),
          });

          spanOptions.attributes = $.toJSON(spanAttributes());

          spanOptions.normalizations = $.toJSON(spanNormalizations());

          dispatcher.post('ajax', [spanOptions, 'edited']);
          dispatcher.post('hideForm');
          $('#waiter').dialog('open');
        };

        dispatcher.post('initForm', [spanForm, {
          alsoResize: '#entity_and_event_wrapper',
          width: 760,
          buttons: [{
            id: 'span_form_add_fragment',
            text: "Add Frag.",
            click: addFragment
          }, {
            id: 'span_form_delete',
            text: "Delete",
            click: deleteSpan
          }, {
            id: 'span_form_delete_fragment',
            text: "Delete Frag.",
            click: deleteFragment
          }, {
            id: 'span_form_reselect',
            text: 'Move',
            click: reselectSpan
          }, {
            id: 'span_form_reselect_fragment',
            text: 'Move Frag.',
            click: reselectFragment
          }, {
            id: 'span_form_split',
            text: 'Split',
            click: splitSpan
          }
          ],
          close: function (evt) {
            keymap = null;
            if (reselectedSpan) {
              $(reselectedSpan.rect).removeClass('reselect');
              reselectedSpan = null;
              svgElement.removeClass('reselect');
            }
          }
        }]);
        // set button tooltips (@amadanmath: can this be done in init?)
        $('#span_form_reselect').attr('title', 'Re-select the text span that this annotation marks.');
        $('#span_form_delete').attr('title', 'Delete this annotation.');
        $('#span_form_split').attr('title', 'Split this annotation into multiple similar annotations, distributing its arguments.');

        dispatcher.post('initForm', [rapidSpanForm, {
          alsoResize: '#rapid_span_types',
          width: 400,
          close: function (evt) {
            keymap = null;
          }
        }]);

        var spanFormSubmit = function (evt, typeRadio) {
          typeRadio = typeRadio || $('#span_form input:radio:checked');
          var type = typeRadio.val();
          $('#span_form-ok').blur();
          dispatcher.post('hideForm');
          $.extend(spanOptions, {
            action: 'createSpan',
            collection: coll,
            'document': doc,
            type: type,
            comment: $('#span_notes').val()
          });

          spanOptions.attributes = $.toJSON(spanAttributes());

          spanOptions.normalizations = $.toJSON(spanNormalizations());

          if (spanOptions.offsets) {
            spanOptions.offsets = $.toJSON(spanOptions.offsets);
          }

          // unfocus all elements to prevent focus being kept after
          // hiding them
          spanForm.parent().find('*').blur();

          $('#waiter').dialog('open');
          dispatcher.post('ajax', [spanOptions, 'edited']);
          return false;
        };
        $('#span_notes').focus(function () {
          keymap = null;
        }).blur(function () {
          keymap = spanKeymap;
        });
        spanForm.submit(spanFormSubmit);

        var rapidSpanFormSubmit = function (evt, typeRadio) {
          typeRadio = typeRadio || $('#rapid_span_form input:radio:checked');
          var type = typeRadio.val();

          // unfocus all elements to prevent focus being kept after
          // hiding them
          rapidSpanForm.parent().find('*').blur();
          dispatcher.post('hideForm');

          if (type == "") {
            // empty type value signals the special case where the user
            // selected "none of the above" of the proposed types and
            // the normal dialog should be brought up for the same span.
            spanOptions = {
              action: 'createSpan',
              offsets: rapidSpanOptions.offsets,
            };
            // TODO: avoid using the stored mouse event
            fillSpanTypesAndDisplayForm(lastRapidAnnotationEvent,
              $('#rapid_span_selected').text());
            dispatcher.post('logAction', ['normalSpanSelected']);
          } else {
            // normal type selection; submit createSpan with the selected type.
            $.extend(rapidSpanOptions, {
              action: 'createSpan',
              collection: coll,
              'document': doc,
              type: type,
            });
            $('#waiter').dialog('open');
            rapidSpanOptions.offsets = JSON.stringify(rapidSpanOptions.offsets);
            dispatcher.post('ajax', [rapidSpanOptions, 'edited']);
          }
          return false;
        };
        rapidSpanForm.submit(rapidSpanFormSubmit);

        var importForm = $('#import_form');
        var importFormSubmit = function (evt) {
          var _docid = $('#import_docid').val();
          var _doctitle = $('#import_title').val();
          var _doctext = $('#import_text').val();
          var opts = {
            action: 'importDocument',
            collection: coll,
            docid: _docid,
            title: _doctitle,
            text: _doctext,
          };
          dispatcher.post('ajax', [opts, function (response) {
            var x = response.exception;
            if (x) {
              if (x == 'fileExistsError') {
                dispatcher.post('messages', [[["A file with the given name exists. Please give a different name to the file to import.", 'error']]]);
              } else {
                dispatcher.post('messages', [[['Unknown error: ' + response.exception, 'error']]]);
              }
            } else {
              dispatcher.post('hideForm');
              dispatcher.post('setDocument', [response.document]);
            }
          }]);
          return false;
        };
        importForm.submit(importFormSubmit);
        dispatcher.post('initForm', [importForm, {
          width: 500,
          alsoResize: '#import_text',
          open: function (evt) {
            keymap = {};
          },
        }]);
        $('#import_button').click(function () {
          dispatcher.post('hideForm');
          dispatcher.post('showForm', [importForm]);
          importForm.find('input, textarea').val('');
        });

        /* BEGIN delete button - related */

        $('#delete_document_button').click(function () {
          if (!doc) {
            dispatcher.post('messages', [[['No document selected', 'error']]]);
            return false;
          }
          if (!confirm('Are you sure you want to permanently remove this document and its annotations from the collection? This action cannot be undone.')) {
            return;
          }
          var delOptions = {
            action: 'deleteDocument',
            collection: coll,
            'document': doc
          }
          dispatcher.post('ajax', [delOptions, 'docDeleted']);
        });

        $('#delete_collection_button').click(function () {
          if (!coll) {
            dispatcher.post('messages', [[['No collection selected', 'error']]]);
            return false;
          }
          if (!confirm('Are you sure you want to permanently REMOVE the ENTIRE COLLECTION ' + coll + ', including all its documents and their annotations?  This action CANNOT BE UNDONE.')) {
            return;
          }
          var delOptions = {
            action: 'deleteCollection',
            collection: coll,
          }
          dispatcher.post('ajax', [delOptions, 'collDeleted']);
        });

        /* END delete button - related */

        $('#undo_button').click(function () {
          if (coll && doc) {
            if (undoStack.length > 0) {
              var storedUndo = undoStack.pop();
              var collection = storedUndo[0];
              var dok = storedUndo[1];
              var token = storedUndo[2];
              var options = {
                'action': 'undo',
                'collection': collection,
                'document': dok,
                'token': token
              }
              dispatcher.post('ajax', [options, 'edited']);
            } else {
              dispatcher.post('messages', [[['No action to be undone', 'error']]]);
            }
          } else {
            dispatcher.post('messages', [[['No document loaded, can not undo changes', 'error']]]);
          }
        });


        var preventDefault = function (evt) {
          evt.preventDefault();
        }

        var $waiter = $('#waiter');
        $waiter.dialog({
          closeOnEscape: false,
          buttons: {},
          modal: true,
          open: function (evt, ui) {
            $(evt.target).parent().find(".ui-dialog-titlebar-close").hide();
          }
        });
        // hide the waiter (Sampo said it's annoying)
        // we don't elliminate it altogether because it still provides the
        // overlay to prevent interaction
        // $waiter.parent().css('opacity', '0');

        var isReloadOkay = function () {
          // do not reload while the user is in the middle of editing
          return arcDragOrigin == null && reselectedSpan == null;
        };

        var userReceived = function (_user) {
          that.user = _user;
        }

        var setAnnotationSpeed = function (speed) {
          if (speed == 1) {
            Configuration.confirmModeOn = true;
          } else {
            Configuration.confirmModeOn = false;
          }
          if (speed == 3) {
            Configuration.rapidModeOn = true;
          } else {
            Configuration.rapidModeOn = false;
          }
          dispatcher.post('configurationChanged');
        };

        var onNewSourceData = function (_sourceData) {
          sourceData = _sourceData;
        }

        var init = function () {
          dispatcher.post('annotationIsAvailable');
        };

        var collectionLoaded = function (collData) {
          coll = collData;
        };

        var requestRenderData = function (docData) {
          doc = docData;
        };

        dispatcher.on('init', init).on('getValidArcTypesForDrag', getValidArcTypesForDrag).on('dataReady', rememberData).on('requestRenderData', requestRenderData).on('collectionLoaded', collectionLoaded).on('collectionLoaded', rememberSpanSettings).on('collectionLoaded', setupTaggerUI).on('collectionLoaded', setupNormalizationUI).on('spanAndAttributeTypesLoaded', spanAndAttributeTypesLoaded).on('newSourceData', onNewSourceData).on('hideForm', hideForm).on('user', userReceived).on('edited', edited).on('current', gotCurrent).on('isReloadOkay', isReloadOkay).on('keydown', onKeyDown).on('dblclick', onDblClick).on('dragstart', preventDefault).on('mousedown', onMouseDown).on('mouseup', onMouseUp).on('mousemove', onMouseMove).on('annotationSpeed', setAnnotationSpeed).on('suggestedSpanTypes', receivedSuggestedSpanTypes).on('normGetNameResult', setSpanNormText).on('normSearchResult', setSpanNormSearchResults);
      };

      return AnnotatorUI;
    })(jQuery, window);

// BRAT STANDALONE LIBRARY BEGIN
// Browserify export
    module.exports = AnnotatorUI;
// BRAT STANDALONE LIBRARY END

  }, {}], 11: [function (require, module, exports) {
// -*- Mode: JavaScript; tab-width: 2; indent-tabs-mode: nil; -*-
// vim:set ft=javascript ts=2 sw=2 sts=2 cindent:
    var Configuration = (function (window, undefined) {
      var Configuration = function () {
        var that = this;
        that.abbrevsOn = true;
        that.textBackgrounds = "striped";
        that.svgWidth = '100%';
        that.rapidModeOn = false;
        that.confirmModeOn = true;
        that.autorefreshOn = false;
        that.visual = {
          margin: {x: 2, y: 1},
          arcTextMargin: 1,
          boxSpacing: 1,
          curlyHeight: 4,
          arcSpacing: 9, //10;
          arcStartHeight: 19, //23; //25;
        };
      };

      return Configuration;
    })(window);

// BRAT STANDALONE LIBRARY BEGIN
// Browserify export
    module.exports = Configuration;
// BRAT STANDALONE LIBRARY END
  }, {}], 12: [function (require, module, exports) {
// -*- Mode: JavaScript; tab-width: 2; indent-tabs-mode: nil; -*-
// vim:set ft=javascript ts=2 sw=2 sts=2 cindent:
// TODO: does 'arguments.callee.caller' work?

    var Dispatcher = (function ($, window, undefined) {
      var Dispatcher = function () {
        var that = this;

        var table = {};

        var on = function (message, host, handler) {
          if (handler === undefined) {
            handler = host;
            host = arguments.callee.caller;
          }
          if (table[message] === undefined) {
            table[message] = [];
          }
          table[message].push([host, handler]);
          return this;
        };

        // Notify listeners that we encountered an error in an asynch call
        var inAsynchError = false; // To avoid error avalanches
        var handleAsynchError = function (e) {
          if (!inAsynchError) {
            inAsynchError = true;
            // TODO: Hook printout into dispatch elsewhere?
            console.warn('Handled async error:', e);
            that.post('dispatchAsynchError', [e]);
            inAsynchError = false;
          } else {
            console.warn('Dropped asynch error:', e);
          }
        };

        var post = function (asynch, message, args, returnType) {
          if (typeof(asynch) !== 'number') {
            // no asynch parameter
            returnType = args;
            args = message;
            message = asynch;
            asynch = null;
          }
          if (args === undefined) {
            args = [];
          }
          var results = [];
          // DEBUG: if (typeof(message) != "string" || !(message.match(/mouse/) || message == "hideComment")) console.log(message, args);

          if (typeof(message) === 'function') {
            // someone was lazy and sent a simple function
            var host = arguments.callee.caller;
            if (asynch !== null) {
              result = setTimeout(function () {
                /*try {*/
                message.apply(host, args);
                /*} catch(e) {
                that.handleAsynchError(e);
              }*/
              }, asynch);
            } else {
              result = message.apply(host, args);
            }
            results.push(result);
          } else {
            // a proper message, propagate to all interested parties
            var todo = table[message];
            if (todo !== undefined) {
              $.each(todo, function (itemNo, item) {
                var result;
                if (asynch !== null) {
                  result = setTimeout(function () {
                    /*try {*/
                    item[1].apply(item[0], args);
                    /*} catch (e) {
                    that.handleAsynchError(e);
                  }*/
                  }, asynch);
                } else {
                  result = item[1].apply(item[0], args);
                }
                results.push(result);
              });
              /* DEBUG
          } else {
            console.warn('Message ' + message + ' has no subscribers.'); // DEBUG
*/
            }
          }
          if (returnType == 'any') {
            var i = results.length;
            while (i--) {
              if (results[i] !== false) return results[i];
            }
            return false;
          }
          if (returnType == 'all') {
            var i = results.length;
            while (i--) {
              if (results[i] === false) return results[i];
            }
          }
          return results;
        };

        var proxy = function (destination, message) {
          this.on(message, function () {
            destination.post(message, Array.prototype.slice.call(arguments));
          });
        };

        var dispatcher = {
          on: on,
          post: post,
          proxy: proxy,
        };
        Dispatcher.dispatchers.push(dispatcher);
        return dispatcher;
      };

      Dispatcher.dispatchers = [];
      Dispatcher.post = function (asynch, message, args, returnType) {
        $.each(Dispatcher.dispatchers, function (dispatcherNo, dispatcher) {
          dispatcher.post(asynch, message, args, returnType);
        });
      };

      return Dispatcher;
    })(jQuery, window);

// BRAT STANDALONE LIBRARY BEGIN
// Browserify export
    module.exports = Dispatcher;
// BRAT STANDALONE LIBRARY END

  }, {}], 13: [function (require, module, exports) {
    var LocalAjax = (function ($, window, undefined) {
      var LocalAjax = function (dispatcher, maxFragmentLength) {
        var that = this;

        var findType = function (entityTypes, type) {
          for (var i = 0; i < entityTypes.length; i++) {
            var entityType = entityTypes[i];
            if (entityType.type === type) {
              return entityType;
            } else {
              if (entityType.children && entityType.children.length) {
                var result = findType(entityType.children, type);
                if (result !== null) {
                  return result;
                }
              }
            }
          }
          return null;
        };

        var createAnnotation = function (data) {
          var attrs = JSON.parse(data.attributes),
            offsets = JSON.parse(data.offsets),
            e_type = findType(data.collection.entity_types, data.type);
          e_id = "";//Entity or Trigger
          if (!e_type) {
            //Trigger
            e_type = data.collection.event_types.find(x => x.type === data.type);
            if (e_type) {
              var trigger_id = "T" + (that.document.triggers.length + 1); //TODO: must absolutely be unique
              e_id = "E" + (that.document.triggers.length + 1); //TODO: must absolutely be unique
              data.document.triggers.push([
                trigger_id,
                data.type,
                offsets
              ]);
              data.document.events.push([
                e_id,
                trigger_id,
                []
              ]);
            }
          } else {
            var e_id = "N" + (that.document.entities.length + 1), //TODO: must absolutely be unique
              new_offsets = splitTooLongFragment(offsets, data, e_id);

            //Entity
            data.document.entities.push([
              e_id,
              data.type,
              new_offsets
            ]);
          }

          for (var key in attrs) {
            if (attrs.hasOwnProperty(key) && attrs[key]) {
              data.document.attributes.push([
                "A" + (that.document.attributes.length + 1), //TODO: must absolutely be unique,
                key,
                e_id,
                attrs[key]
              ]);
            }
          }
          if (data.comment.length) {
            data.document.comments.push([
              e_id,
              "AnnotatorNotes",
              data.comment
            ]);
          }
          return {
            data: data,
            action: data.action,
            annotations: {
              "source_files": data.document.source_files,
              "modifications": data.document.modifications,
              "normalizations": data.document.normalizations,
              "text": data.document.text,
              "entities": data.document.entities,
              "attributes": data.document.attributes,
              "relations": data.document.relations,
              "triggers": data.document.triggers,
              "events": data.document.events,
              "comments": data.document.comments
            },
            edited: [[e_id]],
            messages: [],
            protocol: 1
          };
        };

        // Validate max fragment length based on options.maxFragmentLength
        // Use discontinguity to fix long annotations glitches before calling BRAT rendering engine.
        var splitTooLongFragment = function (offsets, data, e_id) {
          var new_offsets = [];

          if (maxFragmentLength > 0 && offsets.find(x => (x[1] - x[0]) > maxFragmentLength)) {
            offsets.forEach(function (fragment) {
              var from = fragment[0],
                to = fragment[1],
                subtext = data.document.text.substring(from, to);

              if (to - from > maxFragmentLength) {
                var from_end = from + (subtext.indexOf(' ')),
                  to_start = to - (subtext.length - (subtext.lastIndexOf(' ') + 1));
                new_offsets.push([from, from_end]);
                new_offsets.push([to_start, to]);

                // Add special attribute for symbolic representation
                data.document.attributes.push([
                  "A" + (that.document.attributes.length + 1), //TODO: must absolutely be unique,
                  LONG_ANNOTATION_CONST,
                  e_id,
                  [from, to]
                ]);
              } else {
                new_offsets.push([from, to]);
              }
            });
          } else {
            new_offsets = offsets;
          }
          return new_offsets;
        };

        var editAnnotation = function (data) {
          var e_type = {}, //Entity or Trigger
            attrs = JSON.parse(data.attributes),
            offsets = JSON.parse(data.offsets);

          //Edit annotation TODO: Validation is based on id, fix this
          if (data.id.substring(0, 1) == "E") {
            //Event annotation
            //data.normalisations ??
            var annotation = data.document.events.find(x => x[0] === data.id);
            var trigger_id = annotation[1];
            var trigger = data.document.triggers.find(x => x[0] === trigger_id);
            trigger[1] = data.type;
            trigger[2] = offsets;
            e_type = data.collection.event_types.find(x => x.type === data.type);
          } else if (data.id.substring(0, 1) == "N") {
            //Entity annotation
            var entity = data.document.entities.find(x => x[0] === data.id);
            entity[1] = data.type;
            entity[2] = splitTooLongFragment(offsets, data, data.id);
            e_type = findType(data.collection.entity_types, data.type);

          } else {
            //TODO: Error
          }
          if (e_type) {
            //Removed all attributes for this particular annotation id
            var existing_attrs = data.document.attributes.filter(x => x[2] === data.id);
            existing_attrs.forEach(function (attr) {
              var index = data.document.attributes.indexOf(x => x[0] === attr[0]); //TODO: this always returns -1
              data.document.attributes.splice(index, 1);
            });

            //Re-add all attributes
            for (var key in attrs) {
              if (attrs.hasOwnProperty(key) && attrs[key]) {
                existing_attrs.find(x => x[1] === key);

                data.document.attributes.push([
                  "A" + (that.document.attributes.length + 1), //TODO: must absolutely be unique,
                  key,
                  data.id,
                  attrs[key]
                ]);
              }
            }

            //Add/Edit comment content
            if (data.comment.length) {
              var comment = data.document.comments.find(x => x[0] === data.id);
              if (comment) {
                //Edit
                comment[2] = data.comment;
              } else {
                //Add
                data.document.comments.push([
                  data.id,
                  "AnnotatorNotes",
                  data.comment
                ]);
              }
            }
            //Comments && Attributes are deactivated for relations at this point

            return {
              data: data,
              action: data.action,
              annotations: {
                "source_files": data.document.source_files,
                "modifications": data.document.modifications,
                "normalizations": data.document.normalizations,
                "text": data.document.text,
                "entities": data.document.entities,
                "attributes": data.document.attributes,
                "relations": data.document.relations,
                "triggers": data.document.triggers,
                "events": data.document.events,
                "comments": data.document.comments
              },
              edited: [[data.id]],
              messages: [],
              protocol: 1
            };
          } else {
            return {}; //TODO: Error handling
          }

        };

        var deleteAnnotation = function (data) {
          // delete the entity. TODO: also delete events etc
          var entities = data.document.entities;
          for (var i = 0; i < entities.length; i++) {
            if (entities[i][0] === data.id) {  // entity format [id, type, offsets], e.g. ["N1", "Person", Array[2]]
              entities.splice(i, 1);
              break;
            }
          }
          // delete relations containing the entity TODO: attributes etc?
          var relations = data.document.relations;
          for (var i = relations.length - 1; i >= 0; i--) {
            // relation format: ["R1", "Friend", Array[2]]
            var relation = relations[i][2];  // e.g. [['From', "N1"], ['To', 'N2']]
            if (relation[0][1] === data.id || relation[1][1] === data.id) {
              relations.splice(i, 1);
            }
          }

          return {
            action: data.action,
            annotations: data.document,
            edited: [],
            messages: [],
            protocol: 1
          };
        };

        var createRelation = function (data) {
          var e_type = data.collection.relation_types.find(x => x.type === data.type); //Entity or Event

          if (!e_type) {
            //Event relation
            /*data.collection.event_types.forEach(function(event){
                    event.arcs.forEach(function(eRelation){
                        if(eRelation.type === data.type){
                            e_type = event;
                            //TODO: Exit loop
                        }
                    })
                });*/
            e_type = data.document.events.find(x => x[0] === data.origin);
            if (e_type) {
              e_type[2].push([
                data.type,
                data.target
              ]);
            }
          } else {
            //Entity relation
            var obj =
              [
                "R" + (that.document.relations.length + 1), //TODO: must absolutely me unique
                data.type,
                [
                  [e_type.args[0].role, data.origin],
                  [e_type.args[1].role, data.target]]
              ];
            data.document.relations.push(obj);
          }
          return {
            action: data.action,
            annotations: {
              "source_files": data.document.source_files,
              "modifications": data.document.modifications,
              "normalizations": data.document.normalizations,
              "text": data.document.text,
              "entities": data.document.entities,
              "attributes": data.document.attributes,
              "relations": data.document.relations,
              "triggers": data.document.triggers,
              "events": data.document.events
              //"ctime": 1.0,
              //"collection": "",
              //"document": "",
              //"equivs": [],
              //"mtime": 1.0,
              //"sentences_offsets": [],
              //"token_offsets": [],
            },
            edited: [[data.origin], [data.target]],
            messages: [],
            protocol: 1
          };
        };

        var editRelation = function (data) {
          var e_type = data.collection.relation_types.find(x => x.type === data.type); //Entity or Event

          if (!e_type) {
            //Event relation
            e_type = data.document.events.find(x => x[0] === data.origin);
            if (e_type) {

            }
          } else {
            //Entity relation
            var relation = data.document.relations.find(x => x[1] === data.old_type && x[2][0][1] === data.origin && x[2][1][1] === data.old_target);
            relation[1] = data.type;
            relation[2] = [
              [e_type.args[0].role, data.origin],
              [e_type.args[1].role, data.target]
            ];
          }

          return {
            action: data.action,
            annotations: {
              "source_files": data.document.source_files,
              "modifications": data.document.modifications,
              "normalizations": data.document.normalizations,
              "text": data.document.text,
              "entities": data.document.entities,
              "attributes": data.document.attributes,
              "relations": data.document.relations,
              "triggers": data.document.triggers,
              "events": data.document.events,
              "comments": data.document.comments
            },
            edited: [[data.origin], [data.target]],
            messages: [],
            protocol: 1
          };

        };

        var localExecution = function (data, callback, merge) {
          dispatcher.post('spin');
          dispatcher.post('local-ajax-begin', [data]);
          that.collection = data.collection;
          that.document = data.document;
          var response = {};

          switch (data.action) {
            case "getDocument":
              //TODO
              break;
            case "loadConf":
              //TODO
              break;
            case "getCollectionInformation":
              //TODO
              break;
            case "createArc":
              //TODO: Validate model with inputs
              if (data.old_target || data.old_type) {
                response = editRelation(data);
              } else {
                response = createRelation(data);
              }
              break;
            case "deleteArc":
            //TODO
            case "reverseArc":
              //TODO
              break;
            case "createSpan":
              //Edit and Created actions on Entities as well as Triggers(Events)
              //TODO: Validate model with inputs
              if (data.id) {
                response = editAnnotation(data);
              } else {
                response = createAnnotation(data);
              }
              break;
            case "deleteSpan":
              response = deleteAnnotation(data);
              break;
            case "deleteFragmentxyz?":
              //TODO
              break;
            case "splitSpan":
              //TODO
              break;
            case "tag":
              //TODO ??
              var obj = {
                collection: data.collection,
                document: data.document,
                tagger: data.tagger
              };
            case "login":
            case "logout":
            case "whoami":
            case "normGetName":
            case "normSearch":
            case "suggestSpanTypes":
            case "importDocument":
            case "deleteDocument":
            case "deleteCollection":
            case "undo":
            case "normData":
            case "InDocument":
            case "InCollection":
            case "storeSVG":
            case "getDocumentTimestamp":
            case "saveConf":
              break;
            default:
              //TODO
              break;
          }

          dispatcher.post(0, callback, [response]);
          dispatcher.post('local-ajax-done', [response]);
          dispatcher.post('unspin');
        };

        dispatcher.on('ajax', localExecution);
      };

      return LocalAjax;
    })(jQuery, window);

// BRAT STANDALONE LIBRARY BEGIN
// Browserify export
    module.exports = LocalAjax;
// BRAT STANDALONE LIBRARY END

  }, {}], 14: [function (require, module, exports) {
// -*- Mode: JavaScript; tab-width: 2; indent-tabs-mode: nil; -*-
// vim:set ft=javascript ts=2 sw=2 sts=2 cindent:
    var Spinner = (function ($, window, undefined) {
      var Spinner = function (dispatcher, spinElement) {
        var that = this;
        var spinElement = $(spinElement);

        var count = 0;
        var spin = function () {
          if (count === 0) {
            spinElement.css('display', 'block');
          }
          count++;
        };
        var unspin = function () {
          count--;
          if (count === 0) {
            spinElement.css('display', 'none');
          }
        };

        dispatcher.on('spin', spin).on('unspin', unspin);
      };

      return Spinner;
    })(jQuery, window);

// BRAT STANDALONE LIBRARY BEGIN
// Browserify export
    module.exports = Spinner;
// BRAT STANDALONE LIBRARY END

  }, {}], 15: [function (require, module, exports) {
    var URLHash = (function ($, window, undefined) {
      var URLHash = function (collection, _document, _arguments) {
        var that = this;
        that.collection = collection;
        that.document = _document || '';
        that.arguments = _arguments || {};
        that.calcArgs();
      }

      URLHash.prototype = {
        calcArgs: function () {
          var args = URLHash.splitArgs(this.arguments);
          this.intArguments = args[0];
          this.extArguments = args[1];
        },

        setArgument: function (argument, value) {
          if (!this.arguments) {
            this.arguments = {};
          }
          this.arguments[argument] = value;
          this.calcArgs();
          return this;
        },

        setArguments: function (_arguments) {
          // the $.extend here basically takes a copy; raw assignment
          // would allow changes of the args to alter original, which
          // could be e.g. the "args" of search results
          this.arguments = $.extend({}, _arguments || {});
          this.calcArgs();
          return this;
        },

        setDocument: function (_document) {
          this.document = _document;
          return this;
        },

        setCollection: function (collection) {
          this.collection = collection;
          return this;
        },

        getHash: function () {
          var url_hash = this.collection + this.document;

          var url_args = Util.param(this.extArguments);

          if (url_args.length) {
            url_hash += '?' + url_args;
          }

          if (url_hash.length) {
            url_hash = '#' + url_hash;
          }

          return url_hash;
        },
      };

      // arguments that do not appear in the URL
      var INT_ARGS = ['match', 'matchfocus', 'edited'];

      URLHash.splitArgs = function (args) {
        var intArgs = {};
        var extArgs = $.extend({}, args);
        var intArgNameLen = INT_ARGS.length;
        for (var i = 0; i < intArgNameLen; i++) {
          intArgs[INT_ARGS[i]] = extArgs[INT_ARGS[i]];
          delete extArgs[INT_ARGS[i]];
        }
        return [intArgs, extArgs];
      };

      // TODO: Document and conform variables to the rest of the object
      URLHash.parse = function (hash) {
        if (hash.length) {
          // Remove the leading hash (#)
          hash = hash.substr(1);
        }

        var pathAndArgs = hash.split('?');
        var path = pathAndArgs[0] || '';
        var argsStr = pathAndArgs[1] || '';
        var coll;
        var slashPos = path.lastIndexOf('/');
        if (slashPos === -1) {
          coll = '/';
        } else {
          coll = path.substr(0, slashPos + 1);
          if (coll[coll.length - 1] !== '/') {
            coll += '/';
          }
          if (coll[0] !== '/') {
            coll = '/' + coll;
          }
        }
        var doc = path.substr(slashPos + 1);
        var args = Util.deparam(argsStr);
        return new URLHash(coll, doc, args);
      };

      return URLHash;
    })(jQuery, window);

// BRAT STANDALONE LIBRARY BEGIN
// Browserify export
    module.exports = URLHash;
// BRAT STANDALONE LIBRARY END

  }, {}], 16: [function (require, module, exports) {
// -*- Mode: JavaScript; tab-width: 2; indent-tabs-mode: nil; -*-
// vim:set ft=javascript ts=2 sw=2 sts=2 cindent:
    var Util = (function (window, undefined) {

      var monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

      var cmp = function (a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }

      var cmpArrayOnFirstElement = function (a, b) {
        a = a[0];
        b = b[0];
        return a < b ? -1 : a > b ? 1 : 0;
      }

      var unitAgo = function (n, unit) {
        if (n == 1) return "" + n + " " + unit + " ago";
        return "" + n + " " + unit + "s ago";
      };

      var formatTimeAgo = function (time) {
        if (time == -1000) {
          return "never"; // FIXME make the server return the server time!
        }

        var nowDate = new Date();
        var now = nowDate.getTime();
        var diff = Math.floor((now - time) / 1000);
        if (!diff) return "just now";
        if (diff < 60) return unitAgo(diff, "second");
        diff = Math.floor(diff / 60);
        if (diff < 60) return unitAgo(diff, "minute");
        diff = Math.floor(diff / 60);
        if (diff < 24) return unitAgo(diff, "hour");
        diff = Math.floor(diff / 24);
        if (diff < 7) return unitAgo(diff, "day");
        if (diff < 28) return unitAgo(Math.floor(diff / 7), "week");
        var thenDate = new Date(time);
        var result = thenDate.getDate() + ' ' + monthNames[thenDate.getMonth()];
        if (thenDate.getYear() != nowDate.getYear()) {
          result += ' ' + thenDate.getFullYear();
        }
        return result;
      }

      var realBBox = function (span) {
        var box = span.rect.getBBox();
        var chunkTranslation = span.chunk.translation;
        var rowTranslation = span.chunk.row.translation;
        box.x += chunkTranslation.x + rowTranslation.x;
        box.y += chunkTranslation.y + rowTranslation.y;
        return box;
      }

      var escapeHTML = function (str) {
        return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
      }

      var escapeHTMLandQuotes = function (str) {
        return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;');
      }

      var escapeHTMLwithNewlines = function (str) {
        return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\n/g, '<br/>');
      }

      var escapeQuotes = function (str) {
        // we only use double quotes for HTML attributes
        return str.replace(/\"/g, '&quot;');
      }

      var getSpanLabels = function (spanTypes, spanType) {
        var type = spanTypes[spanType];
        return type && type.labels || [];
      }

      var spanDisplayForm = function (spanTypes, spanType) {
        var labels = getSpanLabels(spanTypes, spanType);
        return labels[0] || spanType;
      }

      var getArcLabels = function (spanTypes, spanType, arcType, relationTypesHash) {
        var type = spanTypes[spanType];
        var arcTypes = type && type.arcs || [];
        var arcDesc = null;
        // also consider matches without suffix number, if any
        var noNumArcType;
        if (arcType) {
          var splitType = arcType.match(/^(.*?)(\d*)$/);
          noNumArcType = splitType[1];
        }
        $.each(arcTypes, function (arcno, arcDescI) {
          if (arcDescI.type == arcType || arcDescI.type == noNumArcType) {
            arcDesc = arcDescI;
            return false;
          }
        });
        // fall back to relation types for unconfigured or missing def
        if (!arcDesc) {
          arcDesc = $.extend({}, relationTypesHash[arcType] || relationTypesHash[noNumArcType]);
        }
        return arcDesc && arcDesc.labels || [];
      }

      var arcDisplayForm = function (spanTypes, spanType, arcType, relationTypesHash) {
        var labels = getArcLabels(spanTypes, spanType, arcType, relationTypesHash);
        return labels[0] || arcType;
      }

      // TODO: switching to use of $.param(), this function should
      // be deprecated and removed.
      var objectToUrlStr = function (o) {
        a = [];
        $.each(o, function (key, value) {
          a.push(key + "=" + encodeURIComponent(value));
        });
        return a.join("&");
      }

      // color name RGB list, converted from
      // http://www.w3schools.com/html/html_colornames.asp
      // with perl as
      //     perl -e 'print "var colors = {\n"; while(<>) { /(\S+)\s+\#([0-9a-z]{2})([0-9a-z]{2})([0-9a-z]{2})\s*/i or die "Failed to parse $_"; ($r,$g,$b)=(hex($2),hex($3),hex($4)); print "    '\''",lc($1),"'\'':\[$r,$g,$b\],\n" } print "};\n" '
      var colors = {
        'aliceblue': [240, 248, 255],
        'antiquewhite': [250, 235, 215],
        'aqua': [0, 255, 255],
        'aquamarine': [127, 255, 212],
        'azure': [240, 255, 255],
        'beige': [245, 245, 220],
        'bisque': [255, 228, 196],
        'black': [0, 0, 0],
        'blanchedalmond': [255, 235, 205],
        'blue': [0, 0, 255],
        'blueviolet': [138, 43, 226],
        'brown': [165, 42, 42],
        'burlywood': [222, 184, 135],
        'cadetblue': [95, 158, 160],
        'chartreuse': [127, 255, 0],
        'chocolate': [210, 105, 30],
        'coral': [255, 127, 80],
        'cornflowerblue': [100, 149, 237],
        'cornsilk': [255, 248, 220],
        'crimson': [220, 20, 60],
        'cyan': [0, 255, 255],
        'darkblue': [0, 0, 139],
        'darkcyan': [0, 139, 139],
        'darkgoldenrod': [184, 134, 11],
        'darkgray': [169, 169, 169],
        'darkgrey': [169, 169, 169],
        'darkgreen': [0, 100, 0],
        'darkkhaki': [189, 183, 107],
        'darkmagenta': [139, 0, 139],
        'darkolivegreen': [85, 107, 47],
        'darkorange': [255, 140, 0],
        'darkorchid': [153, 50, 204],
        'darkred': [139, 0, 0],
        'darksalmon': [233, 150, 122],
        'darkseagreen': [143, 188, 143],
        'darkslateblue': [72, 61, 139],
        'darkslategray': [47, 79, 79],
        'darkslategrey': [47, 79, 79],
        'darkturquoise': [0, 206, 209],
        'darkviolet': [148, 0, 211],
        'deeppink': [255, 20, 147],
        'deepskyblue': [0, 191, 255],
        'dimgray': [105, 105, 105],
        'dimgrey': [105, 105, 105],
        'dodgerblue': [30, 144, 255],
        'firebrick': [178, 34, 34],
        'floralwhite': [255, 250, 240],
        'forestgreen': [34, 139, 34],
        'fuchsia': [255, 0, 255],
        'gainsboro': [220, 220, 220],
        'ghostwhite': [248, 248, 255],
        'gold': [255, 215, 0],
        'goldenrod': [218, 165, 32],
        'gray': [128, 128, 128],
        'grey': [128, 128, 128],
        'green': [0, 128, 0],
        'greenyellow': [173, 255, 47],
        'honeydew': [240, 255, 240],
        'hotpink': [255, 105, 180],
        'indianred': [205, 92, 92],
        'indigo': [75, 0, 130],
        'ivory': [255, 255, 240],
        'khaki': [240, 230, 140],
        'lavender': [230, 230, 250],
        'lavenderblush': [255, 240, 245],
        'lawngreen': [124, 252, 0],
        'lemonchiffon': [255, 250, 205],
        'lightblue': [173, 216, 230],
        'lightcoral': [240, 128, 128],
        'lightcyan': [224, 255, 255],
        'lightgoldenrodyellow': [250, 250, 210],
        'lightgray': [211, 211, 211],
        'lightgrey': [211, 211, 211],
        'lightgreen': [144, 238, 144],
        'lightpink': [255, 182, 193],
        'lightsalmon': [255, 160, 122],
        'lightseagreen': [32, 178, 170],
        'lightskyblue': [135, 206, 250],
        'lightslategray': [119, 136, 153],
        'lightslategrey': [119, 136, 153],
        'lightsteelblue': [176, 196, 222],
        'lightyellow': [255, 255, 224],
        'lime': [0, 255, 0],
        'limegreen': [50, 205, 50],
        'linen': [250, 240, 230],
        'magenta': [255, 0, 255],
        'maroon': [128, 0, 0],
        'mediumaquamarine': [102, 205, 170],
        'mediumblue': [0, 0, 205],
        'mediumorchid': [186, 85, 211],
        'mediumpurple': [147, 112, 216],
        'mediumseagreen': [60, 179, 113],
        'mediumslateblue': [123, 104, 238],
        'mediumspringgreen': [0, 250, 154],
        'mediumturquoise': [72, 209, 204],
        'mediumvioletred': [199, 21, 133],
        'midnightblue': [25, 25, 112],
        'mintcream': [245, 255, 250],
        'mistyrose': [255, 228, 225],
        'moccasin': [255, 228, 181],
        'navajowhite': [255, 222, 173],
        'navy': [0, 0, 128],
        'oldlace': [253, 245, 230],
        'olive': [128, 128, 0],
        'olivedrab': [107, 142, 35],
        'orange': [255, 165, 0],
        'orangered': [255, 69, 0],
        'orchid': [218, 112, 214],
        'palegoldenrod': [238, 232, 170],
        'palegreen': [152, 251, 152],
        'paleturquoise': [175, 238, 238],
        'palevioletred': [216, 112, 147],
        'papayawhip': [255, 239, 213],
        'peachpuff': [255, 218, 185],
        'peru': [205, 133, 63],
        'pink': [255, 192, 203],
        'plum': [221, 160, 221],
        'powderblue': [176, 224, 230],
        'purple': [128, 0, 128],
        'red': [255, 0, 0],
        'rosybrown': [188, 143, 143],
        'royalblue': [65, 105, 225],
        'saddlebrown': [139, 69, 19],
        'salmon': [250, 128, 114],
        'sandybrown': [244, 164, 96],
        'seagreen': [46, 139, 87],
        'seashell': [255, 245, 238],
        'sienna': [160, 82, 45],
        'silver': [192, 192, 192],
        'skyblue': [135, 206, 235],
        'slateblue': [106, 90, 205],
        'slategray': [112, 128, 144],
        'slategrey': [112, 128, 144],
        'snow': [255, 250, 250],
        'springgreen': [0, 255, 127],
        'steelblue': [70, 130, 180],
        'tan': [210, 180, 140],
        'teal': [0, 128, 128],
        'thistle': [216, 191, 216],
        'tomato': [255, 99, 71],
        'turquoise': [64, 224, 208],
        'violet': [238, 130, 238],
        'wheat': [245, 222, 179],
        'white': [255, 255, 255],
        'whitesmoke': [245, 245, 245],
        'yellow': [255, 255, 0],
        'yellowgreen': [154, 205, 50],
      };

      // color parsing function originally from
      // http://plugins.jquery.com/files/jquery.color.js.txt
      // (with slight modifications)

      // Parse strings looking for color tuples [255,255,255]
      var rgbNumRE = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/;
      var rgbPercRE = /rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/;
      var rgbHash6RE = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/;
      var rgbHash3RE = /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/;

      var strToRgb = function (color) {
        var result;

        // Check if we're already dealing with an array of colors
//         if ( color && color.constructor == Array && color.length == 3 )
//             return color;

        // Look for rgb(num,num,num)
        if (result = rgbNumRE.exec(color))
          return [parseInt(result[1]), parseInt(result[2]), parseInt(result[3])];

        // Look for rgb(num%,num%,num%)
        if (result = rgbPercRE.exec(color))
          return [parseFloat(result[1]) * 2.55, parseFloat(result[2]) * 2.55, parseFloat(result[3]) * 2.55];

        // Look for #a0b1c2
        if (result = rgbHash6RE.exec(color))
          return [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)];

        // Look for #fff
        if (result = rgbHash3RE.exec(color))
          return [parseInt(result[1] + result[1], 16), parseInt(result[2] + result[2], 16), parseInt(result[3] + result[3], 16)];

        // Otherwise, we're most likely dealing with a named color
        return colors[$.trim(color).toLowerCase()];
      }

      var rgbToStr = function (rgb) {
        // TODO: there has to be a better way, even in JS
        var r = Math.floor(rgb[0]).toString(16);
        var g = Math.floor(rgb[1]).toString(16);
        var b = Math.floor(rgb[2]).toString(16);
        // pad
        r = r.length < 2 ? '0' + r : r;
        g = g.length < 2 ? '0' + g : g;
        b = b.length < 2 ? '0' + b : b;
        return ('#' + r + g + b);
      }

      // Functions rgbToHsl and hslToRgb originally from
      // http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript
      // implementation of functions in Wikipedia
      // (with slight modifications)

      // RGB to HSL color conversion
      var rgbToHsl = function (rgb) {
        var r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255;
        var max = Math.max(r, g, b), min = Math.min(r, g, b);
        var h, s, l = (max + min) / 2;

        if (max == min) {
          h = s = 0; // achromatic
        } else {
          var d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          switch (max) {
            case r:
              h = (g - b) / d + (g < b ? 6 : 0);
              break;
            case g:
              h = (b - r) / d + 2;
              break;
            case b:
              h = (r - g) / d + 4;
              break;
          }
          h /= 6;
        }

        return [h, s, l];
      }

      var hue2rgb = function (p, q, t) {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1 / 6) return p + (q - p) * 6 * t;
        if (t < 1 / 2) return q;
        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
        return p;
      }

      var hslToRgb = function (hsl) {
        var h = hsl[0], s = hsl[1], l = hsl[2];

        var r, g, b;

        if (s == 0) {
          r = g = b = l; // achromatic
        } else {
          var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          var p = 2 * l - q;
          r = hue2rgb(p, q, h + 1 / 3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1 / 3);
        }

        return [r * 255, g * 255, b * 255];
      }

      var adjustLightnessCache = {};

      // given color string and -1<=adjust<=1, returns color string
      // where lightness (in the HSL sense) is adjusted by the given
      // amount, the larger the lighter: -1 gives black, 1 white, and 0
      // the given color.
      var adjustColorLightness = function (colorstr, adjust) {
        if (!(colorstr in adjustLightnessCache)) {
          adjustLightnessCache[colorstr] = {}
        }
        if (!(adjust in adjustLightnessCache[colorstr])) {
          var rgb = strToRgb(colorstr);
          if (rgb === undefined) {
            // failed color string conversion; just return the input
            adjustLightnessCache[colorstr][adjust] = colorstr;
          } else {
            var hsl = rgbToHsl(rgb);
            if (adjust > 0.0) {
              hsl[2] = 1.0 - ((1.0 - hsl[2]) * (1.0 - adjust));
            } else {
              hsl[2] = (1.0 + adjust) * hsl[2];
            }
            var lightRgb = hslToRgb(hsl);
            adjustLightnessCache[colorstr][adjust] = rgbToStr(lightRgb);
          }
        }
        return adjustLightnessCache[colorstr][adjust];
      }

      // Partially stolen from: http://documentcloud.github.com/underscore/
      // MIT-License
      // TODO: Mention in LICENSE.md
      var isEqual = function (a, b) {
        // Check object identity.
        if (a === b) return true;
        // Different types?
        var atype = typeof(a), btype = typeof(b);
        if (atype != btype) return false;
        // Basic equality test (watch out for coercions).
        if (a == b) return true;
        // One is falsy and the other truthy.
        if ((!a && b) || (a && !b)) return false;
        // If a is not an object by this point, we can't handle it.
        if (atype !== 'object') return false;
        // Check for different array lengths before comparing contents.
        if (a.length && (a.length !== b.length)) return false;
        // Nothing else worked, deep compare the contents.
        for (var key in b) if (!(key in a)) return false;
        // Recursive comparison of contents.
        for (var key in a) if (!(key in b) || !isEqual(a[key], b[key])) return false;
        return true;
      };

      var keyValRE = /^([^=]+)=(.*)$/; // key=value
      var isDigitsRE = /^[0-9]+$/;

      var deparam = function (str) {
        var args = str.split('&');
        var len = args.length;
        if (!len) return null;
        var result = {};
        for (var i = 0; i < len; i++) {
          var parts = args[i].match(keyValRE);
          if (!parts || parts.length != 3) break;
          var val = [];
          var arr = parts[2].split(',');
          var sublen = arr.length;
          for (var j = 0; j < sublen; j++) {
            var innermost = [];
            // map empty arguments ("" in URL) to empty arrays
            // (innermost remains [])
            if (arr[j].length) {
              var arrsplit = arr[j].split('~');
              var subsublen = arrsplit.length;
              for (var k = 0; k < subsublen; k++) {
                if (arrsplit[k].match(isDigitsRE)) {
                  // convert digits into ints ...
                  innermost.push(parseInt(arrsplit[k], 10));
                }
                else {
                  // ... anything else remains a string.
                  innermost.push(arrsplit[k]);
                }
              }
            }
            val.push(innermost);
          }
          result[parts[1]] = val;
        }
        return result;
      };

      var paramArray = function (val) {
        val = val || [];
        var len = val.length;
        var arr = [];
        for (var i = 0; i < len; i++) {
          if ($.isArray(val[i])) {
            arr.push(val[i].join('~'));
          } else {
            // non-array argument; this is an error from the caller
            console.error('param: Error: received non-array-in-array argument [', i, ']', ':', val[i], '(fix caller)');
          }
        }
        return arr;
      };

      var param = function (args) {
        if (!args) return '';
        var vals = [];
        for (var key in args) {
          if (args.hasOwnProperty(key)) {
            var val = args[key];
            if (val == undefined) {
              console.error('Error: received argument', key, 'with value', val);
              continue;
            }
            // values normally expected to be arrays, but some callers screw
            // up, so check
            if ($.isArray(val)) {
              var arr = paramArray(val);
              vals.push(key + '=' + arr.join(','));
            } else {
              // non-array argument; this is an error from the caller
              console.error('param: Error: received non-array argument', key, ':', val, '(fix caller)');
            }
          }
        }
        return vals.join('&');
      };

      var profiles = {};
      var profileStarts = {};
      var profileOn = false;
      var profileEnable = function (on) {
        if (on === undefined) on = true;
        profileOn = on;
      }; // profileEnable
      var profileClear = function () {
        if (!profileOn) return;
        profiles = {};
        profileStarts = {};
      }; // profileClear
      var profileStart = function (label) {
        if (!profileOn) return;
        profileStarts[label] = new Date();
      }; // profileStart
      var profileEnd = function (label) {
        if (!profileOn) return;
        var profileElapsed = new Date() - profileStarts[label]
        if (!profiles[label]) profiles[label] = 0;
        profiles[label] += profileElapsed;
      }; // profileEnd
      var profileReport = function () {
        if (!profileOn) return;
        if (window.console) {
          $.each(profiles, function (label, time) {
            console.log("profile " + label, time);
          });
          console.log("-------");
        }
      }; // profileReport

      // container: ID or jQuery element
      // collData: the collection data (in the format of the result of
      //   http://.../brat/ajax.cgi?action=getCollectionInformation&collection=...
      // docData: the document data (in the format of the result of
      //   http://.../brat/ajax.cgi?action=getDocument&collection=...&document=...
      // returns the embedded visualizer's dispatcher object
      var embed = function (container, collData, docData, webFontURLs) {
        var dispatcher = new Dispatcher();
        var visualizer = new Visualizer(dispatcher, container, webFontURLs);
        docData.collection = null;
        dispatcher.post('collectionLoaded', [collData]);
        dispatcher.post('requestRenderData', [docData]);
        return dispatcher;
      };

      // container: ID or jQuery element
      // collDataURL: the URL of the collection data, or collection data
      //   object (if pre-fetched)
      // docDataURL: the url of the document data (if pre-fetched, use
      //   simple `embed` instead)
      // callback: optional; the callback to call afterwards; it will be
      //   passed the embedded visualizer's dispatcher object
      var embedByURL = function (container, collDataURL, docDataURL, callback) {
        var collData, docData;
        var handler = function () {
          if (collData && docData) {
            var dispatcher = embed(container, collData, docData);
            if (callback) callback(dispatcher);
          }
        };
        if (typeof(container) == 'string') {
          $.getJSON(collDataURL, function (data) {
            collData = data;
            handler();
          });
        } else {
          collData = collDataURL;
        }
        $.getJSON(docDataURL, function (data) {
          docData = data;
          handler();
        });
      };


      return {
        profileEnable: profileEnable,
        profileClear: profileClear,
        profileStart: profileStart,
        profileEnd: profileEnd,
        profileReport: profileReport,
        formatTimeAgo: formatTimeAgo,
        realBBox: realBBox,
        getSpanLabels: getSpanLabels,
        spanDisplayForm: spanDisplayForm,
        getArcLabels: getArcLabels,
        arcDisplayForm: arcDisplayForm,
        escapeQuotes: escapeQuotes,
        escapeHTML: escapeHTML,
        escapeHTMLandQuotes: escapeHTMLandQuotes,
        escapeHTMLwithNewlines: escapeHTMLwithNewlines,
        cmp: cmp,
        rgbToHsl: rgbToHsl,
        hslToRgb: hslToRgb,
        adjustColorLightness: adjustColorLightness,
        objectToUrlStr: objectToUrlStr,
        isEqual: isEqual,
        paramArray: paramArray,
        param: param,
        deparam: deparam,
        embed: embed,
        embedByURL: embedByURL,
      };

    })(window);

// BRAT STANDALONE LIBRARY BEGIN
// Browserify export
    module.exports = Util;
// BRAT STANDALONE LIBRARY END

  }, {}], 17: [function (require, module, exports) {
// -*- Mode: JavaScript; tab-width: 2; indent-tabs-mode: nil; -*-
// vim:set ft=javascript ts=2 sw=2 sts=2 cindent:

    var Visualizer = (function ($, window, undefined) {
      var fontLoadTimeout = 5000; // 5 seconds

      var DocumentData = function (text) {
        this.text = text;
        this.chunks = [];
        this.spans = {};
        this.eventDescs = {};
        this.sentComment = {};
        this.arcs = [];
        this.arcById = {};
        this.markedSent = {};
        this.spanAnnTexts = {};
        this.towers = {};
        // this.sizes = {};
      };

      var Fragment = function (id, span, from, to) {
        this.id = id;
        this.span = span;
        this.from = from;
        this.to = to;
        // this.towerId = undefined;
        // this.drawOrder = undefined;
      };

      var Span = function (id, type, offsets, generalType) {
        this.id = id;
        this.type = type;
        this.totalDist = 0;
        this.numArcs = 0;
        this.generalType = generalType;
        this.offsets = offsets;
        this.headFragment = null;
        // this.from = undefined;
        // this.to = undefined;
        // this.wholeFrom = undefined;
        // this.wholeTo = undefined;
        // this.headFragment = undefined;
        // this.chunk = undefined;
        // this.marked = undefined;
        // this.avgDist = undefined;
        // this.curly = undefined;
        // this.comment = undefined; // { type: undefined, text: undefined };
        // this.annotatorNotes = undefined;
        // this.drawCurly = undefined;
        // this.glyphedLabelText = undefined;
        // this.group = undefined;
        // this.height = undefined;
        // this.highlightPos = undefined;
        // this.indexNumber = undefined;
        // this.labelText = undefined;
        // this.nestingDepth = undefined;
        // this.nestingDepthLR = undefined;
        // this.nestingDepthRL = undefined;
        // this.nestingHeight = undefined;
        // this.nestingHeightLR = undefined;
        // this.nestingHeightRL = undefined;
        // this.rect = undefined;
        // this.rectBox = undefined;
        // this.refedIndexSum = undefined;
        // this.right = undefined;
        // this.totaldist = undefined;
        // this.width = undefined;
        this.initContainers(offsets);
      };

      Span.prototype.initContainers = function () {
        this.incoming = [];
        this.outgoing = [];
        this.attributes = {};
        this.attributeText = [];
        this.attributeCues = {};
        this.attributeCueFor = {};
        this.attributeMerge = {}; // for box, cross, etc. that are span-global
        this.fragments = [];
        this.normalizations = [];
      };

      Span.prototype.copy = function (id) {
        var span = $.extend(new Span(), this); // clone
        span.id = id;
        span.initContainers(); // protect from shallow copy
        return span;
      };

      var EventDesc = function (id, triggerId, roles, klass) {
        this.id = id;
        this.triggerId = triggerId;
        var roleList = this.roles = [];
        $.each(roles, function (roleNo, role) {
          roleList.push({type: role[0], targetId: role[1]});
        });
        if (klass == "equiv") {
          this.equiv = true;
        } else if (klass == "relation") {
          this.relation = true;
        }
        // this.leftSpans = undefined;
        // this.rightSpans = undefined;
        // this.annotatorNotes = undefined;
      };

      var Chunk = function (index, text, from, to, space, spans) {
        this.index = index;
        this.text = text;
        this.from = from;
        this.to = to;
        this.space = space;
        this.fragments = [];
        // this.sentence = undefined;
        // this.group = undefined;
        // this.highlightGroup = undefined;
        // this.markedTextStart = undefined;
        // this.markedTextEnd = undefined;
        // this.nextSpace = undefined;
        // this.right = undefined;
        // this.row = undefined;
        // this.textX = undefined;
        // this.translation = undefined;
      }

      var Arc = function (eventDesc, role, dist, eventNo) {
        this.origin = eventDesc.id;
        this.target = role.targetId;
        this.dist = dist;
        this.type = role.type;
        this.shadowClass = eventDesc.shadowClass;
        this.jumpHeight = 0;
        if (eventDesc.equiv) {
          this.equiv = true;
          this.eventDescId = eventNo;
          eventDesc.equivArc = this;
        } else if (eventDesc.relation) {
          this.relation = true;
          this.eventDescId = eventNo;
        }
        // this.marked = undefined;
      };

      var Row = function (svg) {
        this.group = svg.group();
        this.background = svg.group(this.group);
        this.chunks = [];
        this.hasAnnotations = false;
        this.maxArcHeight = 0;
        this.maxSpanHeight = 0;
      };

      var Measurements = function (widths, height, y) {
        this.widths = widths;
        this.height = height;
        this.y = y;
      };

      // A naive whitespace tokeniser
      var tokenise = function (text) {
        var tokenOffsets = [];
        var tokenStart = null;
        var lastCharPos = null;

        for (var i = 0; i < text.length; i++) {
          var c = text[i];
          // Have we found the start of a token?
          if (tokenStart == null && !/\s/.test(c)) {
            tokenStart = i;
            lastCharPos = i;
            // Have we found the end of a token?
          } else if (/\s/.test(c) && tokenStart != null) {
            tokenOffsets.push([tokenStart, i]);
            tokenStart = null;
            // Is it a non-whitespace character?
          } else if (!/\s/.test(c)) {
            lastCharPos = i;
          }
        }
        // Do we have a trailing token?
        if (tokenStart != null) {
          tokenOffsets.push([tokenStart, lastCharPos + 1]);
        }

        return tokenOffsets;
      };

      // A naive newline sentence splitter
      var sentenceSplit = function (text) {
        var sentenceOffsets = [];
        var sentStart = null;
        var lastCharPos = null;

        for (var i = 0; i < text.length; i++) {
          var c = text[i];
          // Have we found the start of a sentence?
          if (sentStart == null && !/\s/.test(c)) {
            sentStart = i;
            lastCharPos = i;
            // Have we found the end of a sentence?
          } else if (c == '\n' && sentStart != null) {
            sentenceOffsets.push([sentStart, i]);
            sentStart = null;
            // Is it a non-whitespace character?
          } else if (!/\s/.test(c)) {
            lastCharPos = i;
          }
        }
        // Do we have a trailing sentence without a closing newline?
        if (sentStart != null) {
          sentenceOffsets.push([sentStart, lastCharPos + 1]);
        }

        return sentenceOffsets;
      };

      // Sets default values for a wide range of optional attributes
      var setSourceDataDefaults = function (sourceData) {
        // The following are empty lists if not set
        $.each([
          'attributes',
          'comments',
          'entities',
          'equivs',
          'events',
          'modifications',
          'normalizations',
          'relations',
          'triggers',
        ], function (attrNo, attr) {
          if (sourceData[attr] === undefined) {
            sourceData[attr] = [];
          }
        });

        // If we lack sentence offsets we fall back on naive sentence splitting
        if (sourceData.sentence_offsets === undefined) {
          sourceData.sentence_offsets = sentenceSplit(sourceData.text);
        }
        // Similarily we fall back on whitespace tokenisation
        if (sourceData.token_offsets === undefined) {
          sourceData.token_offsets = tokenise(sourceData.text);
        }
      };

      // Set default values for a variety of collection attributes
      var setCollectionDefaults = function (collectionData) {
        // The following are empty lists if not set
        $.each([
          'entity_attribute_types',
          'entity_types',
          'event_attribute_types',
          'event_types',
          'relation_attribute_types',
          'relation_types',
          'unconfigured_types',
        ], function (attrNo, attr) {
          if (collectionData[attr] === undefined) {
            collectionData[attr] = [];
          }
        });
      };

      var Visualizer = function (dispatcher, svgId, webFontURLs) {
        var $svgDiv = $('#' + svgId);
        if (!$svgDiv.length) {
          throw Error('Could not find container with id="' + svgId + '"');
        }
        var that = this;

        // OPTIONS
        var roundCoordinates = true; // try to have exact pixel offsets
        var boxTextMargin = {x: 0, y: 1.5}; // effect is inverse of "margin" for some reason
        var highlightRounding = {x: 3, y: 3}; // rx, ry for highlight boxes
        var spaceWidths = {
          ' ': 4,
          '\u00a0': 4,
          '\u200b': 0,
          '\u3000': 8,
          '\u0009': 12, //Unicode tabulation
          '\n': 4
        };
        var coloredCurlies = true; // color curlies by box BG
        var arcSlant = 15; //10;
        var minArcSlant = 8;
        var arcHorizontalSpacing = 10; // min space boxes with connecting arc
        var rowSpacing = -5;          // for some funny reason approx. -10 gives "tight" packing.
        var sentNumMargin = 50;
        var smoothArcCurves = true;   // whether to use curves (vs lines) in arcs
        var smoothArcSteepness = 0.5; // steepness of smooth curves (control point)
        var reverseArcControlx = 5;   // control point distance for "UFO catchers"

        // "shadow" effect settings (note, error, incompelete)
        var rectShadowSize = 3;
        var rectShadowRounding = 2.5;
        var arcLabelShadowSize = 1;
        var arcLabelShadowRounding = 5;
        var shadowStroke = 2.5; // TODO XXX: this doesn't affect anything..?

        // "marked" effect settings (edited, focus, match)
        var markedSpanSize = 6;
        var markedArcSize = 2;
        var markedArcStroke = 7; // TODO XXX: this doesn't seem to do anything..?

        var rowPadding = 2;
        var nestingAdjustYStepSize = 2; // size of height adjust for nested/nesting spans
        var nestingAdjustXStepSize = 1; // size of height adjust for nested/nesting spans

        var highlightSequence = '#FF9632;#FFCC00;#FF9632'; // yellow - deep orange
        //var highlightSequence = '#FFFC69;#FFCC00;#FFFC69'; // a bit toned town
        var highlightSpanSequence = highlightSequence;
        var highlightArcSequence = highlightSequence;
        var highlightTextSequence = highlightSequence;
        var highlightDuration = '2s';
        // different sequence for "mere" matches (as opposed to "focus" and
        // "edited" highlights)
        var highlightMatchSequence = '#FFFF00'; // plain yellow

        var fragmentConnectorDashArray = '1,3,3,3';
        var fragmentConnectorColor = '#000000';

        // END OPTIONS


        var svg;
        var $svg;
        var data = null;
        var sourceData = null;
        var requestedData = null;
        var coll, doc, args;
        var relationTypesHash;
        var isRenderRequested;
        var isCollectionLoaded = false;
        var entityAttributeTypes = null;
        var eventAttributeTypes = null;
        var spanTypes = null;
        var highlightGroup;

        // var commentPrioLevels = ['Unconfirmed', 'Incomplete', 'Warning', 'Error', 'AnnotatorNotes'];
        // XXX Might need to be tweaked - inserted diff levels
        var commentPrioLevels = [
          'Unconfirmed', 'Incomplete', 'Warning', 'Error', 'AnnotatorNotes',
          'AddedAnnotation', 'MissingAnnotation', 'ChangedAnnotation'];

        this.arcDragOrigin = null; // TODO

        // due to silly Chrome bug, I have to make it pay attention
        var forceRedraw = function () {
          if (!$.browser.chrome) return; // not needed
          $svg.css('margin-bottom', 1);
          setTimeout(function () {
            $svg.css('margin-bottom', 0);
          }, 0);
        }

        var rowBBox = function (span) {
          var box = $.extend({}, span.rectBox); // clone
          var chunkTranslation = span.chunk.translation;
          box.x += chunkTranslation.x;
          box.y += chunkTranslation.y;
          return box;
        };

        var commentPriority = function (commentClass) {
          if (commentClass === undefined) return -1;
          var len = commentPrioLevels.length;
          for (var i = 0; i < len; i++) {
            if (commentClass.indexOf(commentPrioLevels[i]) != -1) return i;
          }
          return 0;
        };

        var clearSVG = function () {
          data = null;
          sourceData = null;
          svg.clear();
          $svgDiv.hide();
        };

        var setMarked = function (markedType) {
          $.each(args[markedType] || [], function (markedNo, marked) {
            if (marked[0] == 'sent') {
              data.markedSent[marked[1]] = true;
            } else if (marked[0] == 'equiv') { // [equiv, Equiv, T1]
              $.each(sourceData.equivs, function (equivNo, equiv) {
                if (equiv[1] == marked[1]) {
                  var len = equiv.length;
                  for (var i = 2; i < len; i++) {
                    if (equiv[i] == marked[2]) {
                      // found it
                      len -= 3;
                      for (var i = 1; i <= len; i++) {
                        var arc = data.eventDescs[equiv[0] + "*" + i].equivArc;
                        arc.marked = markedType;
                      }
                      return; // next equiv
                    }
                  }
                }
              });
            } else if (marked.length == 2) {
              markedText.push([parseInt(marked[0], 10), parseInt(marked[1], 10), markedType]);
            } else {
              var span = data.spans[marked[0]];
              if (span) {
                if (marked.length == 3) { // arc
                  $.each(span.outgoing, function (arcNo, arc) {
                    if (arc.target == marked[2] && arc.type == marked[1]) {
                      arc.marked = markedType;
                    }
                  });
                } else { // span
                  span.marked = markedType;
                }
              } else {
                var eventDesc = data.eventDescs[marked[0]];
                if (eventDesc) { // relation
                  var relArc = eventDesc.roles[0];
                  $.each(data.spans[eventDesc.triggerId].outgoing, function (arcNo, arc) {
                    if (arc.target == relArc.targetId && arc.type == relArc.type) {
                      arc.marked = markedType;
                    }
                  });
                } else { // try for trigger
                  $.each(data.eventDescs, function (eventDescNo, eventDesc) {
                    if (eventDesc.triggerId == marked[0]) {
                      data.spans[eventDesc.id].marked = markedType;
                    }
                  });
                }
              }
            }
          });
        };

        var fragmentComparator = function (a, b) {
          var tmp;
          var aSpan = a.span;
          var bSpan = b.span;

          // spans with more fragments go first
          tmp = aSpan.fragments.length - bSpan.fragments.length;
          if (tmp) {
            return tmp < 0 ? 1 : -1;
          }

          // longer arc distances go last
          tmp = aSpan.avgDist - bSpan.avgDist;
          if (tmp) {
            return tmp < 0 ? -1 : 1;
          }
          // spans with more arcs go last
          tmp = aSpan.numArcs - bSpan.numArcs;
          if (tmp) {
            return tmp < 0 ? -1 : 1;
          }
          // compare the span widths,
          // put wider on bottom so they don't mess with arcs, or shorter
          // on bottom if there are no arcs.
          var ad = a.to - a.from;
          var bd = b.to - b.from;
          tmp = ad - bd;
          if (aSpan.numArcs == 0 && bSpan.numArcs == 0) {
            tmp = -tmp;
          }
          if (tmp) {
            return tmp < 0 ? 1 : -1;
          }
          tmp = aSpan.refedIndexSum - bSpan.refedIndexSum;
          if (tmp) {
            return tmp < 0 ? -1 : 1;
          }
          // if no other criterion is found, sort by type to maintain
          // consistency
          // TODO: isn't there a cmp() in JS?
          if (aSpan.type < bSpan.type) {
            return -1;
          } else if (aSpan.type > bSpan.type) {
            return 1;
          }

          return 0;
        };


        var setData = function (_sourceData) {
          if (!args) args = {};
          sourceData = _sourceData;
          dispatcher.post('newSourceData', [sourceData]);
          data = new DocumentData(sourceData.text);

          // collect annotation data
          $.each(sourceData.entities, function (entityNo, entity) {
            // offsets given as array of (start, end) pairs
            var span =
              //      (id,        type,      offsets,   generalType)
              new Span(entity[0], entity[1], entity[2], 'entity');
            data.spans[entity[0]] = span;
          });
          var triggerHash = {};
          $.each(sourceData.triggers, function (triggerNo, trigger) {
            triggerHash[trigger[0]] =
              //       (id,         type,       offsets,    generalType), eventList
              [new Span(trigger[0], trigger[1], trigger[2], 'trigger'), []];
          });
          $.each(sourceData.events, function (eventNo, eventRow) {
            var eventDesc = data.eventDescs[eventRow[0]] =
              //           (id,          triggerId,   roles,        klass)
              new EventDesc(eventRow[0], eventRow[1], eventRow[2]);
            var trigger = triggerHash[eventDesc.triggerId];
            var span = trigger[0].copy(eventDesc.id);
            trigger[1].push(span);
            data.spans[eventDesc.id] = span;
          });

          // XXX modifications: delete later
          $.each(sourceData.modifications, function (modNo, mod) {
            // mod: [id, spanId, modification]
            if (!data.spans[mod[2]]) {
              dispatcher.post('messages', [[['<strong>ERROR</strong><br/>Event ' + mod[2] + ' (referenced from modification ' + mod[0] + ') does not occur in document ' + data.document + '<br/>(please correct the source data)', 'error', 5]]]);
              return;
            }
            data.spans[mod[2]][mod[1]] = true;
          });

          var midpointComparator = function (a, b) {
            var tmp = a.from + a.to - b.from - b.to;
            if (!tmp) return 0;
            return tmp < 0 ? -1 : 1;
          };
          // split spans into span fragments (for discontinuous spans)
          $.each(data.spans, function (spanNo, span) {
            $.each(span.offsets, function (offsetsNo, offsets) {
              var from = parseInt(offsets[0], 10);
              var to = parseInt(offsets[1], 10);
              var fragment = new Fragment(offsetsNo, span, from, to);
              span.fragments.push(fragment);
            });
            // ensure ascending order
            span.fragments.sort(midpointComparator);
            span.wholeFrom = span.fragments[0].from;
            span.wholeTo = span.fragments[span.fragments.length - 1].to;
            span.headFragment = span.fragments[(true) ? span.fragments.length - 1 : 0]; // TODO configurable!
          });

          var spanComparator = function (a, b) {
            var aSpan = data.spans[a];
            var bSpan = data.spans[b];
            var tmp = aSpan.headFragment.from + aSpan.headFragment.to - bSpan.headFragment.from - bSpan.headFragment.to;
            if (tmp) {
              return tmp < 0 ? -1 : 1;
            }
            return 0;
          };
          $.each(sourceData.equivs, function (equivNo, equiv) {
            // equiv: ['*', 'Equiv', spanId...]
            equiv[0] = "*" + equivNo;
            var equivSpans = equiv.slice(2);
            var okEquivSpans = [];
            // collect the equiv spans in an array
            $.each(equivSpans, function (equivSpanNo, equivSpan) {
              if (data.spans[equivSpan]) okEquivSpans.push(equivSpan);
              // TODO: #404, inform the user with a message?
            });
            // sort spans in the equiv by their midpoint
            okEquivSpans.sort(spanComparator);
            // generate the arcs
            var len = okEquivSpans.length;
            for (var i = 1; i < len; i++) {
              var eventDesc = data.eventDescs[equiv[0] + '*' + i] =
                //           (id,                  triggerId,           roles,                         klass)
                new EventDesc(okEquivSpans[i - 1], okEquivSpans[i - 1], [[equiv[1], okEquivSpans[i]]], 'equiv');
              eventDesc.leftSpans = okEquivSpans.slice(0, i);
              eventDesc.rightSpans = okEquivSpans.slice(i);
            }
          });
          $.each(sourceData.relations, function (relNo, rel) {
            // rel[2] is args, rel[2][a][0] is role and rel[2][a][1] is value for a in (0,1)
            var argsDesc = relationTypesHash[rel[1]];
            argsDesc = argsDesc && argsDesc.args;
            var t1, t2;
            if (argsDesc) {
              // sort the arguments according to the config
              var args = {}
              args[rel[2][0][0]] = rel[2][0][1];
              args[rel[2][1][0]] = rel[2][1][1];
              t1 = args[argsDesc[0].role];
              t2 = args[argsDesc[1].role];
            } else {
              // (or leave as-is in its absence)
              t1 = rel[2][0][1];
              t2 = rel[2][1][1];
            }
            data.eventDescs[rel[0]] =
              //           (id, triggerId, roles,          klass)
              new EventDesc(t1, t1, [[rel[1], t2]], 'relation');
          });

          // attributes
          $.each(sourceData.attributes, function (attrNo, attr) {
            // attr: [id, name, spanId, value, cueSpanId

            // TODO: might wish to check what's appropriate for the type
            // instead of using the first attribute def found
            var attrType = (eventAttributeTypes[attr[1]] ||
              entityAttributeTypes[attr[1]]);
            var attrValue = attrType && attrType.values[attrType.bool || attr[3]];
            var span = data.spans[attr[2]];
            if (!span) {
              dispatcher.post('messages', [[['Annotation ' + attr[2] + ', referenced from attribute ' + attr[0] + ', does not exist.', 'error']]]);
              return;
            }
            var valText = (attrValue && attrValue.name) || attr[3];
            var attrText = attrType
              ? (attrType.bool ? attrType.name : (attrType.name + ': ' + valText))
              : (attr[3] == true ? attr[1] : attr[1] + ': ' + attr[3]);
            span.attributeText.push(attrText);
            span.attributes[attr[1]] = attr[3];
            if (attr[4]) { // cue
              span.attributeCues[attr[1]] = attr[4];
              var cueSpan = data.spans[attr[4]];
              cueSpan.attributeCueFor[data.spans[1]] = attr[2];
              cueSpan.cue = 'CUE'; // special css type
            }
            $.extend(span.attributeMerge, attrValue);
          });

          // comments
          $.each(sourceData.comments, function (commentNo, comment) {
            // comment: [entityId, type, text]

            // TODO error handling

            // sentence id: ['sent', sentId]
            if (comment[0] instanceof Array && comment[0][0] == 'sent') {
              // sentence comment
              var sent = comment[0][1];
              var text = comment[2];
              if (data.sentComment[sent]) {
                text = data.sentComment[sent].text + '<br/>' + text;
              }
              data.sentComment[sent] = {type: comment[1], text: text};
            } else {
              var id = comment[0];
              var trigger = triggerHash[id];
              var eventDesc = data.eventDescs[id];
              var commentEntities =
                trigger
                  ? trigger[1] // trigger: [span, ...]
                  : id in data.spans
                  ? [data.spans[id]] // span: [span]
                  : id in data.eventDescs
                    ? [data.eventDescs[id]] // arc: [eventDesc]
                    : [];
              $.each(commentEntities, function (entityId, entity) {
                // if duplicate comment for entity:
                // overwrite type, concatenate comment with a newline
                if (!entity.comment) {
                  entity.comment = {type: comment[1], text: comment[2]};
                } else {
                  entity.comment.type = comment[1];
                  entity.comment.text += "\n" + comment[2];
                }
                // partially duplicate marking of annotator note comments
                if (comment[1] == "AnnotatorNotes") {
                  entity.annotatorNotes = comment[2];
                }
                // prioritize type setting when multiple comments are present
                if (commentPriority(comment[1]) > commentPriority(entity.shadowClass)) {
                  entity.shadowClass = comment[1];
                }
              });
            }
          });

          // normalizations
          $.each(sourceData.normalizations, function (normNo, norm) {
            var id = norm[0];
            var normType = norm[1];
            var target = norm[2];
            var refdb = norm[3];
            var refid = norm[4];
            var reftext = norm[5];

            // grab entity / event the normalization applies to
            var span = data.spans[target];
            if (!span) {
              dispatcher.post('messages', [[['Annotation ' + target + ', referenced from normalization ' + id + ', does not exist.', 'error']]]);
              return;
            }

            // TODO: do we have any possible use for the normType?
            span.normalizations.push([refdb, refid, reftext]);

            // quick hack for span box visual style
            span.normalized = 'Normalized';
          });

          // prepare span boundaries for token containment testing
          var sortedFragments = [];
          $.each(data.spans, function (spanNo, span) {
            $.each(span.fragments, function (fragmentNo, fragment) {
              sortedFragments.push(fragment);
            });
          });
          // sort fragments by beginning, then by end
          sortedFragments.sort(function (a, b) {
            var x = a.from;
            var y = b.from;
            if (x == y) {
              x = a.to;
              y = b.to;
            }
            return ((x < y) ? -1 : ((x > y) ? 1 : 0));
          });
          var currentFragmentId = 0;
          var startFragmentId = 0;
          var numFragments = sortedFragments.length;
          var lastTo = 0;
          var firstFrom = null;
          var chunkNo = 0;
          var space;
          var chunk = null;
          // token containment testing (chunk recognition)
          $.each(sourceData.token_offsets, function () {
            var from = this[0];
            var to = this[1];
            if (firstFrom === null) firstFrom = from;

            // Replaced for speedup; TODO check correctness
            // inSpan = false;
            // $.each(data.spans, function(spanNo, span) {
            //   if (span.from < to && to < span.to) {
            //     // it does; no word break
            //     inSpan = true;
            //     return false;
            //   }
            // });

            // Is the token end inside a span?
            if (startFragmentId && to > sortedFragments[startFragmentId - 1].to) {
              while (startFragmentId < numFragments && to > sortedFragments[startFragmentId].from) {
                startFragmentId++;
              }
            }
            currentFragmentId = startFragmentId;
            while (currentFragmentId < numFragments && to >= sortedFragments[currentFragmentId].to) {
              currentFragmentId++;
            }
            // if yes, the next token is in the same chunk
            if (currentFragmentId < numFragments && to > sortedFragments[currentFragmentId].from) {
              return;
            }

            //Renaud test chunk must not be longer than n
            /*var n = 80;
          var loop = 3;
          if(to - firstFrom > n){ //103
            //create 3 chunks
            for(var i = 0; i < loop; ++i){
              var length = Math.floor((to - firstFrom)/loop);
              var to2 = firstFrom + (length * (i + 1));
              var firstFrom2 = (firstFrom + (length * i)) + 1;

              // otherwise, create the chunk found so far
              space = data.text.substring(to2, firstFrom2);
              var text = data.text.substring(firstFrom2, to2);
              if (chunk) chunk.nextSpace = space;
              chunk = new Chunk(chunkNo++, text, firstFrom2, to2, space);
              data.chunks.push(chunk);
            }

          }else{*/
            // otherwise, create the chunk found so far
            space = data.text.substring(lastTo, firstFrom);
            var text = data.text.substring(firstFrom, to);
            if (chunk) chunk.nextSpace = space;
            //               (index,     text, from,      to, space) {
            chunk = new Chunk(chunkNo++, text, firstFrom, to, space);
            data.chunks.push(chunk);
            /*}*/
            lastTo = to;
            firstFrom = null;
          });
          var numChunks = chunkNo;

          // find sentence boundaries in relation to chunks
          chunkNo = 0;
          var sentenceNo = 0;
          var pastFirst = false;
          $.each(sourceData.sentence_offsets, function () {
            var from = this[0];
            if (chunkNo >= numChunks) return false;
            if (data.chunks[chunkNo].from > from) return;
            var chunk;
            while (chunkNo < numChunks && (chunk = data.chunks[chunkNo]).from < from) {
              chunkNo++;
            }
            chunkNo++;
            if (pastFirst && from <= chunk.from) {
              var numNL = chunk.space.split("\n").length - 1;
              if (!numNL) numNL = 1;
              sentenceNo += numNL;
              chunk.sentence = sentenceNo;
            } else {
              pastFirst = true;
            }
          });

          // assign fragments to appropriate chunks
          var currentChunkId = 0;
          var chunk;
          $.each(sortedFragments, function (fragmentId, fragment) {
            while (fragment.to > (chunk = data.chunks[currentChunkId]).to) currentChunkId++;
            chunk.fragments.push(fragment);
            fragment.text = chunk.text.substring(fragment.from - chunk.from, fragment.to - chunk.from);
            fragment.chunk = chunk;
          });

          // assign arcs to spans; calculate arc distances
          $.each(data.eventDescs, function (eventNo, eventDesc) {
            var dist = 0;
            var origin = data.spans[eventDesc.id];
            if (!origin) {
              // TODO: include missing trigger ID in error message
              dispatcher.post('messages', [[['<strong>ERROR</strong><br/>Trigger for event "' + eventDesc.id + '" not found in ' + data.document + '<br/>(please correct the source data)', 'error', 5]]]);
              return;
            }
            var here = origin.headFragment.from + origin.headFragment.to;
            $.each(eventDesc.roles, function (roleNo, role) {
              var target = data.spans[role.targetId];
              if (!target) {
                dispatcher.post('messages', [[['<strong>ERROR</strong><br/>"' + role.targetId + '" (referenced from "' + eventDesc.id + '") not found in ' + data.document + '<br/>(please correct the source data)', 'error', 5]]]);
                return;
              }
              var there = target.headFragment.from + target.headFragment.to;
              var dist = Math.abs(here - there);
              var arc = new Arc(eventDesc, role, dist, eventNo);
              origin.totalDist += dist;
              origin.numArcs++;
              target.totalDist += dist;
              target.numArcs++;
              data.arcs.push(arc);
              target.incoming.push(arc);
              origin.outgoing.push(arc);
              // ID dict for easy access. TODO: have a function defining the
              // (origin,type,target)->id mapping (see also annotator_ui.js)
              var arcId = origin.id + '--' + role.type + '--' + target.id;
              data.arcById[arcId] = arc;
            }); // roles
          }); // eventDescs

          // highlighting
          markedText = [];
          setMarked('edited'); // set by editing process
          setMarked('focus'); // set by URL
          setMarked('matchfocus'); // set by search process, focused match
          setMarked('match'); // set by search process, other (non-focused) match

          $.each(data.spans, function (spanId, span) {
            // calculate average arc distances
            // average distance of arcs (0 for no arcs)
            span.avgDist = span.numArcs ? span.totalDist / span.numArcs : 0;
            lastSpan = span;

            // collect fragment texts into span texts
            var fragmentTexts = [];
            $.each(span.fragments, function (fragmentNo, fragment) {
              // TODO heuristics
              fragmentTexts.push(fragment.text);
            });
            span.text = fragmentTexts.join('');
          }); // data.spans

          for (var i = 0; i < 2; i++) {
            // preliminary sort to assign heights for basic cases
            // (first round) and cases resolved in the previous
            // round(s).
            $.each(data.chunks, function (chunkNo, chunk) {
              // sort
              chunk.fragments.sort(fragmentComparator);
              // renumber
              $.each(chunk.fragments, function (fragmentNo, fragment) {
                fragment.indexNumber = fragmentNo;
              });
            });
            // nix the sums, so we can sum again
            $.each(data.spans, function (spanNo, span) {
              span.refedIndexSum = 0;
            });
            // resolved cases will now have indexNumber set
            // to indicate their relative order. Sum those for referencing cases
            // for use in iterative resorting
            $.each(data.arcs, function (arcNo, arc) {
              data.spans[arc.origin].refedIndexSum += data.spans[arc.target].headFragment.indexNumber;
            });
          }

          // Final sort of fragments in chunks for drawing purposes
          // Also identify the marked text boundaries regarding chunks
          $.each(data.chunks, function (chunkNo, chunk) {
            // and make the next sort take this into account. Note that this will
            // now resolve first-order dependencies between sort orders but not
            // second-order or higher.
            chunk.fragments.sort(fragmentComparator);
            $.each(chunk.fragments, function (fragmentNo, fragment) {
              fragment.drawOrder = fragmentNo;
            });
          });

          data.spanDrawOrderPermutation = Object.keys(data.spans);
          data.spanDrawOrderPermutation.sort(function (a, b) {
            var spanA = data.spans[a];
            var spanB = data.spans[b];

            // We're jumping all over the chunks, but it's enough that
            // we're doing everything inside each chunk in the right
            // order. should it become necessary to actually do these in
            // linear order, put in a similar condition for
            // spanX.headFragment.chunk.index; but it should not be
            // needed.

            var tmp = spanA.headFragment.drawOrder - spanB.headFragment.drawOrder;
            if (tmp) return tmp < 0 ? -1 : 1;

            return 0;
          });

          // resort the spans for linear order by center
          sortedFragments.sort(midpointComparator);

          // sort fragments into towers, calculate average arc distances
          var lastFragment = null;
          var towerId = -1;
          $.each(sortedFragments, function (i, fragment) {
            if (!lastFragment || (lastFragment.from != fragment.from || lastFragment.to != fragment.to)) {
              towerId++;
            }
            fragment.towerId = towerId;
            lastFragment = fragment;
          }); // sortedFragments

          // find curlies (only the first fragment drawn in a tower)
          $.each(data.spanDrawOrderPermutation, function (spanIdNo, spanId) {
            var span = data.spans[spanId];

            $.each(span.fragments, function (fragmentNo, fragment) {
              if (!data.towers[fragment.towerId]) {
                data.towers[fragment.towerId] = [];
                fragment.drawCurly = true;
                fragment.span.drawCurly = true;
              }
              data.towers[fragment.towerId].push(fragment);
            });
          });

          var spanAnnTexts = {};
          $.each(data.chunks, function (chunkNo, chunk) {
            chunk.markedTextStart = [];
            chunk.markedTextEnd = [];

            $.each(chunk.fragments, function (fragmentNo, fragment) {
              if (chunk.firstFragmentIndex == undefined) {
                chunk.firstFragmentIndex = fragment.towerId;
              }
              chunk.lastFragmentIndex = fragment.towerId;

              var spanLabels = Util.getSpanLabels(spanTypes, fragment.span.type);
              fragment.labelText = Util.spanDisplayForm(spanTypes, fragment.span.type);
              // Find the most appropriate label according to text width
              if (Configuration.abbrevsOn && spanLabels) {
                var labelIdx = 1; // first abbrev
                var maxLength = (fragment.to - fragment.from) / 0.8;
                while (fragment.labelText.length > maxLength &&
                spanLabels[labelIdx]) {
                  fragment.labelText = spanLabels[labelIdx];
                  labelIdx++;
                }
              }

              var svgtext = svg.createText(); // one "text" element per row
              var postfixArray = [];
              var prefix = '';
              var postfix = '';
              var warning = false;
              $.each(fragment.span.attributes, function (attrType, valType) {
                // TODO: might wish to check what's appropriate for the type
                // instead of using the first attribute def found
                var attr = (eventAttributeTypes[attrType] ||
                  entityAttributeTypes[attrType]);
                if (!attr) {
                  // non-existent type
                  warning = true;
                  return;
                }
                var val = attr.values[attr.bool || valType];
                if (!val) {
                  // non-existent value
                  warning = true;
                  return;
                }
                if ($.isEmptyObject(val)) {
                  // defined, but lacks any visual presentation
                  warning = true;
                  return;
                }
                if (val.glyph) {
                  if (val.position == "left") {
                    prefix = val.glyph + prefix;
                    var css = 'glyph';
                    if (attr.css) css += ' glyph_' + Util.escapeQuotes(attr.css);
                    svgtext.span(val.glyph, {'class': css});
                  } else { // XXX right is implied - maybe change
                    postfixArray.push([attr, val]);
                    postfix += val.glyph;
                  }
                }
              });
              var text = fragment.labelText;
              if (prefix !== '') {
                text = prefix + ' ' + text;
                svgtext.string(' ');
              }
              svgtext.string(fragment.labelText);
              if (postfixArray.length) {
                text += ' ' + postfix;
                svgtext.string(' ');
                $.each(postfixArray, function (elNo, el) {
                  var css = 'glyph';
                  if (el[0].css) css += ' glyph_' + Util.escapeQuotes(el[0].css);
                  svgtext.span(el[1].glyph, {'class': css});
                });
              }
              if (warning) {
                svgtext.span("#", {'class': 'glyph attribute_warning'});
                text += ' #';
              }
              fragment.glyphedLabelText = text;

              if (!spanAnnTexts[text]) {
                spanAnnTexts[text] = true;
                data.spanAnnTexts[text] = svgtext;
              }
            }); // chunk.fragments
          }); // chunks

          var numChunks = data.chunks.length;
          // note the location of marked text with respect to chunks
          var startChunk = 0;
          var currentChunk;
          // sort by "from"; we don't need to sort by "to" as well,
          // because unlike spans, chunks are disjunct
          markedText.sort(function (a, b) {
            return Util.cmp(a[0], b[0]);
          });
          $.each(markedText, function (textNo, textPos) {
            var from = textPos[0];
            var to = textPos[1];
            var markedType = textPos[2];
            if (from < 0) from = 0;
            if (to < 0) to = 0;
            if (to >= data.text.length) to = data.text.length - 1;
            if (from > to) from = to;
            while (startChunk < numChunks) {
              var chunk = data.chunks[startChunk];
              if (from <= chunk.to) {
                chunk.markedTextStart.push([textNo, true, from - chunk.from, null, markedType]);
                break;
              }
              startChunk++;
            }
            if (startChunk == numChunks) {
              dispatcher.post('messages', [[['Wrong text offset', 'error']]]);
              return;
            }
            currentChunk = startChunk;
            while (currentChunk < numChunks) {
              var chunk = data.chunks[currentChunk];
              if (to <= chunk.to) {
                chunk.markedTextEnd.push([textNo, false, to - chunk.from]);
                break
              }
              currentChunk++;
            }
            if (currentChunk == numChunks) {
              dispatcher.post('messages', [[['Wrong text offset', 'error']]]);
              var chunk = data.chunks[data.chunks.length - 1];
              chunk.markedTextEnd.push([textNo, false, chunk.text.length]);
              return;
            }
          }); // markedText

          dispatcher.post('dataReady', [data]);
        };

        var resetData = function () {
          setData(sourceData);
          renderData();
        }

        var translate = function (element, x, y) {
          $(element.group).attr('transform', 'translate(' + x + ', ' + y + ')');
          element.translation = {x: x, y: y};
        };

        var showMtime = function () {
          if (data.mtime) {
            // we're getting seconds and need milliseconds
            //$('#document_ctime').text("Created: " + Annotator.formatTime(1000 * data.ctime)).css("display", "inline");
            $('#document_mtime').text("Last modified: " + Util.formatTimeAgo(1000 * data.mtime)).css("display", "inline");
          } else {
            //$('#document_ctime').css("display", "none");
            $('#document_mtime').css("display", "none");
          }
        };

        var addHeaderAndDefs = function () {
          var commentName = (coll + '/' + doc).replace('--', '-\\-');
          $svg.append('<!-- document: ' + commentName + ' -->');
          var defs = svg.defs();
          var $blurFilter = $('<filter id="Gaussian_Blur"><feGaussianBlur in="SourceGraphic" stdDeviation="2" /></filter>');
          svg.add(defs, $blurFilter);
          return defs;
        }

        var getTextMeasurements = function (textsHash, options, callback) {
          // make some text elements, find out the dimensions
          var textMeasureGroup = svg.group(options);

          // changed from $.each because of #264 ('length' can appear)
          for (var text in textsHash) {
            if (textsHash.hasOwnProperty(text)) {
              svg.text(textMeasureGroup, 0, 0, text);
            }
          }

          // measuring goes on here
          var widths = {};
          $(textMeasureGroup).find('text').each(function (svgTextNo, svgText) {
            var text = $(svgText).text();
            widths[text] = this.getComputedTextLength();

            if (callback) {
              $.each(textsHash[text], function (text, object) {
                callback(object, svgText);
              });
            }
          });
          var bbox = textMeasureGroup.getBBox();
          svg.remove(textMeasureGroup);

          return new Measurements(widths, bbox.height, bbox.y);
        };

        var getTextAndSpanTextMeasurements = function () {
          // get the span text sizes
          var chunkTexts = {}; // set of span texts
          $.each(data.chunks, function (chunkNo, chunk) {
            chunk.row = undefined; // reset
            if (!(chunk.text in chunkTexts)) chunkTexts[chunk.text] = []
            var chunkText = chunkTexts[chunk.text];

            // here we also need all the spans that are contained in
            // chunks with this text, because we need to know the position
            // of the span text within the respective chunk text
            chunkText.push.apply(chunkText, chunk.fragments);
            // and also the markedText boundaries
            chunkText.push.apply(chunkText, chunk.markedTextStart);
            chunkText.push.apply(chunkText, chunk.markedTextEnd);
          });
          var textSizes = getTextMeasurements(
            chunkTexts,
            undefined,
            function (fragment, text) {
              if (fragment instanceof Fragment) { // it's a fragment!
                // measure the fragment text position in pixels
                var firstChar = fragment.from - fragment.chunk.from;
                if (firstChar < 0) {
                  firstChar = 0;
                  dispatcher.post('messages', [[['<strong>WARNING</strong>' +
                  '<br/> ' +
                  'The fragment [' + fragment.from + ', ' + fragment.to + '] (' + fragment.text + ') is not ' +
                  'contained in its designated chunk [' +
                  fragment.chunk.from + ', ' + fragment.chunk.to + '] most likely ' +
                  'due to the fragment starting or ending with a space, please ' +
                  'verify the sanity of your data since we are unable to ' +
                  'visualise this fragment correctly and will drop leading ' +
                  'space characters'
                    , 'warning', 15]]]);
                }
                var startPos = text.getStartPositionOfChar(firstChar).x;
                var lastChar = fragment.to - fragment.chunk.from - 1;
                var endPos = (lastChar < 0)
                  ? startPos
                  : text.getEndPositionOfChar(lastChar).x;
                fragment.curly = {
                  from: startPos,
                  to: endPos
                };
              } else { // it's markedText [id, start?, char#, offset]
                if (fragment[2] < 0) fragment[2] = 0;
                if (!fragment[2]) { // start
                  fragment[3] = text.getStartPositionOfChar(fragment[2]).x;
                } else {
                  fragment[3] = text.getEndPositionOfChar(fragment[2] - 1).x + 1;
                }
              }
            });

          // get the fragment annotation text sizes
          var fragmentTexts = {};
          var noSpans = true;
          $.each(data.spans, function (spanNo, span) {
            $.each(span.fragments, function (fragmentNo, fragment) {
              fragmentTexts[fragment.glyphedLabelText] = true;
              noSpans = false;
            });
          });
          if (noSpans) fragmentTexts.$ = true; // dummy so we can at least get the height
          var fragmentSizes = getTextMeasurements(fragmentTexts, {'class': 'span'});

          return {
            texts: textSizes,
            fragments: fragmentSizes
          };
        };

        var addArcTextMeasurements = function (sizes) {
          // get the arc annotation text sizes (for all labels)
          var arcTexts = {};
          $.each(data.arcs, function (arcNo, arc) {
            var labels = Util.getArcLabels(spanTypes, data.spans[arc.origin].type, arc.type, relationTypesHash);
            if (!labels.length) labels = [arc.type];
            $.each(labels, function (labelNo, label) {
              arcTexts[label] = true;
            });
          });
          var arcSizes = getTextMeasurements(arcTexts, {'class': 'arcs'});
          sizes.arcs = arcSizes;
        };

        var adjustTowerAnnotationSizes = function () {
          // find biggest annotation in each tower
          $.each(data.towers, function (towerNo, tower) {
            var maxWidth = 0;
            $.each(tower, function (fragmentNo, fragment) {
              var width = data.sizes.fragments.widths[fragment.glyphedLabelText];
              if (width > maxWidth) maxWidth = width;
            }); // tower
            $.each(tower, function (fragmentNo, fragment) {
              fragment.width = maxWidth;
            }); // tower
          }); // data.towers
        };

        var makeArrow = function (defs, spec) {
          var parsedSpec = spec.split(',');
          var type = parsedSpec[0];
          if (type == 'none') return;

          var width = 5;
          var height = 5;
          var color = "black";
          if ($.isNumeric(parsedSpec[1]) && parsedSpec[2]) {
            if ($.isNumeric(parsedSpec[2]) && parsedSpec[3]) {
              // 3 args, 2 numeric: assume width, height, color
              width = parsedSpec[1];
              height = parsedSpec[2];
              color = parsedSpec[3] || 'black';
            } else {
              // 2 args, 1 numeric: assume width/height, color
              width = height = parsedSpec[1];
              color = parsedSpec[2] || 'black';
            }
          } else {
            // other: assume color only
            width = height = 5;
            color = parsedSpec[1] || 'black';
          }
          // hash needs to be replaced as IDs don't permit it.
          var arrowId = 'arrow_' + spec.replace(/#/g, '').replace(/,/g, '_');

          var arrow;
          if (type == 'triangle') {
            arrow = svg.marker(defs, arrowId,
              width, height / 2, width, height, 'auto',
              {
                markerUnits: 'strokeWidth',
                'fill': color,
              });
            svg.polyline(arrow, [[0, 0], [width, height / 2], [0, height], [width / 12, height / 2]]);
          }
          return arrowId;
        }


        var drawing = false;
        var redraw = false;

        var renderDataReal = function (sourceData) {


          Util.profileEnd('before render');
          Util.profileStart('render');
          Util.profileStart('init');

          if (!sourceData && !data) {
            dispatcher.post('doneRendering', [coll, doc, args]);
            return;
          }
          $svgDiv.show();
          if ((sourceData && sourceData.collection && (sourceData.document !== doc || sourceData.collection !== coll)) || drawing) {
            redraw = true;
            dispatcher.post('doneRendering', [coll, doc, args]);
            return;
          }
          redraw = false;
          drawing = true;

          if (sourceData) setData(sourceData);
          showMtime();

          // clear the SVG
          svg.clear(true);
          if (!data || data.length == 0) return;

          // establish the width according to the enclosing element
          canvasWidth = that.forceWidth || $svgDiv.width();

          var defs = addHeaderAndDefs();

          var backgroundGroup = svg.group({'class': 'background'});
          var glowGroup = svg.group({'class': 'glow'});
          highlightGroup = svg.group({'class': 'highlight'});
          var textGroup = svg.group({'class': 'text'});

          Util.profileEnd('init');
          Util.profileStart('measures');

          var sizes = getTextAndSpanTextMeasurements();
          data.sizes = sizes;

          adjustTowerAnnotationSizes();
          var maxTextWidth = 0;
          for (var text in sizes.texts.widths) {
            if (sizes.texts.widths.hasOwnProperty(text)) {
              var width = sizes.texts.widths[text]
              if (width > maxTextWidth) maxTextWidth = width;
            }
          }

          Util.profileEnd('measures');
          Util.profileStart('chunks');

          var currentX = Configuration.visual.margin.x + sentNumMargin + rowPadding;
          var rows = [];
          var fragmentHeights = [];
          var sentenceToggle = 0;
          var sentenceNumber = 0;
          var row = new Row(svg);
          row.sentence = ++sentenceNumber;
          row.backgroundIndex = sentenceToggle;
          row.index = 0;
          var rowIndex = 0;
          var twoBarWidths; // HACK to avoid measuring space's width
          var openTextHighlights = {};
          var textMarkedRows = [];

          addArcTextMeasurements(sizes);

          // reserve places for spans
          var floors = [];
          var reservations = []; // reservations[chunk][floor] = [[from, to, headroom]...]
          for (var i = 0; i <= data.lastFragmentIndex; i++) {
            reservation[i] = {};
          }
          var inf = 1.0 / 0.0;

          $.each(data.spanDrawOrderPermutation, function (spanIdNo, spanId) {
            var span = data.spans[spanId];

            var f1 = span.fragments[0];
            var f2 = span.fragments[span.fragments.length - 1];

            var x1 = (f1.curly.from + f1.curly.to - f1.width) / 2 -
              Configuration.visual.margin.x;
            var i1 = f1.chunk.index;

            var x2 = (f2.curly.from + f2.curly.to + f2.width) / 2 +
              Configuration.visual.margin.x;
            var i2 = f2.chunk.index;

            // Start from the ground level, going up floor by floor.
            // If no more floors, make a new available one.
            // If a floor is available and there is no carpet, mark it as carpet.
            // If a floor is available and there is carpet and height
            //   difference is at least fragment height + curly, OK.
            // If a floor is not available, forget about carpet.
            // --
            // When OK, calculate exact ceiling.
            // If there isn't one, make a new floor, copy reservations
            //   from floor below (with decreased ceiling)
            // Make the reservation from the carpet to just below the
            //   current floor.
            //
            // TODO drawCurly and height could be prettified to only check
            // actual positions of curlies
            var carpet = 0;
            var outside = true;
            var thisCurlyHeight = span.drawCurly ? Configuration.visual.curlyHeight : 0;
            var height = sizes.fragments.height + thisCurlyHeight + Configuration.visual.boxSpacing +
              2 * Configuration.visual.margin.y - 3;
            $.each(floors, function (floorNo, floor) {
              var floorAvailable = true;
              for (var i = i1; i <= i2; i++) {
                if (!(reservations[i] && reservations[i][floor])) continue;
                var from = (i == i1) ? x1 : -inf;
                var to = (i == i2) ? x2 : inf;
                $.each(reservations[i][floor], function (resNo, res) {
                  if (res[0] < to && from < res[1]) {
                    floorAvailable = false;
                    return false;
                  }
                });
              }
              if (floorAvailable) {
                if (carpet === null) {
                  carpet = floor;
                } else if (height + carpet <= floor) {
                  // found our floor!
                  outside = false;
                  return false;
                }
              } else {
                carpet = null;
              }
            });
            var reslen = reservations.length;
            var makeNewFloorIfNeeded = function (floor) {
              var floorNo = $.inArray(floor, floors);
              if (floorNo == -1) {
                floors.push(floor);
                floors.sort(Util.cmp);
                floorNo = $.inArray(floor, floors);
                if (floorNo != 0) {
                  // copy reservations from the floor below
                  var parquet = floors[floorNo - 1];
                  for (var i = 0; i <= reslen; i++) {
                    if (reservations[i]) {
                      if (!reservations[i][parquet]) {
                        reservations[i][parquet] = [];
                      }
                      var footroom = floor - parquet;
                      $.each(reservations[i][parquet], function (resNo, res) {
                        if (res[2] > footroom) {
                          if (!reservations[i][floor]) {
                            reservations[i][floor] = [];
                          }
                          reservations[i][floor].push([res[0], res[1], res[2] - footroom]);
                        }
                      });
                    }
                  }
                }
              }
              return floorNo;
            }
            var ceiling = carpet + height;
            var ceilingNo = makeNewFloorIfNeeded(ceiling);
            var carpetNo = makeNewFloorIfNeeded(carpet);
            // make the reservation
            var floor, floorNo;
            for (floorNo = carpetNo;
                 (floor = floors[floorNo]) !== undefined && floor < ceiling;
                 floorNo++) {
              var headroom = ceiling - floor;
              for (var i = i1; i <= i2; i++) {
                var from = (i == i1) ? x1 : 0;
                var to = (i == i2) ? x2 : inf;
                if (!reservations[i]) reservations[i] = {};
                if (!reservations[i][floor]) reservations[i][floor] = [];
                reservations[i][floor].push([from, to, headroom]); // XXX maybe add fragment; probably unnecessary
              }
            }
            span.floor = carpet + thisCurlyHeight;
          });

          $.each(data.chunks, function (chunkNo, chunk) {
            reservations = new Array();
            chunk.group = svg.group(row.group);
            chunk.highlightGroup = svg.group(chunk.group);

            var y = 0;
            var minArcDist;
            var hasLeftArcs, hasRightArcs, hasInternalArcs;
            var hasAnnotations;
            var chunkFrom = Infinity;
            var chunkTo = 0;
            var chunkHeight = 0;
            var spacing = 0;
            var spacingChunkId = null;
            var spacingRowBreak = 0;

            $.each(chunk.fragments, function (fragmentNo, fragment) {
              var span = fragment.span;
              var spanDesc = spanTypes[span.type];
              var bgColor = ((spanDesc && spanDesc.bgColor) ||
                (spanTypes.SPAN_DEFAULT &&
                  spanTypes.SPAN_DEFAULT.bgColor) || '#ffffff');
              var fgColor = ((spanDesc && spanDesc.fgColor) ||
                (spanTypes.SPAN_DEFAULT &&
                  spanTypes.SPAN_DEFAULT.fgColor) || '#000000');
              var borderColor = ((spanDesc && spanDesc.borderColor) ||
                (spanTypes.SPAN_DEFAULT &&
                  spanTypes.SPAN_DEFAULT.borderColor) || '#000000');

              // special case: if the border 'color' value is 'darken',
              // then just darken the BG color a bit for the border.
              if (borderColor == 'darken') {
                borderColor = Util.adjustColorLightness(bgColor, -0.6);
              }

              fragment.group = svg.group(chunk.group, {
                'class': 'span',
              });

              var fragmentHeight = 0;

              if (!y) y = -sizes.texts.height;
              var x = (fragment.curly.from + fragment.curly.to) / 2;

              // XXX is it maybe sizes.texts?
              var yy = y + sizes.fragments.y;
              var hh = sizes.fragments.height;
              var ww = fragment.width;
              var xx = x - ww / 2;

              // text margin fine-tuning
              yy += boxTextMargin.y;
              hh -= 2 * boxTextMargin.y;
              xx += boxTextMargin.x;
              ww -= 2 * boxTextMargin.x;
              var rectClass = 'span_' + (span.cue || span.type) + ' span_default'; // TODO XXX first part unneeded I think; remove

              // attach e.g. "False_positive" into the type
              if (span.comment && span.comment.type) {
                rectClass += ' ' + span.comment.type;
              }
              var bx = xx - Configuration.visual.margin.x - boxTextMargin.x;
              var by = yy - Configuration.visual.margin.y;
              var bw = ww + 2 * Configuration.visual.margin.x;
              var bh = hh + 2 * Configuration.visual.margin.y;

              if (roundCoordinates) {
                x = (x | 0) + 0.5;
                bx = (bx | 0) + 0.5;
              }

              var shadowRect;
              var markedRect;
              if (span.marked) {
                markedRect = svg.rect(chunk.highlightGroup,
                  bx - markedSpanSize, by - markedSpanSize,
                  bw + 2 * markedSpanSize, bh + 2 * markedSpanSize, {

                    // filter: 'url(#Gaussian_Blur)',
                    'class': "shadow_EditHighlight",
                    rx: markedSpanSize,
                    ry: markedSpanSize,
                  });
                svg.other(markedRect, 'animate', {
                  'data-type': span.marked,
                  attributeName: 'fill',
                  values: (span.marked == 'match' ? highlightMatchSequence
                    : highlightSpanSequence),
                  dur: highlightDuration,
                  repeatCount: 'indefinite',
                  begin: 'indefinite'
                });
                chunkFrom = Math.min(bx - markedSpanSize, chunkFrom);
                chunkTo = Math.max(bx + bw + markedSpanSize, chunkTo);
                fragmentHeight = Math.max(bh + 2 * markedSpanSize, fragmentHeight);
              }
              // .match() removes unconfigured shadows, which were
              // always showing up as black.
              // TODO: don't hard-code configured shadowclasses.
              if (span.shadowClass &&
                span.shadowClass.match('True_positive|False_positive|False_negative|AnnotationError|AnnotationWarning|AnnotatorNotes|Normalized|AnnotationIncomplete|AnnotationUnconfirmed|rectEditHighlight|EditHighlight_arc|MissingAnnotation|ChangedAnnotation ')) {
                shadowRect = svg.rect(fragment.group,
                  bx - rectShadowSize, by - rectShadowSize,
                  bw + 2 * rectShadowSize, bh + 2 * rectShadowSize, {
                    'class': 'shadow_' + span.shadowClass,
                    filter: 'url(#Gaussian_Blur)',
                    rx: rectShadowRounding,
                    ry: rectShadowRounding,
                  });
                chunkFrom = Math.min(bx - rectShadowSize, chunkFrom);
                chunkTo = Math.max(bx + bw + rectShadowSize, chunkTo);
                fragmentHeight = Math.max(bh + 2 * rectShadowSize, fragmentHeight);
              }
              fragment.rect = svg.rect(fragment.group,
                bx, by, bw, bh, {

                  'class': rectClass,
                  fill: bgColor,
                  stroke: borderColor,
                  rx: Configuration.visual.margin.x,
                  ry: Configuration.visual.margin.y,
                  'data-span-id': span.id,
                  'data-fragment-id': fragment.id,
                  'strokeDashArray': span.attributeMerge.dashArray,
                });

              // TODO XXX: quick nasty hack to allow normalizations
              // to be marked visually; do something cleaner!
              if (span.normalized) {
                $(fragment.rect).addClass(span.normalized);
              }

              fragment.right = bx + bw; // TODO put it somewhere nicer?
              if (!(span.shadowClass || span.marked)) {
                chunkFrom = Math.min(bx, chunkFrom);
                chunkTo = Math.max(bx + bw, chunkTo);
                fragmentHeight = Math.max(bh, fragmentHeight);
              }

              fragment.rectBox = {x: bx, y: by - span.floor, width: bw, height: bh};
              fragment.height = span.floor + hh + 3 * Configuration.visual.margin.y + Configuration.visual.curlyHeight + Configuration.visual.arcSpacing;
              var spacedTowerId = fragment.towerId * 2;
              if (!fragmentHeights[spacedTowerId] || fragmentHeights[spacedTowerId] < fragment.height) {
                fragmentHeights[spacedTowerId] = fragment.height;
              }
              $(fragment.rect).attr('y', yy - Configuration.visual.margin.y - span.floor);
              if (shadowRect) {
                $(shadowRect).attr('y', yy - rectShadowSize - Configuration.visual.margin.y - span.floor);
              }
              if (markedRect) {
                $(markedRect).attr('y', yy - markedSpanSize - Configuration.visual.margin.y - span.floor);
              }
              if (span.attributeMerge.box === "crossed") {
                svg.path(fragment.group, svg.createPath().move(xx, yy - Configuration.visual.margin.y - span.floor).line(xx + fragment.width,
                  yy + hh + Configuration.visual.margin.y - span.floor),
                  {'class': 'boxcross'});
                svg.path(fragment.group, svg.createPath().move(xx + fragment.width, yy - Configuration.visual.margin.y - span.floor).line(xx, yy + hh + Configuration.visual.margin.y - span.floor),
                  {'class': 'boxcross'});
              }
              var fragmentText = svg.text(fragment.group, x, y - span.floor, data.spanAnnTexts[fragment.glyphedLabelText], {fill: fgColor});

              // Make curlies to show the fragment
              if (fragment.drawCurly) {
                var curlyColor = 'grey';
                if (coloredCurlies) {
                  var spanDesc = spanTypes[span.type];
                  var bgColor = ((spanDesc && spanDesc.bgColor) ||
                    (spanTypes.SPAN_DEFAULT &&
                      spanTypes.SPAN_DEFAULT.fgColor) ||
                    '#000000');
                  curlyColor = Util.adjustColorLightness(bgColor, -0.6);
                }

                var bottom = yy + hh + Configuration.visual.margin.y - span.floor + 1;
                svg.path(fragment.group, svg.createPath()
                    .move(fragment.curly.from, bottom + Configuration.visual.curlyHeight)
                    .curveC(fragment.curly.from, bottom,
                      x, bottom + Configuration.visual.curlyHeight,
                      x, bottom)
                    .curveC(x, bottom + Configuration.visual.curlyHeight,
                      fragment.curly.to, bottom,
                      fragment.curly.to, bottom + Configuration.visual.curlyHeight),
                  {
                    'class': 'curly',
                    'stroke': curlyColor,
                  });
                chunkFrom = Math.min(fragment.curly.from, chunkFrom);
                chunkTo = Math.max(fragment.curly.to, chunkTo);
                fragmentHeight = Math.max(Configuration.visual.curlyHeight, fragmentHeight);
              }

              if (fragment == span.headFragment) {
                // find the gap to fit the backwards arcs, but only on
                // head fragment - other fragments don't have arcs
                $.each(span.incoming, function (arcId, arc) {
                  var leftSpan = data.spans[arc.origin];
                  var origin = leftSpan.headFragment.chunk;
                  var border;
                  if (chunk.index == origin.index) {
                    hasInternalArcs = true;
                  }
                  if (origin.row) {
                    var labels = Util.getArcLabels(spanTypes, leftSpan.type, arc.type, relationTypesHash);
                    if (!labels.length) labels = [arc.type];
                    if (origin.row.index == rowIndex) {
                      // same row, but before this
                      border = origin.translation.x + leftSpan.fragments[leftSpan.fragments.length - 1].right;
                    } else {
                      border = Configuration.visual.margin.x + sentNumMargin + rowPadding;
                    }
                    var labelNo = Configuration.abbrevsOn ? labels.length - 1 : 0;
                    var smallestLabelWidth = sizes.arcs.widths[labels[labelNo]] + 2 * minArcSlant;
                    var gap = currentX + bx - border;
                    var arcSpacing = smallestLabelWidth - gap;
                    if (!hasLeftArcs || spacing < arcSpacing) {
                      spacing = arcSpacing;
                      spacingChunkId = origin.index + 1;
                    }
                    arcSpacing = smallestLabelWidth - bx;
                    if (!hasLeftArcs || spacingRowBreak < arcSpacing) {
                      spacingRowBreak = arcSpacing;
                    }
                    hasLeftArcs = true;
                  } else {
                    hasRightArcs = true;
                  }
                });
                $.each(span.outgoing, function (arcId, arc) {
                  var leftSpan = data.spans[arc.target];
                  var target = leftSpan.headFragment.chunk;
                  var border;
                  if (target.row) {
                    var labels = Util.getArcLabels(spanTypes, span.type, arc.type, relationTypesHash);
                    if (!labels.length) labels = [arc.type];
                    if (target.row.index == rowIndex) {
                      // same row, but before this
                      border = target.translation.x + leftSpan.fragments[leftSpan.fragments.length - 1].right;
                    } else {
                      border = Configuration.visual.margin.x + sentNumMargin + rowPadding;
                    }
                    var labelNo = Configuration.abbrevsOn ? labels.length - 1 : 0;
                    var smallestLabelWidth = sizes.arcs.widths[labels[labelNo]] + 2 * minArcSlant;
                    var gap = currentX + bx - border;
                    var arcSpacing = smallestLabelWidth - gap;
                    if (!hasLeftArcs || spacing < arcSpacing) {
                      spacing = arcSpacing;
                      spacingChunkId = target.index + 1;
                    }
                    arcSpacing = smallestLabelWidth - bx;
                    if (!hasLeftArcs || spacingRowBreak < arcSpacing) {
                      spacingRowBreak = arcSpacing;
                    }
                    hasLeftArcs = true;
                  } else {
                    hasRightArcs = true;
                  }
                });
              }
              fragmentHeight += span.floor || Configuration.visual.curlyHeight;
              if (fragmentHeight > chunkHeight) chunkHeight = fragmentHeight;
              hasAnnotations = true;
            }); // fragments

            // positioning of the chunk
            chunk.right = chunkTo;
            var textWidth = sizes.texts.widths[chunk.text];
            chunkHeight += sizes.texts.height;
            var boxX = -Math.min(chunkFrom, 0);
            var boxWidth =
              Math.max(textWidth, chunkTo) -
              Math.min(0, chunkFrom);
            // if (hasLeftArcs) {
            // TODO change this with smallestLeftArc
            // var spacing = arcHorizontalSpacing - (currentX - lastArcBorder);
            // arc too small?
            if (spacing > 0) currentX += spacing;
            // }
            var rightBorderForArcs = hasRightArcs ? arcHorizontalSpacing : (hasInternalArcs ? arcSlant : 0);

            var lastX = currentX;
            var lastRow = row;

            if (chunk.sentence) {
              while (sentenceNumber < chunk.sentence) {
                sentenceNumber++;
                row.arcs = svg.group(row.group, {'class': 'arcs'});
                rows.push(row);
                row = new Row(svg);
                sentenceToggle = 1 - sentenceToggle;
                row.backgroundIndex = sentenceToggle;
                row.index = ++rowIndex;
              }
              sentenceToggle = 1 - sentenceToggle;
            }

            if (chunk.sentence ||
              currentX + boxWidth + rightBorderForArcs >= canvasWidth - 2 * Configuration.visual.margin.x) {
              // the chunk does not fit
              row.arcs = svg.group(row.group, {'class': 'arcs'});
              // TODO: related to issue #571
              // replace arcHorizontalSpacing with a calculated value
              currentX = Configuration.visual.margin.x + sentNumMargin + rowPadding +
                (hasLeftArcs ? arcHorizontalSpacing : (hasInternalArcs ? arcSlant : 0));
              if (hasLeftArcs) {
                var adjustedCurTextWidth = sizes.texts.widths[chunk.text] + arcHorizontalSpacing;
                if (adjustedCurTextWidth > maxTextWidth) {
                  maxTextWidth = adjustedCurTextWidth;
                }
              }
              if (spacingRowBreak > 0) {
                currentX += spacingRowBreak;
                spacing = 0; // do not center intervening elements
              }

              // new row
              rows.push(row);

              svg.remove(chunk.group);
              row = new Row(svg);
              row.backgroundIndex = sentenceToggle;
              row.index = ++rowIndex;
              svg.add(row.group, chunk.group);
              chunk.group = row.group.lastElementChild;
              $(chunk.group).children("g[class='span']").each(function (index, element) {
                chunk.fragments[index].group = element;
              });
              $(chunk.group).find("rect[data-span-id]").each(function (index, element) {
                chunk.fragments[index].rect = element;
              });
            }

            // break the text highlights when the row breaks
            if (row.index !== lastRow.index) {
              $.each(openTextHighlights, function (textId, textDesc) {
                if (textDesc[3] != lastX) {
                  var newDesc = [lastRow, textDesc[3], lastX + boxX, textDesc[4]];
                  textMarkedRows.push(newDesc);
                }
                textDesc[3] = currentX;
              });
            }

            // open text highlights
            $.each(chunk.markedTextStart, function (textNo, textDesc) {
              textDesc[3] += currentX + boxX;
              openTextHighlights[textDesc[0]] = textDesc;
            });

            // close text highlights
            $.each(chunk.markedTextEnd, function (textNo, textDesc) {
              textDesc[3] += currentX + boxX;
              var startDesc = openTextHighlights[textDesc[0]];
              delete openTextHighlights[textDesc[0]];
              markedRow = [row, startDesc[3], textDesc[3], startDesc[4]];
              textMarkedRows.push(markedRow);
            });

            // XXX check this - is it used? should it be lastRow?
            if (hasAnnotations) row.hasAnnotations = true;

            if (chunk.sentence) {
              row.sentence = ++sentenceNumber;
            }

            if (spacing > 0) {
              // if we added a gap, center the intervening elements
              spacing /= 2;
              var firstChunkInRow = row.chunks[row.chunks.length - 1];
              if (spacingChunkId < firstChunkInRow.index) {
                spacingChunkId = firstChunkInRow.index + 1;
              }
              for (var chunkIndex = spacingChunkId; chunkIndex < chunk.index; chunkIndex++) {
                var movedChunk = data.chunks[chunkIndex];
                translate(movedChunk, movedChunk.translation.x + spacing, 0);
                movedChunk.textX += spacing;
              }
            }

            row.chunks.push(chunk);
            chunk.row = row;

            translate(chunk, currentX + boxX, 0);
            chunk.textX = currentX + boxX;

            var spaceWidth = 0;
            var spaceLen = chunk.nextSpace && chunk.nextSpace.length || 0;
            for (var i = 0; i < spaceLen; i++) spaceWidth += spaceWidths[chunk.nextSpace[i]] || 0;
            currentX += spaceWidth + boxWidth;
          }); // chunks

          // finish the last row
          row.arcs = svg.group(row.group, {'class': 'arcs'});
          rows.push(row);

          Util.profileEnd('chunks');
          Util.profileStart('arcsPrep');

          var arrows = {};
          var arrow = makeArrow(defs, 'none');
          if (arrow) arrows['none'] = arrow;

          var len = fragmentHeights.length;
          for (var i = 0; i < len; i++) {
            if (!fragmentHeights[i] || fragmentHeights[i] < Configuration.visual.arcStartHeight) {
              fragmentHeights[i] = Configuration.visual.arcStartHeight;
            }
          }

          // find out how high the arcs have to go
          $.each(data.arcs, function (arcNo, arc) {
            arc.jumpHeight = 0;
            var fromFragment = data.spans[arc.origin].headFragment;
            var toFragment = data.spans[arc.target].headFragment;
            if (fromFragment.towerId > toFragment.towerId) {
              var tmp = fromFragment;
              fromFragment = toFragment;
              toFragment = tmp;
            }
            var from, to;
            if (fromFragment.chunk.index == toFragment.chunk.index) {
              from = fromFragment.towerId;
              to = toFragment.towerId;
            } else {
              from = fromFragment.towerId + 1;
              to = toFragment.towerId - 1;
            }
            for (var i = from; i <= to; i++) {
              if (arc.jumpHeight < fragmentHeights[i * 2]) arc.jumpHeight = fragmentHeights[i * 2];
            }
          });

          // sort the arcs
          data.arcs.sort(function (a, b) {
            // first write those that have less to jump over
            var tmp = a.jumpHeight - b.jumpHeight;
            if (tmp) return tmp < 0 ? -1 : 1;
            // if equal, then those that span less distance
            tmp = a.dist - b.dist;
            if (tmp) return tmp < 0 ? -1 : 1;
            // if equal, then those where heights of the targets are smaller
            tmp = data.spans[a.origin].headFragment.height + data.spans[a.target].headFragment.height -
              data.spans[b.origin].headFragment.height - data.spans[b.target].headFragment.height;
            if (tmp) return tmp < 0 ? -1 : 1;
            // if equal, then those with the lower origin
            tmp = data.spans[a.origin].headFragment.height - data.spans[b.origin].headFragment.height;
            if (tmp) return tmp < 0 ? -1 : 1;
            // if equal, they're just equal.
            return 0;
          });

          // draw the drag arc marker
          var arrowhead = svg.marker(defs, 'drag_arrow',
            5, 2.5, 5, 5, 'auto',
            {
              markerUnits: 'strokeWidth',
              'class': 'drag_fill',
            });
          svg.polyline(arrowhead, [[0, 0], [5, 2.5], [0, 5], [0.2, 2.5]]);

          Util.profileEnd('arcsPrep');
          Util.profileStart('arcs');

          // add the arcs
          $.each(data.arcs, function (arcNo, arc) {
            // separate out possible numeric suffix from type
            var noNumArcType;
            var splitArcType;
            if (arc.type) {
              splitArcType = arc.type.match(/^(.*?)(\d*)$/);
              noNumArcType = splitArcType[1];
            }

            var originSpan = data.spans[arc.origin];
            var targetSpan = data.spans[arc.target];

            var leftToRight = originSpan.headFragment.towerId < targetSpan.headFragment.towerId;
            var left, right;
            if (leftToRight) {
              left = originSpan.headFragment;
              right = targetSpan.headFragment;
            } else {
              left = targetSpan.headFragment;
              right = originSpan.headFragment;
            }

            var spanDesc = spanTypes[originSpan.type];
            // TODO: might make more sense to reformat this as dict instead
            // of searching through the list every type
            var arcDesc;
            if (spanDesc && spanDesc.arcs) {
              $.each(spanDesc.arcs, function (arcDescNo, arcDescIter) {
                if (arcDescIter.type == arc.type) {
                  arcDesc = arcDescIter;
                }
              });
            }
            // fall back on unnumbered type if not found in full
            if (!arcDesc && noNumArcType && noNumArcType != arc.type &&
              spanDesc && spanDesc.arcs) {
              $.each(spanDesc.arcs, function (arcDescNo, arcDescIter) {
                if (arcDescIter.type == noNumArcType) {
                  arcDesc = arcDescIter;
                }
              });
            }
            // fall back on relation types in case we still don't have
            // an arc description, with final fallback to unnumbered relation
            if (!arcDesc) {
              arcDesc = $.extend({}, relationTypesHash[arc.type] || relationTypesHash[noNumArcType]);
            }
            var color = ((arcDesc && arcDesc.color) ||
              (spanTypes.ARC_DEFAULT && spanTypes.ARC_DEFAULT.color) ||
              '#000000');
            var symmetric = arcDesc && arcDesc.properties && arcDesc.properties.symmetric;
            var dashArray = arcDesc && arcDesc.dashArray;
            var arrowHead = ((arcDesc && arcDesc.arrowHead) ||
              (spanTypes.ARC_DEFAULT && spanTypes.ARC_DEFAULT.arrowHead) ||
              'triangle,5') + ',' + color;
            var labelArrowHead = ((arcDesc && arcDesc.labelArrow) ||
              (spanTypes.ARC_DEFAULT && spanTypes.ARC_DEFAULT.labelArrow) ||
              'triangle,5') + ',' + color;

            var leftBox = rowBBox(left);
            var rightBox = rowBBox(right);
            var leftRow = left.chunk.row.index;
            var rightRow = right.chunk.row.index;

            if (!arrows[arrowHead]) {
              var arrow = makeArrow(defs, arrowHead);
              if (arrow) arrows[arrowHead] = arrow;
            }
            if (!arrows[labelArrowHead]) {
              var arrow = makeArrow(defs, labelArrowHead);
              if (arrow) arrows[labelArrowHead] = arrow;
            }

            // find the next height
            var height = 0;

            var fromIndex2, toIndex2;
            if (left.chunk.index == right.chunk.index) {
              fromIndex2 = left.towerId * 2;
              toIndex2 = right.towerId * 2;
            } else {
              fromIndex2 = left.towerId * 2 + 1;
              toIndex2 = right.towerId * 2 - 1;
            }
            for (var i = fromIndex2; i <= toIndex2; i++) {
              if (fragmentHeights[i] > height) height = fragmentHeights[i];
            }
            height += Configuration.visual.arcSpacing;
            var leftSlantBound, rightSlantBound;
            for (var i = fromIndex2; i <= toIndex2; i++) {
              if (fragmentHeights[i] < height) fragmentHeights[i] = height;
            }

            // Adjust the height to align with pixels when rendered

            // TODO: on at least Chrome, this doesn't make a difference:
            // the lines come out pixel-width even without it. Check.
            height += 0.5

            var chunkReverse = false;
            var ufoCatcher = originSpan.headFragment.chunk.index == targetSpan.headFragment.chunk.index;
            if (ufoCatcher) {
              chunkReverse =
                leftBox.x + leftBox.width / 2 < rightBox.x + rightBox.width / 2;
            }
            var ufoCatcherMod = ufoCatcher ? chunkReverse ? -0.5 : 0.5 : 1;

            for (var rowIndex = leftRow; rowIndex <= rightRow; rowIndex++) {
              var row = rows[rowIndex];
              row.hasAnnotations = true;
              var arcGroup = svg.group(row.arcs, {
                'data-from': arc.origin,
                'data-to': arc.target
              });
              var from, to;

              if (rowIndex == leftRow) {
                from = leftBox.x + (chunkReverse ? 0 : leftBox.width);
              } else {
                from = sentNumMargin;
              }

              if (rowIndex == rightRow) {
                to = rightBox.x + (chunkReverse ? rightBox.width : 0);
              } else {
                to = canvasWidth - 2 * Configuration.visual.margin.y;
              }

              var originType = data.spans[arc.origin].type;
              var arcLabels = Util.getArcLabels(spanTypes, originType, arc.type, relationTypesHash);
              var labelText = Util.arcDisplayForm(spanTypes, originType, arc.type, relationTypesHash);
              // if (Configuration.abbrevsOn && !ufoCatcher && arcLabels) {
              if (Configuration.abbrevsOn && arcLabels) {
                var labelIdx = 1; // first abbreviation
                // strictly speaking 2*arcSlant would be needed to allow for
                // the full-width arcs to fit, but judged unabbreviated text
                // to be more important than the space for arcs.
                var maxLength = (to - from) - (arcSlant);
                while (sizes.arcs.widths[labelText] > maxLength &&
                arcLabels[labelIdx]) {
                  labelText = arcLabels[labelIdx];
                  labelIdx++;
                }
              }

              var shadowGroup;
              if (arc.shadowClass || arc.marked) {
                shadowGroup = svg.group(arcGroup);
              }
              var options = {
                'fill': color,
                'data-arc-role': arc.type,
                'data-arc-origin': arc.origin,
                'data-arc-target': arc.target,
                // TODO: confirm this is unused and remove.
                //'data-arc-id': arc.id,
                'data-arc-ed': arc.eventDescId,
              };

              // construct SVG text, showing possible trailing index
              // numbers (as in e.g. "Theme2") as subscripts
              var svgText;
              if (!splitArcType[2]) {
                // no subscript, simple string suffices
                svgText = labelText;
              } else {
                // Need to parse out possible numeric suffixes to avoid
                // duplicating number in label and its subscript
                var splitLabelText = labelText.match(/^(.*?)(\d*)$/);
                var noNumLabelText = splitLabelText[1];

                svgText = svg.createText();
                // TODO: to address issue #453, attaching options also
                // to spans, not only primary text. Make sure there
                // are no problems with this.
                svgText.span(noNumLabelText, options);
                var subscriptSettings = {
                  'dy': '0.3em',
                  'font-size': '80%'
                };
                // alternate possibility
//                 var subscriptSettings = {
//                   'baseline-shift': 'sub',
//                   'font-size': '80%'
//                 };
                $.extend(subscriptSettings, options);
                svgText.span(splitArcType[2], subscriptSettings);
              }

              // guess at the correct baseline shift to get vertical centering.
              // (CSS dominant-baseline can't be used as not all SVG rendereds support it.)
              var baseline_shift = sizes.arcs.height / 4;
              var text = svg.text(arcGroup, (from + to) / 2, -height + baseline_shift,
                svgText, options);

              var width = sizes.arcs.widths[labelText];
              var textBox = {
                x: (from + to - width) / 2,
                width: width,
                y: -height - sizes.arcs.height / 2,
                height: sizes.arcs.height,
              }
              if (arc.marked) {
                var markedRect = svg.rect(shadowGroup,
                  textBox.x - markedArcSize, textBox.y - markedArcSize,
                  textBox.width + 2 * markedArcSize, textBox.height + 2 * markedArcSize, {
                    // filter: 'url(#Gaussian_Blur)',
                    'class': "shadow_EditHighlight",
                    rx: markedArcSize,
                    ry: markedArcSize,
                  });
                svg.other(markedRect, 'animate', {
                  'data-type': arc.marked,
                  attributeName: 'fill',
                  values: (arc.marked == 'match' ? highlightMatchSequence
                    : highlightArcSequence),
                  dur: highlightDuration,
                  repeatCount: 'indefinite',
                  begin: 'indefinite'
                });
              }
              if (arc.shadowClass) {
                svg.rect(shadowGroup,
                  textBox.x - arcLabelShadowSize,
                  textBox.y - arcLabelShadowSize,
                  textBox.width + 2 * arcLabelShadowSize,
                  textBox.height + 2 * arcLabelShadowSize, {
                    'class': 'shadow_' + arc.shadowClass,
                    filter: 'url(#Gaussian_Blur)',
                    rx: arcLabelShadowRounding,
                    ry: arcLabelShadowRounding,
                  });
              }
              var textStart = textBox.x;
              var textEnd = textBox.x + textBox.width;

              // adjust by margin for arc drawing
              textStart -= Configuration.visual.arcTextMargin;
              textEnd += Configuration.visual.arcTextMargin;

              if (from > to) {
                var tmp = textStart;
                textStart = textEnd;
                textEnd = tmp;
              }

              var path;

              if (roundCoordinates) {
                // don't ask
                height = (height | 0) + 0.5;
              }
              if (height > row.maxArcHeight) row.maxArcHeight = height;

              var myArrowHead = ((arcDesc && arcDesc.arrowHead) ||
                (spanTypes.ARC_DEFAULT && spanTypes.ARC_DEFAULT.arrowHead));
              var arrowName = (leftToRight ?
                symmetric && myArrowHead || 'none' :
                myArrowHead || 'triangle,5') + ',' + color;
              var arrowType = arrows[arrowName];
              var arrowDecl = arrowType && ('url(#' + arrowType + ')');

              var arrowAtLabelAdjust = 0;
              var labelArrowDecl = null;
              var myLabelArrowHead = ((arcDesc && arcDesc.labelArrow) ||
                (spanTypes.ARC_DEFAULT && spanTypes.ARC_DEFAULT.labelArrow));
              if (myLabelArrowHead) {
                var labelArrowName = (leftToRight ?
                  symmetric && myLabelArrowHead || 'none' :
                  myLabelArrowHead || 'triangle,5') + ',' + color;
                var labelArrowSplit = labelArrowName.split(',');
                arrowAtLabelAdjust = labelArrowSplit[0] != 'none' && parseInt(labelArrowSplit[1], 10) || 0;
                var labelArrowType = arrows[labelArrowName];
                var labelArrowDecl = labelArrowType && ('url(#' + labelArrowType + ')');
                if (ufoCatcher) arrowAtLabelAdjust = -arrowAtLabelAdjust;
              }
              var arrowStart = textStart - arrowAtLabelAdjust;
              path = svg.createPath().move(arrowStart, -height);
              if (rowIndex == leftRow) {
                var cornerx = from + ufoCatcherMod * arcSlant;
                // for normal cases, should not be past textStart even if narrow
                if (!ufoCatcher && cornerx > arrowStart - 1) {
                  cornerx = arrowStart - 1;
                }
                if (smoothArcCurves) {
                  var controlx = ufoCatcher ? cornerx + 2 * ufoCatcherMod * reverseArcControlx : smoothArcSteepness * from + (1 - smoothArcSteepness) * cornerx;
                  var endy = leftBox.y + (leftToRight || arc.equiv ? leftBox.height / 2 : Configuration.visual.margin.y);
                  // no curving for short lines covering short vertical
                  // distances, the arrowheads can go off (#925)
                  if (Math.abs(-height - endy) < 2 &&
                    Math.abs(cornerx - from) < 5) {
                    endy = -height;
                  }
                  line = path.line(cornerx, -height).curveQ(controlx, -height, from, endy);
                } else {
                  path.line(cornerx, -height).line(from, leftBox.y + (leftToRight || arc.equiv ? leftBox.height / 2 : Configuration.visual.margin.y));
                }
              } else {
                path.line(from, -height);
              }
              svg.path(arcGroup, path, {
                markerEnd: arrowDecl,
                markerStart: labelArrowDecl,
                style: 'stroke: ' + color,
                'strokeDashArray': dashArray,
              });
              if (arc.marked) {
                svg.path(shadowGroup, path, {
                  'class': 'shadow_EditHighlight_arc',
                  strokeWidth: markedArcStroke,
                  'strokeDashArray': dashArray,
                });
                svg.other(markedRect, 'animate', {
                  'data-type': arc.marked,
                  attributeName: 'fill',
                  values: (arc.marked == 'match' ? highlightMatchSequence
                    : highlightArcSequence),
                  dur: highlightDuration,
                  repeatCount: 'indefinite',
                  begin: 'indefinite'
                });
              }
              if (arc.shadowClass) {
                svg.path(shadowGroup, path, {
                  'class': 'shadow_' + arc.shadowClass,
                  strokeWidth: shadowStroke,
                  'strokeDashArray': dashArray,
                });
              }
              var myArrowHead = ((arcDesc && arcDesc.arrowHead) ||
                (spanTypes.ARC_DEFAULT && spanTypes.ARC_DEFAULT.arrowHead));
              var arrowName = (leftToRight ?
                myArrowHead || 'triangle,5' :
                symmetric && myArrowHead || 'none') + ',' + color;
              var arrowType = arrows[arrowName];
              var arrowDecl = arrowType && ('url(#' + arrowType + ')');

              var arrowAtLabelAdjust = 0;
              var labelArrowDecl = null;
              var myLabelArrowHead = ((arcDesc && arcDesc.labelArrow) ||
                (spanTypes.ARC_DEFAULT && spanTypes.ARC_DEFAULT.labelArrow));
              if (myLabelArrowHead) {
                var labelArrowName = (leftToRight ?
                  myLabelArrowHead || 'triangle,5' :
                  symmetric && myLabelArrowHead || 'none') + ',' + color;
                var labelArrowSplit = labelArrowName.split(',');
                arrowAtLabelAdjust = labelArrowSplit[0] != 'none' && parseInt(labelArrowSplit[1], 10) || 0;
                var labelArrowType = arrows[labelArrowName];
                var labelArrowDecl = labelArrowType && ('url(#' + labelArrowType + ')');
                if (ufoCatcher) arrowAtLabelAdjust = -arrowAtLabelAdjust;
              }
              var arrowEnd = textEnd + arrowAtLabelAdjust;
              path = svg.createPath().move(arrowEnd, -height);
              if (rowIndex == rightRow) {
                var cornerx = to - ufoCatcherMod * arcSlant;
                // TODO: duplicates above in part, make funcs
                // for normal cases, should not be past textEnd even if narrow
                if (!ufoCatcher && cornerx < arrowEnd + 1) {
                  cornerx = arrowEnd + 1;
                }
                if (smoothArcCurves) {
                  var controlx = ufoCatcher ? cornerx - 2 * ufoCatcherMod * reverseArcControlx : smoothArcSteepness * to + (1 - smoothArcSteepness) * cornerx;
                  var endy = rightBox.y + (leftToRight && !arc.equiv ? Configuration.visual.margin.y : rightBox.height / 2);
                  // no curving for short lines covering short vertical
                  // distances, the arrowheads can go off (#925)
                  if (Math.abs(-height - endy) < 2 &&
                    Math.abs(cornerx - to) < 5) {
                    endy = -height;
                  }
                  path.line(cornerx, -height).curveQ(controlx, -height, to, endy);
                } else {
                  path.line(cornerx, -height).line(to, rightBox.y + (leftToRight && !arc.equiv ? Configuration.visual.margin.y : rightBox.height / 2));
                }
              } else {
                path.line(to, -height);
              }
              svg.path(arcGroup, path, {
                markerEnd: arrowDecl,
                markerStart: labelArrowDecl,
                style: 'stroke: ' + color,
                'strokeDashArray': dashArray,
              });
              if (arc.marked) {
                svg.path(shadowGroup, path, {
                  'class': 'shadow_EditHighlight_arc',
                  strokeWidth: markedArcStroke,
                  'strokeDashArray': dashArray,
                });
              }
              if (shadowGroup) {
                svg.path(shadowGroup, path, {
                  'class': 'shadow_' + arc.shadowClass,
                  strokeWidth: shadowStroke,
                  'strokeDashArray': dashArray,
                });
              }
            } // arc rows
          }); // arcs

          Util.profileEnd('arcs');
          Util.profileStart('fragmentConnectors');

          $.each(data.spans, function (spanNo, span) {
            var numConnectors = span.fragments.length - 1;
            for (var connectorNo = 0; connectorNo < numConnectors; connectorNo++) {
              var left = span.fragments[connectorNo];
              var right = span.fragments[connectorNo + 1];

              var leftBox = rowBBox(left);
              var rightBox = rowBBox(right);
              var leftRow = left.chunk.row.index;
              var rightRow = right.chunk.row.index;

              for (var rowIndex = leftRow; rowIndex <= rightRow; rowIndex++) {
                var row = rows[rowIndex];
                row.hasAnnotations = true;

                if (rowIndex == leftRow) {
                  from = leftBox.x + leftBox.width;
                } else {
                  from = sentNumMargin;
                }

                if (rowIndex == rightRow) {
                  to = rightBox.x;
                } else {
                  to = canvasWidth - 2 * Configuration.visual.margin.y;
                }

                var height = leftBox.y + leftBox.height - Configuration.visual.margin.y;
                if (roundCoordinates) {
                  // don't ask
                  height = (height | 0) + 0.5;
                }

                var path = svg.createPath().move(from, height).line(to, height);
                svg.path(row.arcs, path, {
                  style: 'stroke: ' + fragmentConnectorColor,
                  'strokeDashArray': fragmentConnectorDashArray
                });
              } // rowIndex
            } // connectorNo
          }); // spans

          Util.profileEnd('fragmentConnectors');
          Util.profileStart('rows');

          // position the rows
          var y = Configuration.visual.margin.y;
          var sentNumGroup = svg.group({'class': 'sentnum'});
          var currentSent;
          $.each(rows, function (rowId, row) {
            $.each(row.chunks, function (chunkId, chunk) {
              $.each(chunk.fragments, function (fragmentId, fragment) {
                if (row.maxSpanHeight < fragment.height) row.maxSpanHeight = fragment.height;
              });
            });
            if (row.sentence) {
              currentSent = row.sentence;
            }
            // SLOW (#724) and replaced with calculations:
            //
            // var rowBox = row.group.getBBox();
            // // Make it work on IE
            // rowBox = { x: rowBox.x, y: rowBox.y, height: rowBox.height, width: rowBox.width };
            // // Make it work on Firefox and Opera
            // if (rowBox.height == -Infinity) {
            //   rowBox = { x: 0, y: 0, height: 0, width: 0 };
            // }

            // XXX TODO HACK: find out where 5 and 1.5 come from!
            // This is the fix for #724, but the numbers are guessed.
            var rowBoxHeight = Math.max(row.maxArcHeight + 5, row.maxSpanHeight + 1.5); // XXX TODO HACK: why 5, 1.5?
            if (row.hasAnnotations) {
              // rowBox.height = -rowBox.y + rowSpacing;
              rowBoxHeight += rowSpacing + 1.5; // XXX TODO HACK: why 1.5?
            } else {
              rowBoxHeight -= 5; // XXX TODO HACK: why -5?
            }

            rowBoxHeight += rowPadding;
            var bgClass;
            if (data.markedSent[currentSent]) {
              // specifically highlighted
              bgClass = 'backgroundHighlight';
            } else if (Configuration.textBackgrounds == "striped") {
              // give every other sentence a different bg class
              bgClass = 'background' + row.backgroundIndex;
            } else {
              // plain "standard" bg
              bgClass = 'background0';
            }
            svg.rect(backgroundGroup,
              0, y + sizes.texts.y + sizes.texts.height,
              canvasWidth, rowBoxHeight + sizes.texts.height + 1, {
                'class': bgClass,
              });
            y += rowBoxHeight;
            y += sizes.texts.height;
            row.textY = y - rowPadding;
            if (row.sentence) {
              var sentence_hash = new URLHash(coll, doc, {focus: [['sent', row.sentence]]});
              var link = svg.link(sentNumGroup, sentence_hash.getHash());
              var text = svg.text(link, sentNumMargin - Configuration.visual.margin.x, y - rowPadding,
                '' + row.sentence, {'data-sent': row.sentence});
              var sentComment = data.sentComment[row.sentence];
              if (sentComment) {
                var box = text.getBBox();
                svg.remove(text);
                // TODO: using rectShadowSize, but this shadow should
                // probably have its own setting for shadow size
                shadowRect = svg.rect(sentNumGroup,
                  box.x - rectShadowSize, box.y - rectShadowSize,
                  box.width + 2 * rectShadowSize, box.height + 2 * rectShadowSize, {

                    'class': 'shadow_' + sentComment.type,
                    filter: 'url(#Gaussian_Blur)',
                    rx: rectShadowRounding,
                    ry: rectShadowRounding,
                    'data-sent': row.sentence,
                  });
                var text = svg.text(sentNumGroup, sentNumMargin - Configuration.visual.margin.x, y - rowPadding,
                  '' + row.sentence, {'data-sent': row.sentence});
              }
            }

            var rowY = y - rowPadding;
            if (roundCoordinates) {
              rowY = rowY | 0;
            }
            translate(row, 0, rowY);
            y += Configuration.visual.margin.y;
          });
          y += Configuration.visual.margin.y;

          Util.profileEnd('rows');
          Util.profileStart('chunkFinish');

          // chunk index sort functions for overlapping fragment drawing
          // algorithm; first for left-to-right pass, sorting primarily
          // by start offset, second for right-to-left pass by end
          // offset. Secondary sort by fragment length in both cases.
          var currentChunk;
          var lrChunkComp = function (a, b) {
            var ac = currentChunk.fragments[a];
            var bc = currentChunk.fragments[b]
            var startDiff = Util.cmp(ac.from, bc.from);
            return startDiff != 0 ? startDiff : Util.cmp(bc.to - bc.from, ac.to - ac.from);
          }
          var rlChunkComp = function (a, b) {
            var ac = currentChunk.fragments[a];
            var bc = currentChunk.fragments[b]
            var endDiff = Util.cmp(bc.to, ac.to);
            return endDiff != 0 ? endDiff : Util.cmp(bc.to - bc.from, ac.to - ac.from);
          }

          var sentenceText = null;
          $.each(data.chunks, function (chunkNo, chunk) {
            // context for sort
            currentChunk = chunk;

            // text rendering
            if (chunk.sentence) {
              if (sentenceText) {
                // svg.text(textGroup, sentenceText); // avoids jQuerySVG bug
                svg.text(textGroup, 0, 0, sentenceText);
              }
              sentenceText = null;
            }
            if (!sentenceText) {
              sentenceText = svg.createText();
            }
            var nextChunk = data.chunks[chunkNo + 1];
            var nextSpace = nextChunk ? nextChunk.space : '';
            sentenceText.span(/*chunk.space +*/ chunk.text + nextSpace, {
              x: chunk.textX,
              y: chunk.row.textY,
              'data-chunk-id': chunk.index
            });

            // chunk backgrounds
            if (chunk.fragments.length) {
              var orderedIdx = [];
              for (var i = chunk.fragments.length - 1; i >= 0; i--) {
                orderedIdx.push(i);
              }

              // Mark entity nesting height/depth (number of
              // nested/nesting entities). To account for crossing
              // brackets in a (mostly) reasonable way, determine
              // depth/height separately in a left-to-right traversal
              // and a right-to-left traversal.
              orderedIdx.sort(lrChunkComp);

              var openFragments = [];
              for (var i = 0; i < orderedIdx.length; i++) {
                var current = chunk.fragments[orderedIdx[i]];
                current.nestingHeightLR = 0;
                current.nestingDepthLR = 0;
                var stillOpen = [];
                for (var o = 0; o < openFragments.length; o++) {
                  if (openFragments[o].to > current.from) {
                    stillOpen.push(openFragments[o]);
                    openFragments[o].nestingHeightLR++;
                  }
                }
                openFragments = stillOpen;
                current.nestingDepthLR = openFragments.length;
                openFragments.push(current);
              }

              // re-sort for right-to-left traversal by end position
              orderedIdx.sort(rlChunkComp);

              openFragments = [];
              for (var i = 0; i < orderedIdx.length; i++) {
                var current = chunk.fragments[orderedIdx[i]];
                current.nestingHeightRL = 0;
                current.nestingDepthRL = 0;
                var stillOpen = [];
                for (var o = 0; o < openFragments.length; o++) {
                  if (openFragments[o].from < current.to) {
                    stillOpen.push(openFragments[o]);
                    openFragments[o].nestingHeightRL++;
                  }
                }
                openFragments = stillOpen;
                current.nestingDepthRL = openFragments.length;
                openFragments.push(current);
              }

              // the effective depth and height are the max of those
              // for the left-to-right and right-to-left traversals.
              for (var i = 0; i < orderedIdx.length; i++) {
                var c = chunk.fragments[orderedIdx[i]];
                c.nestingHeight = c.nestingHeightLR > c.nestingHeightRL ? c.nestingHeightLR : c.nestingHeightRL;
                c.nestingDepth = c.nestingDepthLR > c.nestingDepthRL ? c.nestingDepthLR : c.nestingDepthRL;
              }

              // Re-order by nesting height and draw in order
              orderedIdx.sort(function (a, b) {
                return Util.cmp(chunk.fragments[b].nestingHeight, chunk.fragments[a].nestingHeight)
              });

              for (var i = 0; i < chunk.fragments.length; i++) {
                var fragment = chunk.fragments[orderedIdx[i]];
                var spanDesc = spanTypes[fragment.span.type];
                var bgColor = ((spanDesc && spanDesc.bgColor) ||
                  (spanTypes.SPAN_DEFAULT && spanTypes.SPAN_DEFAULT.bgColor) ||
                  '#ffffff');

                // Tweak for nesting depth/height. Recognize just three
                // levels for now: normal, nested, and nesting, where
                // nested+nesting yields normal. (Currently testing
                // minor tweak: don't shrink for depth 1 as the nesting
                // highlight will grow anyway [check nestingDepth > 1])
                var shrink = 0;
                if (fragment.nestingDepth > 1 && fragment.nestingHeight == 0) {
                  shrink = 1;
                } else if (fragment.nestingDepth == 0 && fragment.nestingHeight > 0) {
                  shrink = -1;
                }
                var yShrink = shrink * nestingAdjustYStepSize;
                var xShrink = shrink * nestingAdjustXStepSize;
                // bit lighter
                var lightBgColor = Util.adjustColorLightness(bgColor, 0.8);
                // tweak for Y start offset (and corresponding height
                // reduction): text rarely hits font max height, so this
                // tends to look better
                var yStartTweak = 1;
                // store to have same mouseover highlight without recalc
                fragment.highlightPos = {
                  x: chunk.textX + fragment.curly.from + xShrink,
                  y: chunk.row.textY + sizes.texts.y + yShrink + yStartTweak,
                  w: fragment.curly.to - fragment.curly.from - 2 * xShrink,
                  h: sizes.texts.height - 2 * yShrink - yStartTweak,
                };
                svg.rect(highlightGroup,
                  fragment.highlightPos.x, fragment.highlightPos.y,
                  fragment.highlightPos.w, fragment.highlightPos.h,
                  {
                    fill: lightBgColor, //opacity:1,
                    rx: highlightRounding.x,
                    ry: highlightRounding.y,
                  });
              }
            }
          });
          if (sentenceText) {
            // svg.text(textGroup, sentenceText); // avoids jQuerySVG bug
            svg.text(textGroup, 0, 0, sentenceText);
          }

          // draw the markedText
          $.each(textMarkedRows, function (textRowNo, textRowDesc) { // row, from, to
            var textHighlight = svg.rect(highlightGroup,
              textRowDesc[1] - 2, textRowDesc[0].textY - sizes.fragments.height,
              textRowDesc[2] - textRowDesc[1] + 4, sizes.fragments.height + 4,
              {fill: 'yellow'} // TODO: put into css file, as default - turn into class
            );
            // NOTE: changing highlightTextSequence here will give
            // different-colored highlights
            // TODO: entirely different settings for non-animations?
            var markedType = textRowDesc[3];
            svg.other(textHighlight, 'animate', {
              'data-type': markedType,
              attributeName: 'fill',
              values: (markedType == 'match' ? highlightMatchSequence
                : highlightTextSequence),
              dur: highlightDuration,
              repeatCount: 'indefinite',
              begin: 'indefinite'
            });
          });


          Util.profileEnd('chunkFinish');
          Util.profileStart('finish');

          svg.path(sentNumGroup, svg.createPath().move(sentNumMargin, 0).line(sentNumMargin, y));

          // resize the SVG
          var width = maxTextWidth + sentNumMargin + 2 * Configuration.visual.margin.x + 1;
          if (width > canvasWidth) canvasWidth = width;

          $svg.width(canvasWidth);
          $svg.height(y);
          $svgDiv.height(y);

          Util.profileEnd('finish');
          Util.profileEnd('render');
          Util.profileReport();


          drawing = false;
          if (redraw) {
            redraw = false;
            renderDataReal();
          }
          $svg.find('animate').each(function () {
            if (this.beginElement) { // protect against non-SMIL browsers
              this.beginElement();
            }
          });
          dispatcher.post('doneRendering', [coll, doc, args]);
        };

        var renderErrors = {
          unableToReadTextFile: true,
          annotationFileNotFound: true,
          isDirectoryError: true
        };
        var renderData = function (sourceData) {
          Util.profileEnd('invoke getDocument');
          if (sourceData && sourceData.exception) {
            if (renderErrors[sourceData.exception]) {
              dispatcher.post('renderError:' + sourceData.exception, [sourceData]);
            } else {
              dispatcher.post('unknownError', [sourceData.exception]);
            }
          } else {
            // Fill in default values that don't necessarily go over the protocol
            if (sourceData) {
              setSourceDataDefaults(sourceData);
            }

            dispatcher.post('startedRendering', [coll, doc, args]);
            dispatcher.post('spin');
            setTimeout(function () {
              try {
                renderDataReal(sourceData);
              } catch (e) {
                // We are sure not to be drawing anymore, reset the state
                drawing = false;
                // TODO: Hook printout into dispatch elsewhere?
                console.warn('Rendering terminated due to:', e);
                dispatcher.post('renderError: Fatal', [sourceData, e]);
              }
              dispatcher.post('unspin');
            }, 0);
          }
        };

        var renderDocument = function () {
          Util.profileStart('invoke getDocument');
          dispatcher.post('ajax', [{
            action: 'getDocument',
            collection: coll,
            'document': doc,
          }, 'renderData', {
            collection: coll,
            'document': doc
          }]);
        };

        var triggerRender = function () {
          if (svg && ((isRenderRequested && isCollectionLoaded) || requestedData) && Visualizer.areFontsLoaded) {
            isRenderRequested = false;
            if (requestedData) {

              Util.profileClear();
              Util.profileStart('before render');

              renderData(requestedData);
            } else if (doc.length) {

              Util.profileClear();
              Util.profileStart('before render');

              renderDocument();
            } else {
              dispatcher.post(0, 'renderError:noFileSpecified');
            }
          }
        };

        var requestRenderData = function (sourceData) {
          requestedData = sourceData;
          triggerRender();
        };

        var collectionChanged = function () {
          isCollectionLoaded = false;
        };

        var gotCurrent = function (_coll, _doc, _args, reloadData) {
          coll = _coll;
          doc = _doc;
          args = _args;
          if (reloadData) {
            isRenderRequested = true;
            triggerRender();
          }
        };


        // event handlers

        var highlight, highlightArcs, highlightSpans, commentId;

        var onMouseOver = function (evt) {
          var target = $(evt.target);
          var id;
          if (id = target.attr('data-span-id')) {
            commentId = id;
            var span = data.spans[id];
            dispatcher.post('displaySpanComment', [
              evt, target, id, span.type, span.attributeText,
              span.text,
              span.comment && span.comment.text,
              span.comment && span.comment.type,
              span.normalizations]);

            var spanDesc = spanTypes[span.type];
            var bgColor = ((spanDesc && spanDesc.bgColor) ||
              (spanTypes.SPAN_DEFAULT && spanTypes.SPAN_DEFAULT.bgColor) ||
              '#ffffff');
            highlight = [];
            $.each(span.fragments, function (fragmentNo, fragment) {
              highlight.push(svg.rect(highlightGroup,
                fragment.highlightPos.x, fragment.highlightPos.y,
                fragment.highlightPos.w, fragment.highlightPos.h,
                {
                  'fill': bgColor, opacity: 0.75,
                  rx: highlightRounding.x,
                  ry: highlightRounding.y,
                }));
            });

            if (that.arcDragOrigin) {
              target.parent().addClass('highlight');
            } else {
              highlightArcs = $svg.find('g[data-from="' + id + '"], g[data-to="' + id + '"]').addClass('highlight');
              var spans = {};
              spans[id] = true;
              var spanIds = [];
              $.each(span.incoming, function (arcNo, arc) {
                spans[arc.origin] = true;
              });
              $.each(span.outgoing, function (arcNo, arc) {
                spans[arc.target] = true;
              });
              $.each(spans, function (spanId, dummy) {
                spanIds.push('rect[data-span-id="' + spanId + '"]');
              });
              highlightSpans = $svg.find(spanIds.join(', ')).parent().addClass('highlight');
            }
            forceRedraw();
          } else if (!that.arcDragOrigin && (id = target.attr('data-arc-role'))) {
            var originSpanId = target.attr('data-arc-origin');
            var targetSpanId = target.attr('data-arc-target');
            var role = target.attr('data-arc-role');
            var symmetric = (relationTypesHash &&
              relationTypesHash[role] &&
              relationTypesHash[role].properties &&
              relationTypesHash[role].properties.symmetric);
            // NOTE: no commentText, commentType for now
            var arcEventDescId = target.attr('data-arc-ed');
            var commentText = '';
            var commentType = '';
            var arcId;
            if (arcEventDescId) {
              var eventDesc = data.eventDescs[arcEventDescId];
              var comment = eventDesc.comment;
              if (comment) {
                commentText = comment.text;
                commentType = comment.type;
                if (commentText == '' && commentType) {
                  // default to type if missing text
                  commentText = commentType;
                }
              }
              if (eventDesc.relation) {
                // among arcs, only ones corresponding to relations have
                // "independent" IDs
                arcId = arcEventDescId;
              }
            }
            var originSpanType = data.spans[originSpanId].type || '';
            var targetSpanType = data.spans[targetSpanId].type || '';
            dispatcher.post('displayArcComment', [
              evt, target, symmetric, arcId,
              originSpanId, originSpanType, role,
              targetSpanId, targetSpanType,
              commentText, commentType]);
            highlightArcs = $svg.find('g[data-from="' + originSpanId + '"][data-to="' + targetSpanId + '"]').addClass('highlight');
            highlightSpans = $($svg).find('rect[data-span-id="' + originSpanId + '"], rect[data-span-id="' + targetSpanId + '"]').parent().addClass('highlight');
          } else if (id = target.attr('data-sent')) {
            var comment = data.sentComment[id];
            if (comment) {
              dispatcher.post('displaySentComment', [evt, target, comment.text, comment.type]);
            }
          }
        };

        var onMouseOut = function (evt) {
          var target = $(evt.target);
          target.removeClass('badTarget');
          dispatcher.post('hideComment');
          if (highlight) {
            $.each(highlight, function () {
              svg.remove(this);
            });
            highlight = undefined;
          }
          if (highlightSpans) {
            highlightArcs.removeClass('highlight');
            highlightSpans.removeClass('highlight');
            highlightSpans = undefined;
          }
          forceRedraw();
        };

        var setAbbrevs = function (_abbrevsOn) {
          // TODO: this is a slightly weird place to tweak the configuration
          Configuration.abbrevsOn = _abbrevsOn;
          dispatcher.post('configurationChanged');
        }

        var setTextBackgrounds = function (_textBackgrounds) {
          Configuration.textBackgrounds = _textBackgrounds;
          dispatcher.post('configurationChanged');
        }

        var setLayoutDensity = function (_density) {
          //dispatcher.post('messages', [[['Setting layout density ' + _density, 'comment']]]);
          // TODO: store standard settings instead of hard-coding
          // them here (again)
          if (_density < 2) {
            // dense
            Configuration.visual.margin = {x: 1, y: 0};
            Configuration.visual.boxSpacing = 1;
            Configuration.visual.curlyHeight = 1;
            Configuration.visual.arcSpacing = 7;
            Configuration.visual.arcStartHeight = 18
          } else if (_density > 2) {
            // spacious
            Configuration.visual.margin = {x: 2, y: 1};
            Configuration.visual.boxSpacing = 3;
            Configuration.visual.curlyHeight = 6;
            Configuration.visual.arcSpacing = 12;
            Configuration.visual.arcStartHeight = 23;
          } else {
            // standard
            Configuration.visual.margin = {x: 2, y: 1};
            Configuration.visual.boxSpacing = 1;
            Configuration.visual.curlyHeight = 4;
            Configuration.visual.arcSpacing = 9;
            Configuration.visual.arcStartHeight = 19;
          }
          dispatcher.post('configurationChanged');
        }

        var setSvgWidth = function (_width) {
          $svgDiv.width(_width);
          if (Configuration.svgWidth != _width) {
            Configuration.svgWidth = _width;
            dispatcher.post('configurationChanged');
          }
        }

        $svgDiv = $($svgDiv).hide();

        // register event listeners
        var registerHandlers = function (element, events) {
          $.each(events, function (eventNo, eventName) {
            element.bind(eventName,
              function (evt) {
                dispatcher.post(eventName, [evt], 'all');
              }
            );
          });
        };
        registerHandlers($svgDiv, [
          'mouseover', 'mouseout', 'mousemove',
          'mouseup', 'mousedown',
          'dragstart',
          'dblclick', 'click'
        ]);
        registerHandlers($(document), [
          'keydown', 'keypress',
          'touchstart', 'touchend'
        ]);
        registerHandlers($(window), [
          'resize'
        ]);

        // create the svg wrapper
        $svgDiv.svg({
          onLoad: function (_svg) {
            that.svg = svg = _svg;
            $svg = $(svg._svg);

            /* XXX HACK REMOVED - not efficient?

              // XXX HACK to allow off-DOM SVG element creation
              // we need to replace the jQuery SVG's _makeNode function
              // with a modified one.
              // Be aware of potential breakage upon jQuery SVG upgrade.
              svg._makeNode = function(parent, name, settings) {
                  // COMMENTED OUT: parent = parent || this._svg;
                  var node = this._svg.ownerDocument.createElementNS($.svg.svgNS, name);
                  for (var name in settings) {
                    var value = settings[name];
                    if (value != null && value != null &&
                        (typeof value != 'string' || value != '')) {
                      node.setAttribute($.svg._attrNames[name] || name, value);
                    }
                  }
                  // ADDED IN:
                  if (parent)
                    parent.appendChild(node);
                  return node;
                };
              */

            triggerRender();
          }
        });

        var loadSpanTypes = function (types) {
          $.each(types, function (typeNo, type) {
            if (type) {
              spanTypes[type.type] = type;
              var children = type.children;
              if (children && children.length) {
                loadSpanTypes(children);
              }
            }
          });
        }

        var loadAttributeTypes = function (response_types) {
          var processed = {};
          $.each(response_types, function (aTypeNo, aType) {
            processed[aType.type] = aType;
            // count the values; if only one, it's a boolean attribute
            var values = [];
            for (var i in aType.values) {
              if (aType.values.hasOwnProperty(i)) {
                values.push(i);
              }
            }
            if (values.length == 1) {
              aType.bool = values[0];
            }
          });
          return processed;
        }

        var loadRelationTypes = function (relation_types) {
          $.each(relation_types, function (relTypeNo, relType) {
            if (relType) {
              relationTypesHash[relType.type] = relType;
              var children = relType.children;
              if (children && children.length) {
                loadRelationTypes(children);
              }
            }
          });
        }

        var collectionLoaded = function (response) {
          if (!response.exception) {
            setCollectionDefaults(response);
            eventAttributeTypes = loadAttributeTypes(response.event_attribute_types);
            entityAttributeTypes = loadAttributeTypes(response.entity_attribute_types);
            spanTypes = {};
            loadSpanTypes(response.entity_types);
            loadSpanTypes(response.event_types);
            loadSpanTypes(response.unconfigured_types);
            relationTypesHash = {};
            loadRelationTypes(response.relation_types);
            loadRelationTypes(response.unconfigured_types);
            // TODO XXX: isn't the following completely redundant with
            // loadRelationTypes?
            $.each(response.relation_types, function (relTypeNo, relType) {
              relationTypesHash[relType.type] = relType;
            });

            dispatcher.post('spanAndAttributeTypesLoaded', [spanTypes, entityAttributeTypes, eventAttributeTypes, relationTypesHash]);

            isCollectionLoaded = true;
            triggerRender();
          } else {
            // exception on collection load; allow visualizer_ui
            // collectionLoaded to handle this
          }
        };

        var isReloadOkay = function () {
          // do not reload while the user is in the dialog
          return !drawing;
        };

        // If we are yet to load our fonts, dispatch them
        if (!Visualizer.areFontsLoaded) {
          var webFontConfig = {
            custom: {
              families: [
                'Astloch',
                'PT Sans Caption',
                //        'Ubuntu',
                'Liberation Sans'
              ],
              /* For some cases, in particular for embedding, we need to
              allow for fonts being hosted elsewhere */
              urls: webFontURLs !== undefined ? webFontURLs : [
                'assets/brat-client/static/fonts/Astloch-Bold.ttf',
                'assets/brat-client/static/fonts/PT_Sans-Caption-Web-Regular.ttf',
                //
                'assets/brat-client/static/fonts/Liberation_Sans-Regular.ttf'
              ],
            },
            active: proceedWithFonts,
            inactive: proceedWithFonts,
            fontactive: function (fontFamily, fontDescription) {
              // Note: Enable for font debugging
              // console.log("font active: ", fontFamily, fontDescription);
            },
            fontloading: function (fontFamily, fontDescription) {
              // Note: Enable for font debugging
              // console.log("font loading:", fontFamily, fontDescription);
            },
          };
          WebFont.load(webFontConfig);
          // Retir par VL le 26/09/2018 : les polices sont charges et a ne devrait pas tre fait de faon synchrone
          // setTimeout(function () {
            //if (!Visualizer.areFontsLoaded) {
              //console.error('Timeout in loading fonts');
              proceedWithFonts();
            //}
          //}, fontLoadTimeout);
        }

        dispatcher.on('collectionChanged', collectionChanged).on('collectionLoaded', collectionLoaded).on('renderData', renderData).on('triggerRender', triggerRender).on('requestRenderData', requestRenderData).on('isReloadOkay', isReloadOkay).on('resetData', resetData).on('abbrevs', setAbbrevs).on('textBackgrounds', setTextBackgrounds).on('layoutDensity', setLayoutDensity).on('svgWidth', setSvgWidth).on('current', gotCurrent).on('clearSVG', clearSVG).on('mouseover', onMouseOver).on('mouseout', onMouseOut);
      };

      Visualizer.areFontsLoaded = false;

      var proceedWithFonts = function () {
        Visualizer.areFontsLoaded = true;
        // Note: Enable for font debugging
        //console.log("fonts done");
        Dispatcher.post('triggerRender');
      };

      return Visualizer;
    })(jQuery, window);

// BRAT STANDALONE LIBRARY BEGIN
// Browserify export
    module.exports = Visualizer;
// BRAT STANDALONE LIBRARY END

  }, {}], 18: [function (require, module, exports) {
// -*- Mode: JavaScript; tab-width: 2; indent-tabs-mode: nil; -*-
// vim:set ft=javascript ts=2 sw=2 sts=2 cindent:
    var VisualizerUI = (function ($, window, undefined) {
      var VisualizerUI = function (dispatcher, svg, showTooltip, overWriteModals) {
        var that = this;

        var messagePostOutFadeDelay = 1000;
        var messageDefaultFadeDelay = 3000;
        var defaultFloatFormat = '%.1f/right';

        var documentListing = null; // always documents of current collection
        var selectorData = null;    // can be search results when available
        var searchActive = false;   // whether search results received and in use
        var loadedSearchData = null;

        var currentForm;
        var spanTypes = null;
        var relationTypesHash = null;
        // TODO: confirm unnecessary and remove
//       var attributeTypes = null;
        var data = null;
        var mtime = null;
        var searchConfig = null;
        var coll, doc, args;
        var collScroll;
        var docScroll;
        var user = null;
        var annotationAvailable = false;

        var svgElement = $(svg._svg);
        var svgId = svgElement.parent().attr('id');

        var maxMessages = 100;

        var currentDocumentSVGsaved = false;
        var fileBrowserClosedWithSubmit = false;

        // normalization: server-side DB by norm DB name
        var normServerDbByNormDbName = {};

        var matchFocus = '';
        var matches = '';

        /* START "no svg" message - related */

        var noSvgTimer = null;

        // this is necessary for centering
        $('#no_svg_wrapper').css('display', 'table');
        // on initial load, hide the "no SVG" message
        $('#no_svg_wrapper').hide();

        var hideNoDocMessage = function () {
          clearTimeout(noSvgTimer);
          $('#no_svg_wrapper').hide(0);
          $('#source_files').show();
        }

        var showNoDocMessage = function () {
          clearTimeout(noSvgTimer);
          noSvgTimer = setTimeout(function () {
            $('#no_svg_wrapper').fadeIn(500);
          }, 2000);
          $('#source_files').hide();
        }

        /* END "no svg" message - related */

        /* START collection browser sorting - related */

        var lastGoodCollection = '/';
        var sortOrder = [2, 1]; // column (0..), sort order (1, -1)
        var collectionSortOrder; // holds previous sort while search is active
        var docSortFunction = function (a, b) {
          // parent at the top
          if (a[2] === '..') return -1;
          if (b[2] === '..') return 1;

          // then other collections
          var aIsColl = a[0] == "c";
          var bIsColl = b[0] == "c";
          if (aIsColl !== bIsColl) return aIsColl ? -1 : 1;

          // desired column in the desired order
          var col = sortOrder[0];
          var aa = a[col];
          var bb = b[col];
          if (selectorData.header[col - 2][1] === 'string-reverse') {
            aa = aa.split('').reverse().join('');
            bb = bb.split('').reverse().join('');
          }
          if (aa != bb) return (aa < bb) ? -sortOrder[1] : sortOrder[1];

          // prevent random shuffles on columns with duplicate values
          // (alphabetical order of documents)
          aa = a[2];
          bb = b[2];
          if (aa != bb) return (aa < bb) ? -1 : 1;
          return 0;
        };

        var makeSortChangeFunction = function (sort, th, thNo) {
          $(th).click(function () {
            // TODO: avoid magic numbers in access to the selector
            // data (column 0 is type, 1 is args, rest is data)
            if (sort[0] === thNo + 1) sort[1] = -sort[1];
            else {
              var type = selectorData.header[thNo - 1][1];
              var ascending = type === "string";
              sort[0] = thNo + 1;
              sort[1] = ascending ? 1 : -1;
            }
            selectorData.items.sort(docSortFunction);
            docScroll = 0;
            showFileBrowser(); // resort
          });
        }

        /* END collection browser sorting - related */


        /* START message display - related */

        var showPullupTrigger = function () {
          $('#pulluptrigger').show('puff');
        }

        var $messageContainer = $('#messages');
        var $messagepullup = $('#messagepullup');
        var pullupTimer = null;
        var displayMessages = function (msgs) {
          var initialMessageNum = $messagepullup.children().length;

          if (msgs === false) {
            $messageContainer.children().each(function (msgElNo, msgEl) {
              $(msgEl).remove();
            });
          } else {
            $.each(msgs, function (msgNo, msg) {
              var element;
              var timer = null;
              try {
                element = $('<div class="' + msg[1] + '">' + msg[0] + '</div>');
              }
              catch (x) {
                escaped = msg[0].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
                element = $('<div class="error"><b>[ERROR: could not display the following message normally due to malformed XML:]</b><br/>' + escaped + '</div>');
              }
              var pullupElement = element.clone();
              $messageContainer.append(element);
              $messagepullup.append(pullupElement.css('display', 'none'));
              slideToggle(pullupElement, true, true);

              var fader = function () {
                if ($messagepullup.is(':visible')) {
                  element.remove();
                } else {
                  element.hide('slow', function () {
                    element.remove();
                  });
                }
              };
              var delay = (msg[2] === undefined)
                ? messageDefaultFadeDelay
                : (msg[2] === -1)
                  ? null
                  : (msg[2] * 1000);
              if (delay === null) {
                var button = $('<input type="button" value="OK"/>');
                element.prepend(button);
                button.click(function (evt) {
                  timer = setTimeout(fader, 0);
                });
              } else {
                timer = setTimeout(fader, delay);
                element.mouseover(function () {
                  clearTimeout(timer);
                  element.show();
                }).mouseout(function () {
                  timer = setTimeout(fader, messagePostOutFadeDelay);
                });
              }
              // setTimeout(fader, messageDefaultFadeDelay);
            });

            // limited history - delete oldest
            var $messages = $messagepullup.children();
            for (var i = 0; i < $messages.length - maxMessages; i++) {
              $($messages[i]).remove();
            }
          }

          // if there is change in the number of messages, may need to
          // tweak trigger visibility
          var messageNum = $messagepullup.children().length;
          if (messageNum != initialMessageNum) {
            if (messageNum == 0) {
              // all gone; nothing to trigger
              $('#pulluptrigger').hide('slow');
            } else if (initialMessageNum == 0) {
              // first messages, show trigger at fade
              setTimeout(showPullupTrigger, messageDefaultFadeDelay + 250);
            }
          }
        };

        // hide pullup trigger by default, show on first message
        $('#pulluptrigger').hide();
        $('#pulluptrigger').mouseenter(function (evt) {
          $('#pulluptrigger').hide('puff');
          clearTimeout(pullupTimer);
          slideToggle($messagepullup.stop(), true, true, true);
        });
        $('#messagepullup').mouseleave(function (evt) {
          setTimeout(showPullupTrigger, 500);
          clearTimeout(pullupTimer);
          pullupTimer = setTimeout(function () {
            slideToggle($messagepullup.stop(), false, true, true);
          }, 500);
        });


        /* END message display - related */


        /* START comment popup - related */

        var adjustToCursor = function (evt, element, offset, top, right) {
          // get the real width, without wrapping
          element.css({left: 0, top: 0});
          var screenHeight = $(window).height();
          var screenWidth = $(window).width();
          // FIXME why the hell is this 22 necessary?!?
          var elementHeight = element.height() + 22;
          var elementWidth = element.width() + 22;
          var x, y;
          offset = offset || 0;
          if (top) {
            y = evt.clientY - elementHeight - offset;
            if (y < 0) top = false;
          }
          if (!top) {
            y = evt.clientY + offset;
          }
          if (right) {
            x = evt.clientX + offset;
            if (x >= screenWidth - elementWidth) right = false;
          }
          if (!right) {
            x = evt.clientX - elementWidth - offset;
          }
          if (y < 0) y = 0;
          if (x < 0) x = 0;
          element.css({top: y, left: x});
        };

        var commentPopup = $('#commentpopup');
        var commentDisplayed = false;

        var displayCommentTimer = null;
        var displayComment = function (evt, target, comment, commentText, commentType, immediately) {
          var idtype;
          if (commentType) {
            // label comment by type, with special case for default note type
            var commentLabel;
            if (commentType == 'AnnotatorNotes') {
              commentLabel = '<b>Note:</b> ';
            } else {
              commentLabel = '<b>' + Util.escapeHTML(commentType) + ':</b> ';
            }
            comment += commentLabel + Util.escapeHTMLwithNewlines(commentText);
            idtype = 'comment_' + commentType;
          }
          commentPopup[0].className = idtype;
          commentPopup.html(comment);
          if (showTooltip) {
            adjustToCursor(evt, commentPopup, 10, true, true);
            clearTimeout(displayCommentTimer);
            /* slight "tooltip" delay to allow highlights to be seen
           before the popup obstructs them. */
            displayCommentTimer = setTimeout(function () {
              commentPopup.stop(true, true).fadeIn();
              commentDisplayed = true;
            }, immediately ? 0 : 500);
          }
        };

        // to avoid clobbering on delayed response
        var commentPopupNormInfoSeqId = 0;

        var normInfoSortFunction = function (a, b) {
          // images at the top
          if (a[0].toLowerCase() == '<img>') return -1;
          if (b[0].toLowerCase() == '<img>') return 1;
          // otherwise stable
          return Util.cmp(a[2], b[2]);
        }

        var displaySpanComment = function (
          evt, target, spanId, spanType, mods, spanText, commentText,
          commentType, normalizations) {

          var immediately = false;
          var comment = ('<div><span class="comment_type_id_wrapper">' +
            '<span class="comment_type">' +
            Util.escapeHTML(Util.spanDisplayForm(spanTypes,
              spanType)) +
            '</span>' +
            ' ' +
            '<span class="comment_id">' +
            'ID:' + Util.escapeHTML(spanId) +
            '</span></span>');
          if (mods.length) {
            comment += '<div>' + Util.escapeHTML(mods.join(', ')) + '</div>';
          }

          comment += '</div>';
          comment += ('<div class="comment_text">"' +
            Util.escapeHTML(spanText) +
            '"</div>');
          var validArcTypesForDrag = dispatcher.post('getValidArcTypesForDrag', [spanId, spanType]);
          if (validArcTypesForDrag && validArcTypesForDrag[0]) {
            if (validArcTypesForDrag[0].length) {
              comment += '<div>' + validArcTypesForDrag[0].join(', ') + '</div>';
            } else {
              $('rect[data-span-id="' + spanId + '"]').addClass('badTarget');
            }
            immediately = true;
          }
          // process normalizations
          var normsToQuery = [];
          $.each(normalizations, function (normNo, norm) {
            var dbName = norm[0], dbKey = norm[1];
            comment += ('<hr/>' +
              '<span class="comment_id">' +
              Util.escapeHTML(dbName) + ':' +
              Util.escapeHTML(dbKey) + '</span>');
            if (dbName in normServerDbByNormDbName &&
              normServerDbByNormDbName[dbName] != '<NONE>') {
              // DB available, add drop-off point to HTML and store
              // query parameters
              commentPopupNormInfoSeqId++;
              comment += ('<br/><div id="norm_info_drop_point_' +
                commentPopupNormInfoSeqId + '"/>');
              normsToQuery.push([dbName, dbKey, commentPopupNormInfoSeqId]);
            } else {
              // no DB, just attach "human-readable" text provided
              // with the annotation, if any
              if (norm[2]) {
                comment += ('<br/><span class="norm_info_value">' +
                  Util.escapeHTML(norm[2]) + '</span>');
              }
            }
          });

          // display initial comment HTML
          if (showTooltip) {
            displayComment(evt, target, comment, commentText, commentType,
              immediately);
          }

          // initiate AJAX calls for the normalization data to query
          $.each(normsToQuery, function (normqNo, normq) {
            // TODO: cache some number of most recent norm_get_data results
            var dbName = normq[0], dbKey = normq[1], infoSeqId = normq[2];
            dispatcher.post('ajax', [{
              action: 'normData',
              database: dbName,
              key: dbKey,
              collection: coll,
            },
              function (response) {
                if (response.exception) {
                  ; // TODO: response to error
                } else if (!response.value) {
                  ; // TODO: response to missing key
                } else {
                  // extend comment popup with normalization data
                  norminfo = '';
                  // flatten outer (name, attr, info) array (idx for sort)
                  infos = [];
                  var idx = 0;
                  for (var i = 0; i < response.value.length; i++) {
                    for (var j = 0; j < response.value[i].length; j++) {
                      var label = response.value[i][j][0];
                      var value = response.value[i][j][1];
                      infos.push([label, value, idx++]);
                    }
                  }
                  // sort, prioritizing images (to get floats right)
                  infos = infos.sort(normInfoSortFunction);
                  // generate HTML
                  for (var i = 0; i < infos.length; i++) {
                    var label = infos[i][0];
                    var value = infos[i][1];
                    if (label && value) {
                      // special treatment for some label values
                      if (label.toLowerCase() == '<img>') {
                        // image
                        norminfo += ('<img class="norm_info_img" src="' +
                          value +
                          '"/>');
                      } else {
                        // normal, as text

                        // max length restriction
                        if (value.length > 300) {
                          value = value.substr(0, 300) + ' ...';
                        }

                        norminfo += ('<span class="norm_info_label">' +
                          Util.escapeHTML(label) +
                          '</span>' +
                          '<span class="norm_info_value">' + ':' +
                          Util.escapeHTML(value) +
                          '</span>' +
                          '<br/>');
                      }
                    }
                  }
                  var drop = $('#norm_info_drop_point_' + infoSeqId);
                  if (drop) {
                    drop.html(norminfo);
                  } else {
                    console.log('norm info drop point not found!'); //TODO XXX
                  }
                }
              }]);
          });
        };

        var onDocChanged = function () {
          commentPopup.hide();
          commentDisplayed = false;
        };

        var displayArcComment = function (
          evt, target, symmetric, arcId,
          originSpanId, originSpanType, role,
          targetSpanId, targetSpanType,
          commentText, commentType) {
          var arcRole = target.attr('data-arc-role');
          // in arrowStr, &#8212 == mdash, &#8594 == Unicode right arrow
          var arrowStr = symmetric ? '&#8212;' : '&#8594;';
          var arcDisplayForm = Util.arcDisplayForm(spanTypes,
            data.spans[originSpanId].type,
            arcRole,
            relationTypesHash);
          var comment = "";
          comment += ('<span class="comment_type_id_wrapper">' +
            '<span class="comment_type">' +
            Util.escapeHTML(Util.spanDisplayForm(spanTypes,
              originSpanType)) +
            ' ' + arrowStr + ' ' +
            Util.escapeHTML(arcDisplayForm) +
            ' ' + arrowStr + ' ' +
            Util.escapeHTML(Util.spanDisplayForm(spanTypes,
              targetSpanType)) +
            '</span>' +
            '<span class="comment_id">' +
            (arcId ? 'ID:' + arcId :
              Util.escapeHTML(originSpanId) +
              arrowStr +
              Util.escapeHTML(targetSpanId)) +
            '</span>' +
            '</span>');
          comment += ('<div class="comment_text">' +
            Util.escapeHTML('"' + data.spans[originSpanId].text + '"') +
            arrowStr +
            Util.escapeHTML('"' + data.spans[targetSpanId].text + '"') +
            '</div>');
          displayComment(evt, target, comment, commentText, commentType);
        };

        var displaySentComment = function (
          evt, target, commentText, commentType) {
          displayComment(evt, target, '', commentText, commentType);
        };

        var hideComment = function () {
          clearTimeout(displayCommentTimer);
          if (commentDisplayed) {
            commentPopup.stop(true, true).fadeOut(function () {
              commentDisplayed = false;
            });
          }
        };

        var onMouseMove = function (evt) {
          if (commentDisplayed && showTooltip) {
            adjustToCursor(evt, commentPopup, 10, true, true);
          }
        };

        /* END comment popup - related */


        /* START form management - related */
        initForm = function (form, opts) {
          opts = opts || {};
          var formId = form.attr('id');

          // alsoResize is special
          var alsoResize = opts.alsoResize;
          delete opts.alsoResize;

          // Always add OK and Cancel
          var buttons = (opts.buttons || []);
          if (opts.no_ok) {
            delete opts.no_ok;
          } else {
            buttons.push({
              id: formId + "-ok",
              text: "OK",
              click: function () {
                form.submit();
              }
            });
          }
          if (opts.no_cancel) {
            delete opts.no_cancel;
          } else {
            buttons.push({
              id: formId + "-cancel",
              text: "Cancel",
              click: function () {
                form.dialog('close');
              }
            });
          }
          delete opts.buttons;

          opts = $.extend({
            autoOpen: false,
            closeOnEscape: true,
            buttons: buttons,
            modal: true
          }, opts);

          form.dialog(opts);
          form.bind('dialogclose', function () {
            if (form == currentForm) {
              currentForm = null;
            }
          });

          // HACK: jQuery UI's dialog does not support alsoResize
          // nor does resizable support a jQuery object of several
          // elements
          // See: http://bugs.jqueryui.com/ticket/4666
          if (alsoResize) {
            form.parent().resizable('option', 'alsoResize',
              '#' + form.attr('id') + ', ' + alsoResize);
          }
        };

        var showForm = function (form) {
          currentForm = form;
          if (!overWriteModals) {
            // as suggested in http://stackoverflow.com/questions/2657076/jquery-ui-dialog-fixed-positioning
            form.parent().css({position: "fixed"});
            form.dialog('open');
            slideToggle($('#pulldown').stop(), false);
          }
          return form;
        };

        var hideForm = function () {
          if (!currentForm) return;
          // currentForm.fadeOut(function() { currentForm = null; });
          currentForm.dialog('close');
          currentForm = null;
        };

        /* END form management - related */


        /* START collection browser - related */

        var selectElementInTable = function (table, docname, mf) {
          table = $(table);
          table.find('tr').removeClass('selected');
          var sel = 'tr';
          var $element;
          if (docname) {
            sel += '[data-doc="' + docname + '"]';
            if (mf) {
              sel += '[data-mf="' + Util.paramArray(mf) + '"]';
            }
            var $element = table.find(sel).first();
            $element.addClass('selected');
          }
          matchFocus = $element && $element.attr('data-mf');
          matches = $element && $element.attr('data-match');
        }

        var chooseDocument = function (evt) {
          var $element = $(evt.target).closest('tr');
          $('#document_select tr').removeClass('selected');
          $('#document_input').val($element.attr('data-doc'));

          $element.addClass('selected');
          matchFocus = $element.attr('data-mf');
          matches = $element.attr('data-match');
        }

        var chooseDocumentAndSubmit = function (evt) {
          chooseDocument(evt);
          fileBrowserSubmit(evt);
        }

        var fileBrowser = $('#collection_browser');
        initForm(fileBrowser, {
          alsoResize: '#document_select',
          close: function (evt) {
            if (!doc) {
              // no document; set and show the relevant message, and
              // clear the "blind" unless waiting for a collection
              if (fileBrowserClosedWithSubmit) {
                $('#no_document_message').hide();
                $('#loading_message').show();
              } else {
                $('#loading_message').hide();
                $('#no_document_message').show();
                $('#waiter').dialog('close');
              }
              showNoDocMessage();
            } else if (!fileBrowserClosedWithSubmit && !searchActive) {
              dispatcher.post('setArguments', [{}, true]);
            }
          },
          width: 500
        });

        /* XXX removed per #900
      // insert the Save link
      var $fileBrowserButtonset = fileBrowser.
          parent().find('.ui-dialog-buttonpane .ui-dialog-buttonset').prepend(' ');
      $('<a href="ajax.cgi?action=downloadSearchFile" id="save_search">Save</a>').
          prependTo($fileBrowserButtonset).button().css('display', 'none');
      */

        var docInputHandler = function (evt) {
          selectElementInTable('#document_select', $(this).val());
        };
        $('#document_input').keyup(docInputHandler);

        var fileBrowserSubmit = function (evt) {
          var _coll, _doc, _args, found;
          var input = $('#document_input').val().replace(/\/?\s+$/, '').replace(/^\s+/, '');
          if (!input.length) return false;
          if (input.substr(0, 2) === '..') {
            // ..
            var pos = coll.substr(0, coll.length - 1).lastIndexOf('/');
            if (pos === -1) {
              dispatcher.post('messages', [[['At the root', 'error', 2]]]);
              $('#document_input').focus().select();
              return false;
            } else {
              _coll = coll.substr(0, pos + 1);
              _doc = '';
            }
          } else if (found = input.match(/^(\/?)((?:[^\/]*\/)*)([^\/?]*)$/)) {
            var abs = found[1];
            var collname = found[2].substr(0, found[2].length - 1);
            var docname = found[3];
            if (abs) {
              _coll = abs + collname;
              if (_coll.length < 2) coll += '/';
              _doc = docname;
            } else {
              if (collname) collname += '/';
              _coll = coll + collname;
              _doc = docname;
            }
          } else {
            dispatcher.post('messages', [[['Invalid document name format', 'error', 2]]]);
            $('#document_input').focus().select();
          }
          docScroll = $('#document_select')[0].scrollTop;
          fileBrowser.find('#document_select tbody').empty();

          if (coll != _coll || doc != _doc ||
            Util.paramArray(args.matchfocus) != matchFocus) {
            // something changed

            // set to allow keeping "blind" down during reload
            fileBrowserClosedWithSubmit = true;
            // ... and change BG message to a more appropriate one

            // trigger clear and changes if something other than the
            // current thing is chosen, but only blank screen before
            // render if the document changed (prevent "flicker" on
            // e.g. picking search results)
            if (coll != _coll || doc != _doc) {
              dispatcher.post('clearSVG');
            }
            dispatcher.post('allowReloadByURL');
            var newArgs = [];
            if (matchFocus) newArgs.push('matchfocus=' + matchFocus);
            if (matches) newArgs.push('match=' + matches);
            dispatcher.post('setCollection', [_coll, _doc, Util.deparam(newArgs.join('&'))]);
          } else {
            // hide even on select current thing
            hideForm();
          }
          return false;
        };
        fileBrowser.submit(fileBrowserSubmit).bind('reset', hideForm);

        var fileBrowserWaiting = false;
        var showFileBrowser = function () {
          // keep tabs on how the browser is closed; we need to keep the
          // "blind" up when retrieving a collection, but not when canceling
          // without selection (would hang the UI)

// BRAT STANDALONE LIBRARY BEGIN
          /*
        fileBrowserClosedWithSubmit = false;

        // no point in showing this while the browser is shown
        hideNoDocMessage();

        if (currentForm == tutorialForm) {
          fileBrowserWaiting = true;
          return;
        }
        fileBrowserWaiting = false;

        // hide "no document" message when file browser shown
        // TODO: can't make this work; I can't detect when it gets hidden.
        // hideNoDocMessage();

        if (!(selectorData && showForm(fileBrowser))) return false;

        var html = ['<tr><th/>'];
        var tbody;
        $.each(selectorData.header, function(headNo, head) {
          html.push('<th>' + head[0] + '</th>');
        });
        html.push('</tr>');
        $('#document_select thead').html(html.join(''));

        html = [];
        // NOTE: we seem to have some excessive sorting going on;
        // disabling this as a test. If everything works, just remove
        // the following commented-out line (and this comment):
        //selectorData.items.sort(docSortFunction);
        $.each(selectorData.items, function(docNo, doc) {
          var isColl = doc[0] == "c"; // "collection"
          // second column is optional annotation-specific pointer,
          // used (at least) for search results
          var annp = doc[1] ? ('?' + Util.escapeHTML(Util.param(doc[1]))) : '';
          var name = Util.escapeHTML(doc[2]);
          var collFile = isColl ? 'collection' : 'file';
          //var collFileImg = isColl ? 'ic_list_folder.png' : 'ic_list_drafts.png';
          //var collFileImg = isColl ? 'Fugue-folder-horizontal-open.png' : 'Fugue-document.png';
          var collFileImg = isColl ? 'Fugue-shadowless-folder-horizontal-open.png' : 'Fugue-shadowless-document.png';
          var collSuffix = isColl ? '/' : '';
          if (doc[1]) {
            var matchfocus = doc[1].matchfocus || [];
            var mfstr = ' data-mf="' + Util.paramArray(matchfocus) + '"';
            var match = doc[1].match || [];
            var matchstr = ' data-match="' + Util.paramArray(match) + '"';
          } else {
            var matchstr = '';
            var mfstr = '';
          }
          html.push('<tr class="' + collFile + '" data-doc="'
            + name + collSuffix + '"' + matchstr + mfstr + '>');
          html.push('<th><img src="./assets/brat-client/static/img/' + collFileImg + '" alt="' + collFile + '"/></th>');
          html.push('<th>' + name + collSuffix + '</th>');
          var len = selectorData.header.length - 1;
          for (var i = 0; i < len; i++) {
            var type = selectorData.header[i + 1][1];
            var datum = doc[i + 3];
            // format rest according to "data type" specified in header
            var formatted = null;
            var cssClass = null;
            if (!type) {
              console.error('Missing document list data type');
              formatted = datum;
            } else if (datum === undefined) {
              formatted = '';
            } else if (type === 'string') {
              formatted = Util.escapeHTML(datum);
            } else if (type === 'string-right' || type === 'string-reverse') {
              formatted = Util.escapeHTML(datum);
              cssClass = 'rightalign';
            } else if (type === 'string-center') {
              formatted = Util.escapeHTML(datum);
              cssClass = 'centeralign';
            } else if (type === 'time') {
              formatted = Util.formatTimeAgo(datum * 1000);
            } else if (type === 'float') {
              type = defaultFloatFormat;
              cssClass = 'rightalign';
            } else if (type === 'int') {
              formatted = '' + datum;
              cssClass = 'rightalign';
            }
            if (formatted === null) {
              var m = type.match(/^(.*?)(?:\/(right))?$/);
              cssClass = m[2] ? 'rightalign' : null;
              formatted = $.sprintf(m[1], datum);
            }
            html.push('<td' + (cssClass ? ' class="' + cssClass + '"' : '') + '>' +
                formatted + '</td>');
          }
          html.push('</tr>');
        });
        html = html.join('');
        tbody = $('#document_select tbody').html(html);
        $('#document_select')[0].scrollTop = docScroll;
        tbody.find('tr').
            click(chooseDocument).
            dblclick(chooseDocumentAndSubmit);

        $('#document_select thead tr *').each(function(thNo, th) {
            makeSortChangeFunction(sortOrder, th, thNo);
        });

        $('#collection_input').val(selectorData.collection);
        $('#document_input').val(doc);

        $('#readme').val(selectorData.description || '');
        if (selectorData.description &&
            (selectorData.description.match(/\n/) ||
             selectorData.description.length > 50)) {
          // multi-line or long description; show "more" button and fill
          // dialog text
          $('#more_readme_button').button(); // TODO: more reasonable place
          $('#more_readme_button').show();
          // only display text up to the first newline in the short info*/
          //var split_readme_text = selectorData.description.match(/^[^\n]*/);
          /*$('#readme').val(split_readme_text[0]);
          $('#more_info_readme').text(selectorData.description);
        } else {
          // empty or short, single-line description; no need for more
          $('#more_readme_button').hide();
          $('#more_info_readme').text('');
        }

        selectElementInTable($('#document_select'), doc, args.matchfocus);
        setTimeout(function() {
          $('#document_input').focus().select();
        }, 0);

*/
// BRAT STANDALONE LIBRARY END
        }; // end showFileBrowser()


        $('#collection_browser_button').click(function (evt) {
          dispatcher.post('clearSearch');
        });

        var currentSelectorPosition = function () {
          var pos;
          $.each(selectorData.items, function (docNo, docRow) {
            if (docRow[2] == doc) {
              // args may have changed, so lacking a perfect match return
              // last matching document as best guess
              pos = docNo;
              // check whether 'focus' agrees; the rest of the args are
              // irrelevant for determining position.
              var collectionArgs = docRow[1] || {};
              if (Util.isEqual(collectionArgs.matchfocus, args.matchfocus)) {
                pos = docNo;
                return false;
              }
            }
          });
          return pos;
        }

        /* END collection browser - related */


        /* START search - related */

        var addSpanTypesToSelect = function ($select, types, included) {
          if (!included) included = {};
          if (!included['']) {
            included[''] = true;
            $select.html('<option value="">- Any -</option>');
          }
          $.each(types, function (typeNo, type) {
            if (type !== null) {
              if (!included[type.name]) {
                included[type.name] = true;
                var $option = $('<option value="' + Util.escapeQuotes(type.type) + '"/>').text(type.name);
                $select.append($option);
                if (type.children) {
                  addSpanTypesToSelect($select, type.children, included);
                }
              }
            }
          });
        };

        var rememberNormDb = function (response) {
          // the visualizer needs to remember aspects of the norm setup
          // so that it can avoid making queries for unconfigured or
          // missing normalization DBs.
          var norm_resources = response.normalization_config || [];
          $.each(norm_resources, function (normNo, norm) {
            var normName = norm[0];
            var serverDb = norm[3];
            normServerDbByNormDbName[normName] = serverDb;
          });
        }

        var setupSearchTypes = function (response) {
          addSpanTypesToSelect($('#search_form_entity_type'), response.entity_types);
          addSpanTypesToSelect($('#search_form_event_type'), response.event_types);
          addSpanTypesToSelect($('#search_form_relation_type'), response.relation_types);
          // nice-looking selects and upload fields
          $('#search_form select').addClass('ui-widget ui-state-default ui-button-text');
          $('#search_form_load_file').addClass('ui-widget ui-state-default ui-button-text');
        }

        // when event role changes, event types do as well
        var searchEventRoles = [];
        var searchEventRoleChanged = function (evt) {
          var $type = $(this).parent().next().children('select');
          var type = $type.val();
          var role = $(this).val();
          var origin = $('#search_form_event_type').val();
          var eventType = spanTypes[origin];
          var arcTypes = eventType && eventType.arcs || [];
          var arcType = null;
          $type.html('<option value="">- Any -</option>');
          $.each(arcTypes, function (arcNo, arcDesc) {
            if (arcDesc.type == role) {
              arcType = arcDesc;
              return false;
            }
          });
          var targets = arcType && arcType.targets || [];
          $.each(targets, function (targetNo, target) {
            var spanType = spanTypes[target];
            var spanName = spanType.name || spanType.labels[0] || target;
            var option = '<option value="' + Util.escapeQuotes(target) + '">' + Util.escapeHTML(spanName) + '</option>'
            $type.append(option);
          });
          // return the type to the same value, if possible
          if (type) {
            $type.val(type);
          }
          ;
        };

        $('#search_form_event_roles .search_event_role select').live('change', searchEventRoleChanged);

        // adding new role rows
        var addEmptySearchEventRole = function () {
          var $roles = $('#search_form_event_roles');
          var rowNo = $roles.children().length;
          var $role = $('<select class="fullwidth"/>');
          $role.append('<option value="">- Any -</option>');
          $.each(searchEventRoles, function (arcTypePairNo, arcTypePair) {
            var option = '<option value="' + Util.escapeQuotes(arcTypePair[0]) + '">' + Util.escapeHTML(arcTypePair[1]) + '</option>'
            $role.append(option);
          });
          var $type = $('<select class="fullwidth"/>');
          var $text = $('<input class="fullwidth"/>');
          var button = $('<input type="button"/>');
          var rowButton = $('<td/>').append(button);
          if (rowNo) {
            rowButton.addClass('search_event_role_del');
            button.val('\u2013'); // n-dash
          } else {
            rowButton.addClass('search_event_role_add');
            button.val('+');
          }
          var $tr = $('<tr/>').append($('<td class="search_event_role"/>').append($role)).append($('<td class="search_event_type"/>').append($type)).append($('<td class="search_event_text"/>').append($text)).append(rowButton);
          $roles.append($tr);
          $role.trigger('change');
          // style selector
          $role.addClass('ui-widget ui-state-default ui-button-text');
          $type.addClass('ui-widget ui-state-default ui-button-text');
          // style button
          button.button();
          button.addClass('small-buttons ui-button-text').removeClass('ui-button');
        };

        // deleting role rows
        var delSearchEventRole = function (evt) {
          $row = $(this).closest('tr');
          $row.remove();
        }

        $('#search_form_event_roles .search_event_role_add input').live('click', addEmptySearchEventRole);
        $('#search_form_event_roles .search_event_role_del input').live('click', delSearchEventRole);

        // When event type changes, the event roles do as well
        // Also, put in one empty role row
        $('#search_form_event_type').change(function (evt) {
          var $roles = $('#search_form_event_roles').empty();
          searchEventRoles = [];
          var eventType = spanTypes[$(this).val()];
          var arcTypes = eventType && eventType.arcs || [];
          $.each(arcTypes, function (arcTypeNo, arcType) {
            var arcTypeName = arcType.labels && arcType.labels[0] || arcType.type;
            searchEventRoles.push([arcType.type, arcTypeName]);
          });
          addEmptySearchEventRole();
        });

        // when relation changes, change choices of arg1 type
        $('#search_form_relation_type').change(function (evt) {
          var relTypeType = $(this).val();
          var $arg1 = $('#search_form_relation_arg1_type').html('<option value="">- Any -</option>');
          var $arg2 = $('#search_form_relation_arg2_type').empty();
          $.each(spanTypes,
            function (spanTypeType, spanType) {
              if (spanType.arcs) {
                $.each(spanType.arcs, function (arcTypeNo, arcType) {
                  if (arcType.type === relTypeType) {
                    var spanName = spanType.name;
                    var option = '<option value="' + Util.escapeQuotes(spanTypeType) + '">' + Util.escapeHTML(spanName) + '</option>'
                    $arg1.append(option);
                  }
                });
              }
            });
          $('#search_form_relation_arg1_type').change();
          // style the selects
          $arg1.addClass('ui-widget ui-state-default ui-button-text');
          $arg2.addClass('ui-widget ui-state-default ui-button-text');
        });

        // when arg1 type changes, change choices of arg2 type
        $('#search_form_relation_arg1_type').change(function (evt) {
          var $arg2 = $('#search_form_relation_arg2_type').html('<option value="">- Any -</option>');
          var relType = $('#search_form_relation_type').val();
          var arg1Type = spanTypes[$(this).val()];
          var arcTypes = arg1Type && arg1Type.arcs || [];
          var arcType = null;
          $.each(arcTypes, function (arcNo, arcDesc) {
            if (arcDesc.type == relType) {
              arcType = arcDesc;
              return false;
            }
          });
          if (arcType && arcType.targets) {
            $.each(arcType.targets, function (spanTypeNo, spanTypeType) {
              var spanName = Util.spanDisplayForm(spanTypes, spanTypeType);
              var option = '<option value="' + Util.escapeQuotes(spanTypeType) + '">' + Util.escapeHTML(spanName) + '</option>'
              $arg2.append(option);
            });
          }
        });

        $('#search_form_note_category').change(function (evt) {
          var category = $(this).val();
          var $type = $('#search_form_note_type');
          if ($.inArray(category, ['entity', 'event', 'relation']) != -1) {
            $type.html($('#search_form_' + category + '_type').html()).val('');
            $('#search_form_note_type_row:not(:visible)').show('highlight');
          } else {
            $type.html('');
            $('#search_form_note_type_row:visible').hide('highlight');
          }
        });


        // context length setting should only be visible if
        // concordancing is on
        // TODO: @amadanmath: help, my jQuery is horrible
        if ($('#concordancing_on').is(':checked')) {
          $('#context_size_div').show("highlight");
        } else {
          $('#context_size_div').hide("highlight");
        }
        $('#concordancing input[type="radio"]').change(function () {
          if ($('#concordancing_on').is(':checked')) {
            $('#context_size_div').show("highlight");
          } else {
            $('#context_size_div').hide("highlight");
          }
        });
        $('#search_options div.advancedOptions').hide("highlight");
        // set up advanced search options; only visible is clicked
        var advancedSearchOptionsVisible = false;
        $('#advanced_search_option_toggle').click(function (evt) {
          if (advancedSearchOptionsVisible) {
            $('#search_options div.advancedOptions').hide("highlight");
            $('#advanced_search_option_toggle').text("Show advanced");
          } else {
            $('#search_options div.advancedOptions').show("highlight");
            $('#advanced_search_option_toggle').text("Hide advanced");
          }
          advancedSearchOptionsVisible = !advancedSearchOptionsVisible;
          // block default
          return false;
        });

        var activeSearchTab = function () {
          // activeTab: 0 = Text, 1 = Entity, 2 = Event, 3 = Relation, 4 = Notes, 5 = Load
          var activeTab = $('#search_tabs').tabs('option', 'selected');
          return ['searchText', 'searchEntity', 'searchEvent',
            'searchRelation', 'searchNote', 'searchLoad'][activeTab];
        }

        var onSearchTabSelect = function () {
          var action = activeSearchTab();
          switch (action) {
            case 'searchText':
              $('#search_form_text_text').focus().select();
              break;
            case 'searchEntity':
              $('#search_form_entity_text').focus().select();
              break;
            case 'searchEvent':
              $('#search_form_event_trigger').focus().select();
              break;
            case 'searchRelation':
              $('#search_form_relation_type').focus().select();
              break;
            case 'searchNote':
              $('#search_form_note_text').focus().select();
              break;
            case 'searchLoad':
              $('#search_form_load_file').focus().select();
              break;
          }
        };

        // set up jQuery UI elements in search form
        $('#search_tabs').tabs({
          show: onSearchTabSelect
        });
        $('#search_form').find('.radio_group').buttonset();

        var applySearchResults = function (response) {
          if (!searchActive) {
            collectionSortOrder = sortOrder;
          }
          dispatcher.post('searchResultsReceived', [response]);
          searchActive = true;
          updateSearchButtons();
        };

        var searchForm = $('#search_form');

        var searchFormSubmit = function (evt) {
          // hack around empty document; "" would be interpreted as
          // missing argument by server dispatcher (issue #513)
          // TODO: do this properly, avoiding magic strings
          var action = activeSearchTab();
          var docArg = doc ? doc : "/NO-DOCUMENT/";
          var opts = {
            action: action,
            collection: coll,
            document: docArg,
            // TODO the search form got complex :)
          };

          switch (action) {
            case 'searchText':
              opts.text = $('#search_form_text_text').val();
              if (!opts.text.length) {
                dispatcher.post('messages', [[['Please fill in the text to search for!', 'comment']]]);
                return false;
              }
              break;
            case 'searchEntity':
              opts.type = $('#search_form_entity_type').val() || '';
              opts.text = $('#search_form_entity_text').val();
              break;
            case 'searchEvent':
              opts.type = $('#search_form_event_type').val() || '';
              opts.trigger = $('#search_form_event_trigger').val();
              var eargs = [];
              $('#search_form_event_roles tr').each(function () {
                var earg = {};
                earg.role = $(this).find('.search_event_role select').val() || '';
                earg.type = $(this).find('.search_event_type select').val() || '';
                earg.text = $(this).find('.search_event_text input').val();
                eargs.push(earg);
              });
              opts.args = $.toJSON(eargs);
              break;
            case 'searchRelation':
              opts.type = $('#search_form_relation_type').val() || '';
              opts.arg1 = $('#search_form_relation_arg1_text').val();
              opts.arg1type = $('#search_form_relation_arg1_type').val() || '';
              opts.arg2 = $('#search_form_relation_arg2_text').val();
              opts.arg2type = $('#search_form_relation_arg2_type').val() || '';
              break;
            case 'searchNote':
              opts.category = $('#search_form_note_category').val() || '';
              opts.type = $('#search_form_note_type').val() || '';
              opts.text = $('#search_form_note_text').val() || '';
              break;
            case 'searchLoad':
              applySearchResults(loadedSearchData);
              return false;
          }

          // fill in scope of search ("document" / "collection")
          var searchScope = $('#search_scope input:checked').val();
          opts.scope = searchScope;

          // adjust specific action to invoke by scope
          if (searchScope == "document") {
            opts.action = opts.action + "InDocument";
          } else {
            opts.action = opts.action + "InCollection";
          }

          // fill in concordancing options
          opts.concordancing = $('#concordancing_on').is(':checked');
          opts.context_length = $('#context_length').val();

          // fill in text match options
          opts.text_match = $('#text_match input:checked').val()
          opts.match_case = $('#match_case_on').is(':checked');

          dispatcher.post('hideForm');
          dispatcher.post('ajax', [opts, function (response) {
            if (response && response.items && response.items.length == 0) {
              // TODO: might consider having this message come from the
              // server instead
              dispatcher.post('messages', [[['No matches to search.', 'comment']]]);
              dispatcher.post('clearSearch', [true]);
            } else {
              applySearchResults(response);
            }
          }]);
          return false;
        };

        $('#search_form_load_file').change(function (evt) {
          var $file = $('#search_form_load_file');
          var file = $file[0].files[0];
          var reader = new FileReader();
          reader.onerror = function (evt) {
            dispatcher.post('messages', [[['The file could not be read.', 'error']]]);
          };
          reader.onloadend = function (evt) {
            try {
              loadedSearchData = JSON.parse(evt.target.result);
              // TODO XXX check for validity of contents, not just whether
              // it's valid JSON or not; throw something if not
            } catch (x) {
              dispatcher.post('messages', [[['The file contains invalid data.', 'error']]]);
              return;
            }
          };
          reader.readAsText(file);
        });

        searchForm.submit(searchFormSubmit);

        initForm(searchForm, {
          width: 500,
          // alsoResize: '#search_tabs',
          resizable: false,
          open: function (evt) {
            keymap = {};
          },
        });
        $('#search_form_clear').attr('title', 'Clear the search and resume normal collection browsing');

        var showSearchForm = function () {
          // this.checked = searchActive; // TODO: dup? unnecessary? remove if yes.
          updateSearchButtons();
          $('#search_form_event_type').change();
          $('#search_form_relation_type').change();
          dispatcher.post('showForm', [searchForm]);
          onSearchTabSelect();
        }

        $('#search_button').click(showSearchForm);

        var clearSearchResults = function () {
          // clear UI, don't show collection browser
          dispatcher.post('clearSearch', [true]);
          // TODO: this was the only way I found to reset search. It
          // trigger an unnecessary round-trip to the server, though,
          // so there should be a better way ...
          dispatcher.post('setArguments', [{}, true]);
        }

        $('#clear_search_button').click(clearSearchResults);

        var updateSearchButtons = function () {
          $searchButton = $('#search_button');
          $searchButton[0].checked = searchActive;
          $searchButton.button('refresh');
          $clearSearchButton = $('#clear_search_button');
          if (searchActive) {
            // TODO: this is a bit poor form, using jQuery UI classes
            // directly -- are these names guaranteed to be stable?
            $('#search_button_label').removeClass('ui-corner-all');
            $('#search_button_label').addClass('ui-corner-left');
            $clearSearchButton.show();
          } else {
            $('#search_button_label').removeClass('ui-corner-left');
            $('#search_button_label').addClass('ui-corner-all');
            $clearSearchButton.hide();
          }
        }

        /* END search - related */


        /* START data dialog - related */

        var dataForm = $('#data_form');
        var dataFormSubmit = function (evt) {
          dispatcher.post('hideForm');
          return false;
        };
        dataForm.submit(dataFormSubmit);
        initForm(dataForm, {
          width: 500,
          resizable: false,
          no_cancel: true,
          open: function (evt) {
            keymap = {};
            // aspects of the data form relating to the current document should
            // only be shown when a document is selected.
            if (!doc) {
              $('#document_export').hide();
              $('#document_visualization').hide();
            } else {
              $('#document_export').show();
              $('#document_visualization').show();
              // the SVG button can only be accessed through the data form,
              // so we'll spare unnecessary saves by only saving here
              saveSVG();
            }
          }
        });
        $('#data_button').click(function () {
          dispatcher.post('showForm', [dataForm]);
        });
        // make nice-looking buttons for checkboxes and buttons
        $('#data_form').find('input[type="checkbox"]').button();
        $('#data_form').find('input[type="button"]').button();

        // resize invalidates stored visualization (SVG etc.); add a
        // button to regen
        $('#stored_file_regenerate').button().hide();
        $('#stored_file_regenerate').click(function (evt) {
          $('#stored_file_regenerate').hide();
          saveSVG();
        });

        /* END data dialog - related */


        /* START options dialog - related */

        var optionsForm = $('#options_form');
        var optionsFormSubmit = function (evt) {
          dispatcher.post('hideForm');
          return false;
        };
        optionsForm.submit(optionsFormSubmit);
        initForm(optionsForm, {
          width: 550,
          resizable: false,
          no_cancel: true,
          open: function (evt) {
            keymap = {};
          }
        });
        $('#options_button').click(function () {
          dispatcher.post('showForm', [optionsForm]);
        });
        // make nice-looking buttons for checkboxes and radios
        $('#options_form').find('input[type="checkbox"]').button();
        $('#options_form').find('.radio_group').buttonset();
        $('#rapid_model').addClass('ui-widget ui-state-default ui-button-text');

        var fillDisambiguatorOptions = function (disambiguators) {
          $('#annotation_speed3').button(disambiguators.length ? 'enable' : 'disable');
          //XXX: We need to disable rapid in the conf too if it is not available
          var $rapid_mode = $('#rapid_model').html('');
          $.each(disambiguators, function (modelNo, model) {
            var $option = $('<option/>').attr('value', model[2]).text(model[2]);
            $rapid_mode.append($option);
          });
        };

        /* END options dialog - related */


        /* START "more collection information" dialog - related */

        var moreInfoDialog = $('#more_information_dialog');
        var moreInfoDialogSubmit = function (evt) {
          dispatcher.post('hideForm');
          return false;
        };
        moreInfoDialog.submit(moreInfoDialogSubmit);
        initForm(moreInfoDialog, {
          width: 500,
          no_cancel: true,
          open: function (evt) {
            keymap = {};
          },
          alsoResize: '#more_info_readme',
        });
        $('#more_readme_button').click(function () {
          dispatcher.post('showForm', [moreInfoDialog]);
        });

        /* END "more collection information" dialog - related */


        var onKeyDown = function (evt) {
          var code = evt.which;

          if (code === $.ui.keyCode.ESCAPE) {
            dispatcher.post('messages', [false]);
            return;
          }

          if (currentForm) {
            if (code === $.ui.keyCode.ENTER) {
              // don't trigger submit in textareas to allow multiline text
              // entry
              // NOTE: spec seems to require this to be upper-case,
              // but at least chrome 8.0.552.215 returns lowercased
              var nodeType = evt.target.type ? evt.target.type.toLowerCase() : '';
              if (evt.target.nodeName &&
                evt.target.nodeName.toLowerCase() == 'input' &&
                (nodeType == 'text' ||
                  nodeType == 'password')) {
                currentForm.trigger('submit');
                return false;
              }
            } else if (evt.ctrlKey &&
              (code == 'F'.charCodeAt(0) || code == 'G'.charCodeAt(0))) {
              // prevent Ctrl-F/Ctrl-G in forms
              evt.preventDefault();
              return false;
            }
            return;
          }

          if (code === $.ui.keyCode.TAB) {
            showFileBrowser();
            return false;
          } else if (code == $.ui.keyCode.LEFT) {
            return moveInFileBrowser(-1);
          } else if (code === $.ui.keyCode.RIGHT) {
            return moveInFileBrowser(+1);
          } else if (evt.shiftKey && code === $.ui.keyCode.UP) {
            autoPaging(true);
          } else if (evt.shiftKey && code === $.ui.keyCode.DOWN) {
            autoPaging(false);
          } else if (evt.ctrlKey && code == 'F'.charCodeAt(0)) {
            evt.preventDefault();
            showSearchForm();
          } else if (searchActive && evt.ctrlKey && code == 'G'.charCodeAt(0)) {
            evt.preventDefault();
            return moveInFileBrowser(+1);
          } else if (searchActive && evt.ctrlKey && code == 'K'.charCodeAt(0)) {
            evt.preventDefault();
            clearSearchResults();
          }
        };

        var moveInFileBrowser = function (dir) {
          var pos = currentSelectorPosition();
          var newPos = pos + dir;
          if (newPos >= 0 && newPos < selectorData.items.length &&
            selectorData.items[newPos][0] != "c") {
            // not at the start, and the previous is not a collection (dir)
            dispatcher.post('allowReloadByURL');
            dispatcher.post('setDocument', [selectorData.items[newPos][2],
              selectorData.items[newPos][1]]);
          }
          return false;
        };

        /* Automatically proceed from document to document */
        var autoPagingTimeout = null;
        var autoPaging = function (on) {
          clearTimeout(autoPagingTimeout);
          if (on) {
            autoPagingTimeout = setInterval(function () {
              moveInFileBrowser(+1);
            }, 2000);
          }
        };

        var resizeFunction = function (evt) {
          dispatcher.post('renderData');
        };

        var resizerTimeout = null;
        var onResize = function (evt) {
          if (evt.target === window) {
            clearTimeout(resizerTimeout);
            resizerTimeout = setTimeout(resizeFunction, 100); // TODO is 100ms okay?
          }
        };

        var collectionLoaded = function (response) {
          if (response.exception) {
            if (response.exception == 'annotationCollectionNotFound' ||
              response.exception == 'collectionNotAccessible') {
              // revert to last good
              dispatcher.post('setCollection', [lastGoodCollection]);
            } else {
              dispatcher.post('messages', [[['Unknown error: ' + response.exception, 'error']]]);
              dispatcher.post('setCollection', ['/']);
            }
          } else {
            lastGoodCollection = response.collection;
            fillDisambiguatorOptions(response.disambiguator_config);
            selectorData = response;
            documentListing = response; // 'backup'
            searchConfig = response.search_config;
            selectorData.items.sort(docSortFunction);
            setupSearchTypes(response);
            // scroller at the top
            docScroll = 0;
          }
        };

        var searchResultsReceived = function (response) {
          if (response.exception) {
            ; // TODO: reasonable reaction
          } else {
            selectorData = response;
            sortOrder = [2, 1]; // reset
            // NOTE: don't sort, allowing order in which
            // responses are given to be used as default
            //selectorData.items.sort(docSortFunction);
            if (response.action.match(/Collection$/)) {
              showFileBrowser();
            } else {
              var item = response.items[0];
              dispatcher.post('setDocument', [item[2], item[1]]);
            }
            $('#save_search').css('display', 'inline-block');
          }
        };

        var clearSearch = function (dontShowFileBrowser) {
          dispatcher.post('hideForm');

          // back off to document collection
          if (searchActive) {
            $('#save_search').css('display', 'none');
            selectorData = documentListing;
            sortOrder = collectionSortOrder;
            selectorData.items.sort(docSortFunction);
            searchActive = false;
            updateSearchButtons();
          }

          if (!dontShowFileBrowser) {
            showFileBrowser();
          }
        }

        var saveSVGTimer = null;
        var saveSVG = function () {
          if (currentDocumentSVGsaved) {
            // no need to store again
            return false;
          }
          clearTimeout(saveSVGTimer);
          $('#stored_file_regenerate').hide();
          $('#stored_file_spinner').show()
          saveSVGTimer = dispatcher.post(1, 'ajax', [{
            action: 'storeSVG',
            svg: $('#svg').html(),
            collection: coll,
            document: doc
          }, 'savedSVG']);
        };

        var onDoneRendering = function (coll, doc, args) {
          if (args && !args.edited) {
            var svgtop = $('svg').offset().top;
            var $inFocus = $('#svg animate[data-type="focus"]:first').parent();
            if ($inFocus.length) {
              $('html,body').animate({scrollTop: $inFocus.offset().top - svgtop - window.innerHeight / 2}, {
                duration: 'slow',
                easing: 'swing'
              });
            }
          }
          dispatcher.post('allowReloadByURL');
          if (!currentForm) {
            $('#waiter').dialog('close');
          }
        }

        var onStartedRendering = function () {
          hideForm();
          if (!currentForm) {
            $('#waiter').dialog('open');
          }
        }

        var savedSVGreceived = function (response) {
          $('#stored_file_spinner').hide()

          if (response && response.exception == 'corruptSVG') {
            dispatcher.post('messages', [[['Cannot save SVG: corrupt', 'error']]]);
            return;
          }
          var $downloadStored = $('#download_stored').empty().show();
          $.each(response.stored, function (storedNo, stored) {
            var params = {
              'action': 'retrieveStored',
              'document': doc,
              'suffix': stored.suffix,
              // TODO: Extract the protocol version into somewhere global
              'protocol': 1
            };
            var $downloadLink = $('<a id="download_' + stored.name + '"' +
              ' target="' + stored.name + '"' +
              '>' + stored.name + '</a>');
            $downloadLink.attr('href', 'ajax.cgi?' + $.param(params));
            $downloadLink.button();
            if (storedNo) $downloadStored.append(' ');
            $downloadStored.append($downloadLink);
          });
          currentDocumentSVGsaved = true;
        };

        var invalidateSavedSVG = function () {
          // assuming that invalidation of the SVG invalidates all stored
          // ./assets/brat-client/static visualizations, as others are derived from the SVG
          $('#download_stored').hide();
          // have a way to regenerate if dialog open when data invalidated
          $('#stored_file_regenerate').show();
          currentDocumentSVGsaved = false;
        };

        var onNewSourceData = function (sourceData) {
          if (!sourceData) return;
          var $sourceFiles = $('#source_files').empty();
          /* Add download links for all available extensions */
          $.each(sourceData.source_files, function (extNo, ext) {
            var $link = $('<a target="brat_search"/>').text(ext).attr('href',
              'ajax.cgi?action=downloadFile&collection=' + encodeURIComponent(coll) +
              '&document=' + encodeURIComponent(doc) + '&extension=' + encodeURIComponent(ext) +
              // TODO: Extract the protocol version into somewhere global
              '&protocol=' + 1);
            $link.button();
            if (extNo) $sourceFiles.append(' ');
            $sourceFiles.append($link);
          });
          /* Add a download link for the whole collection */
          invalidateSavedSVG();

          mtime = sourceData.mtime;
          if (mtime) {
            // we're getting seconds and need milliseconds
            //$('#document_ctime').text("Created: " + Annotator.formatTime(1000 * sourceData.ctime)).css("display", "inline");
            $('#document_mtime').text("Last modified: " + Util.formatTimeAgo(1000 * mtime)).show();
          } else {
            //$('#document_ctime').css("display", "none");
            $('#document_mtime').hide();
          }
        }

        //BRAT STANDALONE LIBRARY BEGIN
        //We do no use notion of documents
        /**/
        var gotCurrent = function (_coll, _doc, _args) {
          var oldColl = coll;

          coll = _coll;
          doc = _doc;
          args = _args;

          // if we have a specific document, hide the "no document" message
          if (_doc) {
            hideNoDocMessage();
          }

          // if we have a collection change, update "collection download" and
          // "side-by-side comparison" buttons
          if (oldColl != coll) {
            var $sourceCollection = $('#source_collection').empty();
            var $collectionDownloadLink = $('<a target="brat_search"/>')
              .text('Download tar.gz')
              .attr('href', 'ajax.cgi?action=downloadCollection&collection=' + encodeURIComponent(coll)
                // TODO: Extract the protocol version into somewhere global
                + '&protocol=' + 1);
            $sourceCollection.append($collectionDownloadLink);
            $collectionDownloadLink.button();

            $cmpButton = $('#side-by-side_cmp').empty();
            var $cmpLink = $('<a target="_blank"/>')
              .text('Comparison mode')
              .attr('href', 'diff.xhtml?diff=' + encodeURIComponent(coll));
            $cmpButton.append($cmpLink);
            $cmpLink.button();
          }

          //BRAT STANDALONE LIBRARY BEGIN
          /*
        $docName = $('#document_name input').val(coll + doc);
        var docName = $docName[0];
        // TODO do this on resize, as well
        // scroll the document name to the right, so the name is visible
        // (even if the collection name isn't, fully)
        docName.scrollLeft = docName.scrollWidth;

        $('#document_mtime').hide();
        */
          //BRAT STANDALONE LIBRARY END
          invalidateSavedSVG();
        };
        /**/
        //BRAT STANDALONE LIBRARY END

        var slideToggle = function (el, show, autoHeight, bottom) {
          var el = $(el);
          var visible = el.is(":visible");
          var height;

          if (show === undefined) show = !visible;

          // @amadanmath: commenting this out appears to remove the annoying
          // misfeature where it's possible to stop the menu halfway by
          // mousing out and back in during closing. Please check that
          // this doesn't introduce other trouble and remove these lines.
//         if (show === visible) return false;

          if (!autoHeight) {
            height = el.data("cachedHeight");
          } else {
            el.height('auto');
          }
          if (!height) {
            height = el.show().height();
            el.data('cachedHeight', height);
            if (!visible) el.hide().css({height: 0});
          }

          if (show) {
            el.show().animate({height: height}, {
              duration: 150,
              complete: function () {
                if (autoHeight) {
                  el.height('auto');
                }
              },
              step: bottom ? function (now, fx) {
                fx.elem.scrollTop = fx.elem.scrollHeight;
              } : undefined
            });
          } else {
            el.animate({height: 0}, {
              duration: 300,
              complete: function () {
                el.hide();
              }
            });
          }
        }

        var menuTimer = null;
        $('#header').mouseenter(function (evt) {
          clearTimeout(menuTimer);
          slideToggle($('#pulldown').stop(), true);
        }).mouseleave(function (evt) {
          clearTimeout(menuTimer);
          menuTimer = setTimeout(function () {
            slideToggle($('#pulldown').stop(), false);
          }, 500);
        });

        $('#label_abbreviations input').click(function (evt) {
          var val = this.value;
          val = val === 'on';
          if (val) {
            dispatcher.post('messages', [[['Abbreviations are now on', 'comment']]]);
          } else {
            dispatcher.post('messages', [[['Abbreviations are now off', 'comment']]]);
          }
          dispatcher.post('abbrevs', [val]);
          // TODO: XXX: for some insane reason, doing the following call
          // synchronously breaks the checkbox (#456). If you ever figure
          // out why, it would make more sense to call
          //    dispatcher.post('resetData');
          // without the asynch.
          dispatcher.post(1, 'resetData');
        });

        $('#text_backgrounds input').click(function (evt) {
          var val = this.value;
          dispatcher.post('textBackgrounds', [val]);
          // TODO: XXX: see comment above for why this is asynchronous
          dispatcher.post(1, 'resetData');
        });

        $('#layout_density input').click(function (evt) {
          var val = this.value;
          dispatcher.post('layoutDensity', [val]);
          // TODO: XXX: see comment above for why this is asynchronous
          dispatcher.post(1, 'resetData');
          return false;
        });

        $('#svg_width_unit input').click(function (evt) {
          var width_unit = this.value;
          var width_value = $('#svg_width_value')[0].value;
          var val = width_value + width_unit;
          dispatcher.post('svgWidth', [val]);
          // TODO: XXX: see comment above for why this is asynchronous
          dispatcher.post(1, 'resetData');
          return false;
        });

        $('#annotation_speed input').click(function (evt) {
          var val = this.value;
          dispatcher.post('annotationSpeed', [val]);
          return false;
        });

        $('#pulldown').find('input').button();
        var headerHeight = $('#mainHeader').height();
        $('#svg').css('margin-top', headerHeight + 10);
        aboutDialog = $('#about');
        aboutDialog.dialog({
          autoOpen: false,
          closeOnEscape: true,
          resizable: false,
          modal: true,
          open: function () {
            aboutDialog.find('*').blur();
          },
          beforeClose: function () {
            currentForm = null;
          }
        });
        $('#mainlogo').click(function () {
          showForm(aboutDialog);
        });

        // TODO: copy from annotator_ui; DRY it up
        var adjustFormToCursor = function (evt, element) {
          var screenHeight = $(window).height() - 8; // TODO HACK - no idea why -8 is needed
          var screenWidth = $(window).width() - 8;
          var elementHeight = element.height();
          var elementWidth = element.width();
          var y = Math.min(evt.clientY, screenHeight - elementHeight);
          var x = Math.min(evt.clientX, screenWidth - elementWidth);
          element.css({top: y, left: x});
        };
        var viewspanForm = $('#viewspan_form');

        var onSingleClick = function (evt) {
          var target = $(evt.target);
          var id;
          if (id = target.attr('data-span-id')) {
            var span = data.spans[id];
            dispatcher.post('sglclick', [span]);
          }
        };

        var onDblClick = function (evt) {
          if (user && annotationAvailable) return;
          var target = $(evt.target);
          var id;
          if (id = target.attr('data-span-id')) {
            window.getSelection().removeAllRanges();
            var span = data.spans[id];

            var urlHash = URLHash.parse(window.location.hash);
            urlHash.setArgument('focus', [[span.id]]);
            $('#viewspan_highlight_link').show().attr('href', urlHash.getHash());

            $('#viewspan_selected').text(span.text);
            var encodedText = encodeURIComponent(span.text);
            $.each(searchConfig, function (searchNo, search) {
              $('#viewspan_' + search[0]).attr('href', search[1].replace('%s', encodedText));
            });
            // annotator comments
            $('#viewspan_notes').val(span.annotatorNotes || '');
            dispatcher.post('showForm', [viewspanForm]);
            $('#viewspan_form-ok').focus();
            adjustFormToCursor(evt, viewspanForm.parent());
          }
        };
        viewspanForm.submit(function (evt) {
          dispatcher.post('hideForm');
          return false;
        });

        var authForm = $('#auth_form');
        initForm(authForm, {resizable: false});
        var authFormSubmit = function (evt) {
          dispatcher.post('hideForm');
          var _user = $('#auth_user').val();
          var password = $('#auth_pass').val();
          dispatcher.post('ajax', [{
            action: 'login',
            user: _user,
            password: password,
          },
            function (response) {
              if (response.exception) {
                dispatcher.post('showForm', [authForm]);
                $('#auth_user').select().focus();
              } else {
                user = _user;
                $('#auth_button').val('Logout ' + user);
                $('#auth_user').val('');
                $('#auth_pass').val('');
                $('.login').show();
                dispatcher.post('user', [user]);
              }
            }]);
          return false;
        };
        $('#auth_button').click(function (evt) {
          if (user) {
            dispatcher.post('ajax', [{
              action: 'logout'
            }, function (response) {
              user = null;
              $('#auth_button').val('Login');
              $('.login').hide();
              dispatcher.post('user', [null]);
            }]);
          } else {
            dispatcher.post('showForm', [authForm]);
          }
        });
        authForm.submit(authFormSubmit);


        var tutorialForm = $('#tutorial');
        if (!$.browser.webkit) {
          // Inject the browser warning
          $('#browserwarning').css('display', 'block');
        }
        initForm(tutorialForm, {
          width: 800,
          height: 600,
          no_cancel: true,
          no_ok: true,
          buttons: [{
            id: "tutorial-ok",
            text: "OK",
            click: function () {
              tutorialForm.dialog('close');
            }
          }],
          close: function () {
            if (fileBrowserWaiting) {
              showFileBrowser();
            }
          }
        });

        var init = function () {
          dispatcher.post('initForm', [viewspanForm, {
            width: 760,
            no_cancel: true
          }]);
          dispatcher.post('ajax', [{
            action: 'whoami'
          }, function (response) {
            var auth_button = $('#auth_button');
            if (response.user) {
              user = response.user;
              dispatcher.post('messages', [[['Welcome back, user "' + user + '"', 'comment']]]);
              auth_button.val('Logout ' + user);
              dispatcher.post('user', [user]);
              $('.login').show();
            } else {
              user = null;
              auth_button.val('Login');
              dispatcher.post('user', [null]);
              $('.login').hide();
              // don't show tutorial if there's a specific document (annoyance)
              if (!doc) {
                dispatcher.post('showForm', [tutorialForm]);
                $('#tutorial-ok').focus();
              }
            }
          },
            {keep: true}
          ]);
          dispatcher.post('ajax', [{action: 'loadConf'}, function (response) {
            if (response.config != undefined) {
              // TODO: check for exceptions
              try {
                Configuration = JSON.parse(response.config);
              } catch (x) {
                // XXX Bad config
                Configuration = {};
                dispatcher.post('messages', [[['Corrupted configuration; resetting.', 'error']]]);
                configurationChanged();
              }
              // TODO: make whole-object assignment work
              // @amadanmath: help! This code is horrible
              // Configuration.svgWidth = storedConf.svgWidth;
              dispatcher.post('svgWidth', [Configuration.svgWidth]);
              // Configuration.abbrevsOn = storedConf.abbrevsOn == "true";
              // Configuration.textBackgrounds = storedConf.textBackgrounds;
              // Configuration.rapidModeOn = storedConf.rapidModeOn == "true";
              // Configuration.confirmModeOn = storedConf.confirmModeOn == "true";
              // Configuration.autorefreshOn = storedConf.autorefreshOn == "true";
              if (Configuration.autorefreshOn) {
                checkForDocumentChanges();
              }
              // Configuration.visual.margin.x = parseInt(storedConf.visual.margin.x);
              // Configuration.visual.margin.y = parseInt(storedConf.visual.margin.y);
              // Configuration.visual.boxSpacing = parseInt(storedConf.visual.boxSpacing);
              // Configuration.visual.curlyHeight = parseInt(storedConf.visual.curlyHeight);
              // Configuration.visual.arcSpacing = parseInt(storedConf.visual.arcSpacing);
              // Configuration.visual.arcStartHeight = parseInt(storedConf.visual.arcStartHeight);
            }
            dispatcher.post('configurationUpdated');
          }]);
        };

        var noFileSpecified = function () {
          // not (only) an error, so no messaging
          dispatcher.post('clearSVG');
          showFileBrowser();
        }

        var showUnableToReadTextFile = function () {
          dispatcher.post('messages', [[['Unable to read the text file.', 'error']]]);
          dispatcher.post('clearSVG');
          showFileBrowser();
        };

        var showAnnotationFileNotFound = function () {
          dispatcher.post('messages', [[['Annotation file not found.', 'error']]]);
          dispatcher.post('clearSVG');
          showFileBrowser();
        };

        var showUnknownError = function (exception) {
          dispatcher.post('messages', [[['Unknown error: ' + exception, 'error']]]);
          dispatcher.post('clearSVG');
          showFileBrowser();
        };

        var reloadDirectoryWithSlash = function (sourceData) {
          var collection = sourceData.collection + sourceData.document + '/';
          dispatcher.post('setCollection', [collection, '', sourceData.arguments]);
        };

        // TODO: confirm attributeTypes unnecessary and remove
//       var spanAndAttributeTypesLoaded = function(_spanTypes, _attributeTypes) {
//         spanTypes = _spanTypes;
//         attributeTypes = _attributeTypes;
//       };
        // TODO: spanAndAttributeTypesLoaded is obviously not descriptive of
        // the full function. Rename reasonably.
        var spanAndAttributeTypesLoaded = function (_spanTypes, _entityAttributeTypes, _eventAttributeTypes, _relationTypesHash) {
          spanTypes = _spanTypes;
          relationTypesHash = _relationTypesHash;
        };

        var annotationIsAvailable = function () {
          annotationAvailable = true;
        };

        // hide anything requiring login, just in case
        $('.login').hide();

        // XXX TODO a lot
        var touchStart;
        var onTouchStart = function (evt) {
          // evt.preventDefault();
          evt = evt.originalEvent;
          if (evt.touches.length == 1) {
            // single touch; start tracking to see if we're doing
            // left/right
            touchStart = $.extend({}, evt.touches[0]); // clone
          } else if (evt.touches.length == 4) {
            // 4 finger tap: file browser
            showFileBrowser();
            return false;
          }
        };
        var onTouchEnd = function (evt) {
          // evt.preventDefault();
          evt = evt.originalEvent;
          $.each(evt.changedTouches, function (touchEndNo, touchEnd) {
            if (touchStart.identifier == touchEnd.identifier) {
              var dx = touchEnd.screenX - touchStart.screenX;
              var dy = touchEnd.screenY - touchStart.screenY;
              var adx = Math.abs(dx);
              var ady = Math.abs(dy);
              if (adx > 200 && ady < adx / 2) {
                // it's left/right!
                return moveInFileBrowser(dx < 0 ? -1 : +1);
              }
            }
          });
        };

        var documentChangesTimer = null;
        var maxDocumentChangesTimeout = 32 * 1000;
        var documentChangesTimeout = 1 * 1000;
        var checkForDocumentChanges = function () {
          if (coll && doc && dispatcher.post('isReloadOkay', [], 'all')) {
            opts = {
              'action': 'getDocumentTimestamp',
              'collection': coll,
              'document': doc
            }
            dispatcher.post('ajax', [opts, function (response) {
              if (data) {
                if (mtime != response.mtime) {
                  dispatcher.post('current', [coll, doc, args, true]);
                  documentChangesTimeout = 1 * 1000;
                } else {
                  documentChangesTimeout *= 2;
                  if (documentChangesTimeout >= maxDocumentChangesTimeout)
                    documentChangesTimeout = maxDocumentChangesTimeout;
                }
              }
            }]);
          } else {
            documentChangesTimeout = 1 * 1000;
          }
          documentChangesTimer = setTimeout(checkForDocumentChanges, documentChangesTimeout);
        }

        if (Configuration.autorefreshOn) {
          checkForDocumentChanges();
        }

        $('#autorefresh_mode').click(function (evt) {
          var val = this.checked;
          if (val) {
            Configuration.autorefreshOn = true;
            checkForDocumentChanges();
            dispatcher.post('messages', [[['Autorefresh mode is now on', 'comment']]]);
          } else {
            Configuration.autorefreshOn = false;
            clearTimeout(documentChangesTimer);
            dispatcher.post('messages', [[['Autorefresh mode is now off', 'comment']]]);
          }
          dispatcher.post('configurationChanged');
        });

        var isReloadOkay = function () {
          // do not reload while the user is in the dialog
          return currentForm == null;
        };

        var configurationChanged = function () {
          // just assume that any config change makes stored
          // visualizations invalid. This is a bit excessive (not all
          // options affect visualization) but mostly harmless.
          invalidateSavedSVG();

          // save configuration changed by user action
          dispatcher.post('ajax', [{
            action: 'saveConf',
            config: JSON.stringify(Configuration),
          }, null]);
        };

        //BRAT STANDALONE LIBRARY BEGIN
        //Config must be managed outside the component
        /*
      var updateConfigurationUI = function() {
        // update UI to reflect non-user config changes (e.g. load)

        // Annotation mode
        if (Configuration.confirmModeOn) {
          $('#annotation_speed1')[0].checked = true;
        } else if (Configuration.rapidModeOn) {
          $('#annotation_speed3')[0].checked = true;
        } else {
          $('#annotation_speed2')[0].checked = true;
        }
        $('#annotation_speed input').button('refresh');

        // Label abbrevs
        $('#label_abbreviations_on')[0].checked  = Configuration.abbrevsOn;
        $('#label_abbreviations_off')[0].checked = !Configuration.abbrevsOn;
        $('#label_abbreviations input').button('refresh');

        // Text backgrounds
        $('#text_backgrounds input[value="'+Configuration.textBackgrounds+'"]')[0].checked = true;
        $('#text_backgrounds input').button('refresh');

        // SVG width
        var splitSvgWidth = Configuration.svgWidth.match(/^(.*?)(px|\%)$/);
        if (!splitSvgWidth) {
          // TODO: reset to sensible value?
          dispatcher.post('messages', [[['Error parsing SVG width "'+Configuration.svgWidth+'"', 'error', 2]]]);
        } else {
          $('#svg_width_value')[0].value = splitSvgWidth[1];
          $('#svg_width_unit input[value="'+splitSvgWidth[2]+'"]')[0].checked = true;
          $('#svg_width_unit input').button('refresh');
        }

        // Autorefresh
        $('#autorefresh_mode')[0].checked = Configuration.autorefreshOn;
        $('#autorefresh_mode').button('refresh');
      }*/

        $('#prev').button().click(function () {
          return moveInFileBrowser(-1);
        });
        $('#next').button().click(function () {
          return moveInFileBrowser(+1);
        });
        $('#footer').show();

        var rememberData = function (_data) {
          if (_data && !_data.exception) {
            data = _data;
          }
        };

        var onScreamingHalt = function () {
          $('#waiter').dialog('close');
          $('#pulldown, #navbuttons, #spinner').remove();
          dispatcher.post('hideForm');
        };

        dispatcher.on('init', init).on('dataReady', rememberData).on('annotationIsAvailable', annotationIsAvailable).on('messages', displayMessages).on('displaySpanComment', displaySpanComment).on('displayArcComment', displayArcComment).on('displaySentComment', displaySentComment).on('docChanged', onDocChanged).on('hideComment', hideComment).on('showForm', showForm).on('hideForm', hideForm).on('initForm', initForm).on('collectionLoaded', rememberNormDb).on('collectionLoaded', collectionLoaded).on('spanAndAttributeTypesLoaded', spanAndAttributeTypesLoaded).on('isReloadOkay', isReloadOkay).on('current', gotCurrent).on('doneRendering', onDoneRendering).on('startedRendering', onStartedRendering).on('newSourceData', onNewSourceData).on('savedSVG', savedSVGreceived).on('renderError:noFileSpecified', noFileSpecified).on('renderError:annotationFileNotFound', showAnnotationFileNotFound).on('renderError:unableToReadTextFile', showUnableToReadTextFile).on('renderError:isDirectoryError', reloadDirectoryWithSlash).on('unknownError', showUnknownError).on('keydown', onKeyDown).on('mousemove', onMouseMove).on('dblclick', onDblClick).on('click', onSingleClick).on('touchstart', onTouchStart).on('touchend', onTouchEnd).on('resize', onResize).on('searchResultsReceived', searchResultsReceived).on('clearSearch', clearSearch).on('clearSVG', showNoDocMessage).on('screamingHalt', onScreamingHalt).//on('configurationUpdated', updateConfigurationUI).
        on('configurationChanged', configurationChanged);
      };

      return VisualizerUI;
    })(jQuery, window);

// BRAT STANDALONE LIBRARY BEGIN
// Browserify export
    module.exports = VisualizerUI;
// BRAT STANDALONE LIBRARY END

  }, {}], 19: [function (require, module, exports) {
    window.$ = require('./client/lib/node-jquery-1.7.1'); //require('jquery-node-browserify'); // @1.7.2 ++
    LONG_ANNOTATION_CONST = "LongAnnotation";

    window.BratFrontendEditor = function (element, collData, docData, options) {
      if (!(element instanceof Element)) {
        throw new Error('element should be an instance of Element');
      }

      collData = collData || {};
      docData = docData || {};
      options = options || {};

      //DEFAULT OPTIONS
      newOptions = {
        activateEdition: true,
        overWriteModals: false,
        showTooltip: false,
        assetsPath: "assets/brat-client/static/",
        maxFragmentLength: 40,
        showTooltip: true,
        overWriteModals: false,
        webFontURLs: [
          'fonts/Astloch-Bold.ttf',
          'fonts/PT_Sans-Caption-Web-Regular.ttf',
          'fonts/Liberation_Sans-Regular.ttf'
        ],
        ajax: 'local' // 'local', 'external' or 'normal'
      };

      // If option defined, over-write newOptions
      for (var opt in options) {
        if (options.hasOwnProperty(opt)) {
          newOptions[opt] = options[opt];
        }
      }

      this.element = element;
      this.collData = collData;
      this.docData = docData;
      this.options = newOptions;
      this.init();
    };

    BratFrontendEditor.prototype = {
      constructor: BratFrontendEditor,
      init: function () {
        var self = this;
        var html = require('./brat.html');
        self.element.innerHTML = html;
        self.setHtmlImgSrc();

        window.jQuery = $;
        (function ($) {
          // require('./index.css'); //TODO: If possible, include css in min.js (browserify-css)
          require('./client/lib/jquery-ui.min');
          require('./client/lib/jquery.svg.min');
          require('./client/lib/jquery.svgdom.min');
          require('jquery-bbq');
          require('./client/lib/jquery.sprintf');
          require('./client/lib/jquery.json.min');
          //TODO Fix this error
          window.WebFont = require('./client/lib/webfont.js').WebFont; //Uncaught TypeError: Cannot set property 'WebFont' of undefined

          //brat global helpers
          var Config = require('./client/src/configuration');
          window.Configuration = new Config();
          window.Util = require('./client/src/util');

          // brat modules
          window.Dispatcher = require('./client/src/dispatcher');
          window.URLHash = require('./client/src/url_hash'); //TODO Figure out
          window.LocalAjax = require('./client/src/local_ajax');
          window.Ajax = require('./client/src/ajax.js');
          window.Visualizer = require('./client/src/visualizer');
          window.VisualizerUI = require('./client/src/visualizer_ui');
          window.AnnotatorUI = require('./client/src/annotator_ui');
          window.Spinner = require('./client/src/spinner');

          $(document).ready(function () {
            self.dispatcher = new Dispatcher();
            switch (self.options.ajax) {
              case 'local':
                self.ajax = new LocalAjax(self.dispatcher, self.options.maxFragmentLength);
                break;
              case 'normal':
                self.ajax = new Ajax(self.dispatcher);
                break;
              case 'external':
                break;
              default:
                self.ajax = new LocalAjax(self.dispatcher, self.options.maxFragmentLength);
                break;
            }
            var absoluteWebFontsURLS = [
              self.options.assetsPath + self.options.webFontURLs[0],
              self.options.assetsPath + self.options.webFontURLs[1],
              self.options.assetsPath + self.options.webFontURLs[2],
            ];
            self.visualizer = new Visualizer(self.dispatcher, 'svg', absoluteWebFontsURLS);
            self.svg = self.visualizer.svg;
            if (self.options.activateEdition === true) {
              self.visualizerUI = new VisualizerUI(self.dispatcher, self.svg, self.options.showTooltip, self.options.overWriteModals);
              self.annotatorUI = new AnnotatorUI(self.dispatcher, self.svg);
              // self.spinner = new Spinner(self.dispatcher, '#spinner');
            }
            self.dispatcher.post('init');

            if (self.options.maxFragmentLength > 0) {
              self.addLongAnnotationEntityAttribute();
            }

            self.docData.collection = null;
            self.dispatcher.post('collectionLoaded', [self.collData]);
            self.dispatcher.post('requestRenderData', [self.docData]);
            self.dispatcher.post('current', [self.collData, self.docData, {}]);
          });

        })($);
      },
      addLongAnnotationEntityAttribute: function () {
        // Special symbol for splitted long annotations
        this.collData.entity_attribute_types.push({
          "name": LONG_ANNOTATION_CONST,
          "type": LONG_ANNOTATION_CONST,
          "values": {LONG_ANNOTATION_CONST: {"glyph": ""}}
        });
        this.collData.entity_types.forEach(function (type) {
          type.attributes.push(LONG_ANNOTATION_CONST);
        });
      },
      setHtmlImgSrc: function () {
        var spinners = this.element.getElementsByClassName("brat-spinner");
        var magnifiers = this.element.getElementsByClassName("brat-fugue-shadowless-magnifier");
        var externals = this.element.getElementsByClassName("brat-fugue-shadowless-external");

        if (spinners && spinners.length) {
          spinners[0].src = this.options.assetsPath + 'img/spinner.gif';
        }
        if (magnifiers && magnifiers.length) {
          magnifiers[0].src = this.options.assetsPath + 'img/Fugue-shadowless-magnifier.png';
        }
        if (externals && externals.length) {
          externals[0].src = this.options.assetsPath + 'img/Fugue-shadowless-external.png';
        }
      }
    };

  }, {
    "./brat.html": 1,
    "./client/lib/jquery-ui.min": 2,
    "./client/lib/jquery.json.min": 3,
    "./client/lib/jquery.sprintf": 4,
    "./client/lib/jquery.svg.min": 5,
    "./client/lib/jquery.svgdom.min": 6,
    "./client/lib/node-jquery-1.7.1": 7,
    "./client/lib/webfont.js": 8,
    "./client/src/ajax.js": 9,
    "./client/src/annotator_ui": 10,
    "./client/src/configuration": 11,
    "./client/src/dispatcher": 12,
    "./client/src/local_ajax": 13,
    "./client/src/spinner": 14,
    "./client/src/url_hash": 15,
    "./client/src/util": 16,
    "./client/src/visualizer": 17,
    "./client/src/visualizer_ui": 18,
    "jquery-bbq": 20
  }], 20: [function (require, module, exports) {
    /*!
 * jQuery BBQ: Back Button & Query Library - v1.3pre - 8/26/2010
 * http://benalman.com/projects/jquery-bbq-plugin/
 *
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */

// Script: jQuery BBQ: Back Button & Query Library
//
// *Version: 1.3pre, Last updated: 8/26/2010*
//
// Project Home - http://benalman.com/projects/jquery-bbq-plugin/
// GitHub       - http://github.com/cowboy/jquery-bbq/
// Source       - http://github.com/cowboy/jquery-bbq/raw/master/jquery.ba-bbq.js
// (Minified)   - http://github.com/cowboy/jquery-bbq/raw/master/jquery.ba-bbq.min.js (2.2kb gzipped)
//
// About: License
//
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
//
// About: Examples
//
// These working examples, complete with fully commented code, illustrate a few
// ways in which this plugin can be used.
//
// Basic AJAX     - http://benalman.com/code/projects/jquery-bbq/examples/fragment-basic/
// Advanced AJAX  - http://benalman.com/code/projects/jquery-bbq/examples/fragment-advanced/
// jQuery UI Tabs - http://benalman.com/code/projects/jquery-bbq/examples/fragment-jquery-ui-tabs/
// Deparam        - http://benalman.com/code/projects/jquery-bbq/examples/deparam/
//
// About: Support and Testing
//
// Information about what version or versions of jQuery this plugin has been
// tested with, what browsers it has been tested in, and where the unit tests
// reside (so you can test it yourself).
//
// jQuery Versions - 1.2.6, 1.3.2, 1.4.1, 1.4.2
// Browsers Tested - Internet Explorer 6-8, Firefox 2-4, Chrome 5-6, Safari 3.2-5,
//                   Opera 9.6-10.60, iPhone 3.1, Android 1.6-2.2, BlackBerry 4.6-5.
// Unit Tests      - http://benalman.com/code/projects/jquery-bbq/unit/
//
// About: Release History
//
// 1.3pre - (8/26/2010) Integrated <jQuery hashchange event> v1.3, which adds
//         document.title and document.domain support in IE6/7, BlackBerry
//         support, better Iframe hiding for accessibility reasons, and the new
//         <jQuery.fn.hashchange> "shortcut" method. Added the
//         <jQuery.param.sorted> method which reduces the possibility of
//         extraneous hashchange event triggering. Added the
//         <jQuery.param.fragment.ajaxCrawlable> method which can be used to
//         enable Google "AJAX Crawlable mode."
// 1.2.1 - (2/17/2010) Actually fixed the stale window.location Safari bug from
//         <jQuery hashchange event> in BBQ, which was the main reason for the
//         previous release!
// 1.2   - (2/16/2010) Integrated <jQuery hashchange event> v1.2, which fixes a
//         Safari bug, the event can now be bound before DOM ready, and IE6/7
//         page should no longer scroll when the event is first bound. Also
//         added the <jQuery.param.fragment.noEscape> method, and reworked the
//         <hashchange event (BBQ)> internal "add" method to be compatible with
//         changes made to the jQuery 1.4.2 special events API.
// 1.1.1 - (1/22/2010) Integrated <jQuery hashchange event> v1.1, which fixes an
//         obscure IE8 EmulateIE7 meta tag compatibility mode bug.
// 1.1   - (1/9/2010) Broke out the jQuery BBQ event.special <hashchange event>
//         functionality into a separate plugin for users who want just the
//         basic event & back button support, without all the extra awesomeness
//         that BBQ provides. This plugin will be included as part of jQuery BBQ,
//         but also be available separately. See <jQuery hashchange event>
//         plugin for more information. Also added the <jQuery.bbq.removeState>
//         method and added additional <jQuery.deparam> examples.
// 1.0.3 - (12/2/2009) Fixed an issue in IE 6 where location.search and
//         location.hash would report incorrectly if the hash contained the ?
//         character. Also <jQuery.param.querystring> and <jQuery.param.fragment>
//         will no longer parse params out of a URL that doesn't contain ? or #,
//         respectively.
// 1.0.2 - (10/10/2009) Fixed an issue in IE 6/7 where the hidden IFRAME caused
//         a "This page contains both secure and nonsecure items." warning when
//         used on an https:// page.
// 1.0.1 - (10/7/2009) Fixed an issue in IE 8. Since both "IE7" and "IE8
//         Compatibility View" modes erroneously report that the browser
//         supports the native window.onhashchange event, a slightly more
//         robust test needed to be added.
// 1.0   - (10/2/2009) Initial release

    (function ($, window) {
      '$:nomunge'; // Used by YUI compressor.

      // Some convenient shortcuts.
      var undefined,
        aps = Array.prototype.slice,
        decode = decodeURIComponent,

        // Method / object references.
        jq_param = $.param,
        jq_param_sorted,
        jq_param_fragment,
        jq_deparam,
        jq_deparam_fragment,
        jq_bbq = $.bbq = $.bbq || {},
        jq_bbq_pushState,
        jq_bbq_getState,
        jq_elemUrlAttr,
        special = $.event.special,

        // Reused strings.
        str_hashchange = 'hashchange',
        str_querystring = 'querystring',
        str_fragment = 'fragment',
        str_elemUrlAttr = 'elemUrlAttr',
        str_href = 'href',
        str_src = 'src',

        // Reused RegExp.
        re_params_querystring = /^.*\?|#.*$/g,
        re_params_fragment,
        re_fragment,
        re_no_escape,

        ajax_crawlable,
        fragment_prefix,

        // Used by jQuery.elemUrlAttr.
        elemUrlAttr_cache = {};

      // A few commonly used bits, broken out to help reduce minified file size.

      function is_string(arg) {
        return typeof arg === 'string';
      };

      // Why write the same function twice? Let's curry! Mmmm, curry..

      function curry(func) {
        var args = aps.call(arguments, 1);

        return function () {
          return func.apply(this, args.concat(aps.call(arguments)));
        };
      };

      // Get location.hash (or what you'd expect location.hash to be) sans any
      // leading #. Thanks for making this necessary, Firefox!
      function get_fragment(url) {
        return url.replace(re_fragment, '$2');
      };

      // Get location.search (or what you'd expect location.search to be) sans any
      // leading #. Thanks for making this necessary, IE6!
      function get_querystring(url) {
        return url.replace(/(?:^[^?#]*\?([^#]*).*$)?.*/, '$1');
      };

      // Section: Param (to string)
      //
      // Method: jQuery.param.querystring
      //
      // Retrieve the query string from a URL or if no arguments are passed, the
      // current window.location.href.
      //
      // Usage:
      //
      // > jQuery.param.querystring( [ url ] );
      //
      // Arguments:
      //
      //  url - (String) A URL containing query string params to be parsed. If url
      //    is not passed, the current window.location.href is used.
      //
      // Returns:
      //
      //  (String) The parsed query string, with any leading "?" removed.
      //

      // Method: jQuery.param.querystring (build url)
      //
      // Merge a URL, with or without pre-existing query string params, plus any
      // object, params string or URL containing query string params into a new URL.
      //
      // Usage:
      //
      // > jQuery.param.querystring( url, params [, merge_mode ] );
      //
      // Arguments:
      //
      //  url - (String) A valid URL for params to be merged into. This URL may
      //    contain a query string and/or fragment (hash).
      //  params - (String) A params string or URL containing query string params to
      //    be merged into url.
      //  params - (Object) A params object to be merged into url.
      //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
      //    specified, and is as-follows:
      //
      //    * 0: params in the params argument will override any query string
      //         params in url.
      //    * 1: any query string params in url will override params in the params
      //         argument.
      //    * 2: params argument will completely replace any query string in url.
      //
      // Returns:
      //
      //  (String) A URL with a urlencoded query string in the format '?a=b&c=d&e=f'.

      // Method: jQuery.param.fragment
      //
      // Retrieve the fragment (hash) from a URL or if no arguments are passed, the
      // current window.location.href.
      //
      // Usage:
      //
      // > jQuery.param.fragment( [ url ] );
      //
      // Arguments:
      //
      //  url - (String) A URL containing fragment (hash) params to be parsed. If
      //    url is not passed, the current window.location.href is used.
      //
      // Returns:
      //
      //  (String) The parsed fragment (hash) string, with any leading "#" removed.

      // Method: jQuery.param.fragment (build url)
      //
      // Merge a URL, with or without pre-existing fragment (hash) params, plus any
      // object, params string or URL containing fragment (hash) params into a new
      // URL.
      //
      // Usage:
      //
      // > jQuery.param.fragment( url, params [, merge_mode ] );
      //
      // Arguments:
      //
      //  url - (String) A valid URL for params to be merged into. This URL may
      //    contain a query string and/or fragment (hash).
      //  params - (String) A params string or URL containing fragment (hash) params
      //    to be merged into url.
      //  params - (Object) A params object to be merged into url.
      //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
      //    specified, and is as-follows:
      //
      //    * 0: params in the params argument will override any fragment (hash)
      //         params in url.
      //    * 1: any fragment (hash) params in url will override params in the
      //         params argument.
      //    * 2: params argument will completely replace any query string in url.
      //
      // Returns:
      //
      //  (String) A URL with a urlencoded fragment (hash) in the format '#a=b&c=d&e=f'.

      function jq_param_sub(is_fragment, get_func, url, params, merge_mode) {
        var result,
          qs,
          matches,
          url_params,
          hash;

        if (params !== undefined) {
          // Build URL by merging params into url string.

          // matches[1] = url part that precedes params, not including trailing ?/#
          // matches[2] = params, not including leading ?/#
          // matches[3] = if in 'querystring' mode, hash including leading #, otherwise ''
          matches = url.match(is_fragment ? re_fragment : /^([^#?]*)\??([^#]*)(#?.*)/);

          // Get the hash if in 'querystring' mode, and it exists.
          hash = matches[3] || '';

          if (merge_mode === 2 && is_string(params)) {
            // If merge_mode is 2 and params is a string, merge the fragment / query
            // string into the URL wholesale, without converting it into an object.
            qs = params.replace(is_fragment ? re_params_fragment : re_params_querystring, '');

          } else {
            // Convert relevant params in url to object.
            url_params = jq_deparam(matches[2]);

            params = is_string(params)

              // Convert passed params string into object.
              ? jq_deparam[is_fragment ? str_fragment : str_querystring](params)

              // Passed params object.
              : params;

            qs = merge_mode === 2 ? params                              // passed params replace url params
              : merge_mode === 1 ? $.extend({}, params, url_params)  // url params override passed params
                : $.extend({}, url_params, params);                     // passed params override url params

            // Convert params object into a sorted params string.
            qs = jq_param_sorted(qs);

            // Unescape characters specified via $.param.noEscape. Since only hash-
            // history users have requested this feature, it's only enabled for
            // fragment-related params strings.
            if (is_fragment) {
              qs = qs.replace(re_no_escape, decode);
            }
          }

          // Build URL from the base url, querystring and hash. In 'querystring'
          // mode, ? is only added if a query string exists. In 'fragment' mode, #
          // is always added.
          result = matches[1] + (is_fragment ? fragment_prefix : qs || !matches[1] ? '?' : '') + qs + hash;

        } else {
          // If URL was passed in, parse params from URL string, otherwise parse
          // params from window.location.href.
          result = get_func(url !== undefined ? url : location.href);
        }

        return result;
      };

      jq_param[str_querystring] = curry(jq_param_sub, 0, get_querystring);
      jq_param[str_fragment] = jq_param_fragment = curry(jq_param_sub, 1, get_fragment);

      // Method: jQuery.param.sorted
      //
      // Returns a params string equivalent to that returned by the internal
      // jQuery.param method, but sorted, which makes it suitable for use as a
      // cache key.
      //
      // For example, in most browsers jQuery.param({z:1,a:2}) returns "z=1&a=2"
      // and jQuery.param({a:2,z:1}) returns "a=2&z=1". Even though both the
      // objects being serialized and the resulting params strings are equivalent,
      // if these params strings were set into the location.hash fragment
      // sequentially, the hashchange event would be triggered unnecessarily, since
      // the strings are different (even though the data described by them is the
      // same). By sorting the params string, unecessary hashchange event triggering
      // can be avoided.
      //
      // Usage:
      //
      // > jQuery.param.sorted( obj [, traditional ] );
      //
      // Arguments:
      //
      //  obj - (Object) An object to be serialized.
      //  traditional - (Boolean) Params deep/shallow serialization mode. See the
      //    documentation at http://api.jquery.com/jQuery.param/ for more detail.
      //
      // Returns:
      //
      //  (String) A sorted params string.

      jq_param.sorted = jq_param_sorted = function (a, traditional) {
        var arr = [],
          obj = {};

        $.each(jq_param(a, traditional).split('&'), function (i, v) {
          var key = v.replace(/(?:%5B|=).*$/, ''),
            key_obj = obj[key];

          if (!key_obj) {
            key_obj = obj[key] = [];
            arr.push(key);
          }

          key_obj.push(v);
        });

        return $.map(arr.sort(), function (v) {
          return obj[v];
        }).join('&');
      };

      // Method: jQuery.param.fragment.noEscape
      //
      // Specify characters that will be left unescaped when fragments are created
      // or merged using <jQuery.param.fragment>, or when the fragment is modified
      // using <jQuery.bbq.pushState>. This option only applies to serialized data
      // object fragments, and not set-as-string fragments. Does not affect the
      // query string. Defaults to ",/" (comma, forward slash).
      //
      // Note that this is considered a purely aesthetic option, and will help to
      // create URLs that "look pretty" in the address bar or bookmarks, without
      // affecting functionality in any way. That being said, be careful to not
      // unescape characters that are used as delimiters or serve a special
      // purpose, such as the "#?&=+" (octothorpe, question mark, ampersand,
      // equals, plus) characters.
      //
      // Usage:
      //
      // > jQuery.param.fragment.noEscape( [ chars ] );
      //
      // Arguments:
      //
      //  chars - (String) The characters to not escape in the fragment. If
      //    unspecified, defaults to empty string (escape all characters).
      //
      // Returns:
      //
      //  Nothing.

      jq_param_fragment.noEscape = function (chars) {
        chars = chars || '';
        var arr = $.map(chars.split(''), encodeURIComponent);
        re_no_escape = new RegExp(arr.join('|'), 'g');
      };

      // A sensible default. These are the characters people seem to complain about
      // "uglifying up the URL" the most.
      jq_param_fragment.noEscape(',/');

      // Method: jQuery.param.fragment.ajaxCrawlable
      //
      // TODO: DESCRIBE
      //
      // Usage:
      //
      // > jQuery.param.fragment.ajaxCrawlable( [ state ] );
      //
      // Arguments:
      //
      //  state - (Boolean) TODO: DESCRIBE
      //
      // Returns:
      //
      //  (Boolean) The current ajaxCrawlable state.

      jq_param_fragment.ajaxCrawlable = function (state) {
        if (state !== undefined) {
          if (state) {
            re_params_fragment = /^.*(?:#!|#)/;
            re_fragment = /^([^#]*)(?:#!|#)?(.*)$/;
            fragment_prefix = '#!';
          } else {
            re_params_fragment = /^.*#/;
            re_fragment = /^([^#]*)#?(.*)$/;
            fragment_prefix = '#';
          }
          ajax_crawlable = !!state;
        }

        return ajax_crawlable;
      };

      jq_param_fragment.ajaxCrawlable(0);

      // Section: Deparam (from string)
      //
      // Method: jQuery.deparam
      //
      // Deserialize a params string into an object, optionally coercing numbers,
      // booleans, null and undefined values; this method is the counterpart to the
      // internal jQuery.param method.
      //
      // Usage:
      //
      // > jQuery.deparam( params [, coerce ] );
      //
      // Arguments:
      //
      //  params - (String) A params string to be parsed.
      //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and
      //    undefined to their actual value. Defaults to false if omitted.
      //
      // Returns:
      //
      //  (Object) An object representing the deserialized params string.

      $.deparam = jq_deparam = function (params, coerce) {
        var obj = {},
          coerce_types = {'true': !0, 'false': !1, 'null': null};

        // Iterate over all name=value pairs.
        $.each(params.replace(/\+/g, ' ').split('&'), function (j, v) {
          var param = v.split('='),
            key = decode(param[0]),
            val,
            cur = obj,
            i = 0,

            // If key is more complex than 'foo', like 'a[]' or 'a[b][c]', split it
            // into its component parts.
            keys = key.split(']['),
            keys_last = keys.length - 1;

          // If the first keys part contains [ and the last ends with ], then []
          // are correctly balanced.
          if (/\[/.test(keys[0]) && /\]$/.test(keys[keys_last])) {
            // Remove the trailing ] from the last keys part.
            keys[keys_last] = keys[keys_last].replace(/\]$/, '');

            // Split first keys part into two parts on the [ and add them back onto
            // the beginning of the keys array.
            keys = keys.shift().split('[').concat(keys);

            keys_last = keys.length - 1;
          } else {
            // Basic 'foo' style key.
            keys_last = 0;
          }

          // Are we dealing with a name=value pair, or just a name?
          if (param.length === 2) {
            val = decode(param[1]);

            // Coerce values.
            if (coerce) {
              val = val && !isNaN(val) ? +val              // number
                : val === 'undefined' ? undefined         // undefined
                  : coerce_types[val] !== undefined ? coerce_types[val] // true, false, null
                    : val;                                                // string
            }

            if (keys_last) {
              // Complex key, build deep object structure based on a few rules:
              // * The 'cur' pointer starts at the object top-level.
              // * [] = array push (n is set to array length), [n] = array if n is
              //   numeric, otherwise object.
              // * If at the last keys part, set the value.
              // * For each keys part, if the current level is undefined create an
              //   object or array based on the type of the next keys part.
              // * Move the 'cur' pointer to the next level.
              // * Rinse & repeat.
              for (; i <= keys_last; i++) {
                key = keys[i] === '' ? cur.length : keys[i];
                cur = cur[key] = i < keys_last
                  ? cur[key] || (keys[i + 1] && isNaN(keys[i + 1]) ? {} : [])
                  : val;
              }

            } else {
              // Simple key, even simpler rules, since only scalars and shallow
              // arrays are allowed.

              if ($.isArray(obj[key])) {
                // val is already an array, so push on the next value.
                obj[key].push(val);

              } else if (obj[key] !== undefined) {
                // val isn't an array, but since a second value has been specified,
                // convert val into an array.
                obj[key] = [obj[key], val];

              } else {
                // val is a scalar.
                obj[key] = val;
              }
            }

          } else if (key) {
            // No value was defined, so set something meaningful.
            obj[key] = coerce
              ? undefined
              : '';
          }
        });

        return obj;
      };

      // Method: jQuery.deparam.querystring
      //
      // Parse the query string from a URL or the current window.location.href,
      // deserializing it into an object, optionally coercing numbers, booleans,
      // null and undefined values.
      //
      // Usage:
      //
      // > jQuery.deparam.querystring( [ url ] [, coerce ] );
      //
      // Arguments:
      //
      //  url - (String) An optional params string or URL containing query string
      //    params to be parsed. If url is omitted, the current
      //    window.location.href is used.
      //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and
      //    undefined to their actual value. Defaults to false if omitted.
      //
      // Returns:
      //
      //  (Object) An object representing the deserialized params string.

      // Method: jQuery.deparam.fragment
      //
      // Parse the fragment (hash) from a URL or the current window.location.href,
      // deserializing it into an object, optionally coercing numbers, booleans,
      // null and undefined values.
      //
      // Usage:
      //
      // > jQuery.deparam.fragment( [ url ] [, coerce ] );
      //
      // Arguments:
      //
      //  url - (String) An optional params string or URL containing fragment (hash)
      //    params to be parsed. If url is omitted, the current window.location.href
      //    is used.
      //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and
      //    undefined to their actual value. Defaults to false if omitted.
      //
      // Returns:
      //
      //  (Object) An object representing the deserialized params string.

      function jq_deparam_sub(is_fragment, url_or_params, coerce) {
        if (url_or_params === undefined || typeof url_or_params === 'boolean') {
          // url_or_params not specified.
          coerce = url_or_params;
          url_or_params = jq_param[is_fragment ? str_fragment : str_querystring]();
        } else {
          url_or_params = is_string(url_or_params)
            ? url_or_params.replace(is_fragment ? re_params_fragment : re_params_querystring, '')
            : url_or_params;
        }

        return jq_deparam(url_or_params, coerce);
      };

      jq_deparam[str_querystring] = curry(jq_deparam_sub, 0);
      jq_deparam[str_fragment] = jq_deparam_fragment = curry(jq_deparam_sub, 1);

      // Section: Element manipulation
      //
      // Method: jQuery.elemUrlAttr
      //
      // Get the internal "Default URL attribute per tag" list, or augment the list
      // with additional tag-attribute pairs, in case the defaults are insufficient.
      //
      // In the <jQuery.fn.querystring> and <jQuery.fn.fragment> methods, this list
      // is used to determine which attribute contains the URL to be modified, if
      // an "attr" param is not specified.
      //
      // Default Tag-Attribute List:
      //
      //  a      - href
      //  base   - href
      //  iframe - src
      //  img    - src
      //  input  - src
      //  form   - action
      //  link   - href
      //  script - src
      //
      // Usage:
      //
      // > jQuery.elemUrlAttr( [ tag_attr ] );
      //
      // Arguments:
      //
      //  tag_attr - (Object) An object containing a list of tag names and their
      //    associated default attribute names in the format { tag: 'attr', ... } to
      //    be merged into the internal tag-attribute list.
      //
      // Returns:
      //
      //  (Object) An object containing all stored tag-attribute values.

      // Only define function and set defaults if function doesn't already exist, as
      // the urlInternal plugin will provide this method as well.
      $[str_elemUrlAttr] || ($[str_elemUrlAttr] = function (obj) {
        return $.extend(elemUrlAttr_cache, obj);
      })({
        a: str_href,
        base: str_href,
        iframe: str_src,
        img: str_src,
        input: str_src,
        form: 'action',
        link: str_href,
        script: str_src
      });

      jq_elemUrlAttr = $[str_elemUrlAttr];

      // Method: jQuery.fn.querystring
      //
      // Update URL attribute in one or more elements, merging the current URL (with
      // or without pre-existing query string params) plus any params object or
      // string into a new URL, which is then set into that attribute. Like
      // <jQuery.param.querystring (build url)>, but for all elements in a jQuery
      // collection.
      //
      // Usage:
      //
      // > jQuery('selector').querystring( [ attr, ] params [, merge_mode ] );
      //
      // Arguments:
      //
      //  attr - (String) Optional name of an attribute that will contain a URL to
      //    merge params or url into. See <jQuery.elemUrlAttr> for a list of default
      //    attributes.
      //  params - (Object) A params object to be merged into the URL attribute.
      //  params - (String) A URL containing query string params, or params string
      //    to be merged into the URL attribute.
      //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
      //    specified, and is as-follows:
      //
      //    * 0: params in the params argument will override any params in attr URL.
      //    * 1: any params in attr URL will override params in the params argument.
      //    * 2: params argument will completely replace any query string in attr
      //         URL.
      //
      // Returns:
      //
      //  (jQuery) The initial jQuery collection of elements, but with modified URL
      //  attribute values.

      // Method: jQuery.fn.fragment
      //
      // Update URL attribute in one or more elements, merging the current URL (with
      // or without pre-existing fragment/hash params) plus any params object or
      // string into a new URL, which is then set into that attribute. Like
      // <jQuery.param.fragment (build url)>, but for all elements in a jQuery
      // collection.
      //
      // Usage:
      //
      // > jQuery('selector').fragment( [ attr, ] params [, merge_mode ] );
      //
      // Arguments:
      //
      //  attr - (String) Optional name of an attribute that will contain a URL to
      //    merge params into. See <jQuery.elemUrlAttr> for a list of default
      //    attributes.
      //  params - (Object) A params object to be merged into the URL attribute.
      //  params - (String) A URL containing fragment (hash) params, or params
      //    string to be merged into the URL attribute.
      //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
      //    specified, and is as-follows:
      //
      //    * 0: params in the params argument will override any params in attr URL.
      //    * 1: any params in attr URL will override params in the params argument.
      //    * 2: params argument will completely replace any fragment (hash) in attr
      //         URL.
      //
      // Returns:
      //
      //  (jQuery) The initial jQuery collection of elements, but with modified URL
      //  attribute values.

      function jq_fn_sub(mode, force_attr, params, merge_mode) {
        if (!is_string(params) && typeof params !== 'object') {
          // force_attr not specified.
          merge_mode = params;
          params = force_attr;
          force_attr = undefined;
        }

        return this.each(function () {
          var that = $(this),

            // Get attribute specified, or default specified via $.elemUrlAttr.
            attr = force_attr || jq_elemUrlAttr()[(this.nodeName || '').toLowerCase()] || '',

            // Get URL value.
            url = attr && that.attr(attr) || '';

          // Update attribute with new URL.
          that.attr(attr, jq_param[mode](url, params, merge_mode));
        });

      };

      $.fn[str_querystring] = curry(jq_fn_sub, str_querystring);
      $.fn[str_fragment] = curry(jq_fn_sub, str_fragment);

      // Section: History, hashchange event
      //
      // Method: jQuery.bbq.pushState
      //
      // Adds a 'state' into the browser history at the current position, setting
      // location.hash and triggering any bound <hashchange event> callbacks
      // (provided the new state is different than the previous state).
      //
      // If no arguments are passed, an empty state is created, which is just a
      // shortcut for jQuery.bbq.pushState( {}, 2 ).
      //
      // Usage:
      //
      // > jQuery.bbq.pushState( [ params [, merge_mode ] ] );
      //
      // Arguments:
      //
      //  params - (String) A serialized params string or a hash string beginning
      //    with # to merge into location.hash.
      //  params - (Object) A params object to merge into location.hash.
      //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
      //    specified (unless a hash string beginning with # is specified, in which
      //    case merge behavior defaults to 2), and is as-follows:
      //
      //    * 0: params in the params argument will override any params in the
      //         current state.
      //    * 1: any params in the current state will override params in the params
      //         argument.
      //    * 2: params argument will completely replace current state.
      //
      // Returns:
      //
      //  Nothing.
      //
      // Additional Notes:
      //
      //  * Setting an empty state may cause the browser to scroll.
      //  * Unlike the fragment and querystring methods, if a hash string beginning
      //    with # is specified as the params agrument, merge_mode defaults to 2.

      jq_bbq.pushState = jq_bbq_pushState = function (params, merge_mode) {
        if (is_string(params) && /^#/.test(params) && merge_mode === undefined) {
          // Params string begins with # and merge_mode not specified, so completely
          // overwrite window.location.hash.
          merge_mode = 2;
        }

        var has_args = params !== undefined,
          // Merge params into window.location using $.param.fragment.
          url = jq_param_fragment(location.href,
            has_args ? params : {}, has_args ? merge_mode : 2);

        // Set new window.location.href. Note that Safari 3 & Chrome barf on
        // location.hash = '#' so the entire URL is set.
        location.href = url;
      };

      // Method: jQuery.bbq.getState
      //
      // Retrieves the current 'state' from the browser history, parsing
      // location.hash for a specific key or returning an object containing the
      // entire state, optionally coercing numbers, booleans, null and undefined
      // values.
      //
      // Usage:
      //
      // > jQuery.bbq.getState( [ key ] [, coerce ] );
      //
      // Arguments:
      //
      //  key - (String) An optional state key for which to return a value.
      //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and
      //    undefined to their actual value. Defaults to false.
      //
      // Returns:
      //
      //  (Anything) If key is passed, returns the value corresponding with that key
      //    in the location.hash 'state', or undefined. If not, an object
      //    representing the entire 'state' is returned.

      jq_bbq.getState = jq_bbq_getState = function (key, coerce) {
        return key === undefined || typeof key === 'boolean'
          ? jq_deparam_fragment(key) // 'key' really means 'coerce' here
          : jq_deparam_fragment(coerce)[key];
      };

      // Method: jQuery.bbq.removeState
      //
      // Remove one or more keys from the current browser history 'state', creating
      // a new state, setting location.hash and triggering any bound
      // <hashchange event> callbacks (provided the new state is different than
      // the previous state).
      //
      // If no arguments are passed, an empty state is created, which is just a
      // shortcut for jQuery.bbq.pushState( {}, 2 ).
      //
      // Usage:
      //
      // > jQuery.bbq.removeState( [ key [, key ... ] ] );
      //
      // Arguments:
      //
      //  key - (String) One or more key values to remove from the current state,
      //    passed as individual arguments.
      //  key - (Array) A single array argument that contains a list of key values
      //    to remove from the current state.
      //
      // Returns:
      //
      //  Nothing.
      //
      // Additional Notes:
      //
      //  * Setting an empty state may cause the browser to scroll.

      jq_bbq.removeState = function (arr) {
        var state = {};

        // If one or more arguments is passed..
        if (arr !== undefined) {

          // Get the current state.
          state = jq_bbq_getState();

          // For each passed key, delete the corresponding property from the current
          // state.
          $.each($.isArray(arr) ? arr : arguments, function (i, v) {
            delete state[v];
          });
        }

        // Set the state, completely overriding any existing state.
        jq_bbq_pushState(state, 2);
      };

      // Event: hashchange event (BBQ)
      //
      // Usage in jQuery 1.4 and newer:
      //
      // In jQuery 1.4 and newer, the event object passed into any hashchange event
      // callback is augmented with a copy of the location.hash fragment at the time
      // the event was triggered as its event.fragment property. In addition, the
      // event.getState method operates on this property (instead of location.hash)
      // which allows this fragment-as-a-state to be referenced later, even after
      // window.location may have changed.
      //
      // Note that event.fragment and event.getState are not defined according to
      // W3C (or any other) specification, but will still be available whether or
      // not the hashchange event exists natively in the browser, because of the
      // utility they provide.
      //
      // The event.fragment property contains the output of <jQuery.param.fragment>
      // and the event.getState method is equivalent to the <jQuery.bbq.getState>
      // method.
      //
      // > $(window).bind( 'hashchange', function( event ) {
      // >   var hash_str = event.fragment,
      // >     param_obj = event.getState(),
      // >     param_val = event.getState( 'param_name' ),
      // >     param_val_coerced = event.getState( 'param_name', true );
      // >   ...
      // > });
      //
      // Usage in jQuery 1.3.2:
      //
      // In jQuery 1.3.2, the event object cannot to be augmented as in jQuery 1.4+,
      // so the fragment state isn't bound to the event object and must instead be
      // parsed using the <jQuery.param.fragment> and <jQuery.bbq.getState> methods.
      //
      // > $(window).bind( 'hashchange', function( event ) {
      // >   var hash_str = $.param.fragment(),
      // >     param_obj = $.bbq.getState(),
      // >     param_val = $.bbq.getState( 'param_name' ),
      // >     param_val_coerced = $.bbq.getState( 'param_name', true );
      // >   ...
      // > });
      //
      // Additional Notes:
      //
      // * Due to changes in the special events API, jQuery BBQ v1.2 or newer is
      //   required to enable the augmented event object in jQuery 1.4.2 and newer.
      // * See <jQuery hashchange event> for more detailed information.

      special[str_hashchange] = $.extend(special[str_hashchange], {

        // Augmenting the event object with the .fragment property and .getState
        // method requires jQuery 1.4 or newer. Note: with 1.3.2, everything will
        // work, but the event won't be augmented)
        add: function (handleObj) {
          var old_handler;

          function new_handler(e) {
            // e.fragment is set to the value of location.hash (with any leading #
            // removed) at the time the event is triggered.
            var hash = e[str_fragment] = jq_param_fragment();

            // e.getState() works just like $.bbq.getState(), but uses the
            // e.fragment property stored on the event object.
            e.getState = function (key, coerce) {
              return key === undefined || typeof key === 'boolean'
                ? jq_deparam(hash, key) // 'key' really means 'coerce' here
                : jq_deparam(hash, coerce)[key];
            };

            old_handler.apply(this, arguments);
          };

          // This may seem a little complicated, but it normalizes the special event
          // .add method between jQuery 1.4/1.4.1 and 1.4.2+
          if ($.isFunction(handleObj)) {
            // 1.4, 1.4.1
            old_handler = handleObj;
            return new_handler;
          } else {
            // 1.4.2+
            old_handler = handleObj.handler;
            handleObj.handler = new_handler;
          }
        }

      });

    })(jQuery, this);

    /*!
 * jQuery hashchange event - v1.3 - 7/21/2010
 * http://benalman.com/projects/jquery-hashchange-plugin/
 *
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */

// Script: jQuery hashchange event
//
// *Version: 1.3, Last updated: 7/21/2010*
//
// Project Home - http://benalman.com/projects/jquery-hashchange-plugin/
// GitHub       - http://github.com/cowboy/jquery-hashchange/
// Source       - http://github.com/cowboy/jquery-hashchange/raw/master/jquery.ba-hashchange.js
// (Minified)   - http://github.com/cowboy/jquery-hashchange/raw/master/jquery.ba-hashchange.min.js (0.8kb gzipped)
//
// About: License
//
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
//
// About: Examples
//
// These working examples, complete with fully commented code, illustrate a few
// ways in which this plugin can be used.
//
// hashchange event - http://benalman.com/code/projects/jquery-hashchange/examples/hashchange/
// document.domain - http://benalman.com/code/projects/jquery-hashchange/examples/document_domain/
//
// About: Support and Testing
//
// Information about what version or versions of jQuery this plugin has been
// tested with, what browsers it has been tested in, and where the unit tests
// reside (so you can test it yourself).
//
// jQuery Versions - 1.2.6, 1.3.2, 1.4.1, 1.4.2
// Browsers Tested - Internet Explorer 6-8, Firefox 2-4, Chrome 5-6, Safari 3.2-5,
//                   Opera 9.6-10.60, iPhone 3.1, Android 1.6-2.2, BlackBerry 4.6-5.
// Unit Tests      - http://benalman.com/code/projects/jquery-hashchange/unit/
//
// About: Known issues
//
// While this jQuery hashchange event implementation is quite stable and
// robust, there are a few unfortunate browser bugs surrounding expected
// hashchange event-based behaviors, independent of any JavaScript
// window.onhashchange abstraction. See the following examples for more
// information:
//
// Chrome: Back Button - http://benalman.com/code/projects/jquery-hashchange/examples/bug-chrome-back-button/
// Firefox: Remote XMLHttpRequest - http://benalman.com/code/projects/jquery-hashchange/examples/bug-firefox-remote-xhr/
// WebKit: Back Button in an Iframe - http://benalman.com/code/projects/jquery-hashchange/examples/bug-webkit-hash-iframe/
// Safari: Back Button from a different domain - http://benalman.com/code/projects/jquery-hashchange/examples/bug-safari-back-from-diff-domain/
//
// Also note that should a browser natively support the window.onhashchange
// event, but not report that it does, the fallback polling loop will be used.
//
// About: Release History
//
// 1.3   - (7/21/2010) Reorganized IE6/7 Iframe code to make it more
//         "removable" for mobile-only development. Added IE6/7 document.title
//         support. Attempted to make Iframe as hidden as possible by using
//         techniques from http://www.paciellogroup.com/blog/?p=604. Added
//         support for the "shortcut" format $(window).hashchange( fn ) and
//         $(window).hashchange() like jQuery provides for built-in events.
//         Renamed jQuery.hashchangeDelay to <jQuery.fn.hashchange.delay> and
//         lowered its default value to 50. Added <jQuery.fn.hashchange.domain>
//         and <jQuery.fn.hashchange.src> properties plus document-domain.html
//         file to address access denied issues when setting document.domain in
//         IE6/7.
// 1.2   - (2/11/2010) Fixed a bug where coming back to a page using this plugin
//         from a page on another domain would cause an error in Safari 4. Also,
//         IE6/7 Iframe is now inserted after the body (this actually works),
//         which prevents the page from scrolling when the event is first bound.
//         Event can also now be bound before DOM ready, but it won't be usable
//         before then in IE6/7.
// 1.1   - (1/21/2010) Incorporated document.documentMode test to fix IE8 bug
//         where browser version is incorrectly reported as 8.0, despite
//         inclusion of the X-UA-Compatible IE=EmulateIE7 meta tag.
// 1.0   - (1/9/2010) Initial Release. Broke out the jQuery BBQ event.special
//         window.onhashchange functionality into a separate plugin for users
//         who want just the basic event & back button support, without all the
//         extra awesomeness that BBQ provides. This plugin will be included as
//         part of jQuery BBQ, but also be available separately.

    (function ($, window, undefined) {
      '$:nomunge'; // Used by YUI compressor.

      // Reused string.
      var str_hashchange = 'hashchange',

        // Method / object references.
        doc = document,
        fake_onhashchange,
        special = $.event.special,

        // Does the browser support window.onhashchange? Note that IE8 running in
        // IE7 compatibility mode reports true for 'onhashchange' in window, even
        // though the event isn't supported, so also test document.documentMode.
        doc_mode = doc.documentMode,
        supports_onhashchange = 'on' + str_hashchange in window && (doc_mode === undefined || doc_mode > 7);

      // Get location.hash (or what you'd expect location.hash to be) sans any
      // leading #. Thanks for making this necessary, Firefox!
      function get_fragment(url) {
        url = url || location.href;
        return '#' + url.replace(/^[^#]*#?(.*)$/, '$1');
      };

      // Method: jQuery.fn.hashchange
      //
      // Bind a handler to the window.onhashchange event or trigger all bound
      // window.onhashchange event handlers. This behavior is consistent with
      // jQuery's built-in event handlers.
      //
      // Usage:
      //
      // > jQuery(window).hashchange( [ handler ] );
      //
      // Arguments:
      //
      //  handler - (Function) Optional handler to be bound to the hashchange
      //    event. This is a "shortcut" for the more verbose form:
      //    jQuery(window).bind( 'hashchange', handler ). If handler is omitted,
      //    all bound window.onhashchange event handlers will be triggered. This
      //    is a shortcut for the more verbose
      //    jQuery(window).trigger( 'hashchange' ). These forms are described in
      //    the <hashchange event> section.
      //
      // Returns:
      //
      //  (jQuery) The initial jQuery collection of elements.

      // Allow the "shortcut" format $(elem).hashchange( fn ) for binding and
      // $(elem).hashchange() for triggering, like jQuery does for built-in events.
      $.fn[str_hashchange] = function (fn) {
        return fn ? this.bind(str_hashchange, fn) : this.trigger(str_hashchange);
      };

      // Property: jQuery.fn.hashchange.delay
      //
      // The numeric interval (in milliseconds) at which the <hashchange event>
      // polling loop executes. Defaults to 50.

      // Property: jQuery.fn.hashchange.domain
      //
      // If you're setting document.domain in your JavaScript, and you want hash
      // history to work in IE6/7, not only must this property be set, but you must
      // also set document.domain BEFORE jQuery is loaded into the page. This
      // property is only applicable if you are supporting IE6/7 (or IE8 operating
      // in "IE7 compatibility" mode).
      //
      // In addition, the <jQuery.fn.hashchange.src> property must be set to the
      // path of the included "document-domain.html" file, which can be renamed or
      // modified if necessary (note that the document.domain specified must be the
      // same in both your main JavaScript as well as in this file).
      //
      // Usage:
      //
      // jQuery.fn.hashchange.domain = document.domain;

      // Property: jQuery.fn.hashchange.src
      //
      // If, for some reason, you need to specify an Iframe src file (for example,
      // when setting document.domain as in <jQuery.fn.hashchange.domain>), you can
      // do so using this property. Note that when using this property, history
      // won't be recorded in IE6/7 until the Iframe src file loads. This property
      // is only applicable if you are supporting IE6/7 (or IE8 operating in "IE7
      // compatibility" mode).
      //
      // Usage:
      //
      // jQuery.fn.hashchange.src = 'path/to/file.html';

      $.fn[str_hashchange].delay = 50;
      /*
  $.fn[ str_hashchange ].domain = null;
  $.fn[ str_hashchange ].src = null;
  */

      // Event: hashchange event
      //
      // Fired when location.hash changes. In browsers that support it, the native
      // HTML5 window.onhashchange event is used, otherwise a polling loop is
      // initialized, running every <jQuery.fn.hashchange.delay> milliseconds to
      // see if the hash has changed. In IE6/7 (and IE8 operating in "IE7
      // compatibility" mode), a hidden Iframe is created to allow the back button
      // and hash-based history to work.
      //
      // Usage as described in <jQuery.fn.hashchange>:
      //
      // > // Bind an event handler.
      // > jQuery(window).hashchange( function(e) {
      // >   var hash = location.hash;
      // >   ...
      // > });
      // >
      // > // Manually trigger the event handler.
      // > jQuery(window).hashchange();
      //
      // A more verbose usage that allows for event namespacing:
      //
      // > // Bind an event handler.
      // > jQuery(window).bind( 'hashchange', function(e) {
      // >   var hash = location.hash;
      // >   ...
      // > });
      // >
      // > // Manually trigger the event handler.
      // > jQuery(window).trigger( 'hashchange' );
      //
      // Additional Notes:
      //
      // * The polling loop and Iframe are not created until at least one handler
      //   is actually bound to the 'hashchange' event.
      // * If you need the bound handler(s) to execute immediately, in cases where
      //   a location.hash exists on page load, via bookmark or page refresh for
      //   example, use jQuery(window).hashchange() or the more verbose
      //   jQuery(window).trigger( 'hashchange' ).
      // * The event can be bound before DOM ready, but since it won't be usable
      //   before then in IE6/7 (due to the necessary Iframe), recommended usage is
      //   to bind it inside a DOM ready handler.

      // Override existing $.event.special.hashchange methods (allowing this plugin
      // to be defined after jQuery BBQ in BBQ's source code).
      special[str_hashchange] = $.extend(special[str_hashchange], {

        // Called only when the first 'hashchange' event is bound to window.
        setup: function () {
          // If window.onhashchange is supported natively, there's nothing to do..
          if (supports_onhashchange) {
            return false;
          }

          // Otherwise, we need to create our own. And we don't want to call this
          // until the user binds to the event, just in case they never do, since it
          // will create a polling loop and possibly even a hidden Iframe.
          $(fake_onhashchange.start);
        },

        // Called only when the last 'hashchange' event is unbound from window.
        teardown: function () {
          // If window.onhashchange is supported natively, there's nothing to do..
          if (supports_onhashchange) {
            return false;
          }

          // Otherwise, we need to stop ours (if possible).
          $(fake_onhashchange.stop);
        }

      });

      // fake_onhashchange does all the work of triggering the window.onhashchange
      // event for browsers that don't natively support it, including creating a
      // polling loop to watch for hash changes and in IE 6/7 creating a hidden
      // Iframe to enable back and forward.
      fake_onhashchange = (function () {
        var self = {},
          timeout_id,

          // Remember the initial hash so it doesn't get triggered immediately.
          last_hash = get_fragment(),

          fn_retval = function (val) {
            return val;
          },
          history_set = fn_retval,
          history_get = fn_retval;

        // Start the polling loop.
        self.start = function () {
          timeout_id || poll();
        };

        // Stop the polling loop.
        self.stop = function () {
          timeout_id && clearTimeout(timeout_id);
          timeout_id = undefined;
        };

        // This polling loop checks every $.fn.hashchange.delay milliseconds to see
        // if location.hash has changed, and triggers the 'hashchange' event on
        // window when necessary.
        function poll() {
          var hash = get_fragment(),
            history_hash = history_get(last_hash);

          if (hash !== last_hash) {
            history_set(last_hash = hash, history_hash);

            $(window).trigger(str_hashchange);

          } else if (history_hash !== last_hash) {
            location.href = location.href.replace(/#.*/, '') + history_hash;
          }

          timeout_id = setTimeout(poll, $.fn[str_hashchange].delay);
        };

        // vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
        // vvvvvvvvvvvvvvvvvvv REMOVE IF NOT SUPPORTING IE6/7/8 vvvvvvvvvvvvvvvvvvv
        // vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
        (/msie|trident/i).test(navigator.userAgent) && !supports_onhashchange && (function () {
          // Not only do IE6/7 need the "magical" Iframe treatment, but so does IE8
          // when running in "IE7 compatibility" mode.

          var iframe,
            iframe_src;

          // When the event is bound and polling starts in IE 6/7, create a hidden
          // Iframe for history handling.
          self.start = function () {
            if (!iframe) {
              iframe_src = $.fn[str_hashchange].src;
              iframe_src = iframe_src && iframe_src + get_fragment();

              // Create hidden Iframe. Attempt to make Iframe as hidden as possible
              // by using techniques from http://www.paciellogroup.com/blog/?p=604.
              iframe = $('<iframe tabindex="-1" title="empty"/>').hide()

              // When Iframe has completely loaded, initialize the history and
              // start polling.
                .one('load', function () {
                  iframe_src || history_set(get_fragment());
                  poll();
                })

                // Load Iframe src if specified, otherwise nothing.
                .attr('src', iframe_src || 'javascript:0')

                // Append Iframe after the end of the body to prevent unnecessary
                // initial page scrolling (yes, this works).
                .insertAfter('body')[0].contentWindow;

              // Whenever `document.title` changes, update the Iframe's title to
              // prettify the back/next history menu entries. Since IE sometimes
              // errors with "Unspecified error" the very first time this is set
              // (yes, very useful) wrap this with a try/catch block.
              doc.onpropertychange = function () {
                try {
                  if (event.propertyName === 'title') {
                    iframe.document.title = doc.title;
                  }
                } catch (e) {
                }
              };

            }
          };

          // Override the "stop" method since an IE6/7 Iframe was created. Even
          // if there are no longer any bound event handlers, the polling loop
          // is still necessary for back/next to work at all!
          self.stop = fn_retval;

          // Get history by looking at the hidden Iframe's location.hash.
          history_get = function () {
            return get_fragment(iframe.location.href);
          };

          // Set a new history item by opening and then closing the Iframe
          // document, *then* setting its location.hash. If document.domain has
          // been set, update that as well.
          history_set = function (hash, history_hash) {
            var iframe_doc = iframe.document,
              domain = $.fn[str_hashchange].domain;

            if (hash !== history_hash) {
              // Update Iframe with any initial `document.title` that might be set.
              iframe_doc.title = doc.title;

              // Opening the Iframe's document after it has been closed is what
              // actually adds a history entry.
              iframe_doc.open();

              // Set document.domain for the Iframe document as well, if necessary.
              domain && iframe_doc.write('<script>document.domain="' + domain + '"</script>');

              iframe_doc.close();

              // Update the Iframe's hash, for great justice.
              iframe.location.hash = hash;
            }
          };

        })();
        // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // ^^^^^^^^^^^^^^^^^^^ REMOVE IF NOT SUPPORTING IE6/7/8 ^^^^^^^^^^^^^^^^^^^
        // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        return self;
      })();

    })(jQuery, this);

  }, {}]
}, {}, [19])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJicmF0Lmh0bWwiLCJjbGllbnQvbGliL2pxdWVyeS11aS5taW4uanMiLCJjbGllbnQvbGliL2pxdWVyeS5qc29uLm1pbi5qcyIsImNsaWVudC9saWIvanF1ZXJ5LnNwcmludGYuanMiLCJjbGllbnQvbGliL2pxdWVyeS5zdmcubWluLmpzIiwiY2xpZW50L2xpYi9qcXVlcnkuc3ZnZG9tLm1pbi5qcyIsImNsaWVudC9saWIvbm9kZS1qcXVlcnktMS43LjEuanMiLCJjbGllbnQvbGliL3dlYmZvbnQuanMiLCJjbGllbnQvc3JjL2FqYXguanMiLCJjbGllbnQvc3JjL2Fubm90YXRvcl91aS5qcyIsImNsaWVudC9zcmMvY29uZmlndXJhdGlvbi5qcyIsImNsaWVudC9zcmMvZGlzcGF0Y2hlci5qcyIsImNsaWVudC9zcmMvbG9jYWxfYWpheC5qcyIsImNsaWVudC9zcmMvc3Bpbm5lci5qcyIsImNsaWVudC9zcmMvdXJsX2hhc2guanMiLCJjbGllbnQvc3JjL3V0aWwuanMiLCJjbGllbnQvc3JjL3Zpc3VhbGl6ZXIuanMiLCJjbGllbnQvc3JjL3Zpc3VhbGl6ZXJfdWkuanMiLCJpbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qcXVlcnktYmJxL2pxdWVyeS5iYS1iYnEuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdHhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFrU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2htRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2h2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgaWQ9XFxcImJyYXQtZnJvbnRlbmQtZWRpdG9yXFxcIj5cXHJcXG4gICAgPGRpdiBpZD1cXFwiY29tbWVudHBvcHVwXFxcIj48L2Rpdj5cXHJcXG4gICAgPGRpdiBpZD1cXFwic3ZnXFxcIj48L2Rpdj5cXHJcXG5cXHJcXG4gICAgPCEtLSBTcGFuIGRpYWxvZyAodmlldytlZGl0KSAtLT5cXHJcXG4gICAgPGZvcm0gaWQ9XFxcInNwYW5fZm9ybVxcXCIgY2xhc3M9XFxcImRpYWxvZ1xcXCIgdGl0bGU9XFxcIlNwYW5cXFwiPlxcclxcbiAgICAgICAgPCEtLSBTcGFuIGRpYWxvZyBhbm5vdGF0ZWQgdGV4dCAtLT5cXHJcXG4gICAgICAgIDxmaWVsZHNldCBpZD1cXFwic3Bhbl9zZWxlY3RlZF9mc2V0XFxcIj5cXHJcXG4gICAgICAgICAgICA8bGVnZW5kPlRleHQ8L2xlZ2VuZD5cXHJcXG4gICAgICAgICAgICA8YSB0YXJnZXQ9XFxcImJyYXRfbGlua2VkXFxcIiBpZD1cXFwic3Bhbl9oaWdobGlnaHRfbGlua1xcXCIgaHJlZj1cXFwiI1xcXCI+TGluazwvYT5cXHJcXG4gICAgICAgICAgICA8ZGl2IGlkPVxcXCJzcGFuX3NlbGVjdGVkXFxcIi8+XFxyXFxuICAgICAgICA8L2ZpZWxkc2V0PlxcclxcbiAgICAgICAgPCEtLSBTcGFuIGRpYWxvZyBzZWFyY2ggbGlua3MgLS0+XFxyXFxuICAgICAgICA8ZmllbGRzZXQgaWQ9XFxcInNwYW5fc2VhcmNoX2ZpZWxkc2V0XFxcIj5cXHJcXG4gICAgICAgICAgICA8bGVnZW5kPlNlYXJjaDwvbGVnZW5kPlxcclxcbiAgICAgICAgICAgIDxkaXYgaWQ9XFxcInNwYW5fc2VhcmNoX2xpbmtzXFxcIi8+XFxyXFxuICAgICAgICA8L2ZpZWxkc2V0PlxcclxcbiAgICAgICAgPCEtLSBTcGFuIGRpYWxvZyB0eXBlIHNlbGVjdG9yIC0tPlxcclxcbiAgICAgICAgPGZpZWxkc2V0PlxcclxcbiAgICAgICAgICAgIDxkaXYgaWQ9XFxcImVudGl0eV9hbmRfZXZlbnRfd3JhcHBlclxcXCIgY2xhc3M9XFxcInNwbGl0X3dyYXBwZXJcXFwiPlxcclxcbiAgICAgICAgICAgICAgICA8ZGl2IGlkPVxcXCJzcGFuX2VudGl0eV9zZWN0aW9uXFxcIiBjbGFzcz1cXFwid3JhcHBlcl9oYWxmX2xlZnRcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cXFwiZW50aXR5X2xhYmVsXFxcIiBjbGFzcz1cXFwibGFiZWwtbGlrZVxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgRW50aXR5IHR5cGVcXHJcXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cXFwiZW50aXR5X3R5cGVzXFxcIiBjbGFzcz1cXFwic2Nyb2xsX3dyYXBwZXJfdXBwZXJcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInNjcm9sbGVyXFxcIj48L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgICAgICAgICAgPCEtLSBOT1RFOiB0aGUgYXR0cmlidXRlIGxhYmVscyBtdXN0IGJlICpvdXRzaWRlKiBvZiB0aGVcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgZGl2cyB0aGV5IGxvZ2ljYWxseSBiZWxvbmcgdG8gcHJldmVudCBzY3JvbGxlcnNcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3dpbmcgdGhlbS4gLS0+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPVxcXCJlbnRpdHlfYXR0cmlidXRlX2xhYmVsXFxcIiBjbGFzcz1cXFwibGFiZWwtbGlrZSB3cmFwcGVyX2xvd2VyX2xhYmVsXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBFbnRpdHkgYXR0cmlidXRlc1xcclxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPVxcXCJlbnRpdHlfYXR0cmlidXRlc1xcXCIgY2xhc3M9XFxcInNjcm9sbF93cmFwcGVyX2xvd2VyXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzY3JvbGxlciBzbWFsbC1idXR0b25zXFxcIj48L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgPGRpdiBpZD1cXFwic3Bhbl9ldmVudF9zZWN0aW9uXFxcIiBjbGFzcz1cXFwid3JhcHBlcl9oYWxmX3JpZ2h0XFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XFxcImV2ZW50X2xhYmVsXFxcIiBjbGFzcz1cXFwibGFiZWwtbGlrZVxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgRXZlbnQgdHlwZVxcclxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPVxcXCJldmVudF90eXBlc1xcXCIgY2xhc3M9XFxcInNjcm9sbF93cmFwcGVyX3VwcGVyXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzY3JvbGxlclxcXCI+PC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XFxcImV2ZW50X2F0dHJpYnV0ZV9sYWJlbFxcXCIgY2xhc3M9XFxcIndyYXBwZXJfbG93ZXJfbGFiZWwgbGFiZWwtbGlrZVxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgRXZlbnQgYXR0cmlidXRlc1xcclxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPVxcXCJldmVudF9hdHRyaWJ1dGVzXFxcIiBjbGFzcz1cXFwic2Nyb2xsX3dyYXBwZXJfbG93ZXJcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInNjcm9sbGVyIHNtYWxsLWJ1dHRvbnNcXFwiPjwvZGl2PlxcclxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPC9maWVsZHNldD5cXHJcXG4gICAgICAgIDwhLS0gU3BhbiBkaWFsb2cgbm9ybWFsaXphdGlvbiAtLT5cXHJcXG4gICAgICAgIDxmaWVsZHNldCBpZD1cXFwibm9ybV9maWVsZHNldFxcXCI+XFxyXFxuICAgICAgICAgICAgPGxlZ2VuZD5Ob3JtYWxpemF0aW9uPC9sZWdlbmQ+XFxyXFxuICAgICAgICAgICAgPGRpdiBpZD1cXFwibm9ybV9jb250YWluZXJcXFwiPlxcclxcbiAgICAgICAgICAgICAgICA8c2VsZWN0IGlkPVxcXCJzcGFuX25vcm1fZGJcXFwiLz5cXHJcXG4gICAgICAgICAgICAgICAgPGEgaWQ9XFxcInNwYW5fbm9ybV9kYl9saW5rXFxcIiB0YXJnZXQ9XFxcImJyYXRfbGlua2VkXFxcIiBocmVmPVxcXCIjXFxcIiB0aXRsZT1cXFwiU2VhcmNoIERCXFxcIj48aW1nIGNsYXNzPVxcXCJicmF0LWZ1Z3VlLXNoYWRvd2xlc3MtbWFnbmlmaWVyXFxcIiBzcmM9XFxcInN0YXRpYy9pbWcvRnVndWUtc2hhZG93bGVzcy1tYWduaWZpZXIucG5nXFxcIiBzdHlsZT1cXFwidmVydGljYWwtYWxpZ246IG1pZGRsZVxcXCIvPjwvYT5cXHJcXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNwYW5fbm9ybV9sYWJlbFxcXCI+SUQ6PC9zcGFuPlxcclxcbiAgICAgICAgICAgICAgICA8aW5wdXQgaWQ9XFxcInNwYW5fbm9ybV9pZFxcXCIgY2xhc3M9XFxcInNwYW5fbm9ybV9pZF9pbnB1dFxcXCJcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPVxcXCJ3aWR0aDoyMCVcXFwiLz5cXHJcXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNwYW5fbm9ybV9sYWJlbFxcXCI+UmVmOjwvc3Bhbj5cXHJcXG4gICAgICAgICAgICAgICAgPGlucHV0IGlkPVxcXCJzcGFuX25vcm1fdHh0XFxcIiBjbGFzcz1cXFwic3Bhbl9ub3JtX3R4dF9pbnB1dFxcXCJcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgIHJlYWRvbmx5PVxcXCJyZWFkb25seVxcXCIgc3R5bGU9XFxcIndpZHRoOjQ1JVxcXCJcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVxcXCJDbGljayBoZXJlIHRvIHNlYXJjaFxcXCIvPlxcclxcbiAgICAgICAgICAgICAgICA8YSBpZD1cXFwic3Bhbl9ub3JtX3JlZl9saW5rXFxcIiB0YXJnZXQ9XFxcImJyYXRfbGlua2VkXFxcIiBocmVmPVxcXCIjXFxcIiB0aXRsZT1cXFwiU2VlIGluIERCXFxcIj48aW1nIGNsYXNzPVxcXCJicmF0LWZ1Z3VlLXNoYWRvd2xlc3MtZXh0ZXJuYWxcXFwiIHNyYz1cXFwic3RhdGljL2ltZy9GdWd1ZS1zaGFkb3dsZXNzLWV4dGVybmFsLnBuZ1xcXCIgc3R5bGU9XFxcInZlcnRpY2FsLWFsaWduOiBtaWRkbGVcXFwiLz48L2E+XFxyXFxuICAgICAgICAgICAgICAgIDxpbnB1dCBpZD1cXFwiY2xlYXJfbm9ybV9idXR0b25cXFwiIHR5cGU9XFxcImJ1dHRvblxcXCJcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPVxcXCImI3gyNzE1O1xcXCIgdGl0bGU9XFxcIkNsZWFyIG5vcm1hbGl6YXRpb25cXFwiLz5cXHJcXG4gICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDwvZmllbGRzZXQ+XFxyXFxuICAgICAgICA8IS0tIFNwYW4gZGlhbG9nIG5vdGVzIC0tPlxcclxcbiAgICAgICAgPGZpZWxkc2V0PlxcclxcbiAgICAgICAgICAgIDxsZWdlbmQ+Tm90ZXM8L2xlZ2VuZD5cXHJcXG4gICAgICAgICAgICA8ZGl2IGlkPVxcXCJub3Rlc19jb250YWluZXJcXFwiPlxcclxcbiAgICAgICAgICAgICAgICA8aW5wdXQgaWQ9XFxcInNwYW5fbm90ZXNcXFwiIGNsYXNzPVxcXCJib3JkZXJsZXNzXFxcIi8+XFxyXFxuICAgICAgICAgICAgICAgIDxpbnB1dCBpZD1cXFwiY2xlYXJfbm90ZXNfYnV0dG9uXFxcIiB0eXBlPVxcXCJidXR0b25cXFwiXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT1cXFwiJiN4MjcxNTtcXFwiIHRpdGxlPVxcXCJDbGVhciBub3Rlc1xcXCIvPlxcclxcbiAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPC9maWVsZHNldD5cXHJcXG4gICAgPC9mb3JtPlxcclxcblxcclxcbiAgICA8IS0tIFJhcGlkIG1vZGUgc3BhbiBkaWFsb2cgLS0+XFxyXFxuICAgIDxmb3JtIGlkPVxcXCJyYXBpZF9zcGFuX2Zvcm1cXFwiIGNsYXNzPVxcXCJkaWFsb2dcXFwiIHRpdGxlPVxcXCJTcGFuIHR5cGVcXFwiPlxcclxcbiAgICAgICAgPGZpZWxkc2V0IGlkPVxcXCJyYXBpZF9zcGFuX3NlbGVjdGVkX2ZzZXRcXFwiPlxcclxcbiAgICAgICAgICAgIDxsZWdlbmQ+VGV4dDwvbGVnZW5kPlxcclxcbiAgICAgICAgICAgIDxkaXYgaWQ9XFxcInJhcGlkX3NwYW5fc2VsZWN0ZWRcXFwiLz5cXHJcXG4gICAgICAgIDwvZmllbGRzZXQ+XFxyXFxuICAgICAgICA8ZGl2IGlkPVxcXCJyYXBpZF9zcGFuX3R5cGVzXFxcIiBjbGFzcz1cXFwic2Nyb2xsX2ZzZXRcXFwiIHN0eWxlPVxcXCJoZWlnaHQ6MjUwcHhcXFwiPlxcclxcbiAgICAgICAgICAgIDxmaWVsZHNldD5cXHJcXG4gICAgICAgICAgICAgICAgPGxlZ2VuZD5TZWxlY3QgdHlwZTwvbGVnZW5kPlxcclxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzY3JvbGxlclxcXCIgaWQ9XFxcInJhcGlkX3NwYW5fdHlwZXNfZGl2XFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDwhLS0gZmlsbGVkIGR5bmFtaWNhbGx5IC0tPlxcclxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICA8L2ZpZWxkc2V0PlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgIDwvZm9ybT5cXHJcXG5cXHJcXG4gICAgPCEtLSBBcmMgZGlhbG9nIC0tPlxcclxcbiAgICA8Zm9ybSBpZD1cXFwiYXJjX2Zvcm1cXFwiIGNsYXNzPVxcXCJkaWFsb2dcXFwiIHRpdGxlPVxcXCJBcmNcXFwiPlxcclxcbiAgICAgICAgPGZpZWxkc2V0IGlkPVxcXCJhcmNfb3JpZ2luX2ZzZXRcXFwiPlxcclxcbiAgICAgICAgICAgIDxsZWdlbmQ+RnJvbTwvbGVnZW5kPlxcclxcbiAgICAgICAgICAgIDxhIHRhcmdldD1cXFwiYnJhdF9saW5rZWRcXFwiIGlkPVxcXCJhcmNfaGlnaGxpZ2h0X2xpbmtcXFwiIGhyZWY9XFxcIiNcXFwiPkxpbms8L2E+XFxyXFxuICAgICAgICAgICAgPGRpdiBpZD1cXFwiYXJjX29yaWdpblxcXCIvPlxcclxcbiAgICAgICAgPC9maWVsZHNldD5cXHJcXG5cXHJcXG4gICAgICAgIDxmaWVsZHNldCBpZD1cXFwiYXJjX3RhcmdldF9mc2V0XFxcIj5cXHJcXG4gICAgICAgICAgICA8bGVnZW5kPlRvPC9sZWdlbmQ+XFxyXFxuICAgICAgICAgICAgPGRpdiBpZD1cXFwiYXJjX3RhcmdldFxcXCIvPlxcclxcbiAgICAgICAgPC9maWVsZHNldD5cXHJcXG5cXHJcXG4gICAgICAgIDxkaXYgaWQ9XFxcImFyY19yb2xlc1xcXCIgY2xhc3M9XFxcInNjcm9sbF9mc2V0XFxcIj5cXHJcXG4gICAgICAgICAgICA8ZmllbGRzZXQ+XFxyXFxuICAgICAgICAgICAgICAgIDxsZWdlbmQ+VHlwZTwvbGVnZW5kPlxcclxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzY3JvbGxlclxcXCIvPlxcclxcbiAgICAgICAgICAgIDwvZmllbGRzZXQ+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG5cXHJcXG4gICAgICAgIDxmaWVsZHNldCBpZD1cXFwiYXJjX25vdGVzX2ZpZWxkc2V0XFxcIj5cXHJcXG4gICAgICAgICAgICA8bGVnZW5kPk5vdGVzPC9sZWdlbmQ+XFxyXFxuICAgICAgICAgICAgPGlucHV0IGlkPVxcXCJhcmNfbm90ZXNcXFwiIGNsYXNzPVxcXCJib3JkZXJsZXNzXFxcIi8+XFxyXFxuICAgICAgICA8L2ZpZWxkc2V0PlxcclxcblxcclxcbiAgICA8L2Zvcm0+XFxyXFxuXFxyXFxuICAgIDwhLS0gU3BsaXQgc3BhbiBhbm5vdGF0aW9uIGRpYWxvZyAtLT5cXHJcXG4gICAgPGZvcm0gaWQ9XFxcInNwbGl0X2Zvcm1cXFwiIGNsYXNzPVxcXCJkaWFsb2dcXFwiIHRpdGxlPVxcXCJTcGxpdCB0aGUgU3BhblxcXCI+XFxyXFxuICAgICAgICA8ZmllbGRzZXQ+XFxyXFxuICAgICAgICAgICAgPGxlZ2VuZD5TcGxpdCBSb2xlczwvbGVnZW5kPlxcclxcbiAgICAgICAgICAgIDxkaXYgaWQ9XFxcInNwbGl0X3JvbGVzXFxcIiBjbGFzcz1cXFwic2Nyb2xsX2ZzZXRcXFwiLz5cXHJcXG4gICAgICAgIDwvZmllbGRzZXQ+XFxyXFxuICAgIDwvZm9ybT5cXHJcXG5cXHJcXG4gICAgPCEtLSBTcGlubmVyIC0tPlxcclxcbiAgICA8IS0tPGRpdiBpZD1cXFwid2FpdGVyXFxcIiBjbGFzcz1cXFwiZGlhbG9nXFxcIiB0aXRsZT1cXFwiUGxlYXNlIHdhaXRcXFwiPlxcclxcbiAgICAgICAgPGltZyBjbGFzcz1cXFwiYnJhdC1zcGlubmVyXFxcIiBzcmM9XFxcInN0YXRpYy9pbWcvc3Bpbm5lci5naWZcXFwiLz5cXHJcXG4gICAgPC9kaXY+LS0+XFxyXFxuPC9kaXY+XCI7XG4iLCIvKiFcclxuICogalF1ZXJ5IFVJIDEuOC4xNlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgMjAxMSwgQVVUSE9SUy50eHQgKGh0dHA6Ly9qcXVlcnl1aS5jb20vYWJvdXQpXHJcbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBvciBHUEwgVmVyc2lvbiAyIGxpY2Vuc2VzLlxyXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXHJcbiAqXHJcbiAqIGh0dHA6Ly9kb2NzLmpxdWVyeS5jb20vVUlcclxuICovXHJcbihmdW5jdGlvbihjLGope2Z1bmN0aW9uIGsoYSxiKXt2YXIgZD1hLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7aWYoXCJhcmVhXCI9PT1kKXtiPWEucGFyZW50Tm9kZTtkPWIubmFtZTtpZighYS5ocmVmfHwhZHx8Yi5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIT09XCJtYXBcIilyZXR1cm4gZmFsc2U7YT1jKFwiaW1nW3VzZW1hcD0jXCIrZCtcIl1cIilbMF07cmV0dXJuISFhJiZsKGEpfXJldHVybigvaW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbnxvYmplY3QvLnRlc3QoZCk/IWEuZGlzYWJsZWQ6XCJhXCI9PWQ/YS5ocmVmfHxiOmIpJiZsKGEpfWZ1bmN0aW9uIGwoYSl7cmV0dXJuIWMoYSkucGFyZW50cygpLmFuZFNlbGYoKS5maWx0ZXIoZnVuY3Rpb24oKXtyZXR1cm4gYy5jdXJDU1ModGhpcyxcInZpc2liaWxpdHlcIik9PT1cImhpZGRlblwifHxjLmV4cHIuZmlsdGVycy5oaWRkZW4odGhpcyl9KS5sZW5ndGh9Yy51aT1jLnVpfHx7fTtpZighYy51aS52ZXJzaW9uKXtjLmV4dGVuZChjLnVpLHt2ZXJzaW9uOlwiMS44LjE2XCIsXHJcbmtleUNvZGU6e0FMVDoxOCxCQUNLU1BBQ0U6OCxDQVBTX0xPQ0s6MjAsQ09NTUE6MTg4LENPTU1BTkQ6OTEsQ09NTUFORF9MRUZUOjkxLENPTU1BTkRfUklHSFQ6OTMsQ09OVFJPTDoxNyxERUxFVEU6NDYsRE9XTjo0MCxFTkQ6MzUsRU5URVI6MTMsRVNDQVBFOjI3LEhPTUU6MzYsSU5TRVJUOjQ1LExFRlQ6MzcsTUVOVTo5MyxOVU1QQURfQUREOjEwNyxOVU1QQURfREVDSU1BTDoxMTAsTlVNUEFEX0RJVklERToxMTEsTlVNUEFEX0VOVEVSOjEwOCxOVU1QQURfTVVMVElQTFk6MTA2LE5VTVBBRF9TVUJUUkFDVDoxMDksUEFHRV9ET1dOOjM0LFBBR0VfVVA6MzMsUEVSSU9EOjE5MCxSSUdIVDozOSxTSElGVDoxNixTUEFDRTozMixUQUI6OSxVUDozOCxXSU5ET1dTOjkxfX0pO2MuZm4uZXh0ZW5kKHtwcm9wQXR0cjpjLmZuLnByb3B8fGMuZm4uYXR0cixfZm9jdXM6Yy5mbi5mb2N1cyxmb2N1czpmdW5jdGlvbihhLGIpe3JldHVybiB0eXBlb2YgYT09PVwibnVtYmVyXCI/dGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGQ9XHJcbnRoaXM7c2V0VGltZW91dChmdW5jdGlvbigpe2MoZCkuZm9jdXMoKTtiJiZiLmNhbGwoZCl9LGEpfSk6dGhpcy5fZm9jdXMuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxzY3JvbGxQYXJlbnQ6ZnVuY3Rpb24oKXt2YXIgYTthPWMuYnJvd3Nlci5tc2llJiYvKHN0YXRpY3xyZWxhdGl2ZSkvLnRlc3QodGhpcy5jc3MoXCJwb3NpdGlvblwiKSl8fC9hYnNvbHV0ZS8udGVzdCh0aGlzLmNzcyhcInBvc2l0aW9uXCIpKT90aGlzLnBhcmVudHMoKS5maWx0ZXIoZnVuY3Rpb24oKXtyZXR1cm4vKHJlbGF0aXZlfGFic29sdXRlfGZpeGVkKS8udGVzdChjLmN1ckNTUyh0aGlzLFwicG9zaXRpb25cIiwxKSkmJi8oYXV0b3xzY3JvbGwpLy50ZXN0KGMuY3VyQ1NTKHRoaXMsXCJvdmVyZmxvd1wiLDEpK2MuY3VyQ1NTKHRoaXMsXCJvdmVyZmxvdy15XCIsMSkrYy5jdXJDU1ModGhpcyxcIm92ZXJmbG93LXhcIiwxKSl9KS5lcSgwKTp0aGlzLnBhcmVudHMoKS5maWx0ZXIoZnVuY3Rpb24oKXtyZXR1cm4vKGF1dG98c2Nyb2xsKS8udGVzdChjLmN1ckNTUyh0aGlzLFxyXG5cIm92ZXJmbG93XCIsMSkrYy5jdXJDU1ModGhpcyxcIm92ZXJmbG93LXlcIiwxKStjLmN1ckNTUyh0aGlzLFwib3ZlcmZsb3cteFwiLDEpKX0pLmVxKDApO3JldHVybi9maXhlZC8udGVzdCh0aGlzLmNzcyhcInBvc2l0aW9uXCIpKXx8IWEubGVuZ3RoP2MoZG9jdW1lbnQpOmF9LHpJbmRleDpmdW5jdGlvbihhKXtpZihhIT09ailyZXR1cm4gdGhpcy5jc3MoXCJ6SW5kZXhcIixhKTtpZih0aGlzLmxlbmd0aCl7YT1jKHRoaXNbMF0pO2Zvcih2YXIgYjthLmxlbmd0aCYmYVswXSE9PWRvY3VtZW50Oyl7Yj1hLmNzcyhcInBvc2l0aW9uXCIpO2lmKGI9PT1cImFic29sdXRlXCJ8fGI9PT1cInJlbGF0aXZlXCJ8fGI9PT1cImZpeGVkXCIpe2I9cGFyc2VJbnQoYS5jc3MoXCJ6SW5kZXhcIiksMTApO2lmKCFpc05hTihiKSYmYiE9PTApcmV0dXJuIGJ9YT1hLnBhcmVudCgpfX1yZXR1cm4gMH0sZGlzYWJsZVNlbGVjdGlvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmJpbmQoKGMuc3VwcG9ydC5zZWxlY3RzdGFydD9cInNlbGVjdHN0YXJ0XCI6XHJcblwibW91c2Vkb3duXCIpK1wiLnVpLWRpc2FibGVTZWxlY3Rpb25cIixmdW5jdGlvbihhKXthLnByZXZlbnREZWZhdWx0KCl9KX0sZW5hYmxlU2VsZWN0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5iaW5kKFwiLnVpLWRpc2FibGVTZWxlY3Rpb25cIil9fSk7Yy5lYWNoKFtcIldpZHRoXCIsXCJIZWlnaHRcIl0sZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBkKGYsZyxtLG4pe2MuZWFjaChlLGZ1bmN0aW9uKCl7Zy09cGFyc2VGbG9hdChjLmN1ckNTUyhmLFwicGFkZGluZ1wiK3RoaXMsdHJ1ZSkpfHwwO2lmKG0pZy09cGFyc2VGbG9hdChjLmN1ckNTUyhmLFwiYm9yZGVyXCIrdGhpcytcIldpZHRoXCIsdHJ1ZSkpfHwwO2lmKG4pZy09cGFyc2VGbG9hdChjLmN1ckNTUyhmLFwibWFyZ2luXCIrdGhpcyx0cnVlKSl8fDB9KTtyZXR1cm4gZ312YXIgZT1iPT09XCJXaWR0aFwiP1tcIkxlZnRcIixcIlJpZ2h0XCJdOltcIlRvcFwiLFwiQm90dG9tXCJdLGg9Yi50b0xvd2VyQ2FzZSgpLGk9e2lubmVyV2lkdGg6Yy5mbi5pbm5lcldpZHRoLGlubmVySGVpZ2h0OmMuZm4uaW5uZXJIZWlnaHQsXHJcbm91dGVyV2lkdGg6Yy5mbi5vdXRlcldpZHRoLG91dGVySGVpZ2h0OmMuZm4ub3V0ZXJIZWlnaHR9O2MuZm5bXCJpbm5lclwiK2JdPWZ1bmN0aW9uKGYpe2lmKGY9PT1qKXJldHVybiBpW1wiaW5uZXJcIitiXS5jYWxsKHRoaXMpO3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtjKHRoaXMpLmNzcyhoLGQodGhpcyxmKStcInB4XCIpfSl9O2MuZm5bXCJvdXRlclwiK2JdPWZ1bmN0aW9uKGYsZyl7aWYodHlwZW9mIGYhPT1cIm51bWJlclwiKXJldHVybiBpW1wib3V0ZXJcIitiXS5jYWxsKHRoaXMsZik7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe2ModGhpcykuY3NzKGgsZCh0aGlzLGYsdHJ1ZSxnKStcInB4XCIpfSl9fSk7Yy5leHRlbmQoYy5leHByW1wiOlwiXSx7ZGF0YTpmdW5jdGlvbihhLGIsZCl7cmV0dXJuISFjLmRhdGEoYSxkWzNdKX0sZm9jdXNhYmxlOmZ1bmN0aW9uKGEpe3JldHVybiBrKGEsIWlzTmFOKGMuYXR0cihhLFwidGFiaW5kZXhcIikpKX0sdGFiYmFibGU6ZnVuY3Rpb24oYSl7dmFyIGI9Yy5hdHRyKGEsXHJcblwidGFiaW5kZXhcIiksZD1pc05hTihiKTtyZXR1cm4oZHx8Yj49MCkmJmsoYSwhZCl9fSk7YyhmdW5jdGlvbigpe3ZhciBhPWRvY3VtZW50LmJvZHksYj1hLmFwcGVuZENoaWxkKGI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7Yy5leHRlbmQoYi5zdHlsZSx7bWluSGVpZ2h0OlwiMTAwcHhcIixoZWlnaHQ6XCJhdXRvXCIscGFkZGluZzowLGJvcmRlcldpZHRoOjB9KTtjLnN1cHBvcnQubWluSGVpZ2h0PWIub2Zmc2V0SGVpZ2h0PT09MTAwO2Muc3VwcG9ydC5zZWxlY3RzdGFydD1cIm9uc2VsZWN0c3RhcnRcImluIGI7YS5yZW1vdmVDaGlsZChiKS5zdHlsZS5kaXNwbGF5PVwibm9uZVwifSk7Yy5leHRlbmQoYy51aSx7cGx1Z2luOnthZGQ6ZnVuY3Rpb24oYSxiLGQpe2E9Yy51aVthXS5wcm90b3R5cGU7Zm9yKHZhciBlIGluIGQpe2EucGx1Z2luc1tlXT1hLnBsdWdpbnNbZV18fFtdO2EucGx1Z2luc1tlXS5wdXNoKFtiLGRbZV1dKX19LGNhbGw6ZnVuY3Rpb24oYSxiLGQpe2lmKChiPWEucGx1Z2luc1tiXSkmJlxyXG5hLmVsZW1lbnRbMF0ucGFyZW50Tm9kZSlmb3IodmFyIGU9MDtlPGIubGVuZ3RoO2UrKylhLm9wdGlvbnNbYltlXVswXV0mJmJbZV1bMV0uYXBwbHkoYS5lbGVtZW50LGQpfX0sY29udGFpbnM6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gZG9jdW1lbnQuY29tcGFyZURvY3VtZW50UG9zaXRpb24/YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKSYxNjphIT09YiYmYS5jb250YWlucyhiKX0saGFzU2Nyb2xsOmZ1bmN0aW9uKGEsYil7aWYoYyhhKS5jc3MoXCJvdmVyZmxvd1wiKT09PVwiaGlkZGVuXCIpcmV0dXJuIGZhbHNlO2I9YiYmYj09PVwibGVmdFwiP1wic2Nyb2xsTGVmdFwiOlwic2Nyb2xsVG9wXCI7dmFyIGQ9ZmFsc2U7aWYoYVtiXT4wKXJldHVybiB0cnVlO2FbYl09MTtkPWFbYl0+MDthW2JdPTA7cmV0dXJuIGR9LGlzT3ZlckF4aXM6ZnVuY3Rpb24oYSxiLGQpe3JldHVybiBhPmImJmE8YitkfSxpc092ZXI6ZnVuY3Rpb24oYSxiLGQsZSxoLGkpe3JldHVybiBjLnVpLmlzT3ZlckF4aXMoYSxkLGgpJiZcclxuYy51aS5pc092ZXJBeGlzKGIsZSxpKX19KX19KShqUXVlcnkpO1xyXG47LyohXHJcbiAqIGpRdWVyeSBVSSBXaWRnZXQgMS44LjE2XHJcbiAqXHJcbiAqIENvcHlyaWdodCAyMDExLCBBVVRIT1JTLnR4dCAoaHR0cDovL2pxdWVyeXVpLmNvbS9hYm91dClcclxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIG9yIEdQTCBWZXJzaW9uIDIgbGljZW5zZXMuXHJcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcclxuICpcclxuICogaHR0cDovL2RvY3MuanF1ZXJ5LmNvbS9VSS9XaWRnZXRcclxuICovXHJcbihmdW5jdGlvbihiLGope2lmKGIuY2xlYW5EYXRhKXt2YXIgaz1iLmNsZWFuRGF0YTtiLmNsZWFuRGF0YT1mdW5jdGlvbihhKXtmb3IodmFyIGM9MCxkOyhkPWFbY10pIT1udWxsO2MrKyl0cnl7YihkKS50cmlnZ2VySGFuZGxlcihcInJlbW92ZVwiKX1jYXRjaChlKXt9ayhhKX19ZWxzZXt2YXIgbD1iLmZuLnJlbW92ZTtiLmZuLnJlbW92ZT1mdW5jdGlvbihhLGMpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtpZighYylpZighYXx8Yi5maWx0ZXIoYSxbdGhpc10pLmxlbmd0aCliKFwiKlwiLHRoaXMpLmFkZChbdGhpc10pLmVhY2goZnVuY3Rpb24oKXt0cnl7Yih0aGlzKS50cmlnZ2VySGFuZGxlcihcInJlbW92ZVwiKX1jYXRjaChkKXt9fSk7cmV0dXJuIGwuY2FsbChiKHRoaXMpLGEsYyl9KX19Yi53aWRnZXQ9ZnVuY3Rpb24oYSxjLGQpe3ZhciBlPWEuc3BsaXQoXCIuXCIpWzBdLGY7YT1hLnNwbGl0KFwiLlwiKVsxXTtmPWUrXCItXCIrYTtpZighZCl7ZD1jO2M9Yi5XaWRnZXR9Yi5leHByW1wiOlwiXVtmXT1cclxuZnVuY3Rpb24oaCl7cmV0dXJuISFiLmRhdGEoaCxhKX07YltlXT1iW2VdfHx7fTtiW2VdW2FdPWZ1bmN0aW9uKGgsZyl7YXJndW1lbnRzLmxlbmd0aCYmdGhpcy5fY3JlYXRlV2lkZ2V0KGgsZyl9O2M9bmV3IGM7Yy5vcHRpb25zPWIuZXh0ZW5kKHRydWUse30sYy5vcHRpb25zKTtiW2VdW2FdLnByb3RvdHlwZT1iLmV4dGVuZCh0cnVlLGMse25hbWVzcGFjZTplLHdpZGdldE5hbWU6YSx3aWRnZXRFdmVudFByZWZpeDpiW2VdW2FdLnByb3RvdHlwZS53aWRnZXRFdmVudFByZWZpeHx8YSx3aWRnZXRCYXNlQ2xhc3M6Zn0sZCk7Yi53aWRnZXQuYnJpZGdlKGEsYltlXVthXSl9O2Iud2lkZ2V0LmJyaWRnZT1mdW5jdGlvbihhLGMpe2IuZm5bYV09ZnVuY3Rpb24oZCl7dmFyIGU9dHlwZW9mIGQ9PT1cInN0cmluZ1wiLGY9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpLGg9dGhpcztkPSFlJiZmLmxlbmd0aD9iLmV4dGVuZC5hcHBseShudWxsLFt0cnVlLGRdLmNvbmNhdChmKSk6XHJcbmQ7aWYoZSYmZC5jaGFyQXQoMCk9PT1cIl9cIilyZXR1cm4gaDtlP3RoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBnPWIuZGF0YSh0aGlzLGEpLGk9ZyYmYi5pc0Z1bmN0aW9uKGdbZF0pP2dbZF0uYXBwbHkoZyxmKTpnO2lmKGkhPT1nJiZpIT09ail7aD1pO3JldHVybiBmYWxzZX19KTp0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgZz1iLmRhdGEodGhpcyxhKTtnP2cub3B0aW9uKGR8fHt9KS5faW5pdCgpOmIuZGF0YSh0aGlzLGEsbmV3IGMoZCx0aGlzKSl9KTtyZXR1cm4gaH19O2IuV2lkZ2V0PWZ1bmN0aW9uKGEsYyl7YXJndW1lbnRzLmxlbmd0aCYmdGhpcy5fY3JlYXRlV2lkZ2V0KGEsYyl9O2IuV2lkZ2V0LnByb3RvdHlwZT17d2lkZ2V0TmFtZTpcIndpZGdldFwiLHdpZGdldEV2ZW50UHJlZml4OlwiXCIsb3B0aW9uczp7ZGlzYWJsZWQ6ZmFsc2V9LF9jcmVhdGVXaWRnZXQ6ZnVuY3Rpb24oYSxjKXtiLmRhdGEoYyx0aGlzLndpZGdldE5hbWUsdGhpcyk7dGhpcy5lbGVtZW50PWIoYyk7dGhpcy5vcHRpb25zPVxyXG5iLmV4dGVuZCh0cnVlLHt9LHRoaXMub3B0aW9ucyx0aGlzLl9nZXRDcmVhdGVPcHRpb25zKCksYSk7dmFyIGQ9dGhpczt0aGlzLmVsZW1lbnQuYmluZChcInJlbW92ZS5cIit0aGlzLndpZGdldE5hbWUsZnVuY3Rpb24oKXtkLmRlc3Ryb3koKX0pO3RoaXMuX2NyZWF0ZSgpO3RoaXMuX3RyaWdnZXIoXCJjcmVhdGVcIik7dGhpcy5faW5pdCgpfSxfZ2V0Q3JlYXRlT3B0aW9uczpmdW5jdGlvbigpe3JldHVybiBiLm1ldGFkYXRhJiZiLm1ldGFkYXRhLmdldCh0aGlzLmVsZW1lbnRbMF0pW3RoaXMud2lkZ2V0TmFtZV19LF9jcmVhdGU6ZnVuY3Rpb24oKXt9LF9pbml0OmZ1bmN0aW9uKCl7fSxkZXN0cm95OmZ1bmN0aW9uKCl7dGhpcy5lbGVtZW50LnVuYmluZChcIi5cIit0aGlzLndpZGdldE5hbWUpLnJlbW92ZURhdGEodGhpcy53aWRnZXROYW1lKTt0aGlzLndpZGdldCgpLnVuYmluZChcIi5cIit0aGlzLndpZGdldE5hbWUpLnJlbW92ZUF0dHIoXCJhcmlhLWRpc2FibGVkXCIpLnJlbW92ZUNsYXNzKHRoaXMud2lkZ2V0QmFzZUNsYXNzK1xyXG5cIi1kaXNhYmxlZCB1aS1zdGF0ZS1kaXNhYmxlZFwiKX0sd2lkZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWxlbWVudH0sb3B0aW9uOmZ1bmN0aW9uKGEsYyl7dmFyIGQ9YTtpZihhcmd1bWVudHMubGVuZ3RoPT09MClyZXR1cm4gYi5leHRlbmQoe30sdGhpcy5vcHRpb25zKTtpZih0eXBlb2YgYT09PVwic3RyaW5nXCIpe2lmKGM9PT1qKXJldHVybiB0aGlzLm9wdGlvbnNbYV07ZD17fTtkW2FdPWN9dGhpcy5fc2V0T3B0aW9ucyhkKTtyZXR1cm4gdGhpc30sX3NldE9wdGlvbnM6ZnVuY3Rpb24oYSl7dmFyIGM9dGhpcztiLmVhY2goYSxmdW5jdGlvbihkLGUpe2MuX3NldE9wdGlvbihkLGUpfSk7cmV0dXJuIHRoaXN9LF9zZXRPcHRpb246ZnVuY3Rpb24oYSxjKXt0aGlzLm9wdGlvbnNbYV09YztpZihhPT09XCJkaXNhYmxlZFwiKXRoaXMud2lkZ2V0KClbYz9cImFkZENsYXNzXCI6XCJyZW1vdmVDbGFzc1wiXSh0aGlzLndpZGdldEJhc2VDbGFzcytcIi1kaXNhYmxlZCB1aS1zdGF0ZS1kaXNhYmxlZFwiKS5hdHRyKFwiYXJpYS1kaXNhYmxlZFwiLFxyXG5jKTtyZXR1cm4gdGhpc30sZW5hYmxlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NldE9wdGlvbihcImRpc2FibGVkXCIsZmFsc2UpfSxkaXNhYmxlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NldE9wdGlvbihcImRpc2FibGVkXCIsdHJ1ZSl9LF90cmlnZ2VyOmZ1bmN0aW9uKGEsYyxkKXt2YXIgZT10aGlzLm9wdGlvbnNbYV07Yz1iLkV2ZW50KGMpO2MudHlwZT0oYT09PXRoaXMud2lkZ2V0RXZlbnRQcmVmaXg/YTp0aGlzLndpZGdldEV2ZW50UHJlZml4K2EpLnRvTG93ZXJDYXNlKCk7ZD1kfHx7fTtpZihjLm9yaWdpbmFsRXZlbnQpe2E9Yi5ldmVudC5wcm9wcy5sZW5ndGg7Zm9yKHZhciBmO2E7KXtmPWIuZXZlbnQucHJvcHNbLS1hXTtjW2ZdPWMub3JpZ2luYWxFdmVudFtmXX19dGhpcy5lbGVtZW50LnRyaWdnZXIoYyxkKTtyZXR1cm4hKGIuaXNGdW5jdGlvbihlKSYmZS5jYWxsKHRoaXMuZWxlbWVudFswXSxjLGQpPT09ZmFsc2V8fGMuaXNEZWZhdWx0UHJldmVudGVkKCkpfX19KShqUXVlcnkpO1xyXG47LyohXHJcbiAqIGpRdWVyeSBVSSBNb3VzZSAxLjguMTZcclxuICpcclxuICogQ29weXJpZ2h0IDIwMTEsIEFVVEhPUlMudHh0IChodHRwOi8vanF1ZXJ5dWkuY29tL2Fib3V0KVxyXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgb3IgR1BMIFZlcnNpb24gMiBsaWNlbnNlcy5cclxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxyXG4gKlxyXG4gKiBodHRwOi8vZG9jcy5qcXVlcnkuY29tL1VJL01vdXNlXHJcbiAqXHJcbiAqIERlcGVuZHM6XHJcbiAqXHRqcXVlcnkudWkud2lkZ2V0LmpzXHJcbiAqL1xyXG4oZnVuY3Rpb24oYil7dmFyIGQ9ZmFsc2U7Yihkb2N1bWVudCkubW91c2V1cChmdW5jdGlvbigpe2Q9ZmFsc2V9KTtiLndpZGdldChcInVpLm1vdXNlXCIse29wdGlvbnM6e2NhbmNlbDpcIjppbnB1dCxvcHRpb25cIixkaXN0YW5jZToxLGRlbGF5OjB9LF9tb3VzZUluaXQ6ZnVuY3Rpb24oKXt2YXIgYT10aGlzO3RoaXMuZWxlbWVudC5iaW5kKFwibW91c2Vkb3duLlwiK3RoaXMud2lkZ2V0TmFtZSxmdW5jdGlvbihjKXtyZXR1cm4gYS5fbW91c2VEb3duKGMpfSkuYmluZChcImNsaWNrLlwiK3RoaXMud2lkZ2V0TmFtZSxmdW5jdGlvbihjKXtpZih0cnVlPT09Yi5kYXRhKGMudGFyZ2V0LGEud2lkZ2V0TmFtZStcIi5wcmV2ZW50Q2xpY2tFdmVudFwiKSl7Yi5yZW1vdmVEYXRhKGMudGFyZ2V0LGEud2lkZ2V0TmFtZStcIi5wcmV2ZW50Q2xpY2tFdmVudFwiKTtjLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO3JldHVybiBmYWxzZX19KTt0aGlzLnN0YXJ0ZWQ9ZmFsc2V9LF9tb3VzZURlc3Ryb3k6ZnVuY3Rpb24oKXt0aGlzLmVsZW1lbnQudW5iaW5kKFwiLlwiK1xyXG50aGlzLndpZGdldE5hbWUpfSxfbW91c2VEb3duOmZ1bmN0aW9uKGEpe2lmKCFkKXt0aGlzLl9tb3VzZVN0YXJ0ZWQmJnRoaXMuX21vdXNlVXAoYSk7dGhpcy5fbW91c2VEb3duRXZlbnQ9YTt2YXIgYz10aGlzLGY9YS53aGljaD09MSxnPXR5cGVvZiB0aGlzLm9wdGlvbnMuY2FuY2VsPT1cInN0cmluZ1wiJiZhLnRhcmdldC5ub2RlTmFtZT9iKGEudGFyZ2V0KS5jbG9zZXN0KHRoaXMub3B0aW9ucy5jYW5jZWwpLmxlbmd0aDpmYWxzZTtpZighZnx8Z3x8IXRoaXMuX21vdXNlQ2FwdHVyZShhKSlyZXR1cm4gdHJ1ZTt0aGlzLm1vdXNlRGVsYXlNZXQ9IXRoaXMub3B0aW9ucy5kZWxheTtpZighdGhpcy5tb3VzZURlbGF5TWV0KXRoaXMuX21vdXNlRGVsYXlUaW1lcj1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Yy5tb3VzZURlbGF5TWV0PXRydWV9LHRoaXMub3B0aW9ucy5kZWxheSk7aWYodGhpcy5fbW91c2VEaXN0YW5jZU1ldChhKSYmdGhpcy5fbW91c2VEZWxheU1ldChhKSl7dGhpcy5fbW91c2VTdGFydGVkPVxyXG50aGlzLl9tb3VzZVN0YXJ0KGEpIT09ZmFsc2U7aWYoIXRoaXMuX21vdXNlU3RhcnRlZCl7YS5wcmV2ZW50RGVmYXVsdCgpO3JldHVybiB0cnVlfX10cnVlPT09Yi5kYXRhKGEudGFyZ2V0LHRoaXMud2lkZ2V0TmFtZStcIi5wcmV2ZW50Q2xpY2tFdmVudFwiKSYmYi5yZW1vdmVEYXRhKGEudGFyZ2V0LHRoaXMud2lkZ2V0TmFtZStcIi5wcmV2ZW50Q2xpY2tFdmVudFwiKTt0aGlzLl9tb3VzZU1vdmVEZWxlZ2F0ZT1mdW5jdGlvbihlKXtyZXR1cm4gYy5fbW91c2VNb3ZlKGUpfTt0aGlzLl9tb3VzZVVwRGVsZWdhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGMuX21vdXNlVXAoZSl9O2IoZG9jdW1lbnQpLmJpbmQoXCJtb3VzZW1vdmUuXCIrdGhpcy53aWRnZXROYW1lLHRoaXMuX21vdXNlTW92ZURlbGVnYXRlKS5iaW5kKFwibW91c2V1cC5cIit0aGlzLndpZGdldE5hbWUsdGhpcy5fbW91c2VVcERlbGVnYXRlKTthLnByZXZlbnREZWZhdWx0KCk7cmV0dXJuIGQ9dHJ1ZX19LF9tb3VzZU1vdmU6ZnVuY3Rpb24oYSl7aWYoYi5icm93c2VyLm1zaWUmJlxyXG4hKGRvY3VtZW50LmRvY3VtZW50TW9kZT49OSkmJiFhLmJ1dHRvbilyZXR1cm4gdGhpcy5fbW91c2VVcChhKTtpZih0aGlzLl9tb3VzZVN0YXJ0ZWQpe3RoaXMuX21vdXNlRHJhZyhhKTtyZXR1cm4gYS5wcmV2ZW50RGVmYXVsdCgpfWlmKHRoaXMuX21vdXNlRGlzdGFuY2VNZXQoYSkmJnRoaXMuX21vdXNlRGVsYXlNZXQoYSkpKHRoaXMuX21vdXNlU3RhcnRlZD10aGlzLl9tb3VzZVN0YXJ0KHRoaXMuX21vdXNlRG93bkV2ZW50LGEpIT09ZmFsc2UpP3RoaXMuX21vdXNlRHJhZyhhKTp0aGlzLl9tb3VzZVVwKGEpO3JldHVybiF0aGlzLl9tb3VzZVN0YXJ0ZWR9LF9tb3VzZVVwOmZ1bmN0aW9uKGEpe2IoZG9jdW1lbnQpLnVuYmluZChcIm1vdXNlbW92ZS5cIit0aGlzLndpZGdldE5hbWUsdGhpcy5fbW91c2VNb3ZlRGVsZWdhdGUpLnVuYmluZChcIm1vdXNldXAuXCIrdGhpcy53aWRnZXROYW1lLHRoaXMuX21vdXNlVXBEZWxlZ2F0ZSk7aWYodGhpcy5fbW91c2VTdGFydGVkKXt0aGlzLl9tb3VzZVN0YXJ0ZWQ9XHJcbmZhbHNlO2EudGFyZ2V0PT10aGlzLl9tb3VzZURvd25FdmVudC50YXJnZXQmJmIuZGF0YShhLnRhcmdldCx0aGlzLndpZGdldE5hbWUrXCIucHJldmVudENsaWNrRXZlbnRcIix0cnVlKTt0aGlzLl9tb3VzZVN0b3AoYSl9cmV0dXJuIGZhbHNlfSxfbW91c2VEaXN0YW5jZU1ldDpmdW5jdGlvbihhKXtyZXR1cm4gTWF0aC5tYXgoTWF0aC5hYnModGhpcy5fbW91c2VEb3duRXZlbnQucGFnZVgtYS5wYWdlWCksTWF0aC5hYnModGhpcy5fbW91c2VEb3duRXZlbnQucGFnZVktYS5wYWdlWSkpPj10aGlzLm9wdGlvbnMuZGlzdGFuY2V9LF9tb3VzZURlbGF5TWV0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubW91c2VEZWxheU1ldH0sX21vdXNlU3RhcnQ6ZnVuY3Rpb24oKXt9LF9tb3VzZURyYWc6ZnVuY3Rpb24oKXt9LF9tb3VzZVN0b3A6ZnVuY3Rpb24oKXt9LF9tb3VzZUNhcHR1cmU6ZnVuY3Rpb24oKXtyZXR1cm4gdHJ1ZX19KX0pKGpRdWVyeSk7XHJcbjsvKlxyXG4gKiBqUXVlcnkgVUkgUG9zaXRpb24gMS44LjE2XHJcbiAqXHJcbiAqIENvcHlyaWdodCAyMDExLCBBVVRIT1JTLnR4dCAoaHR0cDovL2pxdWVyeXVpLmNvbS9hYm91dClcclxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIG9yIEdQTCBWZXJzaW9uIDIgbGljZW5zZXMuXHJcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcclxuICpcclxuICogaHR0cDovL2RvY3MuanF1ZXJ5LmNvbS9VSS9Qb3NpdGlvblxyXG4gKi9cclxuKGZ1bmN0aW9uKGMpe2MudWk9Yy51aXx8e307dmFyIG49L2xlZnR8Y2VudGVyfHJpZ2h0LyxvPS90b3B8Y2VudGVyfGJvdHRvbS8sdD1jLmZuLnBvc2l0aW9uLHU9Yy5mbi5vZmZzZXQ7Yy5mbi5wb3NpdGlvbj1mdW5jdGlvbihiKXtpZighYnx8IWIub2YpcmV0dXJuIHQuYXBwbHkodGhpcyxhcmd1bWVudHMpO2I9Yy5leHRlbmQoe30sYik7dmFyIGE9YyhiLm9mKSxkPWFbMF0sZz0oYi5jb2xsaXNpb258fFwiZmxpcFwiKS5zcGxpdChcIiBcIiksZT1iLm9mZnNldD9iLm9mZnNldC5zcGxpdChcIiBcIik6WzAsMF0saCxrLGo7aWYoZC5ub2RlVHlwZT09PTkpe2g9YS53aWR0aCgpO2s9YS5oZWlnaHQoKTtqPXt0b3A6MCxsZWZ0OjB9fWVsc2UgaWYoZC5zZXRUaW1lb3V0KXtoPWEud2lkdGgoKTtrPWEuaGVpZ2h0KCk7aj17dG9wOmEuc2Nyb2xsVG9wKCksbGVmdDphLnNjcm9sbExlZnQoKX19ZWxzZSBpZihkLnByZXZlbnREZWZhdWx0KXtiLmF0PVwibGVmdCB0b3BcIjtoPWs9MDtqPXt0b3A6Yi5vZi5wYWdlWSxcclxubGVmdDpiLm9mLnBhZ2VYfX1lbHNle2g9YS5vdXRlcldpZHRoKCk7az1hLm91dGVySGVpZ2h0KCk7aj1hLm9mZnNldCgpfWMuZWFjaChbXCJteVwiLFwiYXRcIl0sZnVuY3Rpb24oKXt2YXIgZj0oYlt0aGlzXXx8XCJcIikuc3BsaXQoXCIgXCIpO2lmKGYubGVuZ3RoPT09MSlmPW4udGVzdChmWzBdKT9mLmNvbmNhdChbXCJjZW50ZXJcIl0pOm8udGVzdChmWzBdKT9bXCJjZW50ZXJcIl0uY29uY2F0KGYpOltcImNlbnRlclwiLFwiY2VudGVyXCJdO2ZbMF09bi50ZXN0KGZbMF0pP2ZbMF06XCJjZW50ZXJcIjtmWzFdPW8udGVzdChmWzFdKT9mWzFdOlwiY2VudGVyXCI7Ylt0aGlzXT1mfSk7aWYoZy5sZW5ndGg9PT0xKWdbMV09Z1swXTtlWzBdPXBhcnNlSW50KGVbMF0sMTApfHwwO2lmKGUubGVuZ3RoPT09MSllWzFdPWVbMF07ZVsxXT1wYXJzZUludChlWzFdLDEwKXx8MDtpZihiLmF0WzBdPT09XCJyaWdodFwiKWoubGVmdCs9aDtlbHNlIGlmKGIuYXRbMF09PT1cImNlbnRlclwiKWoubGVmdCs9aC8yO2lmKGIuYXRbMV09PT1cImJvdHRvbVwiKWoudG9wKz1cclxuaztlbHNlIGlmKGIuYXRbMV09PT1cImNlbnRlclwiKWoudG9wKz1rLzI7ai5sZWZ0Kz1lWzBdO2oudG9wKz1lWzFdO3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgZj1jKHRoaXMpLGw9Zi5vdXRlcldpZHRoKCksbT1mLm91dGVySGVpZ2h0KCkscD1wYXJzZUludChjLmN1ckNTUyh0aGlzLFwibWFyZ2luTGVmdFwiLHRydWUpKXx8MCxxPXBhcnNlSW50KGMuY3VyQ1NTKHRoaXMsXCJtYXJnaW5Ub3BcIix0cnVlKSl8fDAsdj1sK3ArKHBhcnNlSW50KGMuY3VyQ1NTKHRoaXMsXCJtYXJnaW5SaWdodFwiLHRydWUpKXx8MCksdz1tK3ErKHBhcnNlSW50KGMuY3VyQ1NTKHRoaXMsXCJtYXJnaW5Cb3R0b21cIix0cnVlKSl8fDApLGk9Yy5leHRlbmQoe30saikscjtpZihiLm15WzBdPT09XCJyaWdodFwiKWkubGVmdC09bDtlbHNlIGlmKGIubXlbMF09PT1cImNlbnRlclwiKWkubGVmdC09bC8yO2lmKGIubXlbMV09PT1cImJvdHRvbVwiKWkudG9wLT1tO2Vsc2UgaWYoYi5teVsxXT09PVwiY2VudGVyXCIpaS50b3AtPVxyXG5tLzI7aS5sZWZ0PU1hdGgucm91bmQoaS5sZWZ0KTtpLnRvcD1NYXRoLnJvdW5kKGkudG9wKTtyPXtsZWZ0OmkubGVmdC1wLHRvcDppLnRvcC1xfTtjLmVhY2goW1wibGVmdFwiLFwidG9wXCJdLGZ1bmN0aW9uKHMseCl7Yy51aS5wb3NpdGlvbltnW3NdXSYmYy51aS5wb3NpdGlvbltnW3NdXVt4XShpLHt0YXJnZXRXaWR0aDpoLHRhcmdldEhlaWdodDprLGVsZW1XaWR0aDpsLGVsZW1IZWlnaHQ6bSxjb2xsaXNpb25Qb3NpdGlvbjpyLGNvbGxpc2lvbldpZHRoOnYsY29sbGlzaW9uSGVpZ2h0Oncsb2Zmc2V0OmUsbXk6Yi5teSxhdDpiLmF0fSl9KTtjLmZuLmJnaWZyYW1lJiZmLmJnaWZyYW1lKCk7Zi5vZmZzZXQoYy5leHRlbmQoaSx7dXNpbmc6Yi51c2luZ30pKX0pfTtjLnVpLnBvc2l0aW9uPXtmaXQ6e2xlZnQ6ZnVuY3Rpb24oYixhKXt2YXIgZD1jKHdpbmRvdyk7ZD1hLmNvbGxpc2lvblBvc2l0aW9uLmxlZnQrYS5jb2xsaXNpb25XaWR0aC1kLndpZHRoKCktZC5zY3JvbGxMZWZ0KCk7Yi5sZWZ0PVxyXG5kPjA/Yi5sZWZ0LWQ6TWF0aC5tYXgoYi5sZWZ0LWEuY29sbGlzaW9uUG9zaXRpb24ubGVmdCxiLmxlZnQpfSx0b3A6ZnVuY3Rpb24oYixhKXt2YXIgZD1jKHdpbmRvdyk7ZD1hLmNvbGxpc2lvblBvc2l0aW9uLnRvcCthLmNvbGxpc2lvbkhlaWdodC1kLmhlaWdodCgpLWQuc2Nyb2xsVG9wKCk7Yi50b3A9ZD4wP2IudG9wLWQ6TWF0aC5tYXgoYi50b3AtYS5jb2xsaXNpb25Qb3NpdGlvbi50b3AsYi50b3ApfX0sZmxpcDp7bGVmdDpmdW5jdGlvbihiLGEpe2lmKGEuYXRbMF0hPT1cImNlbnRlclwiKXt2YXIgZD1jKHdpbmRvdyk7ZD1hLmNvbGxpc2lvblBvc2l0aW9uLmxlZnQrYS5jb2xsaXNpb25XaWR0aC1kLndpZHRoKCktZC5zY3JvbGxMZWZ0KCk7dmFyIGc9YS5teVswXT09PVwibGVmdFwiPy1hLmVsZW1XaWR0aDphLm15WzBdPT09XCJyaWdodFwiP2EuZWxlbVdpZHRoOjAsZT1hLmF0WzBdPT09XCJsZWZ0XCI/YS50YXJnZXRXaWR0aDotYS50YXJnZXRXaWR0aCxoPS0yKmEub2Zmc2V0WzBdO2IubGVmdCs9XHJcbmEuY29sbGlzaW9uUG9zaXRpb24ubGVmdDwwP2crZStoOmQ+MD9nK2UraDowfX0sdG9wOmZ1bmN0aW9uKGIsYSl7aWYoYS5hdFsxXSE9PVwiY2VudGVyXCIpe3ZhciBkPWMod2luZG93KTtkPWEuY29sbGlzaW9uUG9zaXRpb24udG9wK2EuY29sbGlzaW9uSGVpZ2h0LWQuaGVpZ2h0KCktZC5zY3JvbGxUb3AoKTt2YXIgZz1hLm15WzFdPT09XCJ0b3BcIj8tYS5lbGVtSGVpZ2h0OmEubXlbMV09PT1cImJvdHRvbVwiP2EuZWxlbUhlaWdodDowLGU9YS5hdFsxXT09PVwidG9wXCI/YS50YXJnZXRIZWlnaHQ6LWEudGFyZ2V0SGVpZ2h0LGg9LTIqYS5vZmZzZXRbMV07Yi50b3ArPWEuY29sbGlzaW9uUG9zaXRpb24udG9wPDA/ZytlK2g6ZD4wP2crZStoOjB9fX19O2lmKCFjLm9mZnNldC5zZXRPZmZzZXQpe2Mub2Zmc2V0LnNldE9mZnNldD1mdW5jdGlvbihiLGEpe2lmKC9zdGF0aWMvLnRlc3QoYy5jdXJDU1MoYixcInBvc2l0aW9uXCIpKSliLnN0eWxlLnBvc2l0aW9uPVwicmVsYXRpdmVcIjt2YXIgZD1jKGIpLFxyXG5nPWQub2Zmc2V0KCksZT1wYXJzZUludChjLmN1ckNTUyhiLFwidG9wXCIsdHJ1ZSksMTApfHwwLGg9cGFyc2VJbnQoYy5jdXJDU1MoYixcImxlZnRcIix0cnVlKSwxMCl8fDA7Zz17dG9wOmEudG9wLWcudG9wK2UsbGVmdDphLmxlZnQtZy5sZWZ0K2h9O1widXNpbmdcImluIGE/YS51c2luZy5jYWxsKGIsZyk6ZC5jc3MoZyl9O2MuZm4ub2Zmc2V0PWZ1bmN0aW9uKGIpe3ZhciBhPXRoaXNbMF07aWYoIWF8fCFhLm93bmVyRG9jdW1lbnQpcmV0dXJuIG51bGw7aWYoYilyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7Yy5vZmZzZXQuc2V0T2Zmc2V0KHRoaXMsYil9KTtyZXR1cm4gdS5jYWxsKHRoaXMpfX19KShqUXVlcnkpO1xyXG47LypcclxuICogalF1ZXJ5IFVJIERyYWdnYWJsZSAxLjguMTZcclxuICpcclxuICogQ29weXJpZ2h0IDIwMTEsIEFVVEhPUlMudHh0IChodHRwOi8vanF1ZXJ5dWkuY29tL2Fib3V0KVxyXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgb3IgR1BMIFZlcnNpb24gMiBsaWNlbnNlcy5cclxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxyXG4gKlxyXG4gKiBodHRwOi8vZG9jcy5qcXVlcnkuY29tL1VJL0RyYWdnYWJsZXNcclxuICpcclxuICogRGVwZW5kczpcclxuICpcdGpxdWVyeS51aS5jb3JlLmpzXHJcbiAqXHRqcXVlcnkudWkubW91c2UuanNcclxuICpcdGpxdWVyeS51aS53aWRnZXQuanNcclxuICovXHJcbihmdW5jdGlvbihkKXtkLndpZGdldChcInVpLmRyYWdnYWJsZVwiLGQudWkubW91c2Use3dpZGdldEV2ZW50UHJlZml4OlwiZHJhZ1wiLG9wdGlvbnM6e2FkZENsYXNzZXM6dHJ1ZSxhcHBlbmRUbzpcInBhcmVudFwiLGF4aXM6ZmFsc2UsY29ubmVjdFRvU29ydGFibGU6ZmFsc2UsY29udGFpbm1lbnQ6ZmFsc2UsY3Vyc29yOlwiYXV0b1wiLGN1cnNvckF0OmZhbHNlLGdyaWQ6ZmFsc2UsaGFuZGxlOmZhbHNlLGhlbHBlcjpcIm9yaWdpbmFsXCIsaWZyYW1lRml4OmZhbHNlLG9wYWNpdHk6ZmFsc2UscmVmcmVzaFBvc2l0aW9uczpmYWxzZSxyZXZlcnQ6ZmFsc2UscmV2ZXJ0RHVyYXRpb246NTAwLHNjb3BlOlwiZGVmYXVsdFwiLHNjcm9sbDp0cnVlLHNjcm9sbFNlbnNpdGl2aXR5OjIwLHNjcm9sbFNwZWVkOjIwLHNuYXA6ZmFsc2Usc25hcE1vZGU6XCJib3RoXCIsc25hcFRvbGVyYW5jZToyMCxzdGFjazpmYWxzZSx6SW5kZXg6ZmFsc2V9LF9jcmVhdGU6ZnVuY3Rpb24oKXtpZih0aGlzLm9wdGlvbnMuaGVscGVyPT1cclxuXCJvcmlnaW5hbFwiJiYhL14oPzpyfGF8ZikvLnRlc3QodGhpcy5lbGVtZW50LmNzcyhcInBvc2l0aW9uXCIpKSl0aGlzLmVsZW1lbnRbMF0uc3R5bGUucG9zaXRpb249XCJyZWxhdGl2ZVwiO3RoaXMub3B0aW9ucy5hZGRDbGFzc2VzJiZ0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoXCJ1aS1kcmFnZ2FibGVcIik7dGhpcy5vcHRpb25zLmRpc2FibGVkJiZ0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoXCJ1aS1kcmFnZ2FibGUtZGlzYWJsZWRcIik7dGhpcy5fbW91c2VJbml0KCl9LGRlc3Ryb3k6ZnVuY3Rpb24oKXtpZih0aGlzLmVsZW1lbnQuZGF0YShcImRyYWdnYWJsZVwiKSl7dGhpcy5lbGVtZW50LnJlbW92ZURhdGEoXCJkcmFnZ2FibGVcIikudW5iaW5kKFwiLmRyYWdnYWJsZVwiKS5yZW1vdmVDbGFzcyhcInVpLWRyYWdnYWJsZSB1aS1kcmFnZ2FibGUtZHJhZ2dpbmcgdWktZHJhZ2dhYmxlLWRpc2FibGVkXCIpO3RoaXMuX21vdXNlRGVzdHJveSgpO3JldHVybiB0aGlzfX0sX21vdXNlQ2FwdHVyZTpmdW5jdGlvbihhKXt2YXIgYj1cclxudGhpcy5vcHRpb25zO2lmKHRoaXMuaGVscGVyfHxiLmRpc2FibGVkfHxkKGEudGFyZ2V0KS5pcyhcIi51aS1yZXNpemFibGUtaGFuZGxlXCIpKXJldHVybiBmYWxzZTt0aGlzLmhhbmRsZT10aGlzLl9nZXRIYW5kbGUoYSk7aWYoIXRoaXMuaGFuZGxlKXJldHVybiBmYWxzZTtpZihiLmlmcmFtZUZpeClkKGIuaWZyYW1lRml4PT09dHJ1ZT9cImlmcmFtZVwiOmIuaWZyYW1lRml4KS5lYWNoKGZ1bmN0aW9uKCl7ZCgnPGRpdiBjbGFzcz1cInVpLWRyYWdnYWJsZS1pZnJhbWVGaXhcIiBzdHlsZT1cImJhY2tncm91bmQ6ICNmZmY7XCI+PC9kaXY+JykuY3NzKHt3aWR0aDp0aGlzLm9mZnNldFdpZHRoK1wicHhcIixoZWlnaHQ6dGhpcy5vZmZzZXRIZWlnaHQrXCJweFwiLHBvc2l0aW9uOlwiYWJzb2x1dGVcIixvcGFjaXR5OlwiMC4wMDFcIix6SW5kZXg6MUUzfSkuY3NzKGQodGhpcykub2Zmc2V0KCkpLmFwcGVuZFRvKFwiYm9keVwiKX0pO3JldHVybiB0cnVlfSxfbW91c2VTdGFydDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLm9wdGlvbnM7XHJcbnRoaXMuaGVscGVyPXRoaXMuX2NyZWF0ZUhlbHBlcihhKTt0aGlzLl9jYWNoZUhlbHBlclByb3BvcnRpb25zKCk7aWYoZC51aS5kZG1hbmFnZXIpZC51aS5kZG1hbmFnZXIuY3VycmVudD10aGlzO3RoaXMuX2NhY2hlTWFyZ2lucygpO3RoaXMuY3NzUG9zaXRpb249dGhpcy5oZWxwZXIuY3NzKFwicG9zaXRpb25cIik7dGhpcy5zY3JvbGxQYXJlbnQ9dGhpcy5oZWxwZXIuc2Nyb2xsUGFyZW50KCk7dGhpcy5vZmZzZXQ9dGhpcy5wb3NpdGlvbkFicz10aGlzLmVsZW1lbnQub2Zmc2V0KCk7dGhpcy5vZmZzZXQ9e3RvcDp0aGlzLm9mZnNldC50b3AtdGhpcy5tYXJnaW5zLnRvcCxsZWZ0OnRoaXMub2Zmc2V0LmxlZnQtdGhpcy5tYXJnaW5zLmxlZnR9O2QuZXh0ZW5kKHRoaXMub2Zmc2V0LHtjbGljazp7bGVmdDphLnBhZ2VYLXRoaXMub2Zmc2V0LmxlZnQsdG9wOmEucGFnZVktdGhpcy5vZmZzZXQudG9wfSxwYXJlbnQ6dGhpcy5fZ2V0UGFyZW50T2Zmc2V0KCkscmVsYXRpdmU6dGhpcy5fZ2V0UmVsYXRpdmVPZmZzZXQoKX0pO1xyXG50aGlzLm9yaWdpbmFsUG9zaXRpb249dGhpcy5wb3NpdGlvbj10aGlzLl9nZW5lcmF0ZVBvc2l0aW9uKGEpO3RoaXMub3JpZ2luYWxQYWdlWD1hLnBhZ2VYO3RoaXMub3JpZ2luYWxQYWdlWT1hLnBhZ2VZO2IuY3Vyc29yQXQmJnRoaXMuX2FkanVzdE9mZnNldEZyb21IZWxwZXIoYi5jdXJzb3JBdCk7Yi5jb250YWlubWVudCYmdGhpcy5fc2V0Q29udGFpbm1lbnQoKTtpZih0aGlzLl90cmlnZ2VyKFwic3RhcnRcIixhKT09PWZhbHNlKXt0aGlzLl9jbGVhcigpO3JldHVybiBmYWxzZX10aGlzLl9jYWNoZUhlbHBlclByb3BvcnRpb25zKCk7ZC51aS5kZG1hbmFnZXImJiFiLmRyb3BCZWhhdmlvdXImJmQudWkuZGRtYW5hZ2VyLnByZXBhcmVPZmZzZXRzKHRoaXMsYSk7dGhpcy5oZWxwZXIuYWRkQ2xhc3MoXCJ1aS1kcmFnZ2FibGUtZHJhZ2dpbmdcIik7dGhpcy5fbW91c2VEcmFnKGEsdHJ1ZSk7ZC51aS5kZG1hbmFnZXImJmQudWkuZGRtYW5hZ2VyLmRyYWdTdGFydCh0aGlzLGEpO3JldHVybiB0cnVlfSxcclxuX21vdXNlRHJhZzpmdW5jdGlvbihhLGIpe3RoaXMucG9zaXRpb249dGhpcy5fZ2VuZXJhdGVQb3NpdGlvbihhKTt0aGlzLnBvc2l0aW9uQWJzPXRoaXMuX2NvbnZlcnRQb3NpdGlvblRvKFwiYWJzb2x1dGVcIik7aWYoIWIpe2I9dGhpcy5fdWlIYXNoKCk7aWYodGhpcy5fdHJpZ2dlcihcImRyYWdcIixhLGIpPT09ZmFsc2Upe3RoaXMuX21vdXNlVXAoe30pO3JldHVybiBmYWxzZX10aGlzLnBvc2l0aW9uPWIucG9zaXRpb259aWYoIXRoaXMub3B0aW9ucy5heGlzfHx0aGlzLm9wdGlvbnMuYXhpcyE9XCJ5XCIpdGhpcy5oZWxwZXJbMF0uc3R5bGUubGVmdD10aGlzLnBvc2l0aW9uLmxlZnQrXCJweFwiO2lmKCF0aGlzLm9wdGlvbnMuYXhpc3x8dGhpcy5vcHRpb25zLmF4aXMhPVwieFwiKXRoaXMuaGVscGVyWzBdLnN0eWxlLnRvcD10aGlzLnBvc2l0aW9uLnRvcCtcInB4XCI7ZC51aS5kZG1hbmFnZXImJmQudWkuZGRtYW5hZ2VyLmRyYWcodGhpcyxhKTtyZXR1cm4gZmFsc2V9LF9tb3VzZVN0b3A6ZnVuY3Rpb24oYSl7dmFyIGI9XHJcbmZhbHNlO2lmKGQudWkuZGRtYW5hZ2VyJiYhdGhpcy5vcHRpb25zLmRyb3BCZWhhdmlvdXIpYj1kLnVpLmRkbWFuYWdlci5kcm9wKHRoaXMsYSk7aWYodGhpcy5kcm9wcGVkKXtiPXRoaXMuZHJvcHBlZDt0aGlzLmRyb3BwZWQ9ZmFsc2V9aWYoKCF0aGlzLmVsZW1lbnRbMF18fCF0aGlzLmVsZW1lbnRbMF0ucGFyZW50Tm9kZSkmJnRoaXMub3B0aW9ucy5oZWxwZXI9PVwib3JpZ2luYWxcIilyZXR1cm4gZmFsc2U7aWYodGhpcy5vcHRpb25zLnJldmVydD09XCJpbnZhbGlkXCImJiFifHx0aGlzLm9wdGlvbnMucmV2ZXJ0PT1cInZhbGlkXCImJmJ8fHRoaXMub3B0aW9ucy5yZXZlcnQ9PT10cnVlfHxkLmlzRnVuY3Rpb24odGhpcy5vcHRpb25zLnJldmVydCkmJnRoaXMub3B0aW9ucy5yZXZlcnQuY2FsbCh0aGlzLmVsZW1lbnQsYikpe3ZhciBjPXRoaXM7ZCh0aGlzLmhlbHBlcikuYW5pbWF0ZSh0aGlzLm9yaWdpbmFsUG9zaXRpb24scGFyc2VJbnQodGhpcy5vcHRpb25zLnJldmVydER1cmF0aW9uLFxyXG4xMCksZnVuY3Rpb24oKXtjLl90cmlnZ2VyKFwic3RvcFwiLGEpIT09ZmFsc2UmJmMuX2NsZWFyKCl9KX1lbHNlIHRoaXMuX3RyaWdnZXIoXCJzdG9wXCIsYSkhPT1mYWxzZSYmdGhpcy5fY2xlYXIoKTtyZXR1cm4gZmFsc2V9LF9tb3VzZVVwOmZ1bmN0aW9uKGEpe3RoaXMub3B0aW9ucy5pZnJhbWVGaXg9PT10cnVlJiZkKFwiZGl2LnVpLWRyYWdnYWJsZS1pZnJhbWVGaXhcIikuZWFjaChmdW5jdGlvbigpe3RoaXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzKX0pO2QudWkuZGRtYW5hZ2VyJiZkLnVpLmRkbWFuYWdlci5kcmFnU3RvcCh0aGlzLGEpO3JldHVybiBkLnVpLm1vdXNlLnByb3RvdHlwZS5fbW91c2VVcC5jYWxsKHRoaXMsYSl9LGNhbmNlbDpmdW5jdGlvbigpe3RoaXMuaGVscGVyLmlzKFwiLnVpLWRyYWdnYWJsZS1kcmFnZ2luZ1wiKT90aGlzLl9tb3VzZVVwKHt9KTp0aGlzLl9jbGVhcigpO3JldHVybiB0aGlzfSxfZ2V0SGFuZGxlOmZ1bmN0aW9uKGEpe3ZhciBiPSF0aGlzLm9wdGlvbnMuaGFuZGxlfHxcclxuIWQodGhpcy5vcHRpb25zLmhhbmRsZSx0aGlzLmVsZW1lbnQpLmxlbmd0aD90cnVlOmZhbHNlO2QodGhpcy5vcHRpb25zLmhhbmRsZSx0aGlzLmVsZW1lbnQpLmZpbmQoXCIqXCIpLmFuZFNlbGYoKS5lYWNoKGZ1bmN0aW9uKCl7aWYodGhpcz09YS50YXJnZXQpYj10cnVlfSk7cmV0dXJuIGJ9LF9jcmVhdGVIZWxwZXI6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5vcHRpb25zO2E9ZC5pc0Z1bmN0aW9uKGIuaGVscGVyKT9kKGIuaGVscGVyLmFwcGx5KHRoaXMuZWxlbWVudFswXSxbYV0pKTpiLmhlbHBlcj09XCJjbG9uZVwiP3RoaXMuZWxlbWVudC5jbG9uZSgpLnJlbW92ZUF0dHIoXCJpZFwiKTp0aGlzLmVsZW1lbnQ7YS5wYXJlbnRzKFwiYm9keVwiKS5sZW5ndGh8fGEuYXBwZW5kVG8oYi5hcHBlbmRUbz09XCJwYXJlbnRcIj90aGlzLmVsZW1lbnRbMF0ucGFyZW50Tm9kZTpiLmFwcGVuZFRvKTthWzBdIT10aGlzLmVsZW1lbnRbMF0mJiEvKGZpeGVkfGFic29sdXRlKS8udGVzdChhLmNzcyhcInBvc2l0aW9uXCIpKSYmXHJcbmEuY3NzKFwicG9zaXRpb25cIixcImFic29sdXRlXCIpO3JldHVybiBhfSxfYWRqdXN0T2Zmc2V0RnJvbUhlbHBlcjpmdW5jdGlvbihhKXtpZih0eXBlb2YgYT09XCJzdHJpbmdcIilhPWEuc3BsaXQoXCIgXCIpO2lmKGQuaXNBcnJheShhKSlhPXtsZWZ0OithWzBdLHRvcDorYVsxXXx8MH07aWYoXCJsZWZ0XCJpbiBhKXRoaXMub2Zmc2V0LmNsaWNrLmxlZnQ9YS5sZWZ0K3RoaXMubWFyZ2lucy5sZWZ0O2lmKFwicmlnaHRcImluIGEpdGhpcy5vZmZzZXQuY2xpY2subGVmdD10aGlzLmhlbHBlclByb3BvcnRpb25zLndpZHRoLWEucmlnaHQrdGhpcy5tYXJnaW5zLmxlZnQ7aWYoXCJ0b3BcImluIGEpdGhpcy5vZmZzZXQuY2xpY2sudG9wPWEudG9wK3RoaXMubWFyZ2lucy50b3A7aWYoXCJib3R0b21cImluIGEpdGhpcy5vZmZzZXQuY2xpY2sudG9wPXRoaXMuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0LWEuYm90dG9tK3RoaXMubWFyZ2lucy50b3B9LF9nZXRQYXJlbnRPZmZzZXQ6ZnVuY3Rpb24oKXt0aGlzLm9mZnNldFBhcmVudD1cclxudGhpcy5oZWxwZXIub2Zmc2V0UGFyZW50KCk7dmFyIGE9dGhpcy5vZmZzZXRQYXJlbnQub2Zmc2V0KCk7aWYodGhpcy5jc3NQb3NpdGlvbj09XCJhYnNvbHV0ZVwiJiZ0aGlzLnNjcm9sbFBhcmVudFswXSE9ZG9jdW1lbnQmJmQudWkuY29udGFpbnModGhpcy5zY3JvbGxQYXJlbnRbMF0sdGhpcy5vZmZzZXRQYXJlbnRbMF0pKXthLmxlZnQrPXRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbExlZnQoKTthLnRvcCs9dGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsVG9wKCl9aWYodGhpcy5vZmZzZXRQYXJlbnRbMF09PWRvY3VtZW50LmJvZHl8fHRoaXMub2Zmc2V0UGFyZW50WzBdLnRhZ05hbWUmJnRoaXMub2Zmc2V0UGFyZW50WzBdLnRhZ05hbWUudG9Mb3dlckNhc2UoKT09XCJodG1sXCImJmQuYnJvd3Nlci5tc2llKWE9e3RvcDowLGxlZnQ6MH07cmV0dXJue3RvcDphLnRvcCsocGFyc2VJbnQodGhpcy5vZmZzZXRQYXJlbnQuY3NzKFwiYm9yZGVyVG9wV2lkdGhcIiksMTApfHwwKSxsZWZ0OmEubGVmdCsocGFyc2VJbnQodGhpcy5vZmZzZXRQYXJlbnQuY3NzKFwiYm9yZGVyTGVmdFdpZHRoXCIpLFxyXG4xMCl8fDApfX0sX2dldFJlbGF0aXZlT2Zmc2V0OmZ1bmN0aW9uKCl7aWYodGhpcy5jc3NQb3NpdGlvbj09XCJyZWxhdGl2ZVwiKXt2YXIgYT10aGlzLmVsZW1lbnQucG9zaXRpb24oKTtyZXR1cm57dG9wOmEudG9wLShwYXJzZUludCh0aGlzLmhlbHBlci5jc3MoXCJ0b3BcIiksMTApfHwwKSt0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxUb3AoKSxsZWZ0OmEubGVmdC0ocGFyc2VJbnQodGhpcy5oZWxwZXIuY3NzKFwibGVmdFwiKSwxMCl8fDApK3RoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbExlZnQoKX19ZWxzZSByZXR1cm57dG9wOjAsbGVmdDowfX0sX2NhY2hlTWFyZ2luczpmdW5jdGlvbigpe3RoaXMubWFyZ2lucz17bGVmdDpwYXJzZUludCh0aGlzLmVsZW1lbnQuY3NzKFwibWFyZ2luTGVmdFwiKSwxMCl8fDAsdG9wOnBhcnNlSW50KHRoaXMuZWxlbWVudC5jc3MoXCJtYXJnaW5Ub3BcIiksMTApfHwwLHJpZ2h0OnBhcnNlSW50KHRoaXMuZWxlbWVudC5jc3MoXCJtYXJnaW5SaWdodFwiKSwxMCl8fDAsYm90dG9tOnBhcnNlSW50KHRoaXMuZWxlbWVudC5jc3MoXCJtYXJnaW5Cb3R0b21cIiksXHJcbjEwKXx8MH19LF9jYWNoZUhlbHBlclByb3BvcnRpb25zOmZ1bmN0aW9uKCl7dGhpcy5oZWxwZXJQcm9wb3J0aW9ucz17d2lkdGg6dGhpcy5oZWxwZXIub3V0ZXJXaWR0aCgpLGhlaWdodDp0aGlzLmhlbHBlci5vdXRlckhlaWdodCgpfX0sX3NldENvbnRhaW5tZW50OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5vcHRpb25zO2lmKGEuY29udGFpbm1lbnQ9PVwicGFyZW50XCIpYS5jb250YWlubWVudD10aGlzLmhlbHBlclswXS5wYXJlbnROb2RlO2lmKGEuY29udGFpbm1lbnQ9PVwiZG9jdW1lbnRcInx8YS5jb250YWlubWVudD09XCJ3aW5kb3dcIil0aGlzLmNvbnRhaW5tZW50PVthLmNvbnRhaW5tZW50PT1cImRvY3VtZW50XCI/MDpkKHdpbmRvdykuc2Nyb2xsTGVmdCgpLXRoaXMub2Zmc2V0LnJlbGF0aXZlLmxlZnQtdGhpcy5vZmZzZXQucGFyZW50LmxlZnQsYS5jb250YWlubWVudD09XCJkb2N1bWVudFwiPzA6ZCh3aW5kb3cpLnNjcm9sbFRvcCgpLXRoaXMub2Zmc2V0LnJlbGF0aXZlLnRvcC10aGlzLm9mZnNldC5wYXJlbnQudG9wLFxyXG4oYS5jb250YWlubWVudD09XCJkb2N1bWVudFwiPzA6ZCh3aW5kb3cpLnNjcm9sbExlZnQoKSkrZChhLmNvbnRhaW5tZW50PT1cImRvY3VtZW50XCI/ZG9jdW1lbnQ6d2luZG93KS53aWR0aCgpLXRoaXMuaGVscGVyUHJvcG9ydGlvbnMud2lkdGgtdGhpcy5tYXJnaW5zLmxlZnQsKGEuY29udGFpbm1lbnQ9PVwiZG9jdW1lbnRcIj8wOmQod2luZG93KS5zY3JvbGxUb3AoKSkrKGQoYS5jb250YWlubWVudD09XCJkb2N1bWVudFwiP2RvY3VtZW50OndpbmRvdykuaGVpZ2h0KCl8fGRvY3VtZW50LmJvZHkucGFyZW50Tm9kZS5zY3JvbGxIZWlnaHQpLXRoaXMuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0LXRoaXMubWFyZ2lucy50b3BdO2lmKCEvXihkb2N1bWVudHx3aW5kb3d8cGFyZW50KSQvLnRlc3QoYS5jb250YWlubWVudCkmJmEuY29udGFpbm1lbnQuY29uc3RydWN0b3IhPUFycmF5KXthPWQoYS5jb250YWlubWVudCk7dmFyIGI9YVswXTtpZihiKXthLm9mZnNldCgpO3ZhciBjPWQoYikuY3NzKFwib3ZlcmZsb3dcIikhPVxyXG5cImhpZGRlblwiO3RoaXMuY29udGFpbm1lbnQ9WyhwYXJzZUludChkKGIpLmNzcyhcImJvcmRlckxlZnRXaWR0aFwiKSwxMCl8fDApKyhwYXJzZUludChkKGIpLmNzcyhcInBhZGRpbmdMZWZ0XCIpLDEwKXx8MCksKHBhcnNlSW50KGQoYikuY3NzKFwiYm9yZGVyVG9wV2lkdGhcIiksMTApfHwwKSsocGFyc2VJbnQoZChiKS5jc3MoXCJwYWRkaW5nVG9wXCIpLDEwKXx8MCksKGM/TWF0aC5tYXgoYi5zY3JvbGxXaWR0aCxiLm9mZnNldFdpZHRoKTpiLm9mZnNldFdpZHRoKS0ocGFyc2VJbnQoZChiKS5jc3MoXCJib3JkZXJMZWZ0V2lkdGhcIiksMTApfHwwKS0ocGFyc2VJbnQoZChiKS5jc3MoXCJwYWRkaW5nUmlnaHRcIiksMTApfHwwKS10aGlzLmhlbHBlclByb3BvcnRpb25zLndpZHRoLXRoaXMubWFyZ2lucy5sZWZ0LXRoaXMubWFyZ2lucy5yaWdodCwoYz9NYXRoLm1heChiLnNjcm9sbEhlaWdodCxiLm9mZnNldEhlaWdodCk6Yi5vZmZzZXRIZWlnaHQpLShwYXJzZUludChkKGIpLmNzcyhcImJvcmRlclRvcFdpZHRoXCIpLFxyXG4xMCl8fDApLShwYXJzZUludChkKGIpLmNzcyhcInBhZGRpbmdCb3R0b21cIiksMTApfHwwKS10aGlzLmhlbHBlclByb3BvcnRpb25zLmhlaWdodC10aGlzLm1hcmdpbnMudG9wLXRoaXMubWFyZ2lucy5ib3R0b21dO3RoaXMucmVsYXRpdmVfY29udGFpbmVyPWF9fWVsc2UgaWYoYS5jb250YWlubWVudC5jb25zdHJ1Y3Rvcj09QXJyYXkpdGhpcy5jb250YWlubWVudD1hLmNvbnRhaW5tZW50fSxfY29udmVydFBvc2l0aW9uVG86ZnVuY3Rpb24oYSxiKXtpZighYiliPXRoaXMucG9zaXRpb247YT1hPT1cImFic29sdXRlXCI/MTotMTt2YXIgYz10aGlzLmNzc1Bvc2l0aW9uPT1cImFic29sdXRlXCImJiEodGhpcy5zY3JvbGxQYXJlbnRbMF0hPWRvY3VtZW50JiZkLnVpLmNvbnRhaW5zKHRoaXMuc2Nyb2xsUGFyZW50WzBdLHRoaXMub2Zmc2V0UGFyZW50WzBdKSk/dGhpcy5vZmZzZXRQYXJlbnQ6dGhpcy5zY3JvbGxQYXJlbnQsZj0vKGh0bWx8Ym9keSkvaS50ZXN0KGNbMF0udGFnTmFtZSk7cmV0dXJue3RvcDpiLnRvcCtcclxudGhpcy5vZmZzZXQucmVsYXRpdmUudG9wKmErdGhpcy5vZmZzZXQucGFyZW50LnRvcCphLShkLmJyb3dzZXIuc2FmYXJpJiZkLmJyb3dzZXIudmVyc2lvbjw1MjYmJnRoaXMuY3NzUG9zaXRpb249PVwiZml4ZWRcIj8wOih0aGlzLmNzc1Bvc2l0aW9uPT1cImZpeGVkXCI/LXRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCgpOmY/MDpjLnNjcm9sbFRvcCgpKSphKSxsZWZ0OmIubGVmdCt0aGlzLm9mZnNldC5yZWxhdGl2ZS5sZWZ0KmErdGhpcy5vZmZzZXQucGFyZW50LmxlZnQqYS0oZC5icm93c2VyLnNhZmFyaSYmZC5icm93c2VyLnZlcnNpb248NTI2JiZ0aGlzLmNzc1Bvc2l0aW9uPT1cImZpeGVkXCI/MDoodGhpcy5jc3NQb3NpdGlvbj09XCJmaXhlZFwiPy10aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0KCk6Zj8wOmMuc2Nyb2xsTGVmdCgpKSphKX19LF9nZW5lcmF0ZVBvc2l0aW9uOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMub3B0aW9ucyxjPXRoaXMuY3NzUG9zaXRpb249PVwiYWJzb2x1dGVcIiYmXHJcbiEodGhpcy5zY3JvbGxQYXJlbnRbMF0hPWRvY3VtZW50JiZkLnVpLmNvbnRhaW5zKHRoaXMuc2Nyb2xsUGFyZW50WzBdLHRoaXMub2Zmc2V0UGFyZW50WzBdKSk/dGhpcy5vZmZzZXRQYXJlbnQ6dGhpcy5zY3JvbGxQYXJlbnQsZj0vKGh0bWx8Ym9keSkvaS50ZXN0KGNbMF0udGFnTmFtZSksZT1hLnBhZ2VYLGg9YS5wYWdlWTtpZih0aGlzLm9yaWdpbmFsUG9zaXRpb24pe3ZhciBnO2lmKHRoaXMuY29udGFpbm1lbnQpe2lmKHRoaXMucmVsYXRpdmVfY29udGFpbmVyKXtnPXRoaXMucmVsYXRpdmVfY29udGFpbmVyLm9mZnNldCgpO2c9W3RoaXMuY29udGFpbm1lbnRbMF0rZy5sZWZ0LHRoaXMuY29udGFpbm1lbnRbMV0rZy50b3AsdGhpcy5jb250YWlubWVudFsyXStnLmxlZnQsdGhpcy5jb250YWlubWVudFszXStnLnRvcF19ZWxzZSBnPXRoaXMuY29udGFpbm1lbnQ7aWYoYS5wYWdlWC10aGlzLm9mZnNldC5jbGljay5sZWZ0PGdbMF0pZT1nWzBdK3RoaXMub2Zmc2V0LmNsaWNrLmxlZnQ7XHJcbmlmKGEucGFnZVktdGhpcy5vZmZzZXQuY2xpY2sudG9wPGdbMV0paD1nWzFdK3RoaXMub2Zmc2V0LmNsaWNrLnRvcDtpZihhLnBhZ2VYLXRoaXMub2Zmc2V0LmNsaWNrLmxlZnQ+Z1syXSllPWdbMl0rdGhpcy5vZmZzZXQuY2xpY2subGVmdDtpZihhLnBhZ2VZLXRoaXMub2Zmc2V0LmNsaWNrLnRvcD5nWzNdKWg9Z1szXSt0aGlzLm9mZnNldC5jbGljay50b3B9aWYoYi5ncmlkKXtoPWIuZ3JpZFsxXT90aGlzLm9yaWdpbmFsUGFnZVkrTWF0aC5yb3VuZCgoaC10aGlzLm9yaWdpbmFsUGFnZVkpL2IuZ3JpZFsxXSkqYi5ncmlkWzFdOnRoaXMub3JpZ2luYWxQYWdlWTtoPWc/IShoLXRoaXMub2Zmc2V0LmNsaWNrLnRvcDxnWzFdfHxoLXRoaXMub2Zmc2V0LmNsaWNrLnRvcD5nWzNdKT9oOiEoaC10aGlzLm9mZnNldC5jbGljay50b3A8Z1sxXSk/aC1iLmdyaWRbMV06aCtiLmdyaWRbMV06aDtlPWIuZ3JpZFswXT90aGlzLm9yaWdpbmFsUGFnZVgrTWF0aC5yb3VuZCgoZS10aGlzLm9yaWdpbmFsUGFnZVgpL1xyXG5iLmdyaWRbMF0pKmIuZ3JpZFswXTp0aGlzLm9yaWdpbmFsUGFnZVg7ZT1nPyEoZS10aGlzLm9mZnNldC5jbGljay5sZWZ0PGdbMF18fGUtdGhpcy5vZmZzZXQuY2xpY2subGVmdD5nWzJdKT9lOiEoZS10aGlzLm9mZnNldC5jbGljay5sZWZ0PGdbMF0pP2UtYi5ncmlkWzBdOmUrYi5ncmlkWzBdOmV9fXJldHVybnt0b3A6aC10aGlzLm9mZnNldC5jbGljay50b3AtdGhpcy5vZmZzZXQucmVsYXRpdmUudG9wLXRoaXMub2Zmc2V0LnBhcmVudC50b3ArKGQuYnJvd3Nlci5zYWZhcmkmJmQuYnJvd3Nlci52ZXJzaW9uPDUyNiYmdGhpcy5jc3NQb3NpdGlvbj09XCJmaXhlZFwiPzA6dGhpcy5jc3NQb3NpdGlvbj09XCJmaXhlZFwiPy10aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxUb3AoKTpmPzA6Yy5zY3JvbGxUb3AoKSksbGVmdDplLXRoaXMub2Zmc2V0LmNsaWNrLmxlZnQtdGhpcy5vZmZzZXQucmVsYXRpdmUubGVmdC10aGlzLm9mZnNldC5wYXJlbnQubGVmdCsoZC5icm93c2VyLnNhZmFyaSYmZC5icm93c2VyLnZlcnNpb248XHJcbjUyNiYmdGhpcy5jc3NQb3NpdGlvbj09XCJmaXhlZFwiPzA6dGhpcy5jc3NQb3NpdGlvbj09XCJmaXhlZFwiPy10aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0KCk6Zj8wOmMuc2Nyb2xsTGVmdCgpKX19LF9jbGVhcjpmdW5jdGlvbigpe3RoaXMuaGVscGVyLnJlbW92ZUNsYXNzKFwidWktZHJhZ2dhYmxlLWRyYWdnaW5nXCIpO3RoaXMuaGVscGVyWzBdIT10aGlzLmVsZW1lbnRbMF0mJiF0aGlzLmNhbmNlbEhlbHBlclJlbW92YWwmJnRoaXMuaGVscGVyLnJlbW92ZSgpO3RoaXMuaGVscGVyPW51bGw7dGhpcy5jYW5jZWxIZWxwZXJSZW1vdmFsPWZhbHNlfSxfdHJpZ2dlcjpmdW5jdGlvbihhLGIsYyl7Yz1jfHx0aGlzLl91aUhhc2goKTtkLnVpLnBsdWdpbi5jYWxsKHRoaXMsYSxbYixjXSk7aWYoYT09XCJkcmFnXCIpdGhpcy5wb3NpdGlvbkFicz10aGlzLl9jb252ZXJ0UG9zaXRpb25UbyhcImFic29sdXRlXCIpO3JldHVybiBkLldpZGdldC5wcm90b3R5cGUuX3RyaWdnZXIuY2FsbCh0aGlzLGEsYixcclxuYyl9LHBsdWdpbnM6e30sX3VpSGFzaDpmdW5jdGlvbigpe3JldHVybntoZWxwZXI6dGhpcy5oZWxwZXIscG9zaXRpb246dGhpcy5wb3NpdGlvbixvcmlnaW5hbFBvc2l0aW9uOnRoaXMub3JpZ2luYWxQb3NpdGlvbixvZmZzZXQ6dGhpcy5wb3NpdGlvbkFic319fSk7ZC5leHRlbmQoZC51aS5kcmFnZ2FibGUse3ZlcnNpb246XCIxLjguMTZcIn0pO2QudWkucGx1Z2luLmFkZChcImRyYWdnYWJsZVwiLFwiY29ubmVjdFRvU29ydGFibGVcIix7c3RhcnQ6ZnVuY3Rpb24oYSxiKXt2YXIgYz1kKHRoaXMpLmRhdGEoXCJkcmFnZ2FibGVcIiksZj1jLm9wdGlvbnMsZT1kLmV4dGVuZCh7fSxiLHtpdGVtOmMuZWxlbWVudH0pO2Muc29ydGFibGVzPVtdO2QoZi5jb25uZWN0VG9Tb3J0YWJsZSkuZWFjaChmdW5jdGlvbigpe3ZhciBoPWQuZGF0YSh0aGlzLFwic29ydGFibGVcIik7aWYoaCYmIWgub3B0aW9ucy5kaXNhYmxlZCl7Yy5zb3J0YWJsZXMucHVzaCh7aW5zdGFuY2U6aCxzaG91bGRSZXZlcnQ6aC5vcHRpb25zLnJldmVydH0pO1xyXG5oLnJlZnJlc2hQb3NpdGlvbnMoKTtoLl90cmlnZ2VyKFwiYWN0aXZhdGVcIixhLGUpfX0pfSxzdG9wOmZ1bmN0aW9uKGEsYil7dmFyIGM9ZCh0aGlzKS5kYXRhKFwiZHJhZ2dhYmxlXCIpLGY9ZC5leHRlbmQoe30sYix7aXRlbTpjLmVsZW1lbnR9KTtkLmVhY2goYy5zb3J0YWJsZXMsZnVuY3Rpb24oKXtpZih0aGlzLmluc3RhbmNlLmlzT3Zlcil7dGhpcy5pbnN0YW5jZS5pc092ZXI9MDtjLmNhbmNlbEhlbHBlclJlbW92YWw9dHJ1ZTt0aGlzLmluc3RhbmNlLmNhbmNlbEhlbHBlclJlbW92YWw9ZmFsc2U7aWYodGhpcy5zaG91bGRSZXZlcnQpdGhpcy5pbnN0YW5jZS5vcHRpb25zLnJldmVydD10cnVlO3RoaXMuaW5zdGFuY2UuX21vdXNlU3RvcChhKTt0aGlzLmluc3RhbmNlLm9wdGlvbnMuaGVscGVyPXRoaXMuaW5zdGFuY2Uub3B0aW9ucy5faGVscGVyO2Mub3B0aW9ucy5oZWxwZXI9PVwib3JpZ2luYWxcIiYmdGhpcy5pbnN0YW5jZS5jdXJyZW50SXRlbS5jc3Moe3RvcDpcImF1dG9cIixsZWZ0OlwiYXV0b1wifSl9ZWxzZXt0aGlzLmluc3RhbmNlLmNhbmNlbEhlbHBlclJlbW92YWw9XHJcbmZhbHNlO3RoaXMuaW5zdGFuY2UuX3RyaWdnZXIoXCJkZWFjdGl2YXRlXCIsYSxmKX19KX0sZHJhZzpmdW5jdGlvbihhLGIpe3ZhciBjPWQodGhpcykuZGF0YShcImRyYWdnYWJsZVwiKSxmPXRoaXM7ZC5lYWNoKGMuc29ydGFibGVzLGZ1bmN0aW9uKCl7dGhpcy5pbnN0YW5jZS5wb3NpdGlvbkFicz1jLnBvc2l0aW9uQWJzO3RoaXMuaW5zdGFuY2UuaGVscGVyUHJvcG9ydGlvbnM9Yy5oZWxwZXJQcm9wb3J0aW9uczt0aGlzLmluc3RhbmNlLm9mZnNldC5jbGljaz1jLm9mZnNldC5jbGljaztpZih0aGlzLmluc3RhbmNlLl9pbnRlcnNlY3RzV2l0aCh0aGlzLmluc3RhbmNlLmNvbnRhaW5lckNhY2hlKSl7aWYoIXRoaXMuaW5zdGFuY2UuaXNPdmVyKXt0aGlzLmluc3RhbmNlLmlzT3Zlcj0xO3RoaXMuaW5zdGFuY2UuY3VycmVudEl0ZW09ZChmKS5jbG9uZSgpLnJlbW92ZUF0dHIoXCJpZFwiKS5hcHBlbmRUbyh0aGlzLmluc3RhbmNlLmVsZW1lbnQpLmRhdGEoXCJzb3J0YWJsZS1pdGVtXCIsdHJ1ZSk7XHJcbnRoaXMuaW5zdGFuY2Uub3B0aW9ucy5faGVscGVyPXRoaXMuaW5zdGFuY2Uub3B0aW9ucy5oZWxwZXI7dGhpcy5pbnN0YW5jZS5vcHRpb25zLmhlbHBlcj1mdW5jdGlvbigpe3JldHVybiBiLmhlbHBlclswXX07YS50YXJnZXQ9dGhpcy5pbnN0YW5jZS5jdXJyZW50SXRlbVswXTt0aGlzLmluc3RhbmNlLl9tb3VzZUNhcHR1cmUoYSx0cnVlKTt0aGlzLmluc3RhbmNlLl9tb3VzZVN0YXJ0KGEsdHJ1ZSx0cnVlKTt0aGlzLmluc3RhbmNlLm9mZnNldC5jbGljay50b3A9Yy5vZmZzZXQuY2xpY2sudG9wO3RoaXMuaW5zdGFuY2Uub2Zmc2V0LmNsaWNrLmxlZnQ9Yy5vZmZzZXQuY2xpY2subGVmdDt0aGlzLmluc3RhbmNlLm9mZnNldC5wYXJlbnQubGVmdC09Yy5vZmZzZXQucGFyZW50LmxlZnQtdGhpcy5pbnN0YW5jZS5vZmZzZXQucGFyZW50LmxlZnQ7dGhpcy5pbnN0YW5jZS5vZmZzZXQucGFyZW50LnRvcC09Yy5vZmZzZXQucGFyZW50LnRvcC10aGlzLmluc3RhbmNlLm9mZnNldC5wYXJlbnQudG9wO1xyXG5jLl90cmlnZ2VyKFwidG9Tb3J0YWJsZVwiLGEpO2MuZHJvcHBlZD10aGlzLmluc3RhbmNlLmVsZW1lbnQ7Yy5jdXJyZW50SXRlbT1jLmVsZW1lbnQ7dGhpcy5pbnN0YW5jZS5mcm9tT3V0c2lkZT1jfXRoaXMuaW5zdGFuY2UuY3VycmVudEl0ZW0mJnRoaXMuaW5zdGFuY2UuX21vdXNlRHJhZyhhKX1lbHNlIGlmKHRoaXMuaW5zdGFuY2UuaXNPdmVyKXt0aGlzLmluc3RhbmNlLmlzT3Zlcj0wO3RoaXMuaW5zdGFuY2UuY2FuY2VsSGVscGVyUmVtb3ZhbD10cnVlO3RoaXMuaW5zdGFuY2Uub3B0aW9ucy5yZXZlcnQ9ZmFsc2U7dGhpcy5pbnN0YW5jZS5fdHJpZ2dlcihcIm91dFwiLGEsdGhpcy5pbnN0YW5jZS5fdWlIYXNoKHRoaXMuaW5zdGFuY2UpKTt0aGlzLmluc3RhbmNlLl9tb3VzZVN0b3AoYSx0cnVlKTt0aGlzLmluc3RhbmNlLm9wdGlvbnMuaGVscGVyPXRoaXMuaW5zdGFuY2Uub3B0aW9ucy5faGVscGVyO3RoaXMuaW5zdGFuY2UuY3VycmVudEl0ZW0ucmVtb3ZlKCk7dGhpcy5pbnN0YW5jZS5wbGFjZWhvbGRlciYmXHJcbnRoaXMuaW5zdGFuY2UucGxhY2Vob2xkZXIucmVtb3ZlKCk7Yy5fdHJpZ2dlcihcImZyb21Tb3J0YWJsZVwiLGEpO2MuZHJvcHBlZD1mYWxzZX19KX19KTtkLnVpLnBsdWdpbi5hZGQoXCJkcmFnZ2FibGVcIixcImN1cnNvclwiLHtzdGFydDpmdW5jdGlvbigpe3ZhciBhPWQoXCJib2R5XCIpLGI9ZCh0aGlzKS5kYXRhKFwiZHJhZ2dhYmxlXCIpLm9wdGlvbnM7aWYoYS5jc3MoXCJjdXJzb3JcIikpYi5fY3Vyc29yPWEuY3NzKFwiY3Vyc29yXCIpO2EuY3NzKFwiY3Vyc29yXCIsYi5jdXJzb3IpfSxzdG9wOmZ1bmN0aW9uKCl7dmFyIGE9ZCh0aGlzKS5kYXRhKFwiZHJhZ2dhYmxlXCIpLm9wdGlvbnM7YS5fY3Vyc29yJiZkKFwiYm9keVwiKS5jc3MoXCJjdXJzb3JcIixhLl9jdXJzb3IpfX0pO2QudWkucGx1Z2luLmFkZChcImRyYWdnYWJsZVwiLFwib3BhY2l0eVwiLHtzdGFydDpmdW5jdGlvbihhLGIpe2E9ZChiLmhlbHBlcik7Yj1kKHRoaXMpLmRhdGEoXCJkcmFnZ2FibGVcIikub3B0aW9ucztpZihhLmNzcyhcIm9wYWNpdHlcIikpYi5fb3BhY2l0eT1cclxuYS5jc3MoXCJvcGFjaXR5XCIpO2EuY3NzKFwib3BhY2l0eVwiLGIub3BhY2l0eSl9LHN0b3A6ZnVuY3Rpb24oYSxiKXthPWQodGhpcykuZGF0YShcImRyYWdnYWJsZVwiKS5vcHRpb25zO2EuX29wYWNpdHkmJmQoYi5oZWxwZXIpLmNzcyhcIm9wYWNpdHlcIixhLl9vcGFjaXR5KX19KTtkLnVpLnBsdWdpbi5hZGQoXCJkcmFnZ2FibGVcIixcInNjcm9sbFwiLHtzdGFydDpmdW5jdGlvbigpe3ZhciBhPWQodGhpcykuZGF0YShcImRyYWdnYWJsZVwiKTtpZihhLnNjcm9sbFBhcmVudFswXSE9ZG9jdW1lbnQmJmEuc2Nyb2xsUGFyZW50WzBdLnRhZ05hbWUhPVwiSFRNTFwiKWEub3ZlcmZsb3dPZmZzZXQ9YS5zY3JvbGxQYXJlbnQub2Zmc2V0KCl9LGRyYWc6ZnVuY3Rpb24oYSl7dmFyIGI9ZCh0aGlzKS5kYXRhKFwiZHJhZ2dhYmxlXCIpLGM9Yi5vcHRpb25zLGY9ZmFsc2U7aWYoYi5zY3JvbGxQYXJlbnRbMF0hPWRvY3VtZW50JiZiLnNjcm9sbFBhcmVudFswXS50YWdOYW1lIT1cIkhUTUxcIil7aWYoIWMuYXhpc3x8Yy5heGlzIT1cclxuXCJ4XCIpaWYoYi5vdmVyZmxvd09mZnNldC50b3ArYi5zY3JvbGxQYXJlbnRbMF0ub2Zmc2V0SGVpZ2h0LWEucGFnZVk8Yy5zY3JvbGxTZW5zaXRpdml0eSliLnNjcm9sbFBhcmVudFswXS5zY3JvbGxUb3A9Zj1iLnNjcm9sbFBhcmVudFswXS5zY3JvbGxUb3ArYy5zY3JvbGxTcGVlZDtlbHNlIGlmKGEucGFnZVktYi5vdmVyZmxvd09mZnNldC50b3A8Yy5zY3JvbGxTZW5zaXRpdml0eSliLnNjcm9sbFBhcmVudFswXS5zY3JvbGxUb3A9Zj1iLnNjcm9sbFBhcmVudFswXS5zY3JvbGxUb3AtYy5zY3JvbGxTcGVlZDtpZighYy5heGlzfHxjLmF4aXMhPVwieVwiKWlmKGIub3ZlcmZsb3dPZmZzZXQubGVmdCtiLnNjcm9sbFBhcmVudFswXS5vZmZzZXRXaWR0aC1hLnBhZ2VYPGMuc2Nyb2xsU2Vuc2l0aXZpdHkpYi5zY3JvbGxQYXJlbnRbMF0uc2Nyb2xsTGVmdD1mPWIuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbExlZnQrYy5zY3JvbGxTcGVlZDtlbHNlIGlmKGEucGFnZVgtYi5vdmVyZmxvd09mZnNldC5sZWZ0PFxyXG5jLnNjcm9sbFNlbnNpdGl2aXR5KWIuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbExlZnQ9Zj1iLnNjcm9sbFBhcmVudFswXS5zY3JvbGxMZWZ0LWMuc2Nyb2xsU3BlZWR9ZWxzZXtpZighYy5heGlzfHxjLmF4aXMhPVwieFwiKWlmKGEucGFnZVktZChkb2N1bWVudCkuc2Nyb2xsVG9wKCk8Yy5zY3JvbGxTZW5zaXRpdml0eSlmPWQoZG9jdW1lbnQpLnNjcm9sbFRvcChkKGRvY3VtZW50KS5zY3JvbGxUb3AoKS1jLnNjcm9sbFNwZWVkKTtlbHNlIGlmKGQod2luZG93KS5oZWlnaHQoKS0oYS5wYWdlWS1kKGRvY3VtZW50KS5zY3JvbGxUb3AoKSk8Yy5zY3JvbGxTZW5zaXRpdml0eSlmPWQoZG9jdW1lbnQpLnNjcm9sbFRvcChkKGRvY3VtZW50KS5zY3JvbGxUb3AoKStjLnNjcm9sbFNwZWVkKTtpZighYy5heGlzfHxjLmF4aXMhPVwieVwiKWlmKGEucGFnZVgtZChkb2N1bWVudCkuc2Nyb2xsTGVmdCgpPGMuc2Nyb2xsU2Vuc2l0aXZpdHkpZj1kKGRvY3VtZW50KS5zY3JvbGxMZWZ0KGQoZG9jdW1lbnQpLnNjcm9sbExlZnQoKS1cclxuYy5zY3JvbGxTcGVlZCk7ZWxzZSBpZihkKHdpbmRvdykud2lkdGgoKS0oYS5wYWdlWC1kKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkpPGMuc2Nyb2xsU2Vuc2l0aXZpdHkpZj1kKGRvY3VtZW50KS5zY3JvbGxMZWZ0KGQoZG9jdW1lbnQpLnNjcm9sbExlZnQoKStjLnNjcm9sbFNwZWVkKX1mIT09ZmFsc2UmJmQudWkuZGRtYW5hZ2VyJiYhYy5kcm9wQmVoYXZpb3VyJiZkLnVpLmRkbWFuYWdlci5wcmVwYXJlT2Zmc2V0cyhiLGEpfX0pO2QudWkucGx1Z2luLmFkZChcImRyYWdnYWJsZVwiLFwic25hcFwiLHtzdGFydDpmdW5jdGlvbigpe3ZhciBhPWQodGhpcykuZGF0YShcImRyYWdnYWJsZVwiKSxiPWEub3B0aW9uczthLnNuYXBFbGVtZW50cz1bXTtkKGIuc25hcC5jb25zdHJ1Y3RvciE9U3RyaW5nP2Iuc25hcC5pdGVtc3x8XCI6ZGF0YShkcmFnZ2FibGUpXCI6Yi5zbmFwKS5lYWNoKGZ1bmN0aW9uKCl7dmFyIGM9ZCh0aGlzKSxmPWMub2Zmc2V0KCk7dGhpcyE9YS5lbGVtZW50WzBdJiZhLnNuYXBFbGVtZW50cy5wdXNoKHtpdGVtOnRoaXMsXHJcbndpZHRoOmMub3V0ZXJXaWR0aCgpLGhlaWdodDpjLm91dGVySGVpZ2h0KCksdG9wOmYudG9wLGxlZnQ6Zi5sZWZ0fSl9KX0sZHJhZzpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz1kKHRoaXMpLmRhdGEoXCJkcmFnZ2FibGVcIiksZj1jLm9wdGlvbnMsZT1mLnNuYXBUb2xlcmFuY2UsaD1iLm9mZnNldC5sZWZ0LGc9aCtjLmhlbHBlclByb3BvcnRpb25zLndpZHRoLG49Yi5vZmZzZXQudG9wLG89bitjLmhlbHBlclByb3BvcnRpb25zLmhlaWdodCxpPWMuc25hcEVsZW1lbnRzLmxlbmd0aC0xO2k+PTA7aS0tKXt2YXIgaj1jLnNuYXBFbGVtZW50c1tpXS5sZWZ0LGw9aitjLnNuYXBFbGVtZW50c1tpXS53aWR0aCxrPWMuc25hcEVsZW1lbnRzW2ldLnRvcCxtPWsrYy5zbmFwRWxlbWVudHNbaV0uaGVpZ2h0O2lmKGotZTxoJiZoPGwrZSYmay1lPG4mJm48bStlfHxqLWU8aCYmaDxsK2UmJmstZTxvJiZvPG0rZXx8ai1lPGcmJmc8bCtlJiZrLWU8biYmbjxtK2V8fGotZTxnJiZnPGwrZSYmay1lPG8mJlxyXG5vPG0rZSl7aWYoZi5zbmFwTW9kZSE9XCJpbm5lclwiKXt2YXIgcD1NYXRoLmFicyhrLW8pPD1lLHE9TWF0aC5hYnMobS1uKTw9ZSxyPU1hdGguYWJzKGotZyk8PWUscz1NYXRoLmFicyhsLWgpPD1lO2lmKHApYi5wb3NpdGlvbi50b3A9Yy5fY29udmVydFBvc2l0aW9uVG8oXCJyZWxhdGl2ZVwiLHt0b3A6ay1jLmhlbHBlclByb3BvcnRpb25zLmhlaWdodCxsZWZ0OjB9KS50b3AtYy5tYXJnaW5zLnRvcDtpZihxKWIucG9zaXRpb24udG9wPWMuX2NvbnZlcnRQb3NpdGlvblRvKFwicmVsYXRpdmVcIix7dG9wOm0sbGVmdDowfSkudG9wLWMubWFyZ2lucy50b3A7aWYociliLnBvc2l0aW9uLmxlZnQ9Yy5fY29udmVydFBvc2l0aW9uVG8oXCJyZWxhdGl2ZVwiLHt0b3A6MCxsZWZ0OmotYy5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aH0pLmxlZnQtYy5tYXJnaW5zLmxlZnQ7aWYocyliLnBvc2l0aW9uLmxlZnQ9Yy5fY29udmVydFBvc2l0aW9uVG8oXCJyZWxhdGl2ZVwiLHt0b3A6MCxsZWZ0Omx9KS5sZWZ0LWMubWFyZ2lucy5sZWZ0fXZhciB0PVxyXG5wfHxxfHxyfHxzO2lmKGYuc25hcE1vZGUhPVwib3V0ZXJcIil7cD1NYXRoLmFicyhrLW4pPD1lO3E9TWF0aC5hYnMobS1vKTw9ZTtyPU1hdGguYWJzKGotaCk8PWU7cz1NYXRoLmFicyhsLWcpPD1lO2lmKHApYi5wb3NpdGlvbi50b3A9Yy5fY29udmVydFBvc2l0aW9uVG8oXCJyZWxhdGl2ZVwiLHt0b3A6ayxsZWZ0OjB9KS50b3AtYy5tYXJnaW5zLnRvcDtpZihxKWIucG9zaXRpb24udG9wPWMuX2NvbnZlcnRQb3NpdGlvblRvKFwicmVsYXRpdmVcIix7dG9wOm0tYy5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQsbGVmdDowfSkudG9wLWMubWFyZ2lucy50b3A7aWYociliLnBvc2l0aW9uLmxlZnQ9Yy5fY29udmVydFBvc2l0aW9uVG8oXCJyZWxhdGl2ZVwiLHt0b3A6MCxsZWZ0Omp9KS5sZWZ0LWMubWFyZ2lucy5sZWZ0O2lmKHMpYi5wb3NpdGlvbi5sZWZ0PWMuX2NvbnZlcnRQb3NpdGlvblRvKFwicmVsYXRpdmVcIix7dG9wOjAsbGVmdDpsLWMuaGVscGVyUHJvcG9ydGlvbnMud2lkdGh9KS5sZWZ0LWMubWFyZ2lucy5sZWZ0fWlmKCFjLnNuYXBFbGVtZW50c1tpXS5zbmFwcGluZyYmXHJcbihwfHxxfHxyfHxzfHx0KSljLm9wdGlvbnMuc25hcC5zbmFwJiZjLm9wdGlvbnMuc25hcC5zbmFwLmNhbGwoYy5lbGVtZW50LGEsZC5leHRlbmQoYy5fdWlIYXNoKCkse3NuYXBJdGVtOmMuc25hcEVsZW1lbnRzW2ldLml0ZW19KSk7Yy5zbmFwRWxlbWVudHNbaV0uc25hcHBpbmc9cHx8cXx8cnx8c3x8dH1lbHNle2Muc25hcEVsZW1lbnRzW2ldLnNuYXBwaW5nJiZjLm9wdGlvbnMuc25hcC5yZWxlYXNlJiZjLm9wdGlvbnMuc25hcC5yZWxlYXNlLmNhbGwoYy5lbGVtZW50LGEsZC5leHRlbmQoYy5fdWlIYXNoKCkse3NuYXBJdGVtOmMuc25hcEVsZW1lbnRzW2ldLml0ZW19KSk7Yy5zbmFwRWxlbWVudHNbaV0uc25hcHBpbmc9ZmFsc2V9fX19KTtkLnVpLnBsdWdpbi5hZGQoXCJkcmFnZ2FibGVcIixcInN0YWNrXCIse3N0YXJ0OmZ1bmN0aW9uKCl7dmFyIGE9ZCh0aGlzKS5kYXRhKFwiZHJhZ2dhYmxlXCIpLm9wdGlvbnM7YT1kLm1ha2VBcnJheShkKGEuc3RhY2spKS5zb3J0KGZ1bmN0aW9uKGMsZil7cmV0dXJuKHBhcnNlSW50KGQoYykuY3NzKFwiekluZGV4XCIpLFxyXG4xMCl8fDApLShwYXJzZUludChkKGYpLmNzcyhcInpJbmRleFwiKSwxMCl8fDApfSk7aWYoYS5sZW5ndGgpe3ZhciBiPXBhcnNlSW50KGFbMF0uc3R5bGUuekluZGV4KXx8MDtkKGEpLmVhY2goZnVuY3Rpb24oYyl7dGhpcy5zdHlsZS56SW5kZXg9YitjfSk7dGhpc1swXS5zdHlsZS56SW5kZXg9YithLmxlbmd0aH19fSk7ZC51aS5wbHVnaW4uYWRkKFwiZHJhZ2dhYmxlXCIsXCJ6SW5kZXhcIix7c3RhcnQ6ZnVuY3Rpb24oYSxiKXthPWQoYi5oZWxwZXIpO2I9ZCh0aGlzKS5kYXRhKFwiZHJhZ2dhYmxlXCIpLm9wdGlvbnM7aWYoYS5jc3MoXCJ6SW5kZXhcIikpYi5fekluZGV4PWEuY3NzKFwiekluZGV4XCIpO2EuY3NzKFwiekluZGV4XCIsYi56SW5kZXgpfSxzdG9wOmZ1bmN0aW9uKGEsYil7YT1kKHRoaXMpLmRhdGEoXCJkcmFnZ2FibGVcIikub3B0aW9uczthLl96SW5kZXgmJmQoYi5oZWxwZXIpLmNzcyhcInpJbmRleFwiLGEuX3pJbmRleCl9fSl9KShqUXVlcnkpO1xyXG47LypcclxuICogalF1ZXJ5IFVJIERyb3BwYWJsZSAxLjguMTZcclxuICpcclxuICogQ29weXJpZ2h0IDIwMTEsIEFVVEhPUlMudHh0IChodHRwOi8vanF1ZXJ5dWkuY29tL2Fib3V0KVxyXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgb3IgR1BMIFZlcnNpb24gMiBsaWNlbnNlcy5cclxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxyXG4gKlxyXG4gKiBodHRwOi8vZG9jcy5qcXVlcnkuY29tL1VJL0Ryb3BwYWJsZXNcclxuICpcclxuICogRGVwZW5kczpcclxuICpcdGpxdWVyeS51aS5jb3JlLmpzXHJcbiAqXHRqcXVlcnkudWkud2lkZ2V0LmpzXHJcbiAqXHRqcXVlcnkudWkubW91c2UuanNcclxuICpcdGpxdWVyeS51aS5kcmFnZ2FibGUuanNcclxuICovXHJcbihmdW5jdGlvbihkKXtkLndpZGdldChcInVpLmRyb3BwYWJsZVwiLHt3aWRnZXRFdmVudFByZWZpeDpcImRyb3BcIixvcHRpb25zOnthY2NlcHQ6XCIqXCIsYWN0aXZlQ2xhc3M6ZmFsc2UsYWRkQ2xhc3Nlczp0cnVlLGdyZWVkeTpmYWxzZSxob3ZlckNsYXNzOmZhbHNlLHNjb3BlOlwiZGVmYXVsdFwiLHRvbGVyYW5jZTpcImludGVyc2VjdFwifSxfY3JlYXRlOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5vcHRpb25zLGI9YS5hY2NlcHQ7dGhpcy5pc292ZXI9MDt0aGlzLmlzb3V0PTE7dGhpcy5hY2NlcHQ9ZC5pc0Z1bmN0aW9uKGIpP2I6ZnVuY3Rpb24oYyl7cmV0dXJuIGMuaXMoYil9O3RoaXMucHJvcG9ydGlvbnM9e3dpZHRoOnRoaXMuZWxlbWVudFswXS5vZmZzZXRXaWR0aCxoZWlnaHQ6dGhpcy5lbGVtZW50WzBdLm9mZnNldEhlaWdodH07ZC51aS5kZG1hbmFnZXIuZHJvcHBhYmxlc1thLnNjb3BlXT1kLnVpLmRkbWFuYWdlci5kcm9wcGFibGVzW2Euc2NvcGVdfHxbXTtkLnVpLmRkbWFuYWdlci5kcm9wcGFibGVzW2Euc2NvcGVdLnB1c2godGhpcyk7XHJcbmEuYWRkQ2xhc3NlcyYmdGhpcy5lbGVtZW50LmFkZENsYXNzKFwidWktZHJvcHBhYmxlXCIpfSxkZXN0cm95OmZ1bmN0aW9uKCl7Zm9yKHZhciBhPWQudWkuZGRtYW5hZ2VyLmRyb3BwYWJsZXNbdGhpcy5vcHRpb25zLnNjb3BlXSxiPTA7YjxhLmxlbmd0aDtiKyspYVtiXT09dGhpcyYmYS5zcGxpY2UoYiwxKTt0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoXCJ1aS1kcm9wcGFibGUgdWktZHJvcHBhYmxlLWRpc2FibGVkXCIpLnJlbW92ZURhdGEoXCJkcm9wcGFibGVcIikudW5iaW5kKFwiLmRyb3BwYWJsZVwiKTtyZXR1cm4gdGhpc30sX3NldE9wdGlvbjpmdW5jdGlvbihhLGIpe2lmKGE9PVwiYWNjZXB0XCIpdGhpcy5hY2NlcHQ9ZC5pc0Z1bmN0aW9uKGIpP2I6ZnVuY3Rpb24oYyl7cmV0dXJuIGMuaXMoYil9O2QuV2lkZ2V0LnByb3RvdHlwZS5fc2V0T3B0aW9uLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sX2FjdGl2YXRlOmZ1bmN0aW9uKGEpe3ZhciBiPWQudWkuZGRtYW5hZ2VyLmN1cnJlbnQ7dGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzJiZcclxudGhpcy5lbGVtZW50LmFkZENsYXNzKHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcyk7YiYmdGhpcy5fdHJpZ2dlcihcImFjdGl2YXRlXCIsYSx0aGlzLnVpKGIpKX0sX2RlYWN0aXZhdGU6ZnVuY3Rpb24oYSl7dmFyIGI9ZC51aS5kZG1hbmFnZXIuY3VycmVudDt0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MmJnRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpO2ImJnRoaXMuX3RyaWdnZXIoXCJkZWFjdGl2YXRlXCIsYSx0aGlzLnVpKGIpKX0sX292ZXI6ZnVuY3Rpb24oYSl7dmFyIGI9ZC51aS5kZG1hbmFnZXIuY3VycmVudDtpZighKCFifHwoYi5jdXJyZW50SXRlbXx8Yi5lbGVtZW50KVswXT09dGhpcy5lbGVtZW50WzBdKSlpZih0aGlzLmFjY2VwdC5jYWxsKHRoaXMuZWxlbWVudFswXSxiLmN1cnJlbnRJdGVtfHxiLmVsZW1lbnQpKXt0aGlzLm9wdGlvbnMuaG92ZXJDbGFzcyYmdGhpcy5lbGVtZW50LmFkZENsYXNzKHRoaXMub3B0aW9ucy5ob3ZlckNsYXNzKTtcclxudGhpcy5fdHJpZ2dlcihcIm92ZXJcIixhLHRoaXMudWkoYikpfX0sX291dDpmdW5jdGlvbihhKXt2YXIgYj1kLnVpLmRkbWFuYWdlci5jdXJyZW50O2lmKCEoIWJ8fChiLmN1cnJlbnRJdGVtfHxiLmVsZW1lbnQpWzBdPT10aGlzLmVsZW1lbnRbMF0pKWlmKHRoaXMuYWNjZXB0LmNhbGwodGhpcy5lbGVtZW50WzBdLGIuY3VycmVudEl0ZW18fGIuZWxlbWVudCkpe3RoaXMub3B0aW9ucy5ob3ZlckNsYXNzJiZ0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmhvdmVyQ2xhc3MpO3RoaXMuX3RyaWdnZXIoXCJvdXRcIixhLHRoaXMudWkoYikpfX0sX2Ryb3A6ZnVuY3Rpb24oYSxiKXt2YXIgYz1ifHxkLnVpLmRkbWFuYWdlci5jdXJyZW50O2lmKCFjfHwoYy5jdXJyZW50SXRlbXx8Yy5lbGVtZW50KVswXT09dGhpcy5lbGVtZW50WzBdKXJldHVybiBmYWxzZTt2YXIgZT1mYWxzZTt0aGlzLmVsZW1lbnQuZmluZChcIjpkYXRhKGRyb3BwYWJsZSlcIikubm90KFwiLnVpLWRyYWdnYWJsZS1kcmFnZ2luZ1wiKS5lYWNoKGZ1bmN0aW9uKCl7dmFyIGc9XHJcbmQuZGF0YSh0aGlzLFwiZHJvcHBhYmxlXCIpO2lmKGcub3B0aW9ucy5ncmVlZHkmJiFnLm9wdGlvbnMuZGlzYWJsZWQmJmcub3B0aW9ucy5zY29wZT09Yy5vcHRpb25zLnNjb3BlJiZnLmFjY2VwdC5jYWxsKGcuZWxlbWVudFswXSxjLmN1cnJlbnRJdGVtfHxjLmVsZW1lbnQpJiZkLnVpLmludGVyc2VjdChjLGQuZXh0ZW5kKGcse29mZnNldDpnLmVsZW1lbnQub2Zmc2V0KCl9KSxnLm9wdGlvbnMudG9sZXJhbmNlKSl7ZT10cnVlO3JldHVybiBmYWxzZX19KTtpZihlKXJldHVybiBmYWxzZTtpZih0aGlzLmFjY2VwdC5jYWxsKHRoaXMuZWxlbWVudFswXSxjLmN1cnJlbnRJdGVtfHxjLmVsZW1lbnQpKXt0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MmJnRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpO3RoaXMub3B0aW9ucy5ob3ZlckNsYXNzJiZ0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmhvdmVyQ2xhc3MpO3RoaXMuX3RyaWdnZXIoXCJkcm9wXCIsXHJcbmEsdGhpcy51aShjKSk7cmV0dXJuIHRoaXMuZWxlbWVudH1yZXR1cm4gZmFsc2V9LHVpOmZ1bmN0aW9uKGEpe3JldHVybntkcmFnZ2FibGU6YS5jdXJyZW50SXRlbXx8YS5lbGVtZW50LGhlbHBlcjphLmhlbHBlcixwb3NpdGlvbjphLnBvc2l0aW9uLG9mZnNldDphLnBvc2l0aW9uQWJzfX19KTtkLmV4dGVuZChkLnVpLmRyb3BwYWJsZSx7dmVyc2lvbjpcIjEuOC4xNlwifSk7ZC51aS5pbnRlcnNlY3Q9ZnVuY3Rpb24oYSxiLGMpe2lmKCFiLm9mZnNldClyZXR1cm4gZmFsc2U7dmFyIGU9KGEucG9zaXRpb25BYnN8fGEucG9zaXRpb24uYWJzb2x1dGUpLmxlZnQsZz1lK2EuaGVscGVyUHJvcG9ydGlvbnMud2lkdGgsZj0oYS5wb3NpdGlvbkFic3x8YS5wb3NpdGlvbi5hYnNvbHV0ZSkudG9wLGg9ZithLmhlbHBlclByb3BvcnRpb25zLmhlaWdodCxpPWIub2Zmc2V0LmxlZnQsaz1pK2IucHJvcG9ydGlvbnMud2lkdGgsaj1iLm9mZnNldC50b3AsbD1qK2IucHJvcG9ydGlvbnMuaGVpZ2h0O1xyXG5zd2l0Y2goYyl7Y2FzZSBcImZpdFwiOnJldHVybiBpPD1lJiZnPD1rJiZqPD1mJiZoPD1sO2Nhc2UgXCJpbnRlcnNlY3RcIjpyZXR1cm4gaTxlK2EuaGVscGVyUHJvcG9ydGlvbnMud2lkdGgvMiYmZy1hLmhlbHBlclByb3BvcnRpb25zLndpZHRoLzI8ayYmajxmK2EuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0LzImJmgtYS5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQvMjxsO2Nhc2UgXCJwb2ludGVyXCI6cmV0dXJuIGQudWkuaXNPdmVyKChhLnBvc2l0aW9uQWJzfHxhLnBvc2l0aW9uLmFic29sdXRlKS50b3ArKGEuY2xpY2tPZmZzZXR8fGEub2Zmc2V0LmNsaWNrKS50b3AsKGEucG9zaXRpb25BYnN8fGEucG9zaXRpb24uYWJzb2x1dGUpLmxlZnQrKGEuY2xpY2tPZmZzZXR8fGEub2Zmc2V0LmNsaWNrKS5sZWZ0LGosaSxiLnByb3BvcnRpb25zLmhlaWdodCxiLnByb3BvcnRpb25zLndpZHRoKTtjYXNlIFwidG91Y2hcIjpyZXR1cm4oZj49aiYmZjw9bHx8aD49aiYmaDw9bHx8ZjxqJiZoPmwpJiYoZT49XHJcbmkmJmU8PWt8fGc+PWkmJmc8PWt8fGU8aSYmZz5rKTtkZWZhdWx0OnJldHVybiBmYWxzZX19O2QudWkuZGRtYW5hZ2VyPXtjdXJyZW50Om51bGwsZHJvcHBhYmxlczp7XCJkZWZhdWx0XCI6W119LHByZXBhcmVPZmZzZXRzOmZ1bmN0aW9uKGEsYil7dmFyIGM9ZC51aS5kZG1hbmFnZXIuZHJvcHBhYmxlc1thLm9wdGlvbnMuc2NvcGVdfHxbXSxlPWI/Yi50eXBlOm51bGwsZz0oYS5jdXJyZW50SXRlbXx8YS5lbGVtZW50KS5maW5kKFwiOmRhdGEoZHJvcHBhYmxlKVwiKS5hbmRTZWxmKCksZj0wO2E6Zm9yKDtmPGMubGVuZ3RoO2YrKylpZighKGNbZl0ub3B0aW9ucy5kaXNhYmxlZHx8YSYmIWNbZl0uYWNjZXB0LmNhbGwoY1tmXS5lbGVtZW50WzBdLGEuY3VycmVudEl0ZW18fGEuZWxlbWVudCkpKXtmb3IodmFyIGg9MDtoPGcubGVuZ3RoO2grKylpZihnW2hdPT1jW2ZdLmVsZW1lbnRbMF0pe2NbZl0ucHJvcG9ydGlvbnMuaGVpZ2h0PTA7Y29udGludWUgYX1jW2ZdLnZpc2libGU9Y1tmXS5lbGVtZW50LmNzcyhcImRpc3BsYXlcIikhPVxyXG5cIm5vbmVcIjtpZihjW2ZdLnZpc2libGUpe2U9PVwibW91c2Vkb3duXCImJmNbZl0uX2FjdGl2YXRlLmNhbGwoY1tmXSxiKTtjW2ZdLm9mZnNldD1jW2ZdLmVsZW1lbnQub2Zmc2V0KCk7Y1tmXS5wcm9wb3J0aW9ucz17d2lkdGg6Y1tmXS5lbGVtZW50WzBdLm9mZnNldFdpZHRoLGhlaWdodDpjW2ZdLmVsZW1lbnRbMF0ub2Zmc2V0SGVpZ2h0fX19fSxkcm9wOmZ1bmN0aW9uKGEsYil7dmFyIGM9ZmFsc2U7ZC5lYWNoKGQudWkuZGRtYW5hZ2VyLmRyb3BwYWJsZXNbYS5vcHRpb25zLnNjb3BlXXx8W10sZnVuY3Rpb24oKXtpZih0aGlzLm9wdGlvbnMpe2lmKCF0aGlzLm9wdGlvbnMuZGlzYWJsZWQmJnRoaXMudmlzaWJsZSYmZC51aS5pbnRlcnNlY3QoYSx0aGlzLHRoaXMub3B0aW9ucy50b2xlcmFuY2UpKWM9Y3x8dGhpcy5fZHJvcC5jYWxsKHRoaXMsYik7aWYoIXRoaXMub3B0aW9ucy5kaXNhYmxlZCYmdGhpcy52aXNpYmxlJiZ0aGlzLmFjY2VwdC5jYWxsKHRoaXMuZWxlbWVudFswXSxhLmN1cnJlbnRJdGVtfHxcclxuYS5lbGVtZW50KSl7dGhpcy5pc291dD0xO3RoaXMuaXNvdmVyPTA7dGhpcy5fZGVhY3RpdmF0ZS5jYWxsKHRoaXMsYil9fX0pO3JldHVybiBjfSxkcmFnU3RhcnQ6ZnVuY3Rpb24oYSxiKXthLmVsZW1lbnQucGFyZW50cyhcIjpub3QoYm9keSxodG1sKVwiKS5iaW5kKFwic2Nyb2xsLmRyb3BwYWJsZVwiLGZ1bmN0aW9uKCl7YS5vcHRpb25zLnJlZnJlc2hQb3NpdGlvbnN8fGQudWkuZGRtYW5hZ2VyLnByZXBhcmVPZmZzZXRzKGEsYil9KX0sZHJhZzpmdW5jdGlvbihhLGIpe2Eub3B0aW9ucy5yZWZyZXNoUG9zaXRpb25zJiZkLnVpLmRkbWFuYWdlci5wcmVwYXJlT2Zmc2V0cyhhLGIpO2QuZWFjaChkLnVpLmRkbWFuYWdlci5kcm9wcGFibGVzW2Eub3B0aW9ucy5zY29wZV18fFtdLGZ1bmN0aW9uKCl7aWYoISh0aGlzLm9wdGlvbnMuZGlzYWJsZWR8fHRoaXMuZ3JlZWR5Q2hpbGR8fCF0aGlzLnZpc2libGUpKXt2YXIgYz1kLnVpLmludGVyc2VjdChhLHRoaXMsdGhpcy5vcHRpb25zLnRvbGVyYW5jZSk7XHJcbmlmKGM9IWMmJnRoaXMuaXNvdmVyPT0xP1wiaXNvdXRcIjpjJiZ0aGlzLmlzb3Zlcj09MD9cImlzb3ZlclwiOm51bGwpe3ZhciBlO2lmKHRoaXMub3B0aW9ucy5ncmVlZHkpe3ZhciBnPXRoaXMuZWxlbWVudC5wYXJlbnRzKFwiOmRhdGEoZHJvcHBhYmxlKTplcSgwKVwiKTtpZihnLmxlbmd0aCl7ZT1kLmRhdGEoZ1swXSxcImRyb3BwYWJsZVwiKTtlLmdyZWVkeUNoaWxkPWM9PVwiaXNvdmVyXCI/MTowfX1pZihlJiZjPT1cImlzb3ZlclwiKXtlLmlzb3Zlcj0wO2UuaXNvdXQ9MTtlLl9vdXQuY2FsbChlLGIpfXRoaXNbY109MTt0aGlzW2M9PVwiaXNvdXRcIj9cImlzb3ZlclwiOlwiaXNvdXRcIl09MDt0aGlzW2M9PVwiaXNvdmVyXCI/XCJfb3ZlclwiOlwiX291dFwiXS5jYWxsKHRoaXMsYik7aWYoZSYmYz09XCJpc291dFwiKXtlLmlzb3V0PTA7ZS5pc292ZXI9MTtlLl9vdmVyLmNhbGwoZSxiKX19fX0pfSxkcmFnU3RvcDpmdW5jdGlvbihhLGIpe2EuZWxlbWVudC5wYXJlbnRzKFwiOm5vdChib2R5LGh0bWwpXCIpLnVuYmluZChcInNjcm9sbC5kcm9wcGFibGVcIik7XHJcbmEub3B0aW9ucy5yZWZyZXNoUG9zaXRpb25zfHxkLnVpLmRkbWFuYWdlci5wcmVwYXJlT2Zmc2V0cyhhLGIpfX19KShqUXVlcnkpO1xyXG47LypcclxuICogalF1ZXJ5IFVJIFJlc2l6YWJsZSAxLjguMTZcclxuICpcclxuICogQ29weXJpZ2h0IDIwMTEsIEFVVEhPUlMudHh0IChodHRwOi8vanF1ZXJ5dWkuY29tL2Fib3V0KVxyXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgb3IgR1BMIFZlcnNpb24gMiBsaWNlbnNlcy5cclxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxyXG4gKlxyXG4gKiBodHRwOi8vZG9jcy5qcXVlcnkuY29tL1VJL1Jlc2l6YWJsZXNcclxuICpcclxuICogRGVwZW5kczpcclxuICpcdGpxdWVyeS51aS5jb3JlLmpzXHJcbiAqXHRqcXVlcnkudWkubW91c2UuanNcclxuICpcdGpxdWVyeS51aS53aWRnZXQuanNcclxuICovXHJcbihmdW5jdGlvbihlKXtlLndpZGdldChcInVpLnJlc2l6YWJsZVwiLGUudWkubW91c2Use3dpZGdldEV2ZW50UHJlZml4OlwicmVzaXplXCIsb3B0aW9uczp7YWxzb1Jlc2l6ZTpmYWxzZSxhbmltYXRlOmZhbHNlLGFuaW1hdGVEdXJhdGlvbjpcInNsb3dcIixhbmltYXRlRWFzaW5nOlwic3dpbmdcIixhc3BlY3RSYXRpbzpmYWxzZSxhdXRvSGlkZTpmYWxzZSxjb250YWlubWVudDpmYWxzZSxnaG9zdDpmYWxzZSxncmlkOmZhbHNlLGhhbmRsZXM6XCJlLHMsc2VcIixoZWxwZXI6ZmFsc2UsbWF4SGVpZ2h0Om51bGwsbWF4V2lkdGg6bnVsbCxtaW5IZWlnaHQ6MTAsbWluV2lkdGg6MTAsekluZGV4OjFFM30sX2NyZWF0ZTpmdW5jdGlvbigpe3ZhciBiPXRoaXMsYT10aGlzLm9wdGlvbnM7dGhpcy5lbGVtZW50LmFkZENsYXNzKFwidWktcmVzaXphYmxlXCIpO2UuZXh0ZW5kKHRoaXMse19hc3BlY3RSYXRpbzohIWEuYXNwZWN0UmF0aW8sYXNwZWN0UmF0aW86YS5hc3BlY3RSYXRpbyxvcmlnaW5hbEVsZW1lbnQ6dGhpcy5lbGVtZW50LFxyXG5fcHJvcG9ydGlvbmFsbHlSZXNpemVFbGVtZW50czpbXSxfaGVscGVyOmEuaGVscGVyfHxhLmdob3N0fHxhLmFuaW1hdGU/YS5oZWxwZXJ8fFwidWktcmVzaXphYmxlLWhlbHBlclwiOm51bGx9KTtpZih0aGlzLmVsZW1lbnRbMF0ubm9kZU5hbWUubWF0Y2goL2NhbnZhc3x0ZXh0YXJlYXxpbnB1dHxzZWxlY3R8YnV0dG9ufGltZy9pKSl7L3JlbGF0aXZlLy50ZXN0KHRoaXMuZWxlbWVudC5jc3MoXCJwb3NpdGlvblwiKSkmJmUuYnJvd3Nlci5vcGVyYSYmdGhpcy5lbGVtZW50LmNzcyh7cG9zaXRpb246XCJyZWxhdGl2ZVwiLHRvcDpcImF1dG9cIixsZWZ0OlwiYXV0b1wifSk7dGhpcy5lbGVtZW50LndyYXAoZSgnPGRpdiBjbGFzcz1cInVpLXdyYXBwZXJcIiBzdHlsZT1cIm92ZXJmbG93OiBoaWRkZW47XCI+PC9kaXY+JykuY3NzKHtwb3NpdGlvbjp0aGlzLmVsZW1lbnQuY3NzKFwicG9zaXRpb25cIiksd2lkdGg6dGhpcy5lbGVtZW50Lm91dGVyV2lkdGgoKSxoZWlnaHQ6dGhpcy5lbGVtZW50Lm91dGVySGVpZ2h0KCksXHJcbnRvcDp0aGlzLmVsZW1lbnQuY3NzKFwidG9wXCIpLGxlZnQ6dGhpcy5lbGVtZW50LmNzcyhcImxlZnRcIil9KSk7dGhpcy5lbGVtZW50PXRoaXMuZWxlbWVudC5wYXJlbnQoKS5kYXRhKFwicmVzaXphYmxlXCIsdGhpcy5lbGVtZW50LmRhdGEoXCJyZXNpemFibGVcIikpO3RoaXMuZWxlbWVudElzV3JhcHBlcj10cnVlO3RoaXMuZWxlbWVudC5jc3Moe21hcmdpbkxlZnQ6dGhpcy5vcmlnaW5hbEVsZW1lbnQuY3NzKFwibWFyZ2luTGVmdFwiKSxtYXJnaW5Ub3A6dGhpcy5vcmlnaW5hbEVsZW1lbnQuY3NzKFwibWFyZ2luVG9wXCIpLG1hcmdpblJpZ2h0OnRoaXMub3JpZ2luYWxFbGVtZW50LmNzcyhcIm1hcmdpblJpZ2h0XCIpLG1hcmdpbkJvdHRvbTp0aGlzLm9yaWdpbmFsRWxlbWVudC5jc3MoXCJtYXJnaW5Cb3R0b21cIil9KTt0aGlzLm9yaWdpbmFsRWxlbWVudC5jc3Moe21hcmdpbkxlZnQ6MCxtYXJnaW5Ub3A6MCxtYXJnaW5SaWdodDowLG1hcmdpbkJvdHRvbTowfSk7dGhpcy5vcmlnaW5hbFJlc2l6ZVN0eWxlPVxyXG50aGlzLm9yaWdpbmFsRWxlbWVudC5jc3MoXCJyZXNpemVcIik7dGhpcy5vcmlnaW5hbEVsZW1lbnQuY3NzKFwicmVzaXplXCIsXCJub25lXCIpO3RoaXMuX3Byb3BvcnRpb25hbGx5UmVzaXplRWxlbWVudHMucHVzaCh0aGlzLm9yaWdpbmFsRWxlbWVudC5jc3Moe3Bvc2l0aW9uOlwic3RhdGljXCIsem9vbToxLGRpc3BsYXk6XCJibG9ja1wifSkpO3RoaXMub3JpZ2luYWxFbGVtZW50LmNzcyh7bWFyZ2luOnRoaXMub3JpZ2luYWxFbGVtZW50LmNzcyhcIm1hcmdpblwiKX0pO3RoaXMuX3Byb3BvcnRpb25hbGx5UmVzaXplKCl9dGhpcy5oYW5kbGVzPWEuaGFuZGxlc3x8KCFlKFwiLnVpLXJlc2l6YWJsZS1oYW5kbGVcIix0aGlzLmVsZW1lbnQpLmxlbmd0aD9cImUscyxzZVwiOntuOlwiLnVpLXJlc2l6YWJsZS1uXCIsZTpcIi51aS1yZXNpemFibGUtZVwiLHM6XCIudWktcmVzaXphYmxlLXNcIix3OlwiLnVpLXJlc2l6YWJsZS13XCIsc2U6XCIudWktcmVzaXphYmxlLXNlXCIsc3c6XCIudWktcmVzaXphYmxlLXN3XCIsbmU6XCIudWktcmVzaXphYmxlLW5lXCIsXHJcbm53OlwiLnVpLXJlc2l6YWJsZS1ud1wifSk7aWYodGhpcy5oYW5kbGVzLmNvbnN0cnVjdG9yPT1TdHJpbmcpe2lmKHRoaXMuaGFuZGxlcz09XCJhbGxcIil0aGlzLmhhbmRsZXM9XCJuLGUscyx3LHNlLHN3LG5lLG53XCI7dmFyIGM9dGhpcy5oYW5kbGVzLnNwbGl0KFwiLFwiKTt0aGlzLmhhbmRsZXM9e307Zm9yKHZhciBkPTA7ZDxjLmxlbmd0aDtkKyspe3ZhciBmPWUudHJpbShjW2RdKSxnPWUoJzxkaXYgY2xhc3M9XCJ1aS1yZXNpemFibGUtaGFuZGxlICcrKFwidWktcmVzaXphYmxlLVwiK2YpKydcIj48L2Rpdj4nKTsvc3d8c2V8bmV8bncvLnRlc3QoZikmJmcuY3NzKHt6SW5kZXg6KythLnpJbmRleH0pO1wic2VcIj09ZiYmZy5hZGRDbGFzcyhcInVpLWljb24gdWktaWNvbi1ncmlwc21hbGwtZGlhZ29uYWwtc2VcIik7dGhpcy5oYW5kbGVzW2ZdPVwiLnVpLXJlc2l6YWJsZS1cIitmO3RoaXMuZWxlbWVudC5hcHBlbmQoZyl9fXRoaXMuX3JlbmRlckF4aXM9ZnVuY3Rpb24oaCl7aD1ofHx0aGlzLmVsZW1lbnQ7Zm9yKHZhciBpIGluIHRoaXMuaGFuZGxlcyl7aWYodGhpcy5oYW5kbGVzW2ldLmNvbnN0cnVjdG9yPT1cclxuU3RyaW5nKXRoaXMuaGFuZGxlc1tpXT1lKHRoaXMuaGFuZGxlc1tpXSx0aGlzLmVsZW1lbnQpLnNob3coKTtpZih0aGlzLmVsZW1lbnRJc1dyYXBwZXImJnRoaXMub3JpZ2luYWxFbGVtZW50WzBdLm5vZGVOYW1lLm1hdGNoKC90ZXh0YXJlYXxpbnB1dHxzZWxlY3R8YnV0dG9uL2kpKXt2YXIgaj1lKHRoaXMuaGFuZGxlc1tpXSx0aGlzLmVsZW1lbnQpLGw9MDtsPS9zd3xuZXxud3xzZXxufHMvLnRlc3QoaSk/ai5vdXRlckhlaWdodCgpOmoub3V0ZXJXaWR0aCgpO2o9W1wicGFkZGluZ1wiLC9uZXxud3xuLy50ZXN0KGkpP1wiVG9wXCI6L3NlfHN3fHMvLnRlc3QoaSk/XCJCb3R0b21cIjovXmUkLy50ZXN0KGkpP1wiUmlnaHRcIjpcIkxlZnRcIl0uam9pbihcIlwiKTtoLmNzcyhqLGwpO3RoaXMuX3Byb3BvcnRpb25hbGx5UmVzaXplKCl9ZSh0aGlzLmhhbmRsZXNbaV0pfX07dGhpcy5fcmVuZGVyQXhpcyh0aGlzLmVsZW1lbnQpO3RoaXMuX2hhbmRsZXM9ZShcIi51aS1yZXNpemFibGUtaGFuZGxlXCIsdGhpcy5lbGVtZW50KS5kaXNhYmxlU2VsZWN0aW9uKCk7XHJcbnRoaXMuX2hhbmRsZXMubW91c2VvdmVyKGZ1bmN0aW9uKCl7aWYoIWIucmVzaXppbmcpe2lmKHRoaXMuY2xhc3NOYW1lKXZhciBoPXRoaXMuY2xhc3NOYW1lLm1hdGNoKC91aS1yZXNpemFibGUtKHNlfHN3fG5lfG53fG58ZXxzfHcpL2kpO2IuYXhpcz1oJiZoWzFdP2hbMV06XCJzZVwifX0pO2lmKGEuYXV0b0hpZGUpe3RoaXMuX2hhbmRsZXMuaGlkZSgpO2UodGhpcy5lbGVtZW50KS5hZGRDbGFzcyhcInVpLXJlc2l6YWJsZS1hdXRvaGlkZVwiKS5ob3ZlcihmdW5jdGlvbigpe2lmKCFhLmRpc2FibGVkKXtlKHRoaXMpLnJlbW92ZUNsYXNzKFwidWktcmVzaXphYmxlLWF1dG9oaWRlXCIpO2IuX2hhbmRsZXMuc2hvdygpfX0sZnVuY3Rpb24oKXtpZighYS5kaXNhYmxlZClpZighYi5yZXNpemluZyl7ZSh0aGlzKS5hZGRDbGFzcyhcInVpLXJlc2l6YWJsZS1hdXRvaGlkZVwiKTtiLl9oYW5kbGVzLmhpZGUoKX19KX10aGlzLl9tb3VzZUluaXQoKX0sZGVzdHJveTpmdW5jdGlvbigpe3RoaXMuX21vdXNlRGVzdHJveSgpO1xyXG52YXIgYj1mdW5jdGlvbihjKXtlKGMpLnJlbW92ZUNsYXNzKFwidWktcmVzaXphYmxlIHVpLXJlc2l6YWJsZS1kaXNhYmxlZCB1aS1yZXNpemFibGUtcmVzaXppbmdcIikucmVtb3ZlRGF0YShcInJlc2l6YWJsZVwiKS51bmJpbmQoXCIucmVzaXphYmxlXCIpLmZpbmQoXCIudWktcmVzaXphYmxlLWhhbmRsZVwiKS5yZW1vdmUoKX07aWYodGhpcy5lbGVtZW50SXNXcmFwcGVyKXtiKHRoaXMuZWxlbWVudCk7dmFyIGE9dGhpcy5lbGVtZW50O2EuYWZ0ZXIodGhpcy5vcmlnaW5hbEVsZW1lbnQuY3NzKHtwb3NpdGlvbjphLmNzcyhcInBvc2l0aW9uXCIpLHdpZHRoOmEub3V0ZXJXaWR0aCgpLGhlaWdodDphLm91dGVySGVpZ2h0KCksdG9wOmEuY3NzKFwidG9wXCIpLGxlZnQ6YS5jc3MoXCJsZWZ0XCIpfSkpLnJlbW92ZSgpfXRoaXMub3JpZ2luYWxFbGVtZW50LmNzcyhcInJlc2l6ZVwiLHRoaXMub3JpZ2luYWxSZXNpemVTdHlsZSk7Yih0aGlzLm9yaWdpbmFsRWxlbWVudCk7cmV0dXJuIHRoaXN9LF9tb3VzZUNhcHR1cmU6ZnVuY3Rpb24oYil7dmFyIGE9XHJcbmZhbHNlO2Zvcih2YXIgYyBpbiB0aGlzLmhhbmRsZXMpaWYoZSh0aGlzLmhhbmRsZXNbY10pWzBdPT1iLnRhcmdldClhPXRydWU7cmV0dXJuIXRoaXMub3B0aW9ucy5kaXNhYmxlZCYmYX0sX21vdXNlU3RhcnQ6ZnVuY3Rpb24oYil7dmFyIGE9dGhpcy5vcHRpb25zLGM9dGhpcy5lbGVtZW50LnBvc2l0aW9uKCksZD10aGlzLmVsZW1lbnQ7dGhpcy5yZXNpemluZz10cnVlO3RoaXMuZG9jdW1lbnRTY3JvbGw9e3RvcDplKGRvY3VtZW50KS5zY3JvbGxUb3AoKSxsZWZ0OmUoZG9jdW1lbnQpLnNjcm9sbExlZnQoKX07aWYoZC5pcyhcIi51aS1kcmFnZ2FibGVcIil8fC9hYnNvbHV0ZS8udGVzdChkLmNzcyhcInBvc2l0aW9uXCIpKSlkLmNzcyh7cG9zaXRpb246XCJhYnNvbHV0ZVwiLHRvcDpjLnRvcCxsZWZ0OmMubGVmdH0pO2UuYnJvd3Nlci5vcGVyYSYmL3JlbGF0aXZlLy50ZXN0KGQuY3NzKFwicG9zaXRpb25cIikpJiZkLmNzcyh7cG9zaXRpb246XCJyZWxhdGl2ZVwiLHRvcDpcImF1dG9cIixsZWZ0OlwiYXV0b1wifSk7XHJcbnRoaXMuX3JlbmRlclByb3h5KCk7Yz1tKHRoaXMuaGVscGVyLmNzcyhcImxlZnRcIikpO3ZhciBmPW0odGhpcy5oZWxwZXIuY3NzKFwidG9wXCIpKTtpZihhLmNvbnRhaW5tZW50KXtjKz1lKGEuY29udGFpbm1lbnQpLnNjcm9sbExlZnQoKXx8MDtmKz1lKGEuY29udGFpbm1lbnQpLnNjcm9sbFRvcCgpfHwwfXRoaXMub2Zmc2V0PXRoaXMuaGVscGVyLm9mZnNldCgpO3RoaXMucG9zaXRpb249e2xlZnQ6Yyx0b3A6Zn07dGhpcy5zaXplPXRoaXMuX2hlbHBlcj97d2lkdGg6ZC5vdXRlcldpZHRoKCksaGVpZ2h0OmQub3V0ZXJIZWlnaHQoKX06e3dpZHRoOmQud2lkdGgoKSxoZWlnaHQ6ZC5oZWlnaHQoKX07dGhpcy5vcmlnaW5hbFNpemU9dGhpcy5faGVscGVyP3t3aWR0aDpkLm91dGVyV2lkdGgoKSxoZWlnaHQ6ZC5vdXRlckhlaWdodCgpfTp7d2lkdGg6ZC53aWR0aCgpLGhlaWdodDpkLmhlaWdodCgpfTt0aGlzLm9yaWdpbmFsUG9zaXRpb249e2xlZnQ6Yyx0b3A6Zn07dGhpcy5zaXplRGlmZj1cclxue3dpZHRoOmQub3V0ZXJXaWR0aCgpLWQud2lkdGgoKSxoZWlnaHQ6ZC5vdXRlckhlaWdodCgpLWQuaGVpZ2h0KCl9O3RoaXMub3JpZ2luYWxNb3VzZVBvc2l0aW9uPXtsZWZ0OmIucGFnZVgsdG9wOmIucGFnZVl9O3RoaXMuYXNwZWN0UmF0aW89dHlwZW9mIGEuYXNwZWN0UmF0aW89PVwibnVtYmVyXCI/YS5hc3BlY3RSYXRpbzp0aGlzLm9yaWdpbmFsU2l6ZS53aWR0aC90aGlzLm9yaWdpbmFsU2l6ZS5oZWlnaHR8fDE7YT1lKFwiLnVpLXJlc2l6YWJsZS1cIit0aGlzLmF4aXMpLmNzcyhcImN1cnNvclwiKTtlKFwiYm9keVwiKS5jc3MoXCJjdXJzb3JcIixhPT1cImF1dG9cIj90aGlzLmF4aXMrXCItcmVzaXplXCI6YSk7ZC5hZGRDbGFzcyhcInVpLXJlc2l6YWJsZS1yZXNpemluZ1wiKTt0aGlzLl9wcm9wYWdhdGUoXCJzdGFydFwiLGIpO3JldHVybiB0cnVlfSxfbW91c2VEcmFnOmZ1bmN0aW9uKGIpe3ZhciBhPXRoaXMuaGVscGVyLGM9dGhpcy5vcmlnaW5hbE1vdXNlUG9zaXRpb24sZD10aGlzLl9jaGFuZ2VbdGhpcy5heGlzXTtcclxuaWYoIWQpcmV0dXJuIGZhbHNlO2M9ZC5hcHBseSh0aGlzLFtiLGIucGFnZVgtYy5sZWZ0fHwwLGIucGFnZVktYy50b3B8fDBdKTt0aGlzLl91cGRhdGVWaXJ0dWFsQm91bmRhcmllcyhiLnNoaWZ0S2V5KTtpZih0aGlzLl9hc3BlY3RSYXRpb3x8Yi5zaGlmdEtleSljPXRoaXMuX3VwZGF0ZVJhdGlvKGMsYik7Yz10aGlzLl9yZXNwZWN0U2l6ZShjLGIpO3RoaXMuX3Byb3BhZ2F0ZShcInJlc2l6ZVwiLGIpO2EuY3NzKHt0b3A6dGhpcy5wb3NpdGlvbi50b3ArXCJweFwiLGxlZnQ6dGhpcy5wb3NpdGlvbi5sZWZ0K1wicHhcIix3aWR0aDp0aGlzLnNpemUud2lkdGgrXCJweFwiLGhlaWdodDp0aGlzLnNpemUuaGVpZ2h0K1wicHhcIn0pOyF0aGlzLl9oZWxwZXImJnRoaXMuX3Byb3BvcnRpb25hbGx5UmVzaXplRWxlbWVudHMubGVuZ3RoJiZ0aGlzLl9wcm9wb3J0aW9uYWxseVJlc2l6ZSgpO3RoaXMuX3VwZGF0ZUNhY2hlKGMpO3RoaXMuX3RyaWdnZXIoXCJyZXNpemVcIixiLHRoaXMudWkoKSk7cmV0dXJuIGZhbHNlfSxcclxuX21vdXNlU3RvcDpmdW5jdGlvbihiKXt0aGlzLnJlc2l6aW5nPWZhbHNlO3ZhciBhPXRoaXMub3B0aW9ucyxjPXRoaXM7aWYodGhpcy5faGVscGVyKXt2YXIgZD10aGlzLl9wcm9wb3J0aW9uYWxseVJlc2l6ZUVsZW1lbnRzLGY9ZC5sZW5ndGgmJi90ZXh0YXJlYS9pLnRlc3QoZFswXS5ub2RlTmFtZSk7ZD1mJiZlLnVpLmhhc1Njcm9sbChkWzBdLFwibGVmdFwiKT8wOmMuc2l6ZURpZmYuaGVpZ2h0O2Y9Zj8wOmMuc2l6ZURpZmYud2lkdGg7Zj17d2lkdGg6Yy5oZWxwZXIud2lkdGgoKS1mLGhlaWdodDpjLmhlbHBlci5oZWlnaHQoKS1kfTtkPXBhcnNlSW50KGMuZWxlbWVudC5jc3MoXCJsZWZ0XCIpLDEwKSsoYy5wb3NpdGlvbi5sZWZ0LWMub3JpZ2luYWxQb3NpdGlvbi5sZWZ0KXx8bnVsbDt2YXIgZz1wYXJzZUludChjLmVsZW1lbnQuY3NzKFwidG9wXCIpLDEwKSsoYy5wb3NpdGlvbi50b3AtYy5vcmlnaW5hbFBvc2l0aW9uLnRvcCl8fG51bGw7YS5hbmltYXRlfHx0aGlzLmVsZW1lbnQuY3NzKGUuZXh0ZW5kKGYsXHJcbnt0b3A6ZyxsZWZ0OmR9KSk7Yy5oZWxwZXIuaGVpZ2h0KGMuc2l6ZS5oZWlnaHQpO2MuaGVscGVyLndpZHRoKGMuc2l6ZS53aWR0aCk7dGhpcy5faGVscGVyJiYhYS5hbmltYXRlJiZ0aGlzLl9wcm9wb3J0aW9uYWxseVJlc2l6ZSgpfWUoXCJib2R5XCIpLmNzcyhcImN1cnNvclwiLFwiYXV0b1wiKTt0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoXCJ1aS1yZXNpemFibGUtcmVzaXppbmdcIik7dGhpcy5fcHJvcGFnYXRlKFwic3RvcFwiLGIpO3RoaXMuX2hlbHBlciYmdGhpcy5oZWxwZXIucmVtb3ZlKCk7cmV0dXJuIGZhbHNlfSxfdXBkYXRlVmlydHVhbEJvdW5kYXJpZXM6ZnVuY3Rpb24oYil7dmFyIGE9dGhpcy5vcHRpb25zLGMsZCxmO2E9e21pbldpZHRoOmsoYS5taW5XaWR0aCk/YS5taW5XaWR0aDowLG1heFdpZHRoOmsoYS5tYXhXaWR0aCk/YS5tYXhXaWR0aDpJbmZpbml0eSxtaW5IZWlnaHQ6ayhhLm1pbkhlaWdodCk/YS5taW5IZWlnaHQ6MCxtYXhIZWlnaHQ6ayhhLm1heEhlaWdodCk/YS5tYXhIZWlnaHQ6XHJcbkluZmluaXR5fTtpZih0aGlzLl9hc3BlY3RSYXRpb3x8Yil7Yj1hLm1pbkhlaWdodCp0aGlzLmFzcGVjdFJhdGlvO2Q9YS5taW5XaWR0aC90aGlzLmFzcGVjdFJhdGlvO2M9YS5tYXhIZWlnaHQqdGhpcy5hc3BlY3RSYXRpbztmPWEubWF4V2lkdGgvdGhpcy5hc3BlY3RSYXRpbztpZihiPmEubWluV2lkdGgpYS5taW5XaWR0aD1iO2lmKGQ+YS5taW5IZWlnaHQpYS5taW5IZWlnaHQ9ZDtpZihjPGEubWF4V2lkdGgpYS5tYXhXaWR0aD1jO2lmKGY8YS5tYXhIZWlnaHQpYS5tYXhIZWlnaHQ9Zn10aGlzLl92Qm91bmRhcmllcz1hfSxfdXBkYXRlQ2FjaGU6ZnVuY3Rpb24oYil7dGhpcy5vZmZzZXQ9dGhpcy5oZWxwZXIub2Zmc2V0KCk7aWYoayhiLmxlZnQpKXRoaXMucG9zaXRpb24ubGVmdD1iLmxlZnQ7aWYoayhiLnRvcCkpdGhpcy5wb3NpdGlvbi50b3A9Yi50b3A7aWYoayhiLmhlaWdodCkpdGhpcy5zaXplLmhlaWdodD1iLmhlaWdodDtpZihrKGIud2lkdGgpKXRoaXMuc2l6ZS53aWR0aD1cclxuYi53aWR0aH0sX3VwZGF0ZVJhdGlvOmZ1bmN0aW9uKGIpe3ZhciBhPXRoaXMucG9zaXRpb24sYz10aGlzLnNpemUsZD10aGlzLmF4aXM7aWYoayhiLmhlaWdodCkpYi53aWR0aD1iLmhlaWdodCp0aGlzLmFzcGVjdFJhdGlvO2Vsc2UgaWYoayhiLndpZHRoKSliLmhlaWdodD1iLndpZHRoL3RoaXMuYXNwZWN0UmF0aW87aWYoZD09XCJzd1wiKXtiLmxlZnQ9YS5sZWZ0KyhjLndpZHRoLWIud2lkdGgpO2IudG9wPW51bGx9aWYoZD09XCJud1wiKXtiLnRvcD1hLnRvcCsoYy5oZWlnaHQtYi5oZWlnaHQpO2IubGVmdD1hLmxlZnQrKGMud2lkdGgtYi53aWR0aCl9cmV0dXJuIGJ9LF9yZXNwZWN0U2l6ZTpmdW5jdGlvbihiKXt2YXIgYT10aGlzLl92Qm91bmRhcmllcyxjPXRoaXMuYXhpcyxkPWsoYi53aWR0aCkmJmEubWF4V2lkdGgmJmEubWF4V2lkdGg8Yi53aWR0aCxmPWsoYi5oZWlnaHQpJiZhLm1heEhlaWdodCYmYS5tYXhIZWlnaHQ8Yi5oZWlnaHQsZz1rKGIud2lkdGgpJiZhLm1pbldpZHRoJiZcclxuYS5taW5XaWR0aD5iLndpZHRoLGg9ayhiLmhlaWdodCkmJmEubWluSGVpZ2h0JiZhLm1pbkhlaWdodD5iLmhlaWdodDtpZihnKWIud2lkdGg9YS5taW5XaWR0aDtpZihoKWIuaGVpZ2h0PWEubWluSGVpZ2h0O2lmKGQpYi53aWR0aD1hLm1heFdpZHRoO2lmKGYpYi5oZWlnaHQ9YS5tYXhIZWlnaHQ7dmFyIGk9dGhpcy5vcmlnaW5hbFBvc2l0aW9uLmxlZnQrdGhpcy5vcmlnaW5hbFNpemUud2lkdGgsaj10aGlzLnBvc2l0aW9uLnRvcCt0aGlzLnNpemUuaGVpZ2h0LGw9L3N3fG53fHcvLnRlc3QoYyk7Yz0vbnd8bmV8bi8udGVzdChjKTtpZihnJiZsKWIubGVmdD1pLWEubWluV2lkdGg7aWYoZCYmbCliLmxlZnQ9aS1hLm1heFdpZHRoO2lmKGgmJmMpYi50b3A9ai1hLm1pbkhlaWdodDtpZihmJiZjKWIudG9wPWotYS5tYXhIZWlnaHQ7aWYoKGE9IWIud2lkdGgmJiFiLmhlaWdodCkmJiFiLmxlZnQmJmIudG9wKWIudG9wPW51bGw7ZWxzZSBpZihhJiYhYi50b3AmJmIubGVmdCliLmxlZnQ9XHJcbm51bGw7cmV0dXJuIGJ9LF9wcm9wb3J0aW9uYWxseVJlc2l6ZTpmdW5jdGlvbigpe2lmKHRoaXMuX3Byb3BvcnRpb25hbGx5UmVzaXplRWxlbWVudHMubGVuZ3RoKWZvcih2YXIgYj10aGlzLmhlbHBlcnx8dGhpcy5lbGVtZW50LGE9MDthPHRoaXMuX3Byb3BvcnRpb25hbGx5UmVzaXplRWxlbWVudHMubGVuZ3RoO2ErKyl7dmFyIGM9dGhpcy5fcHJvcG9ydGlvbmFsbHlSZXNpemVFbGVtZW50c1thXTtpZighdGhpcy5ib3JkZXJEaWYpe3ZhciBkPVtjLmNzcyhcImJvcmRlclRvcFdpZHRoXCIpLGMuY3NzKFwiYm9yZGVyUmlnaHRXaWR0aFwiKSxjLmNzcyhcImJvcmRlckJvdHRvbVdpZHRoXCIpLGMuY3NzKFwiYm9yZGVyTGVmdFdpZHRoXCIpXSxmPVtjLmNzcyhcInBhZGRpbmdUb3BcIiksYy5jc3MoXCJwYWRkaW5nUmlnaHRcIiksYy5jc3MoXCJwYWRkaW5nQm90dG9tXCIpLGMuY3NzKFwicGFkZGluZ0xlZnRcIildO3RoaXMuYm9yZGVyRGlmPWUubWFwKGQsZnVuY3Rpb24oZyxoKXtnPXBhcnNlSW50KGcsMTApfHxcclxuMDtoPXBhcnNlSW50KGZbaF0sMTApfHwwO3JldHVybiBnK2h9KX1lLmJyb3dzZXIubXNpZSYmKGUoYikuaXMoXCI6aGlkZGVuXCIpfHxlKGIpLnBhcmVudHMoXCI6aGlkZGVuXCIpLmxlbmd0aCl8fGMuY3NzKHtoZWlnaHQ6Yi5oZWlnaHQoKS10aGlzLmJvcmRlckRpZlswXS10aGlzLmJvcmRlckRpZlsyXXx8MCx3aWR0aDpiLndpZHRoKCktdGhpcy5ib3JkZXJEaWZbMV0tdGhpcy5ib3JkZXJEaWZbM118fDB9KX19LF9yZW5kZXJQcm94eTpmdW5jdGlvbigpe3ZhciBiPXRoaXMub3B0aW9uczt0aGlzLmVsZW1lbnRPZmZzZXQ9dGhpcy5lbGVtZW50Lm9mZnNldCgpO2lmKHRoaXMuX2hlbHBlcil7dGhpcy5oZWxwZXI9dGhpcy5oZWxwZXJ8fGUoJzxkaXYgc3R5bGU9XCJvdmVyZmxvdzpoaWRkZW47XCI+PC9kaXY+Jyk7dmFyIGE9ZS5icm93c2VyLm1zaWUmJmUuYnJvd3Nlci52ZXJzaW9uPDcsYz1hPzE6MDthPWE/MjotMTt0aGlzLmhlbHBlci5hZGRDbGFzcyh0aGlzLl9oZWxwZXIpLmNzcyh7d2lkdGg6dGhpcy5lbGVtZW50Lm91dGVyV2lkdGgoKStcclxuYSxoZWlnaHQ6dGhpcy5lbGVtZW50Lm91dGVySGVpZ2h0KCkrYSxwb3NpdGlvbjpcImFic29sdXRlXCIsbGVmdDp0aGlzLmVsZW1lbnRPZmZzZXQubGVmdC1jK1wicHhcIix0b3A6dGhpcy5lbGVtZW50T2Zmc2V0LnRvcC1jK1wicHhcIix6SW5kZXg6KytiLnpJbmRleH0pO3RoaXMuaGVscGVyLmFwcGVuZFRvKFwiYm9keVwiKS5kaXNhYmxlU2VsZWN0aW9uKCl9ZWxzZSB0aGlzLmhlbHBlcj10aGlzLmVsZW1lbnR9LF9jaGFuZ2U6e2U6ZnVuY3Rpb24oYixhKXtyZXR1cm57d2lkdGg6dGhpcy5vcmlnaW5hbFNpemUud2lkdGgrYX19LHc6ZnVuY3Rpb24oYixhKXtyZXR1cm57bGVmdDp0aGlzLm9yaWdpbmFsUG9zaXRpb24ubGVmdCthLHdpZHRoOnRoaXMub3JpZ2luYWxTaXplLndpZHRoLWF9fSxuOmZ1bmN0aW9uKGIsYSxjKXtyZXR1cm57dG9wOnRoaXMub3JpZ2luYWxQb3NpdGlvbi50b3ArYyxoZWlnaHQ6dGhpcy5vcmlnaW5hbFNpemUuaGVpZ2h0LWN9fSxzOmZ1bmN0aW9uKGIsYSxjKXtyZXR1cm57aGVpZ2h0OnRoaXMub3JpZ2luYWxTaXplLmhlaWdodCtcclxuY319LHNlOmZ1bmN0aW9uKGIsYSxjKXtyZXR1cm4gZS5leHRlbmQodGhpcy5fY2hhbmdlLnMuYXBwbHkodGhpcyxhcmd1bWVudHMpLHRoaXMuX2NoYW5nZS5lLmFwcGx5KHRoaXMsW2IsYSxjXSkpfSxzdzpmdW5jdGlvbihiLGEsYyl7cmV0dXJuIGUuZXh0ZW5kKHRoaXMuX2NoYW5nZS5zLmFwcGx5KHRoaXMsYXJndW1lbnRzKSx0aGlzLl9jaGFuZ2Uudy5hcHBseSh0aGlzLFtiLGEsY10pKX0sbmU6ZnVuY3Rpb24oYixhLGMpe3JldHVybiBlLmV4dGVuZCh0aGlzLl9jaGFuZ2Uubi5hcHBseSh0aGlzLGFyZ3VtZW50cyksdGhpcy5fY2hhbmdlLmUuYXBwbHkodGhpcyxbYixhLGNdKSl9LG53OmZ1bmN0aW9uKGIsYSxjKXtyZXR1cm4gZS5leHRlbmQodGhpcy5fY2hhbmdlLm4uYXBwbHkodGhpcyxhcmd1bWVudHMpLHRoaXMuX2NoYW5nZS53LmFwcGx5KHRoaXMsW2IsYSxjXSkpfX0sX3Byb3BhZ2F0ZTpmdW5jdGlvbihiLGEpe2UudWkucGx1Z2luLmNhbGwodGhpcyxiLFthLHRoaXMudWkoKV0pO1xyXG5iIT1cInJlc2l6ZVwiJiZ0aGlzLl90cmlnZ2VyKGIsYSx0aGlzLnVpKCkpfSxwbHVnaW5zOnt9LHVpOmZ1bmN0aW9uKCl7cmV0dXJue29yaWdpbmFsRWxlbWVudDp0aGlzLm9yaWdpbmFsRWxlbWVudCxlbGVtZW50OnRoaXMuZWxlbWVudCxoZWxwZXI6dGhpcy5oZWxwZXIscG9zaXRpb246dGhpcy5wb3NpdGlvbixzaXplOnRoaXMuc2l6ZSxvcmlnaW5hbFNpemU6dGhpcy5vcmlnaW5hbFNpemUsb3JpZ2luYWxQb3NpdGlvbjp0aGlzLm9yaWdpbmFsUG9zaXRpb259fX0pO2UuZXh0ZW5kKGUudWkucmVzaXphYmxlLHt2ZXJzaW9uOlwiMS44LjE2XCJ9KTtlLnVpLnBsdWdpbi5hZGQoXCJyZXNpemFibGVcIixcImFsc29SZXNpemVcIix7c3RhcnQ6ZnVuY3Rpb24oKXt2YXIgYj1lKHRoaXMpLmRhdGEoXCJyZXNpemFibGVcIikub3B0aW9ucyxhPWZ1bmN0aW9uKGMpe2UoYykuZWFjaChmdW5jdGlvbigpe3ZhciBkPWUodGhpcyk7ZC5kYXRhKFwicmVzaXphYmxlLWFsc29yZXNpemVcIix7d2lkdGg6cGFyc2VJbnQoZC53aWR0aCgpLFxyXG4xMCksaGVpZ2h0OnBhcnNlSW50KGQuaGVpZ2h0KCksMTApLGxlZnQ6cGFyc2VJbnQoZC5jc3MoXCJsZWZ0XCIpLDEwKSx0b3A6cGFyc2VJbnQoZC5jc3MoXCJ0b3BcIiksMTApLHBvc2l0aW9uOmQuY3NzKFwicG9zaXRpb25cIil9KX0pfTtpZih0eXBlb2YgYi5hbHNvUmVzaXplPT1cIm9iamVjdFwiJiYhYi5hbHNvUmVzaXplLnBhcmVudE5vZGUpaWYoYi5hbHNvUmVzaXplLmxlbmd0aCl7Yi5hbHNvUmVzaXplPWIuYWxzb1Jlc2l6ZVswXTthKGIuYWxzb1Jlc2l6ZSl9ZWxzZSBlLmVhY2goYi5hbHNvUmVzaXplLGZ1bmN0aW9uKGMpe2EoYyl9KTtlbHNlIGEoYi5hbHNvUmVzaXplKX0scmVzaXplOmZ1bmN0aW9uKGIsYSl7dmFyIGM9ZSh0aGlzKS5kYXRhKFwicmVzaXphYmxlXCIpO2I9Yy5vcHRpb25zO3ZhciBkPWMub3JpZ2luYWxTaXplLGY9Yy5vcmlnaW5hbFBvc2l0aW9uLGc9e2hlaWdodDpjLnNpemUuaGVpZ2h0LWQuaGVpZ2h0fHwwLHdpZHRoOmMuc2l6ZS53aWR0aC1kLndpZHRofHwwLHRvcDpjLnBvc2l0aW9uLnRvcC1cclxuZi50b3B8fDAsbGVmdDpjLnBvc2l0aW9uLmxlZnQtZi5sZWZ0fHwwfSxoPWZ1bmN0aW9uKGksail7ZShpKS5lYWNoKGZ1bmN0aW9uKCl7dmFyIGw9ZSh0aGlzKSxxPWUodGhpcykuZGF0YShcInJlc2l6YWJsZS1hbHNvcmVzaXplXCIpLHA9e30scj1qJiZqLmxlbmd0aD9qOmwucGFyZW50cyhhLm9yaWdpbmFsRWxlbWVudFswXSkubGVuZ3RoP1tcIndpZHRoXCIsXCJoZWlnaHRcIl06W1wid2lkdGhcIixcImhlaWdodFwiLFwidG9wXCIsXCJsZWZ0XCJdO2UuZWFjaChyLGZ1bmN0aW9uKG4sbyl7aWYoKG49KHFbb118fDApKyhnW29dfHwwKSkmJm4+PTApcFtvXT1ufHxudWxsfSk7aWYoZS5icm93c2VyLm9wZXJhJiYvcmVsYXRpdmUvLnRlc3QobC5jc3MoXCJwb3NpdGlvblwiKSkpe2MuX3JldmVydFRvUmVsYXRpdmVQb3NpdGlvbj10cnVlO2wuY3NzKHtwb3NpdGlvbjpcImFic29sdXRlXCIsdG9wOlwiYXV0b1wiLGxlZnQ6XCJhdXRvXCJ9KX1sLmNzcyhwKX0pfTt0eXBlb2YgYi5hbHNvUmVzaXplPT1cIm9iamVjdFwiJiYhYi5hbHNvUmVzaXplLm5vZGVUeXBlP1xyXG5lLmVhY2goYi5hbHNvUmVzaXplLGZ1bmN0aW9uKGksail7aChpLGopfSk6aChiLmFsc29SZXNpemUpfSxzdG9wOmZ1bmN0aW9uKCl7dmFyIGI9ZSh0aGlzKS5kYXRhKFwicmVzaXphYmxlXCIpLGE9Yi5vcHRpb25zLGM9ZnVuY3Rpb24oZCl7ZShkKS5lYWNoKGZ1bmN0aW9uKCl7dmFyIGY9ZSh0aGlzKTtmLmNzcyh7cG9zaXRpb246Zi5kYXRhKFwicmVzaXphYmxlLWFsc29yZXNpemVcIikucG9zaXRpb259KX0pfTtpZihiLl9yZXZlcnRUb1JlbGF0aXZlUG9zaXRpb24pe2IuX3JldmVydFRvUmVsYXRpdmVQb3NpdGlvbj1mYWxzZTt0eXBlb2YgYS5hbHNvUmVzaXplPT1cIm9iamVjdFwiJiYhYS5hbHNvUmVzaXplLm5vZGVUeXBlP2UuZWFjaChhLmFsc29SZXNpemUsZnVuY3Rpb24oZCl7YyhkKX0pOmMoYS5hbHNvUmVzaXplKX1lKHRoaXMpLnJlbW92ZURhdGEoXCJyZXNpemFibGUtYWxzb3Jlc2l6ZVwiKX19KTtlLnVpLnBsdWdpbi5hZGQoXCJyZXNpemFibGVcIixcImFuaW1hdGVcIix7c3RvcDpmdW5jdGlvbihiKXt2YXIgYT1cclxuZSh0aGlzKS5kYXRhKFwicmVzaXphYmxlXCIpLGM9YS5vcHRpb25zLGQ9YS5fcHJvcG9ydGlvbmFsbHlSZXNpemVFbGVtZW50cyxmPWQubGVuZ3RoJiYvdGV4dGFyZWEvaS50ZXN0KGRbMF0ubm9kZU5hbWUpLGc9ZiYmZS51aS5oYXNTY3JvbGwoZFswXSxcImxlZnRcIik/MDphLnNpemVEaWZmLmhlaWdodDtmPXt3aWR0aDphLnNpemUud2lkdGgtKGY/MDphLnNpemVEaWZmLndpZHRoKSxoZWlnaHQ6YS5zaXplLmhlaWdodC1nfTtnPXBhcnNlSW50KGEuZWxlbWVudC5jc3MoXCJsZWZ0XCIpLDEwKSsoYS5wb3NpdGlvbi5sZWZ0LWEub3JpZ2luYWxQb3NpdGlvbi5sZWZ0KXx8bnVsbDt2YXIgaD1wYXJzZUludChhLmVsZW1lbnQuY3NzKFwidG9wXCIpLDEwKSsoYS5wb3NpdGlvbi50b3AtYS5vcmlnaW5hbFBvc2l0aW9uLnRvcCl8fG51bGw7YS5lbGVtZW50LmFuaW1hdGUoZS5leHRlbmQoZixoJiZnP3t0b3A6aCxsZWZ0Omd9Ont9KSx7ZHVyYXRpb246Yy5hbmltYXRlRHVyYXRpb24sZWFzaW5nOmMuYW5pbWF0ZUVhc2luZyxcclxuc3RlcDpmdW5jdGlvbigpe3ZhciBpPXt3aWR0aDpwYXJzZUludChhLmVsZW1lbnQuY3NzKFwid2lkdGhcIiksMTApLGhlaWdodDpwYXJzZUludChhLmVsZW1lbnQuY3NzKFwiaGVpZ2h0XCIpLDEwKSx0b3A6cGFyc2VJbnQoYS5lbGVtZW50LmNzcyhcInRvcFwiKSwxMCksbGVmdDpwYXJzZUludChhLmVsZW1lbnQuY3NzKFwibGVmdFwiKSwxMCl9O2QmJmQubGVuZ3RoJiZlKGRbMF0pLmNzcyh7d2lkdGg6aS53aWR0aCxoZWlnaHQ6aS5oZWlnaHR9KTthLl91cGRhdGVDYWNoZShpKTthLl9wcm9wYWdhdGUoXCJyZXNpemVcIixiKX19KX19KTtlLnVpLnBsdWdpbi5hZGQoXCJyZXNpemFibGVcIixcImNvbnRhaW5tZW50XCIse3N0YXJ0OmZ1bmN0aW9uKCl7dmFyIGI9ZSh0aGlzKS5kYXRhKFwicmVzaXphYmxlXCIpLGE9Yi5lbGVtZW50LGM9Yi5vcHRpb25zLmNvbnRhaW5tZW50O2lmKGE9YyBpbnN0YW5jZW9mIGU/Yy5nZXQoMCk6L3BhcmVudC8udGVzdChjKT9hLnBhcmVudCgpLmdldCgwKTpjKXtiLmNvbnRhaW5lckVsZW1lbnQ9XHJcbmUoYSk7aWYoL2RvY3VtZW50Ly50ZXN0KGMpfHxjPT1kb2N1bWVudCl7Yi5jb250YWluZXJPZmZzZXQ9e2xlZnQ6MCx0b3A6MH07Yi5jb250YWluZXJQb3NpdGlvbj17bGVmdDowLHRvcDowfTtiLnBhcmVudERhdGE9e2VsZW1lbnQ6ZShkb2N1bWVudCksbGVmdDowLHRvcDowLHdpZHRoOmUoZG9jdW1lbnQpLndpZHRoKCksaGVpZ2h0OmUoZG9jdW1lbnQpLmhlaWdodCgpfHxkb2N1bWVudC5ib2R5LnBhcmVudE5vZGUuc2Nyb2xsSGVpZ2h0fX1lbHNle3ZhciBkPWUoYSksZj1bXTtlKFtcIlRvcFwiLFwiUmlnaHRcIixcIkxlZnRcIixcIkJvdHRvbVwiXSkuZWFjaChmdW5jdGlvbihpLGope2ZbaV09bShkLmNzcyhcInBhZGRpbmdcIitqKSl9KTtiLmNvbnRhaW5lck9mZnNldD1kLm9mZnNldCgpO2IuY29udGFpbmVyUG9zaXRpb249ZC5wb3NpdGlvbigpO2IuY29udGFpbmVyU2l6ZT17aGVpZ2h0OmQuaW5uZXJIZWlnaHQoKS1mWzNdLHdpZHRoOmQuaW5uZXJXaWR0aCgpLWZbMV19O2M9Yi5jb250YWluZXJPZmZzZXQ7XHJcbnZhciBnPWIuY29udGFpbmVyU2l6ZS5oZWlnaHQsaD1iLmNvbnRhaW5lclNpemUud2lkdGg7aD1lLnVpLmhhc1Njcm9sbChhLFwibGVmdFwiKT9hLnNjcm9sbFdpZHRoOmg7Zz1lLnVpLmhhc1Njcm9sbChhKT9hLnNjcm9sbEhlaWdodDpnO2IucGFyZW50RGF0YT17ZWxlbWVudDphLGxlZnQ6Yy5sZWZ0LHRvcDpjLnRvcCx3aWR0aDpoLGhlaWdodDpnfX19fSxyZXNpemU6ZnVuY3Rpb24oYil7dmFyIGE9ZSh0aGlzKS5kYXRhKFwicmVzaXphYmxlXCIpLGM9YS5vcHRpb25zLGQ9YS5jb250YWluZXJPZmZzZXQsZj1hLnBvc2l0aW9uO2I9YS5fYXNwZWN0UmF0aW98fGIuc2hpZnRLZXk7dmFyIGc9e3RvcDowLGxlZnQ6MH0saD1hLmNvbnRhaW5lckVsZW1lbnQ7aWYoaFswXSE9ZG9jdW1lbnQmJi9zdGF0aWMvLnRlc3QoaC5jc3MoXCJwb3NpdGlvblwiKSkpZz1kO2lmKGYubGVmdDwoYS5faGVscGVyP2QubGVmdDowKSl7YS5zaXplLndpZHRoKz1hLl9oZWxwZXI/YS5wb3NpdGlvbi5sZWZ0LWQubGVmdDpcclxuYS5wb3NpdGlvbi5sZWZ0LWcubGVmdDtpZihiKWEuc2l6ZS5oZWlnaHQ9YS5zaXplLndpZHRoL2MuYXNwZWN0UmF0aW87YS5wb3NpdGlvbi5sZWZ0PWMuaGVscGVyP2QubGVmdDowfWlmKGYudG9wPChhLl9oZWxwZXI/ZC50b3A6MCkpe2Euc2l6ZS5oZWlnaHQrPWEuX2hlbHBlcj9hLnBvc2l0aW9uLnRvcC1kLnRvcDphLnBvc2l0aW9uLnRvcDtpZihiKWEuc2l6ZS53aWR0aD1hLnNpemUuaGVpZ2h0KmMuYXNwZWN0UmF0aW87YS5wb3NpdGlvbi50b3A9YS5faGVscGVyP2QudG9wOjB9YS5vZmZzZXQubGVmdD1hLnBhcmVudERhdGEubGVmdCthLnBvc2l0aW9uLmxlZnQ7YS5vZmZzZXQudG9wPWEucGFyZW50RGF0YS50b3ArYS5wb3NpdGlvbi50b3A7Yz1NYXRoLmFicygoYS5faGVscGVyP2Eub2Zmc2V0LmxlZnQtZy5sZWZ0OmEub2Zmc2V0LmxlZnQtZy5sZWZ0KSthLnNpemVEaWZmLndpZHRoKTtkPU1hdGguYWJzKChhLl9oZWxwZXI/YS5vZmZzZXQudG9wLWcudG9wOmEub2Zmc2V0LnRvcC1cclxuZC50b3ApK2Euc2l6ZURpZmYuaGVpZ2h0KTtmPWEuY29udGFpbmVyRWxlbWVudC5nZXQoMCk9PWEuZWxlbWVudC5wYXJlbnQoKS5nZXQoMCk7Zz0vcmVsYXRpdmV8YWJzb2x1dGUvLnRlc3QoYS5jb250YWluZXJFbGVtZW50LmNzcyhcInBvc2l0aW9uXCIpKTtpZihmJiZnKWMtPWEucGFyZW50RGF0YS5sZWZ0O2lmKGMrYS5zaXplLndpZHRoPj1hLnBhcmVudERhdGEud2lkdGgpe2Euc2l6ZS53aWR0aD1hLnBhcmVudERhdGEud2lkdGgtYztpZihiKWEuc2l6ZS5oZWlnaHQ9YS5zaXplLndpZHRoL2EuYXNwZWN0UmF0aW99aWYoZCthLnNpemUuaGVpZ2h0Pj1hLnBhcmVudERhdGEuaGVpZ2h0KXthLnNpemUuaGVpZ2h0PWEucGFyZW50RGF0YS5oZWlnaHQtZDtpZihiKWEuc2l6ZS53aWR0aD1hLnNpemUuaGVpZ2h0KmEuYXNwZWN0UmF0aW99fSxzdG9wOmZ1bmN0aW9uKCl7dmFyIGI9ZSh0aGlzKS5kYXRhKFwicmVzaXphYmxlXCIpLGE9Yi5vcHRpb25zLGM9Yi5jb250YWluZXJPZmZzZXQsZD1iLmNvbnRhaW5lclBvc2l0aW9uLFxyXG5mPWIuY29udGFpbmVyRWxlbWVudCxnPWUoYi5oZWxwZXIpLGg9Zy5vZmZzZXQoKSxpPWcub3V0ZXJXaWR0aCgpLWIuc2l6ZURpZmYud2lkdGg7Zz1nLm91dGVySGVpZ2h0KCktYi5zaXplRGlmZi5oZWlnaHQ7Yi5faGVscGVyJiYhYS5hbmltYXRlJiYvcmVsYXRpdmUvLnRlc3QoZi5jc3MoXCJwb3NpdGlvblwiKSkmJmUodGhpcykuY3NzKHtsZWZ0OmgubGVmdC1kLmxlZnQtYy5sZWZ0LHdpZHRoOmksaGVpZ2h0Omd9KTtiLl9oZWxwZXImJiFhLmFuaW1hdGUmJi9zdGF0aWMvLnRlc3QoZi5jc3MoXCJwb3NpdGlvblwiKSkmJmUodGhpcykuY3NzKHtsZWZ0OmgubGVmdC1kLmxlZnQtYy5sZWZ0LHdpZHRoOmksaGVpZ2h0Omd9KX19KTtlLnVpLnBsdWdpbi5hZGQoXCJyZXNpemFibGVcIixcImdob3N0XCIse3N0YXJ0OmZ1bmN0aW9uKCl7dmFyIGI9ZSh0aGlzKS5kYXRhKFwicmVzaXphYmxlXCIpLGE9Yi5vcHRpb25zLGM9Yi5zaXplO2IuZ2hvc3Q9Yi5vcmlnaW5hbEVsZW1lbnQuY2xvbmUoKTtiLmdob3N0LmNzcyh7b3BhY2l0eTowLjI1LFxyXG5kaXNwbGF5OlwiYmxvY2tcIixwb3NpdGlvbjpcInJlbGF0aXZlXCIsaGVpZ2h0OmMuaGVpZ2h0LHdpZHRoOmMud2lkdGgsbWFyZ2luOjAsbGVmdDowLHRvcDowfSkuYWRkQ2xhc3MoXCJ1aS1yZXNpemFibGUtZ2hvc3RcIikuYWRkQ2xhc3ModHlwZW9mIGEuZ2hvc3Q9PVwic3RyaW5nXCI/YS5naG9zdDpcIlwiKTtiLmdob3N0LmFwcGVuZFRvKGIuaGVscGVyKX0scmVzaXplOmZ1bmN0aW9uKCl7dmFyIGI9ZSh0aGlzKS5kYXRhKFwicmVzaXphYmxlXCIpO2IuZ2hvc3QmJmIuZ2hvc3QuY3NzKHtwb3NpdGlvbjpcInJlbGF0aXZlXCIsaGVpZ2h0OmIuc2l6ZS5oZWlnaHQsd2lkdGg6Yi5zaXplLndpZHRofSl9LHN0b3A6ZnVuY3Rpb24oKXt2YXIgYj1lKHRoaXMpLmRhdGEoXCJyZXNpemFibGVcIik7Yi5naG9zdCYmYi5oZWxwZXImJmIuaGVscGVyLmdldCgwKS5yZW1vdmVDaGlsZChiLmdob3N0LmdldCgwKSl9fSk7ZS51aS5wbHVnaW4uYWRkKFwicmVzaXphYmxlXCIsXCJncmlkXCIse3Jlc2l6ZTpmdW5jdGlvbigpe3ZhciBiPVxyXG5lKHRoaXMpLmRhdGEoXCJyZXNpemFibGVcIiksYT1iLm9wdGlvbnMsYz1iLnNpemUsZD1iLm9yaWdpbmFsU2l6ZSxmPWIub3JpZ2luYWxQb3NpdGlvbixnPWIuYXhpczthLmdyaWQ9dHlwZW9mIGEuZ3JpZD09XCJudW1iZXJcIj9bYS5ncmlkLGEuZ3JpZF06YS5ncmlkO3ZhciBoPU1hdGgucm91bmQoKGMud2lkdGgtZC53aWR0aCkvKGEuZ3JpZFswXXx8MSkpKihhLmdyaWRbMF18fDEpO2E9TWF0aC5yb3VuZCgoYy5oZWlnaHQtZC5oZWlnaHQpLyhhLmdyaWRbMV18fDEpKSooYS5ncmlkWzFdfHwxKTtpZigvXihzZXxzfGUpJC8udGVzdChnKSl7Yi5zaXplLndpZHRoPWQud2lkdGgraDtiLnNpemUuaGVpZ2h0PWQuaGVpZ2h0K2F9ZWxzZSBpZigvXihuZSkkLy50ZXN0KGcpKXtiLnNpemUud2lkdGg9ZC53aWR0aCtoO2Iuc2l6ZS5oZWlnaHQ9ZC5oZWlnaHQrYTtiLnBvc2l0aW9uLnRvcD1mLnRvcC1hfWVsc2V7aWYoL14oc3cpJC8udGVzdChnKSl7Yi5zaXplLndpZHRoPWQud2lkdGgraDtiLnNpemUuaGVpZ2h0PVxyXG5kLmhlaWdodCthfWVsc2V7Yi5zaXplLndpZHRoPWQud2lkdGgraDtiLnNpemUuaGVpZ2h0PWQuaGVpZ2h0K2E7Yi5wb3NpdGlvbi50b3A9Zi50b3AtYX1iLnBvc2l0aW9uLmxlZnQ9Zi5sZWZ0LWh9fX0pO3ZhciBtPWZ1bmN0aW9uKGIpe3JldHVybiBwYXJzZUludChiLDEwKXx8MH0saz1mdW5jdGlvbihiKXtyZXR1cm4haXNOYU4ocGFyc2VJbnQoYiwxMCkpfX0pKGpRdWVyeSk7XHJcbjsvKlxyXG4gKiBqUXVlcnkgVUkgU2VsZWN0YWJsZSAxLjguMTZcclxuICpcclxuICogQ29weXJpZ2h0IDIwMTEsIEFVVEhPUlMudHh0IChodHRwOi8vanF1ZXJ5dWkuY29tL2Fib3V0KVxyXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgb3IgR1BMIFZlcnNpb24gMiBsaWNlbnNlcy5cclxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxyXG4gKlxyXG4gKiBodHRwOi8vZG9jcy5qcXVlcnkuY29tL1VJL1NlbGVjdGFibGVzXHJcbiAqXHJcbiAqIERlcGVuZHM6XHJcbiAqXHRqcXVlcnkudWkuY29yZS5qc1xyXG4gKlx0anF1ZXJ5LnVpLm1vdXNlLmpzXHJcbiAqXHRqcXVlcnkudWkud2lkZ2V0LmpzXHJcbiAqL1xyXG4oZnVuY3Rpb24oZSl7ZS53aWRnZXQoXCJ1aS5zZWxlY3RhYmxlXCIsZS51aS5tb3VzZSx7b3B0aW9uczp7YXBwZW5kVG86XCJib2R5XCIsYXV0b1JlZnJlc2g6dHJ1ZSxkaXN0YW5jZTowLGZpbHRlcjpcIipcIix0b2xlcmFuY2U6XCJ0b3VjaFwifSxfY3JlYXRlOmZ1bmN0aW9uKCl7dmFyIGM9dGhpczt0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoXCJ1aS1zZWxlY3RhYmxlXCIpO3RoaXMuZHJhZ2dlZD1mYWxzZTt2YXIgZjt0aGlzLnJlZnJlc2g9ZnVuY3Rpb24oKXtmPWUoYy5vcHRpb25zLmZpbHRlcixjLmVsZW1lbnRbMF0pO2YuZWFjaChmdW5jdGlvbigpe3ZhciBkPWUodGhpcyksYj1kLm9mZnNldCgpO2UuZGF0YSh0aGlzLFwic2VsZWN0YWJsZS1pdGVtXCIse2VsZW1lbnQ6dGhpcywkZWxlbWVudDpkLGxlZnQ6Yi5sZWZ0LHRvcDpiLnRvcCxyaWdodDpiLmxlZnQrZC5vdXRlcldpZHRoKCksYm90dG9tOmIudG9wK2Qub3V0ZXJIZWlnaHQoKSxzdGFydHNlbGVjdGVkOmZhbHNlLHNlbGVjdGVkOmQuaGFzQ2xhc3MoXCJ1aS1zZWxlY3RlZFwiKSxcclxuc2VsZWN0aW5nOmQuaGFzQ2xhc3MoXCJ1aS1zZWxlY3RpbmdcIiksdW5zZWxlY3Rpbmc6ZC5oYXNDbGFzcyhcInVpLXVuc2VsZWN0aW5nXCIpfSl9KX07dGhpcy5yZWZyZXNoKCk7dGhpcy5zZWxlY3RlZXM9Zi5hZGRDbGFzcyhcInVpLXNlbGVjdGVlXCIpO3RoaXMuX21vdXNlSW5pdCgpO3RoaXMuaGVscGVyPWUoXCI8ZGl2IGNsYXNzPSd1aS1zZWxlY3RhYmxlLWhlbHBlcic+PC9kaXY+XCIpfSxkZXN0cm95OmZ1bmN0aW9uKCl7dGhpcy5zZWxlY3RlZXMucmVtb3ZlQ2xhc3MoXCJ1aS1zZWxlY3RlZVwiKS5yZW1vdmVEYXRhKFwic2VsZWN0YWJsZS1pdGVtXCIpO3RoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyhcInVpLXNlbGVjdGFibGUgdWktc2VsZWN0YWJsZS1kaXNhYmxlZFwiKS5yZW1vdmVEYXRhKFwic2VsZWN0YWJsZVwiKS51bmJpbmQoXCIuc2VsZWN0YWJsZVwiKTt0aGlzLl9tb3VzZURlc3Ryb3koKTtyZXR1cm4gdGhpc30sX21vdXNlU3RhcnQ6ZnVuY3Rpb24oYyl7dmFyIGY9dGhpczt0aGlzLm9wb3M9W2MucGFnZVgsXHJcbmMucGFnZVldO2lmKCF0aGlzLm9wdGlvbnMuZGlzYWJsZWQpe3ZhciBkPXRoaXMub3B0aW9uczt0aGlzLnNlbGVjdGVlcz1lKGQuZmlsdGVyLHRoaXMuZWxlbWVudFswXSk7dGhpcy5fdHJpZ2dlcihcInN0YXJ0XCIsYyk7ZShkLmFwcGVuZFRvKS5hcHBlbmQodGhpcy5oZWxwZXIpO3RoaXMuaGVscGVyLmNzcyh7bGVmdDpjLmNsaWVudFgsdG9wOmMuY2xpZW50WSx3aWR0aDowLGhlaWdodDowfSk7ZC5hdXRvUmVmcmVzaCYmdGhpcy5yZWZyZXNoKCk7dGhpcy5zZWxlY3RlZXMuZmlsdGVyKFwiLnVpLXNlbGVjdGVkXCIpLmVhY2goZnVuY3Rpb24oKXt2YXIgYj1lLmRhdGEodGhpcyxcInNlbGVjdGFibGUtaXRlbVwiKTtiLnN0YXJ0c2VsZWN0ZWQ9dHJ1ZTtpZighYy5tZXRhS2V5KXtiLiRlbGVtZW50LnJlbW92ZUNsYXNzKFwidWktc2VsZWN0ZWRcIik7Yi5zZWxlY3RlZD1mYWxzZTtiLiRlbGVtZW50LmFkZENsYXNzKFwidWktdW5zZWxlY3RpbmdcIik7Yi51bnNlbGVjdGluZz10cnVlO2YuX3RyaWdnZXIoXCJ1bnNlbGVjdGluZ1wiLFxyXG5jLHt1bnNlbGVjdGluZzpiLmVsZW1lbnR9KX19KTtlKGMudGFyZ2V0KS5wYXJlbnRzKCkuYW5kU2VsZigpLmVhY2goZnVuY3Rpb24oKXt2YXIgYj1lLmRhdGEodGhpcyxcInNlbGVjdGFibGUtaXRlbVwiKTtpZihiKXt2YXIgZz0hYy5tZXRhS2V5fHwhYi4kZWxlbWVudC5oYXNDbGFzcyhcInVpLXNlbGVjdGVkXCIpO2IuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoZz9cInVpLXVuc2VsZWN0aW5nXCI6XCJ1aS1zZWxlY3RlZFwiKS5hZGRDbGFzcyhnP1widWktc2VsZWN0aW5nXCI6XCJ1aS11bnNlbGVjdGluZ1wiKTtiLnVuc2VsZWN0aW5nPSFnO2Iuc2VsZWN0aW5nPWc7KGIuc2VsZWN0ZWQ9Zyk/Zi5fdHJpZ2dlcihcInNlbGVjdGluZ1wiLGMse3NlbGVjdGluZzpiLmVsZW1lbnR9KTpmLl90cmlnZ2VyKFwidW5zZWxlY3RpbmdcIixjLHt1bnNlbGVjdGluZzpiLmVsZW1lbnR9KTtyZXR1cm4gZmFsc2V9fSl9fSxfbW91c2VEcmFnOmZ1bmN0aW9uKGMpe3ZhciBmPXRoaXM7dGhpcy5kcmFnZ2VkPXRydWU7aWYoIXRoaXMub3B0aW9ucy5kaXNhYmxlZCl7dmFyIGQ9XHJcbnRoaXMub3B0aW9ucyxiPXRoaXMub3Bvc1swXSxnPXRoaXMub3Bvc1sxXSxoPWMucGFnZVgsaT1jLnBhZ2VZO2lmKGI+aCl7dmFyIGo9aDtoPWI7Yj1qfWlmKGc+aSl7aj1pO2k9ZztnPWp9dGhpcy5oZWxwZXIuY3NzKHtsZWZ0OmIsdG9wOmcsd2lkdGg6aC1iLGhlaWdodDppLWd9KTt0aGlzLnNlbGVjdGVlcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGE9ZS5kYXRhKHRoaXMsXCJzZWxlY3RhYmxlLWl0ZW1cIik7aWYoISghYXx8YS5lbGVtZW50PT1mLmVsZW1lbnRbMF0pKXt2YXIgaz1mYWxzZTtpZihkLnRvbGVyYW5jZT09XCJ0b3VjaFwiKWs9IShhLmxlZnQ+aHx8YS5yaWdodDxifHxhLnRvcD5pfHxhLmJvdHRvbTxnKTtlbHNlIGlmKGQudG9sZXJhbmNlPT1cImZpdFwiKWs9YS5sZWZ0PmImJmEucmlnaHQ8aCYmYS50b3A+ZyYmYS5ib3R0b208aTtpZihrKXtpZihhLnNlbGVjdGVkKXthLiRlbGVtZW50LnJlbW92ZUNsYXNzKFwidWktc2VsZWN0ZWRcIik7YS5zZWxlY3RlZD1mYWxzZX1pZihhLnVuc2VsZWN0aW5nKXthLiRlbGVtZW50LnJlbW92ZUNsYXNzKFwidWktdW5zZWxlY3RpbmdcIik7XHJcbmEudW5zZWxlY3Rpbmc9ZmFsc2V9aWYoIWEuc2VsZWN0aW5nKXthLiRlbGVtZW50LmFkZENsYXNzKFwidWktc2VsZWN0aW5nXCIpO2Euc2VsZWN0aW5nPXRydWU7Zi5fdHJpZ2dlcihcInNlbGVjdGluZ1wiLGMse3NlbGVjdGluZzphLmVsZW1lbnR9KX19ZWxzZXtpZihhLnNlbGVjdGluZylpZihjLm1ldGFLZXkmJmEuc3RhcnRzZWxlY3RlZCl7YS4kZWxlbWVudC5yZW1vdmVDbGFzcyhcInVpLXNlbGVjdGluZ1wiKTthLnNlbGVjdGluZz1mYWxzZTthLiRlbGVtZW50LmFkZENsYXNzKFwidWktc2VsZWN0ZWRcIik7YS5zZWxlY3RlZD10cnVlfWVsc2V7YS4kZWxlbWVudC5yZW1vdmVDbGFzcyhcInVpLXNlbGVjdGluZ1wiKTthLnNlbGVjdGluZz1mYWxzZTtpZihhLnN0YXJ0c2VsZWN0ZWQpe2EuJGVsZW1lbnQuYWRkQ2xhc3MoXCJ1aS11bnNlbGVjdGluZ1wiKTthLnVuc2VsZWN0aW5nPXRydWV9Zi5fdHJpZ2dlcihcInVuc2VsZWN0aW5nXCIsYyx7dW5zZWxlY3Rpbmc6YS5lbGVtZW50fSl9aWYoYS5zZWxlY3RlZClpZighYy5tZXRhS2V5JiZcclxuIWEuc3RhcnRzZWxlY3RlZCl7YS4kZWxlbWVudC5yZW1vdmVDbGFzcyhcInVpLXNlbGVjdGVkXCIpO2Euc2VsZWN0ZWQ9ZmFsc2U7YS4kZWxlbWVudC5hZGRDbGFzcyhcInVpLXVuc2VsZWN0aW5nXCIpO2EudW5zZWxlY3Rpbmc9dHJ1ZTtmLl90cmlnZ2VyKFwidW5zZWxlY3RpbmdcIixjLHt1bnNlbGVjdGluZzphLmVsZW1lbnR9KX19fX0pO3JldHVybiBmYWxzZX19LF9tb3VzZVN0b3A6ZnVuY3Rpb24oYyl7dmFyIGY9dGhpczt0aGlzLmRyYWdnZWQ9ZmFsc2U7ZShcIi51aS11bnNlbGVjdGluZ1wiLHRoaXMuZWxlbWVudFswXSkuZWFjaChmdW5jdGlvbigpe3ZhciBkPWUuZGF0YSh0aGlzLFwic2VsZWN0YWJsZS1pdGVtXCIpO2QuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoXCJ1aS11bnNlbGVjdGluZ1wiKTtkLnVuc2VsZWN0aW5nPWZhbHNlO2Quc3RhcnRzZWxlY3RlZD1mYWxzZTtmLl90cmlnZ2VyKFwidW5zZWxlY3RlZFwiLGMse3Vuc2VsZWN0ZWQ6ZC5lbGVtZW50fSl9KTtlKFwiLnVpLXNlbGVjdGluZ1wiLHRoaXMuZWxlbWVudFswXSkuZWFjaChmdW5jdGlvbigpe3ZhciBkPVxyXG5lLmRhdGEodGhpcyxcInNlbGVjdGFibGUtaXRlbVwiKTtkLiRlbGVtZW50LnJlbW92ZUNsYXNzKFwidWktc2VsZWN0aW5nXCIpLmFkZENsYXNzKFwidWktc2VsZWN0ZWRcIik7ZC5zZWxlY3Rpbmc9ZmFsc2U7ZC5zZWxlY3RlZD10cnVlO2Quc3RhcnRzZWxlY3RlZD10cnVlO2YuX3RyaWdnZXIoXCJzZWxlY3RlZFwiLGMse3NlbGVjdGVkOmQuZWxlbWVudH0pfSk7dGhpcy5fdHJpZ2dlcihcInN0b3BcIixjKTt0aGlzLmhlbHBlci5yZW1vdmUoKTtyZXR1cm4gZmFsc2V9fSk7ZS5leHRlbmQoZS51aS5zZWxlY3RhYmxlLHt2ZXJzaW9uOlwiMS44LjE2XCJ9KX0pKGpRdWVyeSk7XHJcbjsvKlxyXG4gKiBqUXVlcnkgVUkgU29ydGFibGUgMS44LjE2XHJcbiAqXHJcbiAqIENvcHlyaWdodCAyMDExLCBBVVRIT1JTLnR4dCAoaHR0cDovL2pxdWVyeXVpLmNvbS9hYm91dClcclxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIG9yIEdQTCBWZXJzaW9uIDIgbGljZW5zZXMuXHJcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcclxuICpcclxuICogaHR0cDovL2RvY3MuanF1ZXJ5LmNvbS9VSS9Tb3J0YWJsZXNcclxuICpcclxuICogRGVwZW5kczpcclxuICpcdGpxdWVyeS51aS5jb3JlLmpzXHJcbiAqXHRqcXVlcnkudWkubW91c2UuanNcclxuICpcdGpxdWVyeS51aS53aWRnZXQuanNcclxuICovXHJcbihmdW5jdGlvbihkKXtkLndpZGdldChcInVpLnNvcnRhYmxlXCIsZC51aS5tb3VzZSx7d2lkZ2V0RXZlbnRQcmVmaXg6XCJzb3J0XCIsb3B0aW9uczp7YXBwZW5kVG86XCJwYXJlbnRcIixheGlzOmZhbHNlLGNvbm5lY3RXaXRoOmZhbHNlLGNvbnRhaW5tZW50OmZhbHNlLGN1cnNvcjpcImF1dG9cIixjdXJzb3JBdDpmYWxzZSxkcm9wT25FbXB0eTp0cnVlLGZvcmNlUGxhY2Vob2xkZXJTaXplOmZhbHNlLGZvcmNlSGVscGVyU2l6ZTpmYWxzZSxncmlkOmZhbHNlLGhhbmRsZTpmYWxzZSxoZWxwZXI6XCJvcmlnaW5hbFwiLGl0ZW1zOlwiPiAqXCIsb3BhY2l0eTpmYWxzZSxwbGFjZWhvbGRlcjpmYWxzZSxyZXZlcnQ6ZmFsc2Usc2Nyb2xsOnRydWUsc2Nyb2xsU2Vuc2l0aXZpdHk6MjAsc2Nyb2xsU3BlZWQ6MjAsc2NvcGU6XCJkZWZhdWx0XCIsdG9sZXJhbmNlOlwiaW50ZXJzZWN0XCIsekluZGV4OjFFM30sX2NyZWF0ZTpmdW5jdGlvbigpe3ZhciBhPXRoaXMub3B0aW9uczt0aGlzLmNvbnRhaW5lckNhY2hlPXt9O3RoaXMuZWxlbWVudC5hZGRDbGFzcyhcInVpLXNvcnRhYmxlXCIpO1xyXG50aGlzLnJlZnJlc2goKTt0aGlzLmZsb2F0aW5nPXRoaXMuaXRlbXMubGVuZ3RoP2EuYXhpcz09PVwieFwifHwvbGVmdHxyaWdodC8udGVzdCh0aGlzLml0ZW1zWzBdLml0ZW0uY3NzKFwiZmxvYXRcIikpfHwvaW5saW5lfHRhYmxlLWNlbGwvLnRlc3QodGhpcy5pdGVtc1swXS5pdGVtLmNzcyhcImRpc3BsYXlcIikpOmZhbHNlO3RoaXMub2Zmc2V0PXRoaXMuZWxlbWVudC5vZmZzZXQoKTt0aGlzLl9tb3VzZUluaXQoKX0sZGVzdHJveTpmdW5jdGlvbigpe3RoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyhcInVpLXNvcnRhYmxlIHVpLXNvcnRhYmxlLWRpc2FibGVkXCIpLnJlbW92ZURhdGEoXCJzb3J0YWJsZVwiKS51bmJpbmQoXCIuc29ydGFibGVcIik7dGhpcy5fbW91c2VEZXN0cm95KCk7Zm9yKHZhciBhPXRoaXMuaXRlbXMubGVuZ3RoLTE7YT49MDthLS0pdGhpcy5pdGVtc1thXS5pdGVtLnJlbW92ZURhdGEoXCJzb3J0YWJsZS1pdGVtXCIpO3JldHVybiB0aGlzfSxfc2V0T3B0aW9uOmZ1bmN0aW9uKGEsYil7aWYoYT09PVxyXG5cImRpc2FibGVkXCIpe3RoaXMub3B0aW9uc1thXT1iO3RoaXMud2lkZ2V0KClbYj9cImFkZENsYXNzXCI6XCJyZW1vdmVDbGFzc1wiXShcInVpLXNvcnRhYmxlLWRpc2FibGVkXCIpfWVsc2UgZC5XaWRnZXQucHJvdG90eXBlLl9zZXRPcHRpb24uYXBwbHkodGhpcyxhcmd1bWVudHMpfSxfbW91c2VDYXB0dXJlOmZ1bmN0aW9uKGEsYil7aWYodGhpcy5yZXZlcnRpbmcpcmV0dXJuIGZhbHNlO2lmKHRoaXMub3B0aW9ucy5kaXNhYmxlZHx8dGhpcy5vcHRpb25zLnR5cGU9PVwic3RhdGljXCIpcmV0dXJuIGZhbHNlO3RoaXMuX3JlZnJlc2hJdGVtcyhhKTt2YXIgYz1udWxsLGU9dGhpcztkKGEudGFyZ2V0KS5wYXJlbnRzKCkuZWFjaChmdW5jdGlvbigpe2lmKGQuZGF0YSh0aGlzLFwic29ydGFibGUtaXRlbVwiKT09ZSl7Yz1kKHRoaXMpO3JldHVybiBmYWxzZX19KTtpZihkLmRhdGEoYS50YXJnZXQsXCJzb3J0YWJsZS1pdGVtXCIpPT1lKWM9ZChhLnRhcmdldCk7aWYoIWMpcmV0dXJuIGZhbHNlO2lmKHRoaXMub3B0aW9ucy5oYW5kbGUmJlxyXG4hYil7dmFyIGY9ZmFsc2U7ZCh0aGlzLm9wdGlvbnMuaGFuZGxlLGMpLmZpbmQoXCIqXCIpLmFuZFNlbGYoKS5lYWNoKGZ1bmN0aW9uKCl7aWYodGhpcz09YS50YXJnZXQpZj10cnVlfSk7aWYoIWYpcmV0dXJuIGZhbHNlfXRoaXMuY3VycmVudEl0ZW09Yzt0aGlzLl9yZW1vdmVDdXJyZW50c0Zyb21JdGVtcygpO3JldHVybiB0cnVlfSxfbW91c2VTdGFydDpmdW5jdGlvbihhLGIsYyl7Yj10aGlzLm9wdGlvbnM7dmFyIGU9dGhpczt0aGlzLmN1cnJlbnRDb250YWluZXI9dGhpczt0aGlzLnJlZnJlc2hQb3NpdGlvbnMoKTt0aGlzLmhlbHBlcj10aGlzLl9jcmVhdGVIZWxwZXIoYSk7dGhpcy5fY2FjaGVIZWxwZXJQcm9wb3J0aW9ucygpO3RoaXMuX2NhY2hlTWFyZ2lucygpO3RoaXMuc2Nyb2xsUGFyZW50PXRoaXMuaGVscGVyLnNjcm9sbFBhcmVudCgpO3RoaXMub2Zmc2V0PXRoaXMuY3VycmVudEl0ZW0ub2Zmc2V0KCk7dGhpcy5vZmZzZXQ9e3RvcDp0aGlzLm9mZnNldC50b3AtdGhpcy5tYXJnaW5zLnRvcCxcclxubGVmdDp0aGlzLm9mZnNldC5sZWZ0LXRoaXMubWFyZ2lucy5sZWZ0fTt0aGlzLmhlbHBlci5jc3MoXCJwb3NpdGlvblwiLFwiYWJzb2x1dGVcIik7dGhpcy5jc3NQb3NpdGlvbj10aGlzLmhlbHBlci5jc3MoXCJwb3NpdGlvblwiKTtkLmV4dGVuZCh0aGlzLm9mZnNldCx7Y2xpY2s6e2xlZnQ6YS5wYWdlWC10aGlzLm9mZnNldC5sZWZ0LHRvcDphLnBhZ2VZLXRoaXMub2Zmc2V0LnRvcH0scGFyZW50OnRoaXMuX2dldFBhcmVudE9mZnNldCgpLHJlbGF0aXZlOnRoaXMuX2dldFJlbGF0aXZlT2Zmc2V0KCl9KTt0aGlzLm9yaWdpbmFsUG9zaXRpb249dGhpcy5fZ2VuZXJhdGVQb3NpdGlvbihhKTt0aGlzLm9yaWdpbmFsUGFnZVg9YS5wYWdlWDt0aGlzLm9yaWdpbmFsUGFnZVk9YS5wYWdlWTtiLmN1cnNvckF0JiZ0aGlzLl9hZGp1c3RPZmZzZXRGcm9tSGVscGVyKGIuY3Vyc29yQXQpO3RoaXMuZG9tUG9zaXRpb249e3ByZXY6dGhpcy5jdXJyZW50SXRlbS5wcmV2KClbMF0scGFyZW50OnRoaXMuY3VycmVudEl0ZW0ucGFyZW50KClbMF19O1xyXG50aGlzLmhlbHBlclswXSE9dGhpcy5jdXJyZW50SXRlbVswXSYmdGhpcy5jdXJyZW50SXRlbS5oaWRlKCk7dGhpcy5fY3JlYXRlUGxhY2Vob2xkZXIoKTtiLmNvbnRhaW5tZW50JiZ0aGlzLl9zZXRDb250YWlubWVudCgpO2lmKGIuY3Vyc29yKXtpZihkKFwiYm9keVwiKS5jc3MoXCJjdXJzb3JcIikpdGhpcy5fc3RvcmVkQ3Vyc29yPWQoXCJib2R5XCIpLmNzcyhcImN1cnNvclwiKTtkKFwiYm9keVwiKS5jc3MoXCJjdXJzb3JcIixiLmN1cnNvcil9aWYoYi5vcGFjaXR5KXtpZih0aGlzLmhlbHBlci5jc3MoXCJvcGFjaXR5XCIpKXRoaXMuX3N0b3JlZE9wYWNpdHk9dGhpcy5oZWxwZXIuY3NzKFwib3BhY2l0eVwiKTt0aGlzLmhlbHBlci5jc3MoXCJvcGFjaXR5XCIsYi5vcGFjaXR5KX1pZihiLnpJbmRleCl7aWYodGhpcy5oZWxwZXIuY3NzKFwiekluZGV4XCIpKXRoaXMuX3N0b3JlZFpJbmRleD10aGlzLmhlbHBlci5jc3MoXCJ6SW5kZXhcIik7dGhpcy5oZWxwZXIuY3NzKFwiekluZGV4XCIsYi56SW5kZXgpfWlmKHRoaXMuc2Nyb2xsUGFyZW50WzBdIT1cclxuZG9jdW1lbnQmJnRoaXMuc2Nyb2xsUGFyZW50WzBdLnRhZ05hbWUhPVwiSFRNTFwiKXRoaXMub3ZlcmZsb3dPZmZzZXQ9dGhpcy5zY3JvbGxQYXJlbnQub2Zmc2V0KCk7dGhpcy5fdHJpZ2dlcihcInN0YXJ0XCIsYSx0aGlzLl91aUhhc2goKSk7dGhpcy5fcHJlc2VydmVIZWxwZXJQcm9wb3J0aW9uc3x8dGhpcy5fY2FjaGVIZWxwZXJQcm9wb3J0aW9ucygpO2lmKCFjKWZvcihjPXRoaXMuY29udGFpbmVycy5sZW5ndGgtMTtjPj0wO2MtLSl0aGlzLmNvbnRhaW5lcnNbY10uX3RyaWdnZXIoXCJhY3RpdmF0ZVwiLGEsZS5fdWlIYXNoKHRoaXMpKTtpZihkLnVpLmRkbWFuYWdlcilkLnVpLmRkbWFuYWdlci5jdXJyZW50PXRoaXM7ZC51aS5kZG1hbmFnZXImJiFiLmRyb3BCZWhhdmlvdXImJmQudWkuZGRtYW5hZ2VyLnByZXBhcmVPZmZzZXRzKHRoaXMsYSk7dGhpcy5kcmFnZ2luZz10cnVlO3RoaXMuaGVscGVyLmFkZENsYXNzKFwidWktc29ydGFibGUtaGVscGVyXCIpO3RoaXMuX21vdXNlRHJhZyhhKTtcclxucmV0dXJuIHRydWV9LF9tb3VzZURyYWc6ZnVuY3Rpb24oYSl7dGhpcy5wb3NpdGlvbj10aGlzLl9nZW5lcmF0ZVBvc2l0aW9uKGEpO3RoaXMucG9zaXRpb25BYnM9dGhpcy5fY29udmVydFBvc2l0aW9uVG8oXCJhYnNvbHV0ZVwiKTtpZighdGhpcy5sYXN0UG9zaXRpb25BYnMpdGhpcy5sYXN0UG9zaXRpb25BYnM9dGhpcy5wb3NpdGlvbkFicztpZih0aGlzLm9wdGlvbnMuc2Nyb2xsKXt2YXIgYj10aGlzLm9wdGlvbnMsYz1mYWxzZTtpZih0aGlzLnNjcm9sbFBhcmVudFswXSE9ZG9jdW1lbnQmJnRoaXMuc2Nyb2xsUGFyZW50WzBdLnRhZ05hbWUhPVwiSFRNTFwiKXtpZih0aGlzLm92ZXJmbG93T2Zmc2V0LnRvcCt0aGlzLnNjcm9sbFBhcmVudFswXS5vZmZzZXRIZWlnaHQtYS5wYWdlWTxiLnNjcm9sbFNlbnNpdGl2aXR5KXRoaXMuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbFRvcD1jPXRoaXMuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbFRvcCtiLnNjcm9sbFNwZWVkO2Vsc2UgaWYoYS5wYWdlWS10aGlzLm92ZXJmbG93T2Zmc2V0LnRvcDxcclxuYi5zY3JvbGxTZW5zaXRpdml0eSl0aGlzLnNjcm9sbFBhcmVudFswXS5zY3JvbGxUb3A9Yz10aGlzLnNjcm9sbFBhcmVudFswXS5zY3JvbGxUb3AtYi5zY3JvbGxTcGVlZDtpZih0aGlzLm92ZXJmbG93T2Zmc2V0LmxlZnQrdGhpcy5zY3JvbGxQYXJlbnRbMF0ub2Zmc2V0V2lkdGgtYS5wYWdlWDxiLnNjcm9sbFNlbnNpdGl2aXR5KXRoaXMuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbExlZnQ9Yz10aGlzLnNjcm9sbFBhcmVudFswXS5zY3JvbGxMZWZ0K2Iuc2Nyb2xsU3BlZWQ7ZWxzZSBpZihhLnBhZ2VYLXRoaXMub3ZlcmZsb3dPZmZzZXQubGVmdDxiLnNjcm9sbFNlbnNpdGl2aXR5KXRoaXMuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbExlZnQ9Yz10aGlzLnNjcm9sbFBhcmVudFswXS5zY3JvbGxMZWZ0LWIuc2Nyb2xsU3BlZWR9ZWxzZXtpZihhLnBhZ2VZLWQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpPGIuc2Nyb2xsU2Vuc2l0aXZpdHkpYz1kKGRvY3VtZW50KS5zY3JvbGxUb3AoZChkb2N1bWVudCkuc2Nyb2xsVG9wKCktXHJcbmIuc2Nyb2xsU3BlZWQpO2Vsc2UgaWYoZCh3aW5kb3cpLmhlaWdodCgpLShhLnBhZ2VZLWQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpKTxiLnNjcm9sbFNlbnNpdGl2aXR5KWM9ZChkb2N1bWVudCkuc2Nyb2xsVG9wKGQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpK2Iuc2Nyb2xsU3BlZWQpO2lmKGEucGFnZVgtZChkb2N1bWVudCkuc2Nyb2xsTGVmdCgpPGIuc2Nyb2xsU2Vuc2l0aXZpdHkpYz1kKGRvY3VtZW50KS5zY3JvbGxMZWZ0KGQoZG9jdW1lbnQpLnNjcm9sbExlZnQoKS1iLnNjcm9sbFNwZWVkKTtlbHNlIGlmKGQod2luZG93KS53aWR0aCgpLShhLnBhZ2VYLWQoZG9jdW1lbnQpLnNjcm9sbExlZnQoKSk8Yi5zY3JvbGxTZW5zaXRpdml0eSljPWQoZG9jdW1lbnQpLnNjcm9sbExlZnQoZChkb2N1bWVudCkuc2Nyb2xsTGVmdCgpK2Iuc2Nyb2xsU3BlZWQpfWMhPT1mYWxzZSYmZC51aS5kZG1hbmFnZXImJiFiLmRyb3BCZWhhdmlvdXImJmQudWkuZGRtYW5hZ2VyLnByZXBhcmVPZmZzZXRzKHRoaXMsXHJcbmEpfXRoaXMucG9zaXRpb25BYnM9dGhpcy5fY29udmVydFBvc2l0aW9uVG8oXCJhYnNvbHV0ZVwiKTtpZighdGhpcy5vcHRpb25zLmF4aXN8fHRoaXMub3B0aW9ucy5heGlzIT1cInlcIil0aGlzLmhlbHBlclswXS5zdHlsZS5sZWZ0PXRoaXMucG9zaXRpb24ubGVmdCtcInB4XCI7aWYoIXRoaXMub3B0aW9ucy5heGlzfHx0aGlzLm9wdGlvbnMuYXhpcyE9XCJ4XCIpdGhpcy5oZWxwZXJbMF0uc3R5bGUudG9wPXRoaXMucG9zaXRpb24udG9wK1wicHhcIjtmb3IoYj10aGlzLml0ZW1zLmxlbmd0aC0xO2I+PTA7Yi0tKXtjPXRoaXMuaXRlbXNbYl07dmFyIGU9Yy5pdGVtWzBdLGY9dGhpcy5faW50ZXJzZWN0c1dpdGhQb2ludGVyKGMpO2lmKGYpaWYoZSE9dGhpcy5jdXJyZW50SXRlbVswXSYmdGhpcy5wbGFjZWhvbGRlcltmPT0xP1wibmV4dFwiOlwicHJldlwiXSgpWzBdIT1lJiYhZC51aS5jb250YWlucyh0aGlzLnBsYWNlaG9sZGVyWzBdLGUpJiYodGhpcy5vcHRpb25zLnR5cGU9PVwic2VtaS1keW5hbWljXCI/IWQudWkuY29udGFpbnModGhpcy5lbGVtZW50WzBdLFxyXG5lKTp0cnVlKSl7dGhpcy5kaXJlY3Rpb249Zj09MT9cImRvd25cIjpcInVwXCI7aWYodGhpcy5vcHRpb25zLnRvbGVyYW5jZT09XCJwb2ludGVyXCJ8fHRoaXMuX2ludGVyc2VjdHNXaXRoU2lkZXMoYykpdGhpcy5fcmVhcnJhbmdlKGEsYyk7ZWxzZSBicmVhazt0aGlzLl90cmlnZ2VyKFwiY2hhbmdlXCIsYSx0aGlzLl91aUhhc2goKSk7YnJlYWt9fXRoaXMuX2NvbnRhY3RDb250YWluZXJzKGEpO2QudWkuZGRtYW5hZ2VyJiZkLnVpLmRkbWFuYWdlci5kcmFnKHRoaXMsYSk7dGhpcy5fdHJpZ2dlcihcInNvcnRcIixhLHRoaXMuX3VpSGFzaCgpKTt0aGlzLmxhc3RQb3NpdGlvbkFicz10aGlzLnBvc2l0aW9uQWJzO3JldHVybiBmYWxzZX0sX21vdXNlU3RvcDpmdW5jdGlvbihhLGIpe2lmKGEpe2QudWkuZGRtYW5hZ2VyJiYhdGhpcy5vcHRpb25zLmRyb3BCZWhhdmlvdXImJmQudWkuZGRtYW5hZ2VyLmRyb3AodGhpcyxhKTtpZih0aGlzLm9wdGlvbnMucmV2ZXJ0KXt2YXIgYz10aGlzO2I9Yy5wbGFjZWhvbGRlci5vZmZzZXQoKTtcclxuYy5yZXZlcnRpbmc9dHJ1ZTtkKHRoaXMuaGVscGVyKS5hbmltYXRlKHtsZWZ0OmIubGVmdC10aGlzLm9mZnNldC5wYXJlbnQubGVmdC1jLm1hcmdpbnMubGVmdCsodGhpcy5vZmZzZXRQYXJlbnRbMF09PWRvY3VtZW50LmJvZHk/MDp0aGlzLm9mZnNldFBhcmVudFswXS5zY3JvbGxMZWZ0KSx0b3A6Yi50b3AtdGhpcy5vZmZzZXQucGFyZW50LnRvcC1jLm1hcmdpbnMudG9wKyh0aGlzLm9mZnNldFBhcmVudFswXT09ZG9jdW1lbnQuYm9keT8wOnRoaXMub2Zmc2V0UGFyZW50WzBdLnNjcm9sbFRvcCl9LHBhcnNlSW50KHRoaXMub3B0aW9ucy5yZXZlcnQsMTApfHw1MDAsZnVuY3Rpb24oKXtjLl9jbGVhcihhKX0pfWVsc2UgdGhpcy5fY2xlYXIoYSxiKTtyZXR1cm4gZmFsc2V9fSxjYW5jZWw6ZnVuY3Rpb24oKXt2YXIgYT10aGlzO2lmKHRoaXMuZHJhZ2dpbmcpe3RoaXMuX21vdXNlVXAoe3RhcmdldDpudWxsfSk7dGhpcy5vcHRpb25zLmhlbHBlcj09XCJvcmlnaW5hbFwiP3RoaXMuY3VycmVudEl0ZW0uY3NzKHRoaXMuX3N0b3JlZENTUykucmVtb3ZlQ2xhc3MoXCJ1aS1zb3J0YWJsZS1oZWxwZXJcIik6XHJcbnRoaXMuY3VycmVudEl0ZW0uc2hvdygpO2Zvcih2YXIgYj10aGlzLmNvbnRhaW5lcnMubGVuZ3RoLTE7Yj49MDtiLS0pe3RoaXMuY29udGFpbmVyc1tiXS5fdHJpZ2dlcihcImRlYWN0aXZhdGVcIixudWxsLGEuX3VpSGFzaCh0aGlzKSk7aWYodGhpcy5jb250YWluZXJzW2JdLmNvbnRhaW5lckNhY2hlLm92ZXIpe3RoaXMuY29udGFpbmVyc1tiXS5fdHJpZ2dlcihcIm91dFwiLG51bGwsYS5fdWlIYXNoKHRoaXMpKTt0aGlzLmNvbnRhaW5lcnNbYl0uY29udGFpbmVyQ2FjaGUub3Zlcj0wfX19aWYodGhpcy5wbGFjZWhvbGRlcil7dGhpcy5wbGFjZWhvbGRlclswXS5wYXJlbnROb2RlJiZ0aGlzLnBsYWNlaG9sZGVyWzBdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5wbGFjZWhvbGRlclswXSk7dGhpcy5vcHRpb25zLmhlbHBlciE9XCJvcmlnaW5hbFwiJiZ0aGlzLmhlbHBlciYmdGhpcy5oZWxwZXJbMF0ucGFyZW50Tm9kZSYmdGhpcy5oZWxwZXIucmVtb3ZlKCk7ZC5leHRlbmQodGhpcyx7aGVscGVyOm51bGwsXHJcbmRyYWdnaW5nOmZhbHNlLHJldmVydGluZzpmYWxzZSxfbm9GaW5hbFNvcnQ6bnVsbH0pO3RoaXMuZG9tUG9zaXRpb24ucHJldj9kKHRoaXMuZG9tUG9zaXRpb24ucHJldikuYWZ0ZXIodGhpcy5jdXJyZW50SXRlbSk6ZCh0aGlzLmRvbVBvc2l0aW9uLnBhcmVudCkucHJlcGVuZCh0aGlzLmN1cnJlbnRJdGVtKX1yZXR1cm4gdGhpc30sc2VyaWFsaXplOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuX2dldEl0ZW1zQXNqUXVlcnkoYSYmYS5jb25uZWN0ZWQpLGM9W107YT1hfHx7fTtkKGIpLmVhY2goZnVuY3Rpb24oKXt2YXIgZT0oZChhLml0ZW18fHRoaXMpLmF0dHIoYS5hdHRyaWJ1dGV8fFwiaWRcIil8fFwiXCIpLm1hdGNoKGEuZXhwcmVzc2lvbnx8LyguKylbLT1fXSguKykvKTtpZihlKWMucHVzaCgoYS5rZXl8fGVbMV0rXCJbXVwiKStcIj1cIisoYS5rZXkmJmEuZXhwcmVzc2lvbj9lWzFdOmVbMl0pKX0pOyFjLmxlbmd0aCYmYS5rZXkmJmMucHVzaChhLmtleStcIj1cIik7cmV0dXJuIGMuam9pbihcIiZcIil9LFxyXG50b0FycmF5OmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuX2dldEl0ZW1zQXNqUXVlcnkoYSYmYS5jb25uZWN0ZWQpLGM9W107YT1hfHx7fTtiLmVhY2goZnVuY3Rpb24oKXtjLnB1c2goZChhLml0ZW18fHRoaXMpLmF0dHIoYS5hdHRyaWJ1dGV8fFwiaWRcIil8fFwiXCIpfSk7cmV0dXJuIGN9LF9pbnRlcnNlY3RzV2l0aDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLnBvc2l0aW9uQWJzLmxlZnQsYz1iK3RoaXMuaGVscGVyUHJvcG9ydGlvbnMud2lkdGgsZT10aGlzLnBvc2l0aW9uQWJzLnRvcCxmPWUrdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQsZz1hLmxlZnQsaD1nK2Eud2lkdGgsaT1hLnRvcCxrPWkrYS5oZWlnaHQsaj10aGlzLm9mZnNldC5jbGljay50b3AsbD10aGlzLm9mZnNldC5jbGljay5sZWZ0O2o9ZStqPmkmJmUrajxrJiZiK2w+ZyYmYitsPGg7cmV0dXJuIHRoaXMub3B0aW9ucy50b2xlcmFuY2U9PVwicG9pbnRlclwifHx0aGlzLm9wdGlvbnMuZm9yY2VQb2ludGVyRm9yQ29udGFpbmVyc3x8XHJcbnRoaXMub3B0aW9ucy50b2xlcmFuY2UhPVwicG9pbnRlclwiJiZ0aGlzLmhlbHBlclByb3BvcnRpb25zW3RoaXMuZmxvYXRpbmc/XCJ3aWR0aFwiOlwiaGVpZ2h0XCJdPmFbdGhpcy5mbG9hdGluZz9cIndpZHRoXCI6XCJoZWlnaHRcIl0/ajpnPGIrdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aC8yJiZjLXRoaXMuaGVscGVyUHJvcG9ydGlvbnMud2lkdGgvMjxoJiZpPGUrdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQvMiYmZi10aGlzLmhlbHBlclByb3BvcnRpb25zLmhlaWdodC8yPGt9LF9pbnRlcnNlY3RzV2l0aFBvaW50ZXI6ZnVuY3Rpb24oYSl7dmFyIGI9ZC51aS5pc092ZXJBeGlzKHRoaXMucG9zaXRpb25BYnMudG9wK3RoaXMub2Zmc2V0LmNsaWNrLnRvcCxhLnRvcCxhLmhlaWdodCk7YT1kLnVpLmlzT3ZlckF4aXModGhpcy5wb3NpdGlvbkFicy5sZWZ0K3RoaXMub2Zmc2V0LmNsaWNrLmxlZnQsYS5sZWZ0LGEud2lkdGgpO2I9YiYmYTthPXRoaXMuX2dldERyYWdWZXJ0aWNhbERpcmVjdGlvbigpO1xyXG52YXIgYz10aGlzLl9nZXREcmFnSG9yaXpvbnRhbERpcmVjdGlvbigpO2lmKCFiKXJldHVybiBmYWxzZTtyZXR1cm4gdGhpcy5mbG9hdGluZz9jJiZjPT1cInJpZ2h0XCJ8fGE9PVwiZG93blwiPzI6MTphJiYoYT09XCJkb3duXCI/MjoxKX0sX2ludGVyc2VjdHNXaXRoU2lkZXM6ZnVuY3Rpb24oYSl7dmFyIGI9ZC51aS5pc092ZXJBeGlzKHRoaXMucG9zaXRpb25BYnMudG9wK3RoaXMub2Zmc2V0LmNsaWNrLnRvcCxhLnRvcCthLmhlaWdodC8yLGEuaGVpZ2h0KTthPWQudWkuaXNPdmVyQXhpcyh0aGlzLnBvc2l0aW9uQWJzLmxlZnQrdGhpcy5vZmZzZXQuY2xpY2subGVmdCxhLmxlZnQrYS53aWR0aC8yLGEud2lkdGgpO3ZhciBjPXRoaXMuX2dldERyYWdWZXJ0aWNhbERpcmVjdGlvbigpLGU9dGhpcy5fZ2V0RHJhZ0hvcml6b250YWxEaXJlY3Rpb24oKTtyZXR1cm4gdGhpcy5mbG9hdGluZyYmZT9lPT1cInJpZ2h0XCImJmF8fGU9PVwibGVmdFwiJiYhYTpjJiYoYz09XCJkb3duXCImJmJ8fGM9PVwidXBcIiYmIWIpfSxcclxuX2dldERyYWdWZXJ0aWNhbERpcmVjdGlvbjpmdW5jdGlvbigpe3ZhciBhPXRoaXMucG9zaXRpb25BYnMudG9wLXRoaXMubGFzdFBvc2l0aW9uQWJzLnRvcDtyZXR1cm4gYSE9MCYmKGE+MD9cImRvd25cIjpcInVwXCIpfSxfZ2V0RHJhZ0hvcml6b250YWxEaXJlY3Rpb246ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnBvc2l0aW9uQWJzLmxlZnQtdGhpcy5sYXN0UG9zaXRpb25BYnMubGVmdDtyZXR1cm4gYSE9MCYmKGE+MD9cInJpZ2h0XCI6XCJsZWZ0XCIpfSxyZWZyZXNoOmZ1bmN0aW9uKGEpe3RoaXMuX3JlZnJlc2hJdGVtcyhhKTt0aGlzLnJlZnJlc2hQb3NpdGlvbnMoKTtyZXR1cm4gdGhpc30sX2Nvbm5lY3RXaXRoOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5vcHRpb25zO3JldHVybiBhLmNvbm5lY3RXaXRoLmNvbnN0cnVjdG9yPT1TdHJpbmc/W2EuY29ubmVjdFdpdGhdOmEuY29ubmVjdFdpdGh9LF9nZXRJdGVtc0FzalF1ZXJ5OmZ1bmN0aW9uKGEpe3ZhciBiPVtdLGM9W10sZT10aGlzLl9jb25uZWN0V2l0aCgpO1xyXG5pZihlJiZhKWZvcihhPWUubGVuZ3RoLTE7YT49MDthLS0pZm9yKHZhciBmPWQoZVthXSksZz1mLmxlbmd0aC0xO2c+PTA7Zy0tKXt2YXIgaD1kLmRhdGEoZltnXSxcInNvcnRhYmxlXCIpO2lmKGgmJmghPXRoaXMmJiFoLm9wdGlvbnMuZGlzYWJsZWQpYy5wdXNoKFtkLmlzRnVuY3Rpb24oaC5vcHRpb25zLml0ZW1zKT9oLm9wdGlvbnMuaXRlbXMuY2FsbChoLmVsZW1lbnQpOmQoaC5vcHRpb25zLml0ZW1zLGguZWxlbWVudCkubm90KFwiLnVpLXNvcnRhYmxlLWhlbHBlclwiKS5ub3QoXCIudWktc29ydGFibGUtcGxhY2Vob2xkZXJcIiksaF0pfWMucHVzaChbZC5pc0Z1bmN0aW9uKHRoaXMub3B0aW9ucy5pdGVtcyk/dGhpcy5vcHRpb25zLml0ZW1zLmNhbGwodGhpcy5lbGVtZW50LG51bGwse29wdGlvbnM6dGhpcy5vcHRpb25zLGl0ZW06dGhpcy5jdXJyZW50SXRlbX0pOmQodGhpcy5vcHRpb25zLml0ZW1zLHRoaXMuZWxlbWVudCkubm90KFwiLnVpLXNvcnRhYmxlLWhlbHBlclwiKS5ub3QoXCIudWktc29ydGFibGUtcGxhY2Vob2xkZXJcIiksXHJcbnRoaXNdKTtmb3IoYT1jLmxlbmd0aC0xO2E+PTA7YS0tKWNbYV1bMF0uZWFjaChmdW5jdGlvbigpe2IucHVzaCh0aGlzKX0pO3JldHVybiBkKGIpfSxfcmVtb3ZlQ3VycmVudHNGcm9tSXRlbXM6ZnVuY3Rpb24oKXtmb3IodmFyIGE9dGhpcy5jdXJyZW50SXRlbS5maW5kKFwiOmRhdGEoc29ydGFibGUtaXRlbSlcIiksYj0wO2I8dGhpcy5pdGVtcy5sZW5ndGg7YisrKWZvcih2YXIgYz0wO2M8YS5sZW5ndGg7YysrKWFbY109PXRoaXMuaXRlbXNbYl0uaXRlbVswXSYmdGhpcy5pdGVtcy5zcGxpY2UoYiwxKX0sX3JlZnJlc2hJdGVtczpmdW5jdGlvbihhKXt0aGlzLml0ZW1zPVtdO3RoaXMuY29udGFpbmVycz1bdGhpc107dmFyIGI9dGhpcy5pdGVtcyxjPVtbZC5pc0Z1bmN0aW9uKHRoaXMub3B0aW9ucy5pdGVtcyk/dGhpcy5vcHRpb25zLml0ZW1zLmNhbGwodGhpcy5lbGVtZW50WzBdLGEse2l0ZW06dGhpcy5jdXJyZW50SXRlbX0pOmQodGhpcy5vcHRpb25zLml0ZW1zLHRoaXMuZWxlbWVudCksXHJcbnRoaXNdXSxlPXRoaXMuX2Nvbm5lY3RXaXRoKCk7aWYoZSlmb3IodmFyIGY9ZS5sZW5ndGgtMTtmPj0wO2YtLSlmb3IodmFyIGc9ZChlW2ZdKSxoPWcubGVuZ3RoLTE7aD49MDtoLS0pe3ZhciBpPWQuZGF0YShnW2hdLFwic29ydGFibGVcIik7aWYoaSYmaSE9dGhpcyYmIWkub3B0aW9ucy5kaXNhYmxlZCl7Yy5wdXNoKFtkLmlzRnVuY3Rpb24oaS5vcHRpb25zLml0ZW1zKT9pLm9wdGlvbnMuaXRlbXMuY2FsbChpLmVsZW1lbnRbMF0sYSx7aXRlbTp0aGlzLmN1cnJlbnRJdGVtfSk6ZChpLm9wdGlvbnMuaXRlbXMsaS5lbGVtZW50KSxpXSk7dGhpcy5jb250YWluZXJzLnB1c2goaSl9fWZvcihmPWMubGVuZ3RoLTE7Zj49MDtmLS0pe2E9Y1tmXVsxXTtlPWNbZl1bMF07aD0wO2ZvcihnPWUubGVuZ3RoO2g8ZztoKyspe2k9ZChlW2hdKTtpLmRhdGEoXCJzb3J0YWJsZS1pdGVtXCIsYSk7Yi5wdXNoKHtpdGVtOmksaW5zdGFuY2U6YSx3aWR0aDowLGhlaWdodDowLGxlZnQ6MCx0b3A6MH0pfX19LHJlZnJlc2hQb3NpdGlvbnM6ZnVuY3Rpb24oYSl7aWYodGhpcy5vZmZzZXRQYXJlbnQmJlxyXG50aGlzLmhlbHBlcil0aGlzLm9mZnNldC5wYXJlbnQ9dGhpcy5fZ2V0UGFyZW50T2Zmc2V0KCk7Zm9yKHZhciBiPXRoaXMuaXRlbXMubGVuZ3RoLTE7Yj49MDtiLS0pe3ZhciBjPXRoaXMuaXRlbXNbYl07aWYoIShjLmluc3RhbmNlIT10aGlzLmN1cnJlbnRDb250YWluZXImJnRoaXMuY3VycmVudENvbnRhaW5lciYmYy5pdGVtWzBdIT10aGlzLmN1cnJlbnRJdGVtWzBdKSl7dmFyIGU9dGhpcy5vcHRpb25zLnRvbGVyYW5jZUVsZW1lbnQ/ZCh0aGlzLm9wdGlvbnMudG9sZXJhbmNlRWxlbWVudCxjLml0ZW0pOmMuaXRlbTtpZighYSl7Yy53aWR0aD1lLm91dGVyV2lkdGgoKTtjLmhlaWdodD1lLm91dGVySGVpZ2h0KCl9ZT1lLm9mZnNldCgpO2MubGVmdD1lLmxlZnQ7Yy50b3A9ZS50b3B9fWlmKHRoaXMub3B0aW9ucy5jdXN0b20mJnRoaXMub3B0aW9ucy5jdXN0b20ucmVmcmVzaENvbnRhaW5lcnMpdGhpcy5vcHRpb25zLmN1c3RvbS5yZWZyZXNoQ29udGFpbmVycy5jYWxsKHRoaXMpO2Vsc2UgZm9yKGI9XHJcbnRoaXMuY29udGFpbmVycy5sZW5ndGgtMTtiPj0wO2ItLSl7ZT10aGlzLmNvbnRhaW5lcnNbYl0uZWxlbWVudC5vZmZzZXQoKTt0aGlzLmNvbnRhaW5lcnNbYl0uY29udGFpbmVyQ2FjaGUubGVmdD1lLmxlZnQ7dGhpcy5jb250YWluZXJzW2JdLmNvbnRhaW5lckNhY2hlLnRvcD1lLnRvcDt0aGlzLmNvbnRhaW5lcnNbYl0uY29udGFpbmVyQ2FjaGUud2lkdGg9dGhpcy5jb250YWluZXJzW2JdLmVsZW1lbnQub3V0ZXJXaWR0aCgpO3RoaXMuY29udGFpbmVyc1tiXS5jb250YWluZXJDYWNoZS5oZWlnaHQ9dGhpcy5jb250YWluZXJzW2JdLmVsZW1lbnQub3V0ZXJIZWlnaHQoKX1yZXR1cm4gdGhpc30sX2NyZWF0ZVBsYWNlaG9sZGVyOmZ1bmN0aW9uKGEpe3ZhciBiPWF8fHRoaXMsYz1iLm9wdGlvbnM7aWYoIWMucGxhY2Vob2xkZXJ8fGMucGxhY2Vob2xkZXIuY29uc3RydWN0b3I9PVN0cmluZyl7dmFyIGU9Yy5wbGFjZWhvbGRlcjtjLnBsYWNlaG9sZGVyPXtlbGVtZW50OmZ1bmN0aW9uKCl7dmFyIGY9XHJcbmQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChiLmN1cnJlbnRJdGVtWzBdLm5vZGVOYW1lKSkuYWRkQ2xhc3MoZXx8Yi5jdXJyZW50SXRlbVswXS5jbGFzc05hbWUrXCIgdWktc29ydGFibGUtcGxhY2Vob2xkZXJcIikucmVtb3ZlQ2xhc3MoXCJ1aS1zb3J0YWJsZS1oZWxwZXJcIilbMF07aWYoIWUpZi5zdHlsZS52aXNpYmlsaXR5PVwiaGlkZGVuXCI7cmV0dXJuIGZ9LHVwZGF0ZTpmdW5jdGlvbihmLGcpe2lmKCEoZSYmIWMuZm9yY2VQbGFjZWhvbGRlclNpemUpKXtnLmhlaWdodCgpfHxnLmhlaWdodChiLmN1cnJlbnRJdGVtLmlubmVySGVpZ2h0KCktcGFyc2VJbnQoYi5jdXJyZW50SXRlbS5jc3MoXCJwYWRkaW5nVG9wXCIpfHwwLDEwKS1wYXJzZUludChiLmN1cnJlbnRJdGVtLmNzcyhcInBhZGRpbmdCb3R0b21cIil8fDAsMTApKTtnLndpZHRoKCl8fGcud2lkdGgoYi5jdXJyZW50SXRlbS5pbm5lcldpZHRoKCktcGFyc2VJbnQoYi5jdXJyZW50SXRlbS5jc3MoXCJwYWRkaW5nTGVmdFwiKXx8MCwxMCktcGFyc2VJbnQoYi5jdXJyZW50SXRlbS5jc3MoXCJwYWRkaW5nUmlnaHRcIil8fFxyXG4wLDEwKSl9fX19Yi5wbGFjZWhvbGRlcj1kKGMucGxhY2Vob2xkZXIuZWxlbWVudC5jYWxsKGIuZWxlbWVudCxiLmN1cnJlbnRJdGVtKSk7Yi5jdXJyZW50SXRlbS5hZnRlcihiLnBsYWNlaG9sZGVyKTtjLnBsYWNlaG9sZGVyLnVwZGF0ZShiLGIucGxhY2Vob2xkZXIpfSxfY29udGFjdENvbnRhaW5lcnM6ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPW51bGwsYz1udWxsLGU9dGhpcy5jb250YWluZXJzLmxlbmd0aC0xO2U+PTA7ZS0tKWlmKCFkLnVpLmNvbnRhaW5zKHRoaXMuY3VycmVudEl0ZW1bMF0sdGhpcy5jb250YWluZXJzW2VdLmVsZW1lbnRbMF0pKWlmKHRoaXMuX2ludGVyc2VjdHNXaXRoKHRoaXMuY29udGFpbmVyc1tlXS5jb250YWluZXJDYWNoZSkpe2lmKCEoYiYmZC51aS5jb250YWlucyh0aGlzLmNvbnRhaW5lcnNbZV0uZWxlbWVudFswXSxiLmVsZW1lbnRbMF0pKSl7Yj10aGlzLmNvbnRhaW5lcnNbZV07Yz1lfX1lbHNlIGlmKHRoaXMuY29udGFpbmVyc1tlXS5jb250YWluZXJDYWNoZS5vdmVyKXt0aGlzLmNvbnRhaW5lcnNbZV0uX3RyaWdnZXIoXCJvdXRcIixcclxuYSx0aGlzLl91aUhhc2godGhpcykpO3RoaXMuY29udGFpbmVyc1tlXS5jb250YWluZXJDYWNoZS5vdmVyPTB9aWYoYilpZih0aGlzLmNvbnRhaW5lcnMubGVuZ3RoPT09MSl7dGhpcy5jb250YWluZXJzW2NdLl90cmlnZ2VyKFwib3ZlclwiLGEsdGhpcy5fdWlIYXNoKHRoaXMpKTt0aGlzLmNvbnRhaW5lcnNbY10uY29udGFpbmVyQ2FjaGUub3Zlcj0xfWVsc2UgaWYodGhpcy5jdXJyZW50Q29udGFpbmVyIT10aGlzLmNvbnRhaW5lcnNbY10pe2I9MUU0O2U9bnVsbDtmb3IodmFyIGY9dGhpcy5wb3NpdGlvbkFic1t0aGlzLmNvbnRhaW5lcnNbY10uZmxvYXRpbmc/XCJsZWZ0XCI6XCJ0b3BcIl0sZz10aGlzLml0ZW1zLmxlbmd0aC0xO2c+PTA7Zy0tKWlmKGQudWkuY29udGFpbnModGhpcy5jb250YWluZXJzW2NdLmVsZW1lbnRbMF0sdGhpcy5pdGVtc1tnXS5pdGVtWzBdKSl7dmFyIGg9dGhpcy5pdGVtc1tnXVt0aGlzLmNvbnRhaW5lcnNbY10uZmxvYXRpbmc/XCJsZWZ0XCI6XCJ0b3BcIl07aWYoTWF0aC5hYnMoaC1cclxuZik8Yil7Yj1NYXRoLmFicyhoLWYpO2U9dGhpcy5pdGVtc1tnXX19aWYoZXx8dGhpcy5vcHRpb25zLmRyb3BPbkVtcHR5KXt0aGlzLmN1cnJlbnRDb250YWluZXI9dGhpcy5jb250YWluZXJzW2NdO2U/dGhpcy5fcmVhcnJhbmdlKGEsZSxudWxsLHRydWUpOnRoaXMuX3JlYXJyYW5nZShhLG51bGwsdGhpcy5jb250YWluZXJzW2NdLmVsZW1lbnQsdHJ1ZSk7dGhpcy5fdHJpZ2dlcihcImNoYW5nZVwiLGEsdGhpcy5fdWlIYXNoKCkpO3RoaXMuY29udGFpbmVyc1tjXS5fdHJpZ2dlcihcImNoYW5nZVwiLGEsdGhpcy5fdWlIYXNoKHRoaXMpKTt0aGlzLm9wdGlvbnMucGxhY2Vob2xkZXIudXBkYXRlKHRoaXMuY3VycmVudENvbnRhaW5lcix0aGlzLnBsYWNlaG9sZGVyKTt0aGlzLmNvbnRhaW5lcnNbY10uX3RyaWdnZXIoXCJvdmVyXCIsYSx0aGlzLl91aUhhc2godGhpcykpO3RoaXMuY29udGFpbmVyc1tjXS5jb250YWluZXJDYWNoZS5vdmVyPTF9fX0sX2NyZWF0ZUhlbHBlcjpmdW5jdGlvbihhKXt2YXIgYj1cclxudGhpcy5vcHRpb25zO2E9ZC5pc0Z1bmN0aW9uKGIuaGVscGVyKT9kKGIuaGVscGVyLmFwcGx5KHRoaXMuZWxlbWVudFswXSxbYSx0aGlzLmN1cnJlbnRJdGVtXSkpOmIuaGVscGVyPT1cImNsb25lXCI/dGhpcy5jdXJyZW50SXRlbS5jbG9uZSgpOnRoaXMuY3VycmVudEl0ZW07YS5wYXJlbnRzKFwiYm9keVwiKS5sZW5ndGh8fGQoYi5hcHBlbmRUbyE9XCJwYXJlbnRcIj9iLmFwcGVuZFRvOnRoaXMuY3VycmVudEl0ZW1bMF0ucGFyZW50Tm9kZSlbMF0uYXBwZW5kQ2hpbGQoYVswXSk7aWYoYVswXT09dGhpcy5jdXJyZW50SXRlbVswXSl0aGlzLl9zdG9yZWRDU1M9e3dpZHRoOnRoaXMuY3VycmVudEl0ZW1bMF0uc3R5bGUud2lkdGgsaGVpZ2h0OnRoaXMuY3VycmVudEl0ZW1bMF0uc3R5bGUuaGVpZ2h0LHBvc2l0aW9uOnRoaXMuY3VycmVudEl0ZW0uY3NzKFwicG9zaXRpb25cIiksdG9wOnRoaXMuY3VycmVudEl0ZW0uY3NzKFwidG9wXCIpLGxlZnQ6dGhpcy5jdXJyZW50SXRlbS5jc3MoXCJsZWZ0XCIpfTtpZihhWzBdLnN0eWxlLndpZHRoPT1cclxuXCJcInx8Yi5mb3JjZUhlbHBlclNpemUpYS53aWR0aCh0aGlzLmN1cnJlbnRJdGVtLndpZHRoKCkpO2lmKGFbMF0uc3R5bGUuaGVpZ2h0PT1cIlwifHxiLmZvcmNlSGVscGVyU2l6ZSlhLmhlaWdodCh0aGlzLmN1cnJlbnRJdGVtLmhlaWdodCgpKTtyZXR1cm4gYX0sX2FkanVzdE9mZnNldEZyb21IZWxwZXI6ZnVuY3Rpb24oYSl7aWYodHlwZW9mIGE9PVwic3RyaW5nXCIpYT1hLnNwbGl0KFwiIFwiKTtpZihkLmlzQXJyYXkoYSkpYT17bGVmdDorYVswXSx0b3A6K2FbMV18fDB9O2lmKFwibGVmdFwiaW4gYSl0aGlzLm9mZnNldC5jbGljay5sZWZ0PWEubGVmdCt0aGlzLm1hcmdpbnMubGVmdDtpZihcInJpZ2h0XCJpbiBhKXRoaXMub2Zmc2V0LmNsaWNrLmxlZnQ9dGhpcy5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aC1hLnJpZ2h0K3RoaXMubWFyZ2lucy5sZWZ0O2lmKFwidG9wXCJpbiBhKXRoaXMub2Zmc2V0LmNsaWNrLnRvcD1hLnRvcCt0aGlzLm1hcmdpbnMudG9wO2lmKFwiYm90dG9tXCJpbiBhKXRoaXMub2Zmc2V0LmNsaWNrLnRvcD1cclxudGhpcy5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQtYS5ib3R0b20rdGhpcy5tYXJnaW5zLnRvcH0sX2dldFBhcmVudE9mZnNldDpmdW5jdGlvbigpe3RoaXMub2Zmc2V0UGFyZW50PXRoaXMuaGVscGVyLm9mZnNldFBhcmVudCgpO3ZhciBhPXRoaXMub2Zmc2V0UGFyZW50Lm9mZnNldCgpO2lmKHRoaXMuY3NzUG9zaXRpb249PVwiYWJzb2x1dGVcIiYmdGhpcy5zY3JvbGxQYXJlbnRbMF0hPWRvY3VtZW50JiZkLnVpLmNvbnRhaW5zKHRoaXMuc2Nyb2xsUGFyZW50WzBdLHRoaXMub2Zmc2V0UGFyZW50WzBdKSl7YS5sZWZ0Kz10aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0KCk7YS50b3ArPXRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCgpfWlmKHRoaXMub2Zmc2V0UGFyZW50WzBdPT1kb2N1bWVudC5ib2R5fHx0aGlzLm9mZnNldFBhcmVudFswXS50YWdOYW1lJiZ0aGlzLm9mZnNldFBhcmVudFswXS50YWdOYW1lLnRvTG93ZXJDYXNlKCk9PVwiaHRtbFwiJiZkLmJyb3dzZXIubXNpZSlhPVxyXG57dG9wOjAsbGVmdDowfTtyZXR1cm57dG9wOmEudG9wKyhwYXJzZUludCh0aGlzLm9mZnNldFBhcmVudC5jc3MoXCJib3JkZXJUb3BXaWR0aFwiKSwxMCl8fDApLGxlZnQ6YS5sZWZ0KyhwYXJzZUludCh0aGlzLm9mZnNldFBhcmVudC5jc3MoXCJib3JkZXJMZWZ0V2lkdGhcIiksMTApfHwwKX19LF9nZXRSZWxhdGl2ZU9mZnNldDpmdW5jdGlvbigpe2lmKHRoaXMuY3NzUG9zaXRpb249PVwicmVsYXRpdmVcIil7dmFyIGE9dGhpcy5jdXJyZW50SXRlbS5wb3NpdGlvbigpO3JldHVybnt0b3A6YS50b3AtKHBhcnNlSW50KHRoaXMuaGVscGVyLmNzcyhcInRvcFwiKSwxMCl8fDApK3RoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCgpLGxlZnQ6YS5sZWZ0LShwYXJzZUludCh0aGlzLmhlbHBlci5jc3MoXCJsZWZ0XCIpLDEwKXx8MCkrdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsTGVmdCgpfX1lbHNlIHJldHVybnt0b3A6MCxsZWZ0OjB9fSxfY2FjaGVNYXJnaW5zOmZ1bmN0aW9uKCl7dGhpcy5tYXJnaW5zPXtsZWZ0OnBhcnNlSW50KHRoaXMuY3VycmVudEl0ZW0uY3NzKFwibWFyZ2luTGVmdFwiKSxcclxuMTApfHwwLHRvcDpwYXJzZUludCh0aGlzLmN1cnJlbnRJdGVtLmNzcyhcIm1hcmdpblRvcFwiKSwxMCl8fDB9fSxfY2FjaGVIZWxwZXJQcm9wb3J0aW9uczpmdW5jdGlvbigpe3RoaXMuaGVscGVyUHJvcG9ydGlvbnM9e3dpZHRoOnRoaXMuaGVscGVyLm91dGVyV2lkdGgoKSxoZWlnaHQ6dGhpcy5oZWxwZXIub3V0ZXJIZWlnaHQoKX19LF9zZXRDb250YWlubWVudDpmdW5jdGlvbigpe3ZhciBhPXRoaXMub3B0aW9ucztpZihhLmNvbnRhaW5tZW50PT1cInBhcmVudFwiKWEuY29udGFpbm1lbnQ9dGhpcy5oZWxwZXJbMF0ucGFyZW50Tm9kZTtpZihhLmNvbnRhaW5tZW50PT1cImRvY3VtZW50XCJ8fGEuY29udGFpbm1lbnQ9PVwid2luZG93XCIpdGhpcy5jb250YWlubWVudD1bMC10aGlzLm9mZnNldC5yZWxhdGl2ZS5sZWZ0LXRoaXMub2Zmc2V0LnBhcmVudC5sZWZ0LDAtdGhpcy5vZmZzZXQucmVsYXRpdmUudG9wLXRoaXMub2Zmc2V0LnBhcmVudC50b3AsZChhLmNvbnRhaW5tZW50PT1cImRvY3VtZW50XCI/XHJcbmRvY3VtZW50OndpbmRvdykud2lkdGgoKS10aGlzLmhlbHBlclByb3BvcnRpb25zLndpZHRoLXRoaXMubWFyZ2lucy5sZWZ0LChkKGEuY29udGFpbm1lbnQ9PVwiZG9jdW1lbnRcIj9kb2N1bWVudDp3aW5kb3cpLmhlaWdodCgpfHxkb2N1bWVudC5ib2R5LnBhcmVudE5vZGUuc2Nyb2xsSGVpZ2h0KS10aGlzLmhlbHBlclByb3BvcnRpb25zLmhlaWdodC10aGlzLm1hcmdpbnMudG9wXTtpZighL14oZG9jdW1lbnR8d2luZG93fHBhcmVudCkkLy50ZXN0KGEuY29udGFpbm1lbnQpKXt2YXIgYj1kKGEuY29udGFpbm1lbnQpWzBdO2E9ZChhLmNvbnRhaW5tZW50KS5vZmZzZXQoKTt2YXIgYz1kKGIpLmNzcyhcIm92ZXJmbG93XCIpIT1cImhpZGRlblwiO3RoaXMuY29udGFpbm1lbnQ9W2EubGVmdCsocGFyc2VJbnQoZChiKS5jc3MoXCJib3JkZXJMZWZ0V2lkdGhcIiksMTApfHwwKSsocGFyc2VJbnQoZChiKS5jc3MoXCJwYWRkaW5nTGVmdFwiKSwxMCl8fDApLXRoaXMubWFyZ2lucy5sZWZ0LGEudG9wKyhwYXJzZUludChkKGIpLmNzcyhcImJvcmRlclRvcFdpZHRoXCIpLFxyXG4xMCl8fDApKyhwYXJzZUludChkKGIpLmNzcyhcInBhZGRpbmdUb3BcIiksMTApfHwwKS10aGlzLm1hcmdpbnMudG9wLGEubGVmdCsoYz9NYXRoLm1heChiLnNjcm9sbFdpZHRoLGIub2Zmc2V0V2lkdGgpOmIub2Zmc2V0V2lkdGgpLShwYXJzZUludChkKGIpLmNzcyhcImJvcmRlckxlZnRXaWR0aFwiKSwxMCl8fDApLShwYXJzZUludChkKGIpLmNzcyhcInBhZGRpbmdSaWdodFwiKSwxMCl8fDApLXRoaXMuaGVscGVyUHJvcG9ydGlvbnMud2lkdGgtdGhpcy5tYXJnaW5zLmxlZnQsYS50b3ArKGM/TWF0aC5tYXgoYi5zY3JvbGxIZWlnaHQsYi5vZmZzZXRIZWlnaHQpOmIub2Zmc2V0SGVpZ2h0KS0ocGFyc2VJbnQoZChiKS5jc3MoXCJib3JkZXJUb3BXaWR0aFwiKSwxMCl8fDApLShwYXJzZUludChkKGIpLmNzcyhcInBhZGRpbmdCb3R0b21cIiksMTApfHwwKS10aGlzLmhlbHBlclByb3BvcnRpb25zLmhlaWdodC10aGlzLm1hcmdpbnMudG9wXX19LF9jb252ZXJ0UG9zaXRpb25UbzpmdW5jdGlvbihhLGIpe2lmKCFiKWI9XHJcbnRoaXMucG9zaXRpb247YT1hPT1cImFic29sdXRlXCI/MTotMTt2YXIgYz10aGlzLmNzc1Bvc2l0aW9uPT1cImFic29sdXRlXCImJiEodGhpcy5zY3JvbGxQYXJlbnRbMF0hPWRvY3VtZW50JiZkLnVpLmNvbnRhaW5zKHRoaXMuc2Nyb2xsUGFyZW50WzBdLHRoaXMub2Zmc2V0UGFyZW50WzBdKSk/dGhpcy5vZmZzZXRQYXJlbnQ6dGhpcy5zY3JvbGxQYXJlbnQsZT0vKGh0bWx8Ym9keSkvaS50ZXN0KGNbMF0udGFnTmFtZSk7cmV0dXJue3RvcDpiLnRvcCt0aGlzLm9mZnNldC5yZWxhdGl2ZS50b3AqYSt0aGlzLm9mZnNldC5wYXJlbnQudG9wKmEtKGQuYnJvd3Nlci5zYWZhcmkmJnRoaXMuY3NzUG9zaXRpb249PVwiZml4ZWRcIj8wOih0aGlzLmNzc1Bvc2l0aW9uPT1cImZpeGVkXCI/LXRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCgpOmU/MDpjLnNjcm9sbFRvcCgpKSphKSxsZWZ0OmIubGVmdCt0aGlzLm9mZnNldC5yZWxhdGl2ZS5sZWZ0KmErdGhpcy5vZmZzZXQucGFyZW50LmxlZnQqYS0oZC5icm93c2VyLnNhZmFyaSYmXHJcbnRoaXMuY3NzUG9zaXRpb249PVwiZml4ZWRcIj8wOih0aGlzLmNzc1Bvc2l0aW9uPT1cImZpeGVkXCI/LXRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbExlZnQoKTplPzA6Yy5zY3JvbGxMZWZ0KCkpKmEpfX0sX2dlbmVyYXRlUG9zaXRpb246ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5vcHRpb25zLGM9dGhpcy5jc3NQb3NpdGlvbj09XCJhYnNvbHV0ZVwiJiYhKHRoaXMuc2Nyb2xsUGFyZW50WzBdIT1kb2N1bWVudCYmZC51aS5jb250YWlucyh0aGlzLnNjcm9sbFBhcmVudFswXSx0aGlzLm9mZnNldFBhcmVudFswXSkpP3RoaXMub2Zmc2V0UGFyZW50OnRoaXMuc2Nyb2xsUGFyZW50LGU9LyhodG1sfGJvZHkpL2kudGVzdChjWzBdLnRhZ05hbWUpO2lmKHRoaXMuY3NzUG9zaXRpb249PVwicmVsYXRpdmVcIiYmISh0aGlzLnNjcm9sbFBhcmVudFswXSE9ZG9jdW1lbnQmJnRoaXMuc2Nyb2xsUGFyZW50WzBdIT10aGlzLm9mZnNldFBhcmVudFswXSkpdGhpcy5vZmZzZXQucmVsYXRpdmU9dGhpcy5fZ2V0UmVsYXRpdmVPZmZzZXQoKTtcclxudmFyIGY9YS5wYWdlWCxnPWEucGFnZVk7aWYodGhpcy5vcmlnaW5hbFBvc2l0aW9uKXtpZih0aGlzLmNvbnRhaW5tZW50KXtpZihhLnBhZ2VYLXRoaXMub2Zmc2V0LmNsaWNrLmxlZnQ8dGhpcy5jb250YWlubWVudFswXSlmPXRoaXMuY29udGFpbm1lbnRbMF0rdGhpcy5vZmZzZXQuY2xpY2subGVmdDtpZihhLnBhZ2VZLXRoaXMub2Zmc2V0LmNsaWNrLnRvcDx0aGlzLmNvbnRhaW5tZW50WzFdKWc9dGhpcy5jb250YWlubWVudFsxXSt0aGlzLm9mZnNldC5jbGljay50b3A7aWYoYS5wYWdlWC10aGlzLm9mZnNldC5jbGljay5sZWZ0PnRoaXMuY29udGFpbm1lbnRbMl0pZj10aGlzLmNvbnRhaW5tZW50WzJdK3RoaXMub2Zmc2V0LmNsaWNrLmxlZnQ7aWYoYS5wYWdlWS10aGlzLm9mZnNldC5jbGljay50b3A+dGhpcy5jb250YWlubWVudFszXSlnPXRoaXMuY29udGFpbm1lbnRbM10rdGhpcy5vZmZzZXQuY2xpY2sudG9wfWlmKGIuZ3JpZCl7Zz10aGlzLm9yaWdpbmFsUGFnZVkrTWF0aC5yb3VuZCgoZy1cclxudGhpcy5vcmlnaW5hbFBhZ2VZKS9iLmdyaWRbMV0pKmIuZ3JpZFsxXTtnPXRoaXMuY29udGFpbm1lbnQ/IShnLXRoaXMub2Zmc2V0LmNsaWNrLnRvcDx0aGlzLmNvbnRhaW5tZW50WzFdfHxnLXRoaXMub2Zmc2V0LmNsaWNrLnRvcD50aGlzLmNvbnRhaW5tZW50WzNdKT9nOiEoZy10aGlzLm9mZnNldC5jbGljay50b3A8dGhpcy5jb250YWlubWVudFsxXSk/Zy1iLmdyaWRbMV06ZytiLmdyaWRbMV06ZztmPXRoaXMub3JpZ2luYWxQYWdlWCtNYXRoLnJvdW5kKChmLXRoaXMub3JpZ2luYWxQYWdlWCkvYi5ncmlkWzBdKSpiLmdyaWRbMF07Zj10aGlzLmNvbnRhaW5tZW50PyEoZi10aGlzLm9mZnNldC5jbGljay5sZWZ0PHRoaXMuY29udGFpbm1lbnRbMF18fGYtdGhpcy5vZmZzZXQuY2xpY2subGVmdD50aGlzLmNvbnRhaW5tZW50WzJdKT9mOiEoZi10aGlzLm9mZnNldC5jbGljay5sZWZ0PHRoaXMuY29udGFpbm1lbnRbMF0pP2YtYi5ncmlkWzBdOmYrYi5ncmlkWzBdOmZ9fXJldHVybnt0b3A6Zy1cclxudGhpcy5vZmZzZXQuY2xpY2sudG9wLXRoaXMub2Zmc2V0LnJlbGF0aXZlLnRvcC10aGlzLm9mZnNldC5wYXJlbnQudG9wKyhkLmJyb3dzZXIuc2FmYXJpJiZ0aGlzLmNzc1Bvc2l0aW9uPT1cImZpeGVkXCI/MDp0aGlzLmNzc1Bvc2l0aW9uPT1cImZpeGVkXCI/LXRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCgpOmU/MDpjLnNjcm9sbFRvcCgpKSxsZWZ0OmYtdGhpcy5vZmZzZXQuY2xpY2subGVmdC10aGlzLm9mZnNldC5yZWxhdGl2ZS5sZWZ0LXRoaXMub2Zmc2V0LnBhcmVudC5sZWZ0KyhkLmJyb3dzZXIuc2FmYXJpJiZ0aGlzLmNzc1Bvc2l0aW9uPT1cImZpeGVkXCI/MDp0aGlzLmNzc1Bvc2l0aW9uPT1cImZpeGVkXCI/LXRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbExlZnQoKTplPzA6Yy5zY3JvbGxMZWZ0KCkpfX0sX3JlYXJyYW5nZTpmdW5jdGlvbihhLGIsYyxlKXtjP2NbMF0uYXBwZW5kQ2hpbGQodGhpcy5wbGFjZWhvbGRlclswXSk6Yi5pdGVtWzBdLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMucGxhY2Vob2xkZXJbMF0sXHJcbnRoaXMuZGlyZWN0aW9uPT1cImRvd25cIj9iLml0ZW1bMF06Yi5pdGVtWzBdLm5leHRTaWJsaW5nKTt0aGlzLmNvdW50ZXI9dGhpcy5jb3VudGVyPysrdGhpcy5jb3VudGVyOjE7dmFyIGY9dGhpcyxnPXRoaXMuY291bnRlcjt3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpe2c9PWYuY291bnRlciYmZi5yZWZyZXNoUG9zaXRpb25zKCFlKX0sMCl9LF9jbGVhcjpmdW5jdGlvbihhLGIpe3RoaXMucmV2ZXJ0aW5nPWZhbHNlO3ZhciBjPVtdOyF0aGlzLl9ub0ZpbmFsU29ydCYmdGhpcy5jdXJyZW50SXRlbS5wYXJlbnQoKS5sZW5ndGgmJnRoaXMucGxhY2Vob2xkZXIuYmVmb3JlKHRoaXMuY3VycmVudEl0ZW0pO3RoaXMuX25vRmluYWxTb3J0PW51bGw7aWYodGhpcy5oZWxwZXJbMF09PXRoaXMuY3VycmVudEl0ZW1bMF0pe2Zvcih2YXIgZSBpbiB0aGlzLl9zdG9yZWRDU1MpaWYodGhpcy5fc3RvcmVkQ1NTW2VdPT1cImF1dG9cInx8dGhpcy5fc3RvcmVkQ1NTW2VdPT1cInN0YXRpY1wiKXRoaXMuX3N0b3JlZENTU1tlXT1cclxuXCJcIjt0aGlzLmN1cnJlbnRJdGVtLmNzcyh0aGlzLl9zdG9yZWRDU1MpLnJlbW92ZUNsYXNzKFwidWktc29ydGFibGUtaGVscGVyXCIpfWVsc2UgdGhpcy5jdXJyZW50SXRlbS5zaG93KCk7dGhpcy5mcm9tT3V0c2lkZSYmIWImJmMucHVzaChmdW5jdGlvbihmKXt0aGlzLl90cmlnZ2VyKFwicmVjZWl2ZVwiLGYsdGhpcy5fdWlIYXNoKHRoaXMuZnJvbU91dHNpZGUpKX0pO2lmKCh0aGlzLmZyb21PdXRzaWRlfHx0aGlzLmRvbVBvc2l0aW9uLnByZXYhPXRoaXMuY3VycmVudEl0ZW0ucHJldigpLm5vdChcIi51aS1zb3J0YWJsZS1oZWxwZXJcIilbMF18fHRoaXMuZG9tUG9zaXRpb24ucGFyZW50IT10aGlzLmN1cnJlbnRJdGVtLnBhcmVudCgpWzBdKSYmIWIpYy5wdXNoKGZ1bmN0aW9uKGYpe3RoaXMuX3RyaWdnZXIoXCJ1cGRhdGVcIixmLHRoaXMuX3VpSGFzaCgpKX0pO2lmKCFkLnVpLmNvbnRhaW5zKHRoaXMuZWxlbWVudFswXSx0aGlzLmN1cnJlbnRJdGVtWzBdKSl7Ynx8Yy5wdXNoKGZ1bmN0aW9uKGYpe3RoaXMuX3RyaWdnZXIoXCJyZW1vdmVcIixcclxuZix0aGlzLl91aUhhc2goKSl9KTtmb3IoZT10aGlzLmNvbnRhaW5lcnMubGVuZ3RoLTE7ZT49MDtlLS0paWYoZC51aS5jb250YWlucyh0aGlzLmNvbnRhaW5lcnNbZV0uZWxlbWVudFswXSx0aGlzLmN1cnJlbnRJdGVtWzBdKSYmIWIpe2MucHVzaChmdW5jdGlvbihmKXtyZXR1cm4gZnVuY3Rpb24oZyl7Zi5fdHJpZ2dlcihcInJlY2VpdmVcIixnLHRoaXMuX3VpSGFzaCh0aGlzKSl9fS5jYWxsKHRoaXMsdGhpcy5jb250YWluZXJzW2VdKSk7Yy5wdXNoKGZ1bmN0aW9uKGYpe3JldHVybiBmdW5jdGlvbihnKXtmLl90cmlnZ2VyKFwidXBkYXRlXCIsZyx0aGlzLl91aUhhc2godGhpcykpfX0uY2FsbCh0aGlzLHRoaXMuY29udGFpbmVyc1tlXSkpfX1mb3IoZT10aGlzLmNvbnRhaW5lcnMubGVuZ3RoLTE7ZT49MDtlLS0pe2J8fGMucHVzaChmdW5jdGlvbihmKXtyZXR1cm4gZnVuY3Rpb24oZyl7Zi5fdHJpZ2dlcihcImRlYWN0aXZhdGVcIixnLHRoaXMuX3VpSGFzaCh0aGlzKSl9fS5jYWxsKHRoaXMsXHJcbnRoaXMuY29udGFpbmVyc1tlXSkpO2lmKHRoaXMuY29udGFpbmVyc1tlXS5jb250YWluZXJDYWNoZS5vdmVyKXtjLnB1c2goZnVuY3Rpb24oZil7cmV0dXJuIGZ1bmN0aW9uKGcpe2YuX3RyaWdnZXIoXCJvdXRcIixnLHRoaXMuX3VpSGFzaCh0aGlzKSl9fS5jYWxsKHRoaXMsdGhpcy5jb250YWluZXJzW2VdKSk7dGhpcy5jb250YWluZXJzW2VdLmNvbnRhaW5lckNhY2hlLm92ZXI9MH19dGhpcy5fc3RvcmVkQ3Vyc29yJiZkKFwiYm9keVwiKS5jc3MoXCJjdXJzb3JcIix0aGlzLl9zdG9yZWRDdXJzb3IpO3RoaXMuX3N0b3JlZE9wYWNpdHkmJnRoaXMuaGVscGVyLmNzcyhcIm9wYWNpdHlcIix0aGlzLl9zdG9yZWRPcGFjaXR5KTtpZih0aGlzLl9zdG9yZWRaSW5kZXgpdGhpcy5oZWxwZXIuY3NzKFwiekluZGV4XCIsdGhpcy5fc3RvcmVkWkluZGV4PT1cImF1dG9cIj9cIlwiOnRoaXMuX3N0b3JlZFpJbmRleCk7dGhpcy5kcmFnZ2luZz1mYWxzZTtpZih0aGlzLmNhbmNlbEhlbHBlclJlbW92YWwpe2lmKCFiKXt0aGlzLl90cmlnZ2VyKFwiYmVmb3JlU3RvcFwiLFxyXG5hLHRoaXMuX3VpSGFzaCgpKTtmb3IoZT0wO2U8Yy5sZW5ndGg7ZSsrKWNbZV0uY2FsbCh0aGlzLGEpO3RoaXMuX3RyaWdnZXIoXCJzdG9wXCIsYSx0aGlzLl91aUhhc2goKSl9cmV0dXJuIGZhbHNlfWJ8fHRoaXMuX3RyaWdnZXIoXCJiZWZvcmVTdG9wXCIsYSx0aGlzLl91aUhhc2goKSk7dGhpcy5wbGFjZWhvbGRlclswXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMucGxhY2Vob2xkZXJbMF0pO3RoaXMuaGVscGVyWzBdIT10aGlzLmN1cnJlbnRJdGVtWzBdJiZ0aGlzLmhlbHBlci5yZW1vdmUoKTt0aGlzLmhlbHBlcj1udWxsO2lmKCFiKXtmb3IoZT0wO2U8Yy5sZW5ndGg7ZSsrKWNbZV0uY2FsbCh0aGlzLGEpO3RoaXMuX3RyaWdnZXIoXCJzdG9wXCIsYSx0aGlzLl91aUhhc2goKSl9dGhpcy5mcm9tT3V0c2lkZT1mYWxzZTtyZXR1cm4gdHJ1ZX0sX3RyaWdnZXI6ZnVuY3Rpb24oKXtkLldpZGdldC5wcm90b3R5cGUuX3RyaWdnZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpPT09ZmFsc2UmJnRoaXMuY2FuY2VsKCl9LFxyXG5fdWlIYXNoOmZ1bmN0aW9uKGEpe3ZhciBiPWF8fHRoaXM7cmV0dXJue2hlbHBlcjpiLmhlbHBlcixwbGFjZWhvbGRlcjpiLnBsYWNlaG9sZGVyfHxkKFtdKSxwb3NpdGlvbjpiLnBvc2l0aW9uLG9yaWdpbmFsUG9zaXRpb246Yi5vcmlnaW5hbFBvc2l0aW9uLG9mZnNldDpiLnBvc2l0aW9uQWJzLGl0ZW06Yi5jdXJyZW50SXRlbSxzZW5kZXI6YT9hLmVsZW1lbnQ6bnVsbH19fSk7ZC5leHRlbmQoZC51aS5zb3J0YWJsZSx7dmVyc2lvbjpcIjEuOC4xNlwifSl9KShqUXVlcnkpO1xyXG47LypcclxuICogalF1ZXJ5IFVJIEFjY29yZGlvbiAxLjguMTZcclxuICpcclxuICogQ29weXJpZ2h0IDIwMTEsIEFVVEhPUlMudHh0IChodHRwOi8vanF1ZXJ5dWkuY29tL2Fib3V0KVxyXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgb3IgR1BMIFZlcnNpb24gMiBsaWNlbnNlcy5cclxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxyXG4gKlxyXG4gKiBodHRwOi8vZG9jcy5qcXVlcnkuY29tL1VJL0FjY29yZGlvblxyXG4gKlxyXG4gKiBEZXBlbmRzOlxyXG4gKlx0anF1ZXJ5LnVpLmNvcmUuanNcclxuICpcdGpxdWVyeS51aS53aWRnZXQuanNcclxuICovXHJcbihmdW5jdGlvbihjKXtjLndpZGdldChcInVpLmFjY29yZGlvblwiLHtvcHRpb25zOnthY3RpdmU6MCxhbmltYXRlZDpcInNsaWRlXCIsYXV0b0hlaWdodDp0cnVlLGNsZWFyU3R5bGU6ZmFsc2UsY29sbGFwc2libGU6ZmFsc2UsZXZlbnQ6XCJjbGlja1wiLGZpbGxTcGFjZTpmYWxzZSxoZWFkZXI6XCI+IGxpID4gOmZpcnN0LWNoaWxkLD4gOm5vdChsaSk6ZXZlblwiLGljb25zOntoZWFkZXI6XCJ1aS1pY29uLXRyaWFuZ2xlLTEtZVwiLGhlYWRlclNlbGVjdGVkOlwidWktaWNvbi10cmlhbmdsZS0xLXNcIn0sbmF2aWdhdGlvbjpmYWxzZSxuYXZpZ2F0aW9uRmlsdGVyOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaHJlZi50b0xvd2VyQ2FzZSgpPT09bG9jYXRpb24uaHJlZi50b0xvd2VyQ2FzZSgpfX0sX2NyZWF0ZTpmdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1hLm9wdGlvbnM7YS5ydW5uaW5nPTA7YS5lbGVtZW50LmFkZENsYXNzKFwidWktYWNjb3JkaW9uIHVpLXdpZGdldCB1aS1oZWxwZXItcmVzZXRcIikuY2hpbGRyZW4oXCJsaVwiKS5hZGRDbGFzcyhcInVpLWFjY29yZGlvbi1saS1maXhcIik7XHJcbmEuaGVhZGVycz1hLmVsZW1lbnQuZmluZChiLmhlYWRlcikuYWRkQ2xhc3MoXCJ1aS1hY2NvcmRpb24taGVhZGVyIHVpLWhlbHBlci1yZXNldCB1aS1zdGF0ZS1kZWZhdWx0IHVpLWNvcm5lci1hbGxcIikuYmluZChcIm1vdXNlZW50ZXIuYWNjb3JkaW9uXCIsZnVuY3Rpb24oKXtiLmRpc2FibGVkfHxjKHRoaXMpLmFkZENsYXNzKFwidWktc3RhdGUtaG92ZXJcIil9KS5iaW5kKFwibW91c2VsZWF2ZS5hY2NvcmRpb25cIixmdW5jdGlvbigpe2IuZGlzYWJsZWR8fGModGhpcykucmVtb3ZlQ2xhc3MoXCJ1aS1zdGF0ZS1ob3ZlclwiKX0pLmJpbmQoXCJmb2N1cy5hY2NvcmRpb25cIixmdW5jdGlvbigpe2IuZGlzYWJsZWR8fGModGhpcykuYWRkQ2xhc3MoXCJ1aS1zdGF0ZS1mb2N1c1wiKX0pLmJpbmQoXCJibHVyLmFjY29yZGlvblwiLGZ1bmN0aW9uKCl7Yi5kaXNhYmxlZHx8Yyh0aGlzKS5yZW1vdmVDbGFzcyhcInVpLXN0YXRlLWZvY3VzXCIpfSk7YS5oZWFkZXJzLm5leHQoKS5hZGRDbGFzcyhcInVpLWFjY29yZGlvbi1jb250ZW50IHVpLWhlbHBlci1yZXNldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYm90dG9tXCIpO1xyXG5pZihiLm5hdmlnYXRpb24pe3ZhciBkPWEuZWxlbWVudC5maW5kKFwiYVwiKS5maWx0ZXIoYi5uYXZpZ2F0aW9uRmlsdGVyKS5lcSgwKTtpZihkLmxlbmd0aCl7dmFyIGg9ZC5jbG9zZXN0KFwiLnVpLWFjY29yZGlvbi1oZWFkZXJcIik7YS5hY3RpdmU9aC5sZW5ndGg/aDpkLmNsb3Nlc3QoXCIudWktYWNjb3JkaW9uLWNvbnRlbnRcIikucHJldigpfX1hLmFjdGl2ZT1hLl9maW5kQWN0aXZlKGEuYWN0aXZlfHxiLmFjdGl2ZSkuYWRkQ2xhc3MoXCJ1aS1zdGF0ZS1kZWZhdWx0IHVpLXN0YXRlLWFjdGl2ZVwiKS50b2dnbGVDbGFzcyhcInVpLWNvcm5lci1hbGxcIikudG9nZ2xlQ2xhc3MoXCJ1aS1jb3JuZXItdG9wXCIpO2EuYWN0aXZlLm5leHQoKS5hZGRDbGFzcyhcInVpLWFjY29yZGlvbi1jb250ZW50LWFjdGl2ZVwiKTthLl9jcmVhdGVJY29ucygpO2EucmVzaXplKCk7YS5lbGVtZW50LmF0dHIoXCJyb2xlXCIsXCJ0YWJsaXN0XCIpO2EuaGVhZGVycy5hdHRyKFwicm9sZVwiLFwidGFiXCIpLmJpbmQoXCJrZXlkb3duLmFjY29yZGlvblwiLFxyXG5mdW5jdGlvbihmKXtyZXR1cm4gYS5fa2V5ZG93bihmKX0pLm5leHQoKS5hdHRyKFwicm9sZVwiLFwidGFicGFuZWxcIik7YS5oZWFkZXJzLm5vdChhLmFjdGl2ZXx8XCJcIikuYXR0cih7XCJhcmlhLWV4cGFuZGVkXCI6XCJmYWxzZVwiLFwiYXJpYS1zZWxlY3RlZFwiOlwiZmFsc2VcIix0YWJJbmRleDotMX0pLm5leHQoKS5oaWRlKCk7YS5hY3RpdmUubGVuZ3RoP2EuYWN0aXZlLmF0dHIoe1wiYXJpYS1leHBhbmRlZFwiOlwidHJ1ZVwiLFwiYXJpYS1zZWxlY3RlZFwiOlwidHJ1ZVwiLHRhYkluZGV4OjB9KTphLmhlYWRlcnMuZXEoMCkuYXR0cihcInRhYkluZGV4XCIsMCk7Yy5icm93c2VyLnNhZmFyaXx8YS5oZWFkZXJzLmZpbmQoXCJhXCIpLmF0dHIoXCJ0YWJJbmRleFwiLC0xKTtiLmV2ZW50JiZhLmhlYWRlcnMuYmluZChiLmV2ZW50LnNwbGl0KFwiIFwiKS5qb2luKFwiLmFjY29yZGlvbiBcIikrXCIuYWNjb3JkaW9uXCIsZnVuY3Rpb24oZil7YS5fY2xpY2tIYW5kbGVyLmNhbGwoYSxmLHRoaXMpO2YucHJldmVudERlZmF1bHQoKX0pfSxfY3JlYXRlSWNvbnM6ZnVuY3Rpb24oKXt2YXIgYT1cclxudGhpcy5vcHRpb25zO2lmKGEuaWNvbnMpe2MoXCI8c3Bhbj48L3NwYW4+XCIpLmFkZENsYXNzKFwidWktaWNvbiBcIithLmljb25zLmhlYWRlcikucHJlcGVuZFRvKHRoaXMuaGVhZGVycyk7dGhpcy5hY3RpdmUuY2hpbGRyZW4oXCIudWktaWNvblwiKS50b2dnbGVDbGFzcyhhLmljb25zLmhlYWRlcikudG9nZ2xlQ2xhc3MoYS5pY29ucy5oZWFkZXJTZWxlY3RlZCk7dGhpcy5lbGVtZW50LmFkZENsYXNzKFwidWktYWNjb3JkaW9uLWljb25zXCIpfX0sX2Rlc3Ryb3lJY29uczpmdW5jdGlvbigpe3RoaXMuaGVhZGVycy5jaGlsZHJlbihcIi51aS1pY29uXCIpLnJlbW92ZSgpO3RoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyhcInVpLWFjY29yZGlvbi1pY29uc1wiKX0sZGVzdHJveTpmdW5jdGlvbigpe3ZhciBhPXRoaXMub3B0aW9uczt0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoXCJ1aS1hY2NvcmRpb24gdWktd2lkZ2V0IHVpLWhlbHBlci1yZXNldFwiKS5yZW1vdmVBdHRyKFwicm9sZVwiKTt0aGlzLmhlYWRlcnMudW5iaW5kKFwiLmFjY29yZGlvblwiKS5yZW1vdmVDbGFzcyhcInVpLWFjY29yZGlvbi1oZWFkZXIgdWktYWNjb3JkaW9uLWRpc2FibGVkIHVpLWhlbHBlci1yZXNldCB1aS1zdGF0ZS1kZWZhdWx0IHVpLWNvcm5lci1hbGwgdWktc3RhdGUtYWN0aXZlIHVpLXN0YXRlLWRpc2FibGVkIHVpLWNvcm5lci10b3BcIikucmVtb3ZlQXR0cihcInJvbGVcIikucmVtb3ZlQXR0cihcImFyaWEtZXhwYW5kZWRcIikucmVtb3ZlQXR0cihcImFyaWEtc2VsZWN0ZWRcIikucmVtb3ZlQXR0cihcInRhYkluZGV4XCIpO1xyXG50aGlzLmhlYWRlcnMuZmluZChcImFcIikucmVtb3ZlQXR0cihcInRhYkluZGV4XCIpO3RoaXMuX2Rlc3Ryb3lJY29ucygpO3ZhciBiPXRoaXMuaGVhZGVycy5uZXh0KCkuY3NzKFwiZGlzcGxheVwiLFwiXCIpLnJlbW92ZUF0dHIoXCJyb2xlXCIpLnJlbW92ZUNsYXNzKFwidWktaGVscGVyLXJlc2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1ib3R0b20gdWktYWNjb3JkaW9uLWNvbnRlbnQgdWktYWNjb3JkaW9uLWNvbnRlbnQtYWN0aXZlIHVpLWFjY29yZGlvbi1kaXNhYmxlZCB1aS1zdGF0ZS1kaXNhYmxlZFwiKTtpZihhLmF1dG9IZWlnaHR8fGEuZmlsbEhlaWdodCliLmNzcyhcImhlaWdodFwiLFwiXCIpO3JldHVybiBjLldpZGdldC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpfSxfc2V0T3B0aW9uOmZ1bmN0aW9uKGEsYil7Yy5XaWRnZXQucHJvdG90eXBlLl9zZXRPcHRpb24uYXBwbHkodGhpcyxhcmd1bWVudHMpO2E9PVwiYWN0aXZlXCImJnRoaXMuYWN0aXZhdGUoYik7aWYoYT09XCJpY29uc1wiKXt0aGlzLl9kZXN0cm95SWNvbnMoKTtcclxuYiYmdGhpcy5fY3JlYXRlSWNvbnMoKX1pZihhPT1cImRpc2FibGVkXCIpdGhpcy5oZWFkZXJzLmFkZCh0aGlzLmhlYWRlcnMubmV4dCgpKVtiP1wiYWRkQ2xhc3NcIjpcInJlbW92ZUNsYXNzXCJdKFwidWktYWNjb3JkaW9uLWRpc2FibGVkIHVpLXN0YXRlLWRpc2FibGVkXCIpfSxfa2V5ZG93bjpmdW5jdGlvbihhKXtpZighKHRoaXMub3B0aW9ucy5kaXNhYmxlZHx8YS5hbHRLZXl8fGEuY3RybEtleSkpe3ZhciBiPWMudWkua2V5Q29kZSxkPXRoaXMuaGVhZGVycy5sZW5ndGgsaD10aGlzLmhlYWRlcnMuaW5kZXgoYS50YXJnZXQpLGY9ZmFsc2U7c3dpdGNoKGEua2V5Q29kZSl7Y2FzZSBiLlJJR0hUOmNhc2UgYi5ET1dOOmY9dGhpcy5oZWFkZXJzWyhoKzEpJWRdO2JyZWFrO2Nhc2UgYi5MRUZUOmNhc2UgYi5VUDpmPXRoaXMuaGVhZGVyc1soaC0xK2QpJWRdO2JyZWFrO2Nhc2UgYi5TUEFDRTpjYXNlIGIuRU5URVI6dGhpcy5fY2xpY2tIYW5kbGVyKHt0YXJnZXQ6YS50YXJnZXR9LGEudGFyZ2V0KTtcclxuYS5wcmV2ZW50RGVmYXVsdCgpfWlmKGYpe2MoYS50YXJnZXQpLmF0dHIoXCJ0YWJJbmRleFwiLC0xKTtjKGYpLmF0dHIoXCJ0YWJJbmRleFwiLDApO2YuZm9jdXMoKTtyZXR1cm4gZmFsc2V9cmV0dXJuIHRydWV9fSxyZXNpemU6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLm9wdGlvbnMsYjtpZihhLmZpbGxTcGFjZSl7aWYoYy5icm93c2VyLm1zaWUpe3ZhciBkPXRoaXMuZWxlbWVudC5wYXJlbnQoKS5jc3MoXCJvdmVyZmxvd1wiKTt0aGlzLmVsZW1lbnQucGFyZW50KCkuY3NzKFwib3ZlcmZsb3dcIixcImhpZGRlblwiKX1iPXRoaXMuZWxlbWVudC5wYXJlbnQoKS5oZWlnaHQoKTtjLmJyb3dzZXIubXNpZSYmdGhpcy5lbGVtZW50LnBhcmVudCgpLmNzcyhcIm92ZXJmbG93XCIsZCk7dGhpcy5oZWFkZXJzLmVhY2goZnVuY3Rpb24oKXtiLT1jKHRoaXMpLm91dGVySGVpZ2h0KHRydWUpfSk7dGhpcy5oZWFkZXJzLm5leHQoKS5lYWNoKGZ1bmN0aW9uKCl7Yyh0aGlzKS5oZWlnaHQoTWF0aC5tYXgoMCxiLWModGhpcykuaW5uZXJIZWlnaHQoKStcclxuYyh0aGlzKS5oZWlnaHQoKSkpfSkuY3NzKFwib3ZlcmZsb3dcIixcImF1dG9cIil9ZWxzZSBpZihhLmF1dG9IZWlnaHQpe2I9MDt0aGlzLmhlYWRlcnMubmV4dCgpLmVhY2goZnVuY3Rpb24oKXtiPU1hdGgubWF4KGIsYyh0aGlzKS5oZWlnaHQoXCJcIikuaGVpZ2h0KCkpfSkuaGVpZ2h0KGIpfXJldHVybiB0aGlzfSxhY3RpdmF0ZTpmdW5jdGlvbihhKXt0aGlzLm9wdGlvbnMuYWN0aXZlPWE7YT10aGlzLl9maW5kQWN0aXZlKGEpWzBdO3RoaXMuX2NsaWNrSGFuZGxlcih7dGFyZ2V0OmF9LGEpO3JldHVybiB0aGlzfSxfZmluZEFjdGl2ZTpmdW5jdGlvbihhKXtyZXR1cm4gYT90eXBlb2YgYT09PVwibnVtYmVyXCI/dGhpcy5oZWFkZXJzLmZpbHRlcihcIjplcShcIithK1wiKVwiKTp0aGlzLmhlYWRlcnMubm90KHRoaXMuaGVhZGVycy5ub3QoYSkpOmE9PT1mYWxzZT9jKFtdKTp0aGlzLmhlYWRlcnMuZmlsdGVyKFwiOmVxKDApXCIpfSxfY2xpY2tIYW5kbGVyOmZ1bmN0aW9uKGEsYil7dmFyIGQ9dGhpcy5vcHRpb25zO1xyXG5pZighZC5kaXNhYmxlZClpZihhLnRhcmdldCl7YT1jKGEuY3VycmVudFRhcmdldHx8Yik7Yj1hWzBdPT09dGhpcy5hY3RpdmVbMF07ZC5hY3RpdmU9ZC5jb2xsYXBzaWJsZSYmYj9mYWxzZTp0aGlzLmhlYWRlcnMuaW5kZXgoYSk7aWYoISh0aGlzLnJ1bm5pbmd8fCFkLmNvbGxhcHNpYmxlJiZiKSl7dmFyIGg9dGhpcy5hY3RpdmU7aj1hLm5leHQoKTtnPXRoaXMuYWN0aXZlLm5leHQoKTtlPXtvcHRpb25zOmQsbmV3SGVhZGVyOmImJmQuY29sbGFwc2libGU/YyhbXSk6YSxvbGRIZWFkZXI6dGhpcy5hY3RpdmUsbmV3Q29udGVudDpiJiZkLmNvbGxhcHNpYmxlP2MoW10pOmosb2xkQ29udGVudDpnfTt2YXIgZj10aGlzLmhlYWRlcnMuaW5kZXgodGhpcy5hY3RpdmVbMF0pPnRoaXMuaGVhZGVycy5pbmRleChhWzBdKTt0aGlzLmFjdGl2ZT1iP2MoW10pOmE7dGhpcy5fdG9nZ2xlKGosZyxlLGIsZik7aC5yZW1vdmVDbGFzcyhcInVpLXN0YXRlLWFjdGl2ZSB1aS1jb3JuZXItdG9wXCIpLmFkZENsYXNzKFwidWktc3RhdGUtZGVmYXVsdCB1aS1jb3JuZXItYWxsXCIpLmNoaWxkcmVuKFwiLnVpLWljb25cIikucmVtb3ZlQ2xhc3MoZC5pY29ucy5oZWFkZXJTZWxlY3RlZCkuYWRkQ2xhc3MoZC5pY29ucy5oZWFkZXIpO1xyXG5pZighYil7YS5yZW1vdmVDbGFzcyhcInVpLXN0YXRlLWRlZmF1bHQgdWktY29ybmVyLWFsbFwiKS5hZGRDbGFzcyhcInVpLXN0YXRlLWFjdGl2ZSB1aS1jb3JuZXItdG9wXCIpLmNoaWxkcmVuKFwiLnVpLWljb25cIikucmVtb3ZlQ2xhc3MoZC5pY29ucy5oZWFkZXIpLmFkZENsYXNzKGQuaWNvbnMuaGVhZGVyU2VsZWN0ZWQpO2EubmV4dCgpLmFkZENsYXNzKFwidWktYWNjb3JkaW9uLWNvbnRlbnQtYWN0aXZlXCIpfX19ZWxzZSBpZihkLmNvbGxhcHNpYmxlKXt0aGlzLmFjdGl2ZS5yZW1vdmVDbGFzcyhcInVpLXN0YXRlLWFjdGl2ZSB1aS1jb3JuZXItdG9wXCIpLmFkZENsYXNzKFwidWktc3RhdGUtZGVmYXVsdCB1aS1jb3JuZXItYWxsXCIpLmNoaWxkcmVuKFwiLnVpLWljb25cIikucmVtb3ZlQ2xhc3MoZC5pY29ucy5oZWFkZXJTZWxlY3RlZCkuYWRkQ2xhc3MoZC5pY29ucy5oZWFkZXIpO3RoaXMuYWN0aXZlLm5leHQoKS5hZGRDbGFzcyhcInVpLWFjY29yZGlvbi1jb250ZW50LWFjdGl2ZVwiKTt2YXIgZz10aGlzLmFjdGl2ZS5uZXh0KCksXHJcbmU9e29wdGlvbnM6ZCxuZXdIZWFkZXI6YyhbXSksb2xkSGVhZGVyOmQuYWN0aXZlLG5ld0NvbnRlbnQ6YyhbXSksb2xkQ29udGVudDpnfSxqPXRoaXMuYWN0aXZlPWMoW10pO3RoaXMuX3RvZ2dsZShqLGcsZSl9fSxfdG9nZ2xlOmZ1bmN0aW9uKGEsYixkLGgsZil7dmFyIGc9dGhpcyxlPWcub3B0aW9ucztnLnRvU2hvdz1hO2cudG9IaWRlPWI7Zy5kYXRhPWQ7dmFyIGo9ZnVuY3Rpb24oKXtpZihnKXJldHVybiBnLl9jb21wbGV0ZWQuYXBwbHkoZyxhcmd1bWVudHMpfTtnLl90cmlnZ2VyKFwiY2hhbmdlc3RhcnRcIixudWxsLGcuZGF0YSk7Zy5ydW5uaW5nPWIuc2l6ZSgpPT09MD9hLnNpemUoKTpiLnNpemUoKTtpZihlLmFuaW1hdGVkKXtkPXt9O2Q9ZS5jb2xsYXBzaWJsZSYmaD97dG9TaG93OmMoW10pLHRvSGlkZTpiLGNvbXBsZXRlOmosZG93bjpmLGF1dG9IZWlnaHQ6ZS5hdXRvSGVpZ2h0fHxlLmZpbGxTcGFjZX06e3RvU2hvdzphLHRvSGlkZTpiLGNvbXBsZXRlOmosZG93bjpmLGF1dG9IZWlnaHQ6ZS5hdXRvSGVpZ2h0fHxcclxuZS5maWxsU3BhY2V9O2lmKCFlLnByb3hpZWQpZS5wcm94aWVkPWUuYW5pbWF0ZWQ7aWYoIWUucHJveGllZER1cmF0aW9uKWUucHJveGllZER1cmF0aW9uPWUuZHVyYXRpb247ZS5hbmltYXRlZD1jLmlzRnVuY3Rpb24oZS5wcm94aWVkKT9lLnByb3hpZWQoZCk6ZS5wcm94aWVkO2UuZHVyYXRpb249Yy5pc0Z1bmN0aW9uKGUucHJveGllZER1cmF0aW9uKT9lLnByb3hpZWREdXJhdGlvbihkKTplLnByb3hpZWREdXJhdGlvbjtoPWMudWkuYWNjb3JkaW9uLmFuaW1hdGlvbnM7dmFyIGk9ZS5kdXJhdGlvbixrPWUuYW5pbWF0ZWQ7aWYoayYmIWhba10mJiFjLmVhc2luZ1trXSlrPVwic2xpZGVcIjtoW2tdfHwoaFtrXT1mdW5jdGlvbihsKXt0aGlzLnNsaWRlKGwse2Vhc2luZzprLGR1cmF0aW9uOml8fDcwMH0pfSk7aFtrXShkKX1lbHNle2lmKGUuY29sbGFwc2libGUmJmgpYS50b2dnbGUoKTtlbHNle2IuaGlkZSgpO2Euc2hvdygpfWoodHJ1ZSl9Yi5wcmV2KCkuYXR0cih7XCJhcmlhLWV4cGFuZGVkXCI6XCJmYWxzZVwiLFxyXG5cImFyaWEtc2VsZWN0ZWRcIjpcImZhbHNlXCIsdGFiSW5kZXg6LTF9KS5ibHVyKCk7YS5wcmV2KCkuYXR0cih7XCJhcmlhLWV4cGFuZGVkXCI6XCJ0cnVlXCIsXCJhcmlhLXNlbGVjdGVkXCI6XCJ0cnVlXCIsdGFiSW5kZXg6MH0pLmZvY3VzKCl9LF9jb21wbGV0ZWQ6ZnVuY3Rpb24oYSl7dGhpcy5ydW5uaW5nPWE/MDotLXRoaXMucnVubmluZztpZighdGhpcy5ydW5uaW5nKXt0aGlzLm9wdGlvbnMuY2xlYXJTdHlsZSYmdGhpcy50b1Nob3cuYWRkKHRoaXMudG9IaWRlKS5jc3Moe2hlaWdodDpcIlwiLG92ZXJmbG93OlwiXCJ9KTt0aGlzLnRvSGlkZS5yZW1vdmVDbGFzcyhcInVpLWFjY29yZGlvbi1jb250ZW50LWFjdGl2ZVwiKTtpZih0aGlzLnRvSGlkZS5sZW5ndGgpdGhpcy50b0hpZGUucGFyZW50KClbMF0uY2xhc3NOYW1lPXRoaXMudG9IaWRlLnBhcmVudCgpWzBdLmNsYXNzTmFtZTt0aGlzLl90cmlnZ2VyKFwiY2hhbmdlXCIsbnVsbCx0aGlzLmRhdGEpfX19KTtjLmV4dGVuZChjLnVpLmFjY29yZGlvbix7dmVyc2lvbjpcIjEuOC4xNlwiLFxyXG5hbmltYXRpb25zOntzbGlkZTpmdW5jdGlvbihhLGIpe2E9Yy5leHRlbmQoe2Vhc2luZzpcInN3aW5nXCIsZHVyYXRpb246MzAwfSxhLGIpO2lmKGEudG9IaWRlLnNpemUoKSlpZihhLnRvU2hvdy5zaXplKCkpe3ZhciBkPWEudG9TaG93LmNzcyhcIm92ZXJmbG93XCIpLGg9MCxmPXt9LGc9e30sZTtiPWEudG9TaG93O2U9YlswXS5zdHlsZS53aWR0aDtiLndpZHRoKHBhcnNlSW50KGIucGFyZW50KCkud2lkdGgoKSwxMCktcGFyc2VJbnQoYi5jc3MoXCJwYWRkaW5nTGVmdFwiKSwxMCktcGFyc2VJbnQoYi5jc3MoXCJwYWRkaW5nUmlnaHRcIiksMTApLShwYXJzZUludChiLmNzcyhcImJvcmRlckxlZnRXaWR0aFwiKSwxMCl8fDApLShwYXJzZUludChiLmNzcyhcImJvcmRlclJpZ2h0V2lkdGhcIiksMTApfHwwKSk7Yy5lYWNoKFtcImhlaWdodFwiLFwicGFkZGluZ1RvcFwiLFwicGFkZGluZ0JvdHRvbVwiXSxmdW5jdGlvbihqLGkpe2dbaV09XCJoaWRlXCI7aj0oXCJcIitjLmNzcyhhLnRvU2hvd1swXSxpKSkubWF0Y2goL14oW1xcZCstLl0rKSguKikkLyk7XHJcbmZbaV09e3ZhbHVlOmpbMV0sdW5pdDpqWzJdfHxcInB4XCJ9fSk7YS50b1Nob3cuY3NzKHtoZWlnaHQ6MCxvdmVyZmxvdzpcImhpZGRlblwifSkuc2hvdygpO2EudG9IaWRlLmZpbHRlcihcIjpoaWRkZW5cIikuZWFjaChhLmNvbXBsZXRlKS5lbmQoKS5maWx0ZXIoXCI6dmlzaWJsZVwiKS5hbmltYXRlKGcse3N0ZXA6ZnVuY3Rpb24oaixpKXtpZihpLnByb3A9PVwiaGVpZ2h0XCIpaD1pLmVuZC1pLnN0YXJ0PT09MD8wOihpLm5vdy1pLnN0YXJ0KS8oaS5lbmQtaS5zdGFydCk7YS50b1Nob3dbMF0uc3R5bGVbaS5wcm9wXT1oKmZbaS5wcm9wXS52YWx1ZStmW2kucHJvcF0udW5pdH0sZHVyYXRpb246YS5kdXJhdGlvbixlYXNpbmc6YS5lYXNpbmcsY29tcGxldGU6ZnVuY3Rpb24oKXthLmF1dG9IZWlnaHR8fGEudG9TaG93LmNzcyhcImhlaWdodFwiLFwiXCIpO2EudG9TaG93LmNzcyh7d2lkdGg6ZSxvdmVyZmxvdzpkfSk7YS5jb21wbGV0ZSgpfX0pfWVsc2UgYS50b0hpZGUuYW5pbWF0ZSh7aGVpZ2h0OlwiaGlkZVwiLFxyXG5wYWRkaW5nVG9wOlwiaGlkZVwiLHBhZGRpbmdCb3R0b206XCJoaWRlXCJ9LGEpO2Vsc2UgYS50b1Nob3cuYW5pbWF0ZSh7aGVpZ2h0Olwic2hvd1wiLHBhZGRpbmdUb3A6XCJzaG93XCIscGFkZGluZ0JvdHRvbTpcInNob3dcIn0sYSl9LGJvdW5jZXNsaWRlOmZ1bmN0aW9uKGEpe3RoaXMuc2xpZGUoYSx7ZWFzaW5nOmEuZG93bj9cImVhc2VPdXRCb3VuY2VcIjpcInN3aW5nXCIsZHVyYXRpb246YS5kb3duPzFFMzoyMDB9KX19fSl9KShqUXVlcnkpO1xyXG47LypcclxuICogalF1ZXJ5IFVJIEF1dG9jb21wbGV0ZSAxLjguMTZcclxuICpcclxuICogQ29weXJpZ2h0IDIwMTEsIEFVVEhPUlMudHh0IChodHRwOi8vanF1ZXJ5dWkuY29tL2Fib3V0KVxyXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgb3IgR1BMIFZlcnNpb24gMiBsaWNlbnNlcy5cclxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxyXG4gKlxyXG4gKiBodHRwOi8vZG9jcy5qcXVlcnkuY29tL1VJL0F1dG9jb21wbGV0ZVxyXG4gKlxyXG4gKiBEZXBlbmRzOlxyXG4gKlx0anF1ZXJ5LnVpLmNvcmUuanNcclxuICpcdGpxdWVyeS51aS53aWRnZXQuanNcclxuICpcdGpxdWVyeS51aS5wb3NpdGlvbi5qc1xyXG4gKi9cclxuKGZ1bmN0aW9uKGQpe3ZhciBlPTA7ZC53aWRnZXQoXCJ1aS5hdXRvY29tcGxldGVcIix7b3B0aW9uczp7YXBwZW5kVG86XCJib2R5XCIsYXV0b0ZvY3VzOmZhbHNlLGRlbGF5OjMwMCxtaW5MZW5ndGg6MSxwb3NpdGlvbjp7bXk6XCJsZWZ0IHRvcFwiLGF0OlwibGVmdCBib3R0b21cIixjb2xsaXNpb246XCJub25lXCJ9LHNvdXJjZTpudWxsfSxwZW5kaW5nOjAsX2NyZWF0ZTpmdW5jdGlvbigpe3ZhciBhPXRoaXMsYj10aGlzLmVsZW1lbnRbMF0ub3duZXJEb2N1bWVudCxnO3RoaXMuZWxlbWVudC5hZGRDbGFzcyhcInVpLWF1dG9jb21wbGV0ZS1pbnB1dFwiKS5hdHRyKFwiYXV0b2NvbXBsZXRlXCIsXCJvZmZcIikuYXR0cih7cm9sZTpcInRleHRib3hcIixcImFyaWEtYXV0b2NvbXBsZXRlXCI6XCJsaXN0XCIsXCJhcmlhLWhhc3BvcHVwXCI6XCJ0cnVlXCJ9KS5iaW5kKFwia2V5ZG93bi5hdXRvY29tcGxldGVcIixmdW5jdGlvbihjKXtpZighKGEub3B0aW9ucy5kaXNhYmxlZHx8YS5lbGVtZW50LnByb3BBdHRyKFwicmVhZE9ubHlcIikpKXtnPVxyXG5mYWxzZTt2YXIgZj1kLnVpLmtleUNvZGU7c3dpdGNoKGMua2V5Q29kZSl7Y2FzZSBmLlBBR0VfVVA6YS5fbW92ZShcInByZXZpb3VzUGFnZVwiLGMpO2JyZWFrO2Nhc2UgZi5QQUdFX0RPV046YS5fbW92ZShcIm5leHRQYWdlXCIsYyk7YnJlYWs7Y2FzZSBmLlVQOmEuX21vdmUoXCJwcmV2aW91c1wiLGMpO2MucHJldmVudERlZmF1bHQoKTticmVhaztjYXNlIGYuRE9XTjphLl9tb3ZlKFwibmV4dFwiLGMpO2MucHJldmVudERlZmF1bHQoKTticmVhaztjYXNlIGYuRU5URVI6Y2FzZSBmLk5VTVBBRF9FTlRFUjppZihhLm1lbnUuYWN0aXZlKXtnPXRydWU7Yy5wcmV2ZW50RGVmYXVsdCgpfWNhc2UgZi5UQUI6aWYoIWEubWVudS5hY3RpdmUpcmV0dXJuO2EubWVudS5zZWxlY3QoYyk7YnJlYWs7Y2FzZSBmLkVTQ0FQRTphLmVsZW1lbnQudmFsKGEudGVybSk7YS5jbG9zZShjKTticmVhaztkZWZhdWx0OmNsZWFyVGltZW91dChhLnNlYXJjaGluZyk7YS5zZWFyY2hpbmc9c2V0VGltZW91dChmdW5jdGlvbigpe2lmKGEudGVybSE9XHJcbmEuZWxlbWVudC52YWwoKSl7YS5zZWxlY3RlZEl0ZW09bnVsbDthLnNlYXJjaChudWxsLGMpfX0sYS5vcHRpb25zLmRlbGF5KTticmVha319fSkuYmluZChcImtleXByZXNzLmF1dG9jb21wbGV0ZVwiLGZ1bmN0aW9uKGMpe2lmKGcpe2c9ZmFsc2U7Yy5wcmV2ZW50RGVmYXVsdCgpfX0pLmJpbmQoXCJmb2N1cy5hdXRvY29tcGxldGVcIixmdW5jdGlvbigpe2lmKCFhLm9wdGlvbnMuZGlzYWJsZWQpe2Euc2VsZWN0ZWRJdGVtPW51bGw7YS5wcmV2aW91cz1hLmVsZW1lbnQudmFsKCl9fSkuYmluZChcImJsdXIuYXV0b2NvbXBsZXRlXCIsZnVuY3Rpb24oYyl7aWYoIWEub3B0aW9ucy5kaXNhYmxlZCl7Y2xlYXJUaW1lb3V0KGEuc2VhcmNoaW5nKTthLmNsb3Npbmc9c2V0VGltZW91dChmdW5jdGlvbigpe2EuY2xvc2UoYyk7YS5fY2hhbmdlKGMpfSwxNTApfX0pO3RoaXMuX2luaXRTb3VyY2UoKTt0aGlzLnJlc3BvbnNlPWZ1bmN0aW9uKCl7cmV0dXJuIGEuX3Jlc3BvbnNlLmFwcGx5KGEsYXJndW1lbnRzKX07XHJcbnRoaXMubWVudT1kKFwiPHVsPjwvdWw+XCIpLmFkZENsYXNzKFwidWktYXV0b2NvbXBsZXRlXCIpLmFwcGVuZFRvKGQodGhpcy5vcHRpb25zLmFwcGVuZFRvfHxcImJvZHlcIixiKVswXSkubW91c2Vkb3duKGZ1bmN0aW9uKGMpe3ZhciBmPWEubWVudS5lbGVtZW50WzBdO2QoYy50YXJnZXQpLmNsb3Nlc3QoXCIudWktbWVudS1pdGVtXCIpLmxlbmd0aHx8c2V0VGltZW91dChmdW5jdGlvbigpe2QoZG9jdW1lbnQpLm9uZShcIm1vdXNlZG93blwiLGZ1bmN0aW9uKGgpe2gudGFyZ2V0IT09YS5lbGVtZW50WzBdJiZoLnRhcmdldCE9PWYmJiFkLnVpLmNvbnRhaW5zKGYsaC50YXJnZXQpJiZhLmNsb3NlKCl9KX0sMSk7c2V0VGltZW91dChmdW5jdGlvbigpe2NsZWFyVGltZW91dChhLmNsb3NpbmcpfSwxMyl9KS5tZW51KHtmb2N1czpmdW5jdGlvbihjLGYpe2Y9Zi5pdGVtLmRhdGEoXCJpdGVtLmF1dG9jb21wbGV0ZVwiKTtmYWxzZSE9PWEuX3RyaWdnZXIoXCJmb2N1c1wiLGMse2l0ZW06Zn0pJiYvXmtleS8udGVzdChjLm9yaWdpbmFsRXZlbnQudHlwZSkmJlxyXG5hLmVsZW1lbnQudmFsKGYudmFsdWUpfSxzZWxlY3RlZDpmdW5jdGlvbihjLGYpe3ZhciBoPWYuaXRlbS5kYXRhKFwiaXRlbS5hdXRvY29tcGxldGVcIiksaT1hLnByZXZpb3VzO2lmKGEuZWxlbWVudFswXSE9PWIuYWN0aXZlRWxlbWVudCl7YS5lbGVtZW50LmZvY3VzKCk7YS5wcmV2aW91cz1pO3NldFRpbWVvdXQoZnVuY3Rpb24oKXthLnByZXZpb3VzPWk7YS5zZWxlY3RlZEl0ZW09aH0sMSl9ZmFsc2UhPT1hLl90cmlnZ2VyKFwic2VsZWN0XCIsYyx7aXRlbTpofSkmJmEuZWxlbWVudC52YWwoaC52YWx1ZSk7YS50ZXJtPWEuZWxlbWVudC52YWwoKTthLmNsb3NlKGMpO2Euc2VsZWN0ZWRJdGVtPWh9LGJsdXI6ZnVuY3Rpb24oKXthLm1lbnUuZWxlbWVudC5pcyhcIjp2aXNpYmxlXCIpJiZhLmVsZW1lbnQudmFsKCkhPT1hLnRlcm0mJmEuZWxlbWVudC52YWwoYS50ZXJtKX19KS56SW5kZXgodGhpcy5lbGVtZW50LnpJbmRleCgpKzEpLmNzcyh7dG9wOjAsbGVmdDowfSkuaGlkZSgpLmRhdGEoXCJtZW51XCIpO1xyXG5kLmZuLmJnaWZyYW1lJiZ0aGlzLm1lbnUuZWxlbWVudC5iZ2lmcmFtZSgpfSxkZXN0cm95OmZ1bmN0aW9uKCl7dGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKFwidWktYXV0b2NvbXBsZXRlLWlucHV0XCIpLnJlbW92ZUF0dHIoXCJhdXRvY29tcGxldGVcIikucmVtb3ZlQXR0cihcInJvbGVcIikucmVtb3ZlQXR0cihcImFyaWEtYXV0b2NvbXBsZXRlXCIpLnJlbW92ZUF0dHIoXCJhcmlhLWhhc3BvcHVwXCIpO3RoaXMubWVudS5lbGVtZW50LnJlbW92ZSgpO2QuV2lkZ2V0LnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyl9LF9zZXRPcHRpb246ZnVuY3Rpb24oYSxiKXtkLldpZGdldC5wcm90b3R5cGUuX3NldE9wdGlvbi5hcHBseSh0aGlzLGFyZ3VtZW50cyk7YT09PVwic291cmNlXCImJnRoaXMuX2luaXRTb3VyY2UoKTtpZihhPT09XCJhcHBlbmRUb1wiKXRoaXMubWVudS5lbGVtZW50LmFwcGVuZFRvKGQoYnx8XCJib2R5XCIsdGhpcy5lbGVtZW50WzBdLm93bmVyRG9jdW1lbnQpWzBdKTthPT09XCJkaXNhYmxlZFwiJiZcclxuYiYmdGhpcy54aHImJnRoaXMueGhyLmFib3J0KCl9LF9pbml0U291cmNlOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiLGc7aWYoZC5pc0FycmF5KHRoaXMub3B0aW9ucy5zb3VyY2UpKXtiPXRoaXMub3B0aW9ucy5zb3VyY2U7dGhpcy5zb3VyY2U9ZnVuY3Rpb24oYyxmKXtmKGQudWkuYXV0b2NvbXBsZXRlLmZpbHRlcihiLGMudGVybSkpfX1lbHNlIGlmKHR5cGVvZiB0aGlzLm9wdGlvbnMuc291cmNlPT09XCJzdHJpbmdcIil7Zz10aGlzLm9wdGlvbnMuc291cmNlO3RoaXMuc291cmNlPWZ1bmN0aW9uKGMsZil7YS54aHImJmEueGhyLmFib3J0KCk7YS54aHI9ZC5hamF4KHt1cmw6ZyxkYXRhOmMsZGF0YVR5cGU6XCJqc29uXCIsYXV0b2NvbXBsZXRlUmVxdWVzdDorK2Usc3VjY2VzczpmdW5jdGlvbihoKXt0aGlzLmF1dG9jb21wbGV0ZVJlcXVlc3Q9PT1lJiZmKGgpfSxlcnJvcjpmdW5jdGlvbigpe3RoaXMuYXV0b2NvbXBsZXRlUmVxdWVzdD09PWUmJmYoW10pfX0pfX1lbHNlIHRoaXMuc291cmNlPVxyXG50aGlzLm9wdGlvbnMuc291cmNlfSxzZWFyY2g6ZnVuY3Rpb24oYSxiKXthPWEhPW51bGw/YTp0aGlzLmVsZW1lbnQudmFsKCk7dGhpcy50ZXJtPXRoaXMuZWxlbWVudC52YWwoKTtpZihhLmxlbmd0aDx0aGlzLm9wdGlvbnMubWluTGVuZ3RoKXJldHVybiB0aGlzLmNsb3NlKGIpO2NsZWFyVGltZW91dCh0aGlzLmNsb3NpbmcpO2lmKHRoaXMuX3RyaWdnZXIoXCJzZWFyY2hcIixiKSE9PWZhbHNlKXJldHVybiB0aGlzLl9zZWFyY2goYSl9LF9zZWFyY2g6ZnVuY3Rpb24oYSl7dGhpcy5wZW5kaW5nKys7dGhpcy5lbGVtZW50LmFkZENsYXNzKFwidWktYXV0b2NvbXBsZXRlLWxvYWRpbmdcIik7dGhpcy5zb3VyY2Uoe3Rlcm06YX0sdGhpcy5yZXNwb25zZSl9LF9yZXNwb25zZTpmdW5jdGlvbihhKXtpZighdGhpcy5vcHRpb25zLmRpc2FibGVkJiZhJiZhLmxlbmd0aCl7YT10aGlzLl9ub3JtYWxpemUoYSk7dGhpcy5fc3VnZ2VzdChhKTt0aGlzLl90cmlnZ2VyKFwib3BlblwiKX1lbHNlIHRoaXMuY2xvc2UoKTtcclxudGhpcy5wZW5kaW5nLS07dGhpcy5wZW5kaW5nfHx0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoXCJ1aS1hdXRvY29tcGxldGUtbG9hZGluZ1wiKX0sY2xvc2U6ZnVuY3Rpb24oYSl7Y2xlYXJUaW1lb3V0KHRoaXMuY2xvc2luZyk7aWYodGhpcy5tZW51LmVsZW1lbnQuaXMoXCI6dmlzaWJsZVwiKSl7dGhpcy5tZW51LmVsZW1lbnQuaGlkZSgpO3RoaXMubWVudS5kZWFjdGl2YXRlKCk7dGhpcy5fdHJpZ2dlcihcImNsb3NlXCIsYSl9fSxfY2hhbmdlOmZ1bmN0aW9uKGEpe3RoaXMucHJldmlvdXMhPT10aGlzLmVsZW1lbnQudmFsKCkmJnRoaXMuX3RyaWdnZXIoXCJjaGFuZ2VcIixhLHtpdGVtOnRoaXMuc2VsZWN0ZWRJdGVtfSl9LF9ub3JtYWxpemU6ZnVuY3Rpb24oYSl7aWYoYS5sZW5ndGgmJmFbMF0ubGFiZWwmJmFbMF0udmFsdWUpcmV0dXJuIGE7cmV0dXJuIGQubWFwKGEsZnVuY3Rpb24oYil7aWYodHlwZW9mIGI9PT1cInN0cmluZ1wiKXJldHVybntsYWJlbDpiLHZhbHVlOmJ9O3JldHVybiBkLmV4dGVuZCh7bGFiZWw6Yi5sYWJlbHx8XHJcbmIudmFsdWUsdmFsdWU6Yi52YWx1ZXx8Yi5sYWJlbH0sYil9KX0sX3N1Z2dlc3Q6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5tZW51LmVsZW1lbnQuZW1wdHkoKS56SW5kZXgodGhpcy5lbGVtZW50LnpJbmRleCgpKzEpO3RoaXMuX3JlbmRlck1lbnUoYixhKTt0aGlzLm1lbnUuZGVhY3RpdmF0ZSgpO3RoaXMubWVudS5yZWZyZXNoKCk7Yi5zaG93KCk7dGhpcy5fcmVzaXplTWVudSgpO2IucG9zaXRpb24oZC5leHRlbmQoe29mOnRoaXMuZWxlbWVudH0sdGhpcy5vcHRpb25zLnBvc2l0aW9uKSk7dGhpcy5vcHRpb25zLmF1dG9Gb2N1cyYmdGhpcy5tZW51Lm5leHQobmV3IGQuRXZlbnQoXCJtb3VzZW92ZXJcIikpfSxfcmVzaXplTWVudTpmdW5jdGlvbigpe3ZhciBhPXRoaXMubWVudS5lbGVtZW50O2Eub3V0ZXJXaWR0aChNYXRoLm1heChhLndpZHRoKFwiXCIpLm91dGVyV2lkdGgoKSx0aGlzLmVsZW1lbnQub3V0ZXJXaWR0aCgpKSl9LF9yZW5kZXJNZW51OmZ1bmN0aW9uKGEsYil7dmFyIGc9dGhpcztcclxuZC5lYWNoKGIsZnVuY3Rpb24oYyxmKXtnLl9yZW5kZXJJdGVtKGEsZil9KX0sX3JlbmRlckl0ZW06ZnVuY3Rpb24oYSxiKXtyZXR1cm4gZChcIjxsaT48L2xpPlwiKS5kYXRhKFwiaXRlbS5hdXRvY29tcGxldGVcIixiKS5hcHBlbmQoZChcIjxhPjwvYT5cIikudGV4dChiLmxhYmVsKSkuYXBwZW5kVG8oYSl9LF9tb3ZlOmZ1bmN0aW9uKGEsYil7aWYodGhpcy5tZW51LmVsZW1lbnQuaXMoXCI6dmlzaWJsZVwiKSlpZih0aGlzLm1lbnUuZmlyc3QoKSYmL15wcmV2aW91cy8udGVzdChhKXx8dGhpcy5tZW51Lmxhc3QoKSYmL15uZXh0Ly50ZXN0KGEpKXt0aGlzLmVsZW1lbnQudmFsKHRoaXMudGVybSk7dGhpcy5tZW51LmRlYWN0aXZhdGUoKX1lbHNlIHRoaXMubWVudVthXShiKTtlbHNlIHRoaXMuc2VhcmNoKG51bGwsYil9LHdpZGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1lbnUuZWxlbWVudH19KTtkLmV4dGVuZChkLnVpLmF1dG9jb21wbGV0ZSx7ZXNjYXBlUmVnZXg6ZnVuY3Rpb24oYSl7cmV0dXJuIGEucmVwbGFjZSgvWy1bXFxde30oKSorPy4sXFxcXF4kfCNcXHNdL2csXHJcblwiXFxcXCQmXCIpfSxmaWx0ZXI6ZnVuY3Rpb24oYSxiKXt2YXIgZz1uZXcgUmVnRXhwKGQudWkuYXV0b2NvbXBsZXRlLmVzY2FwZVJlZ2V4KGIpLFwiaVwiKTtyZXR1cm4gZC5ncmVwKGEsZnVuY3Rpb24oYyl7cmV0dXJuIGcudGVzdChjLmxhYmVsfHxjLnZhbHVlfHxjKX0pfX0pfSkoalF1ZXJ5KTtcclxuKGZ1bmN0aW9uKGQpe2Qud2lkZ2V0KFwidWkubWVudVwiLHtfY3JlYXRlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpczt0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoXCJ1aS1tZW51IHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsXCIpLmF0dHIoe3JvbGU6XCJsaXN0Ym94XCIsXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIjpcInVpLWFjdGl2ZS1tZW51aXRlbVwifSkuY2xpY2soZnVuY3Rpb24oYSl7aWYoZChhLnRhcmdldCkuY2xvc2VzdChcIi51aS1tZW51LWl0ZW0gYVwiKS5sZW5ndGgpe2EucHJldmVudERlZmF1bHQoKTtlLnNlbGVjdChhKX19KTt0aGlzLnJlZnJlc2goKX0scmVmcmVzaDpmdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy5lbGVtZW50LmNoaWxkcmVuKFwibGk6bm90KC51aS1tZW51LWl0ZW0pOmhhcyhhKVwiKS5hZGRDbGFzcyhcInVpLW1lbnUtaXRlbVwiKS5hdHRyKFwicm9sZVwiLFwibWVudWl0ZW1cIikuY2hpbGRyZW4oXCJhXCIpLmFkZENsYXNzKFwidWktY29ybmVyLWFsbFwiKS5hdHRyKFwidGFiaW5kZXhcIixcclxuLTEpLm1vdXNlZW50ZXIoZnVuY3Rpb24oYSl7ZS5hY3RpdmF0ZShhLGQodGhpcykucGFyZW50KCkpfSkubW91c2VsZWF2ZShmdW5jdGlvbigpe2UuZGVhY3RpdmF0ZSgpfSl9LGFjdGl2YXRlOmZ1bmN0aW9uKGUsYSl7dGhpcy5kZWFjdGl2YXRlKCk7aWYodGhpcy5oYXNTY3JvbGwoKSl7dmFyIGI9YS5vZmZzZXQoKS50b3AtdGhpcy5lbGVtZW50Lm9mZnNldCgpLnRvcCxnPXRoaXMuZWxlbWVudC5zY3JvbGxUb3AoKSxjPXRoaXMuZWxlbWVudC5oZWlnaHQoKTtpZihiPDApdGhpcy5lbGVtZW50LnNjcm9sbFRvcChnK2IpO2Vsc2UgYj49YyYmdGhpcy5lbGVtZW50LnNjcm9sbFRvcChnK2ItYythLmhlaWdodCgpKX10aGlzLmFjdGl2ZT1hLmVxKDApLmNoaWxkcmVuKFwiYVwiKS5hZGRDbGFzcyhcInVpLXN0YXRlLWhvdmVyXCIpLmF0dHIoXCJpZFwiLFwidWktYWN0aXZlLW1lbnVpdGVtXCIpLmVuZCgpO3RoaXMuX3RyaWdnZXIoXCJmb2N1c1wiLGUse2l0ZW06YX0pfSxkZWFjdGl2YXRlOmZ1bmN0aW9uKCl7aWYodGhpcy5hY3RpdmUpe3RoaXMuYWN0aXZlLmNoaWxkcmVuKFwiYVwiKS5yZW1vdmVDbGFzcyhcInVpLXN0YXRlLWhvdmVyXCIpLnJlbW92ZUF0dHIoXCJpZFwiKTtcclxudGhpcy5fdHJpZ2dlcihcImJsdXJcIik7dGhpcy5hY3RpdmU9bnVsbH19LG5leHQ6ZnVuY3Rpb24oZSl7dGhpcy5tb3ZlKFwibmV4dFwiLFwiLnVpLW1lbnUtaXRlbTpmaXJzdFwiLGUpfSxwcmV2aW91czpmdW5jdGlvbihlKXt0aGlzLm1vdmUoXCJwcmV2XCIsXCIudWktbWVudS1pdGVtOmxhc3RcIixlKX0sZmlyc3Q6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hY3RpdmUmJiF0aGlzLmFjdGl2ZS5wcmV2QWxsKFwiLnVpLW1lbnUtaXRlbVwiKS5sZW5ndGh9LGxhc3Q6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hY3RpdmUmJiF0aGlzLmFjdGl2ZS5uZXh0QWxsKFwiLnVpLW1lbnUtaXRlbVwiKS5sZW5ndGh9LG1vdmU6ZnVuY3Rpb24oZSxhLGIpe2lmKHRoaXMuYWN0aXZlKXtlPXRoaXMuYWN0aXZlW2UrXCJBbGxcIl0oXCIudWktbWVudS1pdGVtXCIpLmVxKDApO2UubGVuZ3RoP3RoaXMuYWN0aXZhdGUoYixlKTp0aGlzLmFjdGl2YXRlKGIsdGhpcy5lbGVtZW50LmNoaWxkcmVuKGEpKX1lbHNlIHRoaXMuYWN0aXZhdGUoYixcclxudGhpcy5lbGVtZW50LmNoaWxkcmVuKGEpKX0sbmV4dFBhZ2U6ZnVuY3Rpb24oZSl7aWYodGhpcy5oYXNTY3JvbGwoKSlpZighdGhpcy5hY3RpdmV8fHRoaXMubGFzdCgpKXRoaXMuYWN0aXZhdGUoZSx0aGlzLmVsZW1lbnQuY2hpbGRyZW4oXCIudWktbWVudS1pdGVtOmZpcnN0XCIpKTtlbHNle3ZhciBhPXRoaXMuYWN0aXZlLm9mZnNldCgpLnRvcCxiPXRoaXMuZWxlbWVudC5oZWlnaHQoKSxnPXRoaXMuZWxlbWVudC5jaGlsZHJlbihcIi51aS1tZW51LWl0ZW1cIikuZmlsdGVyKGZ1bmN0aW9uKCl7dmFyIGM9ZCh0aGlzKS5vZmZzZXQoKS50b3AtYS1iK2QodGhpcykuaGVpZ2h0KCk7cmV0dXJuIGM8MTAmJmM+LTEwfSk7Zy5sZW5ndGh8fChnPXRoaXMuZWxlbWVudC5jaGlsZHJlbihcIi51aS1tZW51LWl0ZW06bGFzdFwiKSk7dGhpcy5hY3RpdmF0ZShlLGcpfWVsc2UgdGhpcy5hY3RpdmF0ZShlLHRoaXMuZWxlbWVudC5jaGlsZHJlbihcIi51aS1tZW51LWl0ZW1cIikuZmlsdGVyKCF0aGlzLmFjdGl2ZXx8XHJcbnRoaXMubGFzdCgpP1wiOmZpcnN0XCI6XCI6bGFzdFwiKSl9LHByZXZpb3VzUGFnZTpmdW5jdGlvbihlKXtpZih0aGlzLmhhc1Njcm9sbCgpKWlmKCF0aGlzLmFjdGl2ZXx8dGhpcy5maXJzdCgpKXRoaXMuYWN0aXZhdGUoZSx0aGlzLmVsZW1lbnQuY2hpbGRyZW4oXCIudWktbWVudS1pdGVtOmxhc3RcIikpO2Vsc2V7dmFyIGE9dGhpcy5hY3RpdmUub2Zmc2V0KCkudG9wLGI9dGhpcy5lbGVtZW50LmhlaWdodCgpO3Jlc3VsdD10aGlzLmVsZW1lbnQuY2hpbGRyZW4oXCIudWktbWVudS1pdGVtXCIpLmZpbHRlcihmdW5jdGlvbigpe3ZhciBnPWQodGhpcykub2Zmc2V0KCkudG9wLWErYi1kKHRoaXMpLmhlaWdodCgpO3JldHVybiBnPDEwJiZnPi0xMH0pO3Jlc3VsdC5sZW5ndGh8fChyZXN1bHQ9dGhpcy5lbGVtZW50LmNoaWxkcmVuKFwiLnVpLW1lbnUtaXRlbTpmaXJzdFwiKSk7dGhpcy5hY3RpdmF0ZShlLHJlc3VsdCl9ZWxzZSB0aGlzLmFjdGl2YXRlKGUsdGhpcy5lbGVtZW50LmNoaWxkcmVuKFwiLnVpLW1lbnUtaXRlbVwiKS5maWx0ZXIoIXRoaXMuYWN0aXZlfHxcclxudGhpcy5maXJzdCgpP1wiOmxhc3RcIjpcIjpmaXJzdFwiKSl9LGhhc1Njcm9sbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVsZW1lbnQuaGVpZ2h0KCk8dGhpcy5lbGVtZW50W2QuZm4ucHJvcD9cInByb3BcIjpcImF0dHJcIl0oXCJzY3JvbGxIZWlnaHRcIil9LHNlbGVjdDpmdW5jdGlvbihlKXt0aGlzLl90cmlnZ2VyKFwic2VsZWN0ZWRcIixlLHtpdGVtOnRoaXMuYWN0aXZlfSl9fSl9KShqUXVlcnkpO1xyXG47LypcclxuICogalF1ZXJ5IFVJIEJ1dHRvbiAxLjguMTZcclxuICpcclxuICogQ29weXJpZ2h0IDIwMTEsIEFVVEhPUlMudHh0IChodHRwOi8vanF1ZXJ5dWkuY29tL2Fib3V0KVxyXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgb3IgR1BMIFZlcnNpb24gMiBsaWNlbnNlcy5cclxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxyXG4gKlxyXG4gKiBodHRwOi8vZG9jcy5qcXVlcnkuY29tL1VJL0J1dHRvblxyXG4gKlxyXG4gKiBEZXBlbmRzOlxyXG4gKlx0anF1ZXJ5LnVpLmNvcmUuanNcclxuICpcdGpxdWVyeS51aS53aWRnZXQuanNcclxuICovXHJcbihmdW5jdGlvbihiKXt2YXIgaCxpLGosZyxsPWZ1bmN0aW9uKCl7dmFyIGE9Yih0aGlzKS5maW5kKFwiOnVpLWJ1dHRvblwiKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YS5idXR0b24oXCJyZWZyZXNoXCIpfSwxKX0saz1mdW5jdGlvbihhKXt2YXIgYz1hLm5hbWUsZT1hLmZvcm0sZj1iKFtdKTtpZihjKWY9ZT9iKGUpLmZpbmQoXCJbbmFtZT0nXCIrYytcIiddXCIpOmIoXCJbbmFtZT0nXCIrYytcIiddXCIsYS5vd25lckRvY3VtZW50KS5maWx0ZXIoZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5mb3JtfSk7cmV0dXJuIGZ9O2Iud2lkZ2V0KFwidWkuYnV0dG9uXCIse29wdGlvbnM6e2Rpc2FibGVkOm51bGwsdGV4dDp0cnVlLGxhYmVsOm51bGwsaWNvbnM6e3ByaW1hcnk6bnVsbCxzZWNvbmRhcnk6bnVsbH19LF9jcmVhdGU6ZnVuY3Rpb24oKXt0aGlzLmVsZW1lbnQuY2xvc2VzdChcImZvcm1cIikudW5iaW5kKFwicmVzZXQuYnV0dG9uXCIpLmJpbmQoXCJyZXNldC5idXR0b25cIixsKTtpZih0eXBlb2YgdGhpcy5vcHRpb25zLmRpc2FibGVkIT09XHJcblwiYm9vbGVhblwiKXRoaXMub3B0aW9ucy5kaXNhYmxlZD10aGlzLmVsZW1lbnQucHJvcEF0dHIoXCJkaXNhYmxlZFwiKTt0aGlzLl9kZXRlcm1pbmVCdXR0b25UeXBlKCk7dGhpcy5oYXNUaXRsZT0hIXRoaXMuYnV0dG9uRWxlbWVudC5hdHRyKFwidGl0bGVcIik7dmFyIGE9dGhpcyxjPXRoaXMub3B0aW9ucyxlPXRoaXMudHlwZT09PVwiY2hlY2tib3hcInx8dGhpcy50eXBlPT09XCJyYWRpb1wiLGY9XCJ1aS1zdGF0ZS1ob3ZlclwiKyghZT9cIiB1aS1zdGF0ZS1hY3RpdmVcIjpcIlwiKTtpZihjLmxhYmVsPT09bnVsbCljLmxhYmVsPXRoaXMuYnV0dG9uRWxlbWVudC5odG1sKCk7aWYodGhpcy5lbGVtZW50LmlzKFwiOmRpc2FibGVkXCIpKWMuZGlzYWJsZWQ9dHJ1ZTt0aGlzLmJ1dHRvbkVsZW1lbnQuYWRkQ2xhc3MoXCJ1aS1idXR0b24gdWktd2lkZ2V0IHVpLXN0YXRlLWRlZmF1bHQgdWktY29ybmVyLWFsbFwiKS5hdHRyKFwicm9sZVwiLFwiYnV0dG9uXCIpLmJpbmQoXCJtb3VzZWVudGVyLmJ1dHRvblwiLGZ1bmN0aW9uKCl7aWYoIWMuZGlzYWJsZWQpe2IodGhpcykuYWRkQ2xhc3MoXCJ1aS1zdGF0ZS1ob3ZlclwiKTtcclxudGhpcz09PWgmJmIodGhpcykuYWRkQ2xhc3MoXCJ1aS1zdGF0ZS1hY3RpdmVcIil9fSkuYmluZChcIm1vdXNlbGVhdmUuYnV0dG9uXCIsZnVuY3Rpb24oKXtjLmRpc2FibGVkfHxiKHRoaXMpLnJlbW92ZUNsYXNzKGYpfSkuYmluZChcImNsaWNrLmJ1dHRvblwiLGZ1bmN0aW9uKGQpe2lmKGMuZGlzYWJsZWQpe2QucHJldmVudERlZmF1bHQoKTtkLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpfX0pO3RoaXMuZWxlbWVudC5iaW5kKFwiZm9jdXMuYnV0dG9uXCIsZnVuY3Rpb24oKXthLmJ1dHRvbkVsZW1lbnQuYWRkQ2xhc3MoXCJ1aS1zdGF0ZS1mb2N1c1wiKX0pLmJpbmQoXCJibHVyLmJ1dHRvblwiLGZ1bmN0aW9uKCl7YS5idXR0b25FbGVtZW50LnJlbW92ZUNsYXNzKFwidWktc3RhdGUtZm9jdXNcIil9KTtpZihlKXt0aGlzLmVsZW1lbnQuYmluZChcImNoYW5nZS5idXR0b25cIixmdW5jdGlvbigpe2d8fGEucmVmcmVzaCgpfSk7dGhpcy5idXR0b25FbGVtZW50LmJpbmQoXCJtb3VzZWRvd24uYnV0dG9uXCIsZnVuY3Rpb24oZCl7aWYoIWMuZGlzYWJsZWQpe2c9XHJcbmZhbHNlO2k9ZC5wYWdlWDtqPWQucGFnZVl9fSkuYmluZChcIm1vdXNldXAuYnV0dG9uXCIsZnVuY3Rpb24oZCl7aWYoIWMuZGlzYWJsZWQpaWYoaSE9PWQucGFnZVh8fGohPT1kLnBhZ2VZKWc9dHJ1ZX0pfWlmKHRoaXMudHlwZT09PVwiY2hlY2tib3hcIil0aGlzLmJ1dHRvbkVsZW1lbnQuYmluZChcImNsaWNrLmJ1dHRvblwiLGZ1bmN0aW9uKCl7aWYoYy5kaXNhYmxlZHx8ZylyZXR1cm4gZmFsc2U7Yih0aGlzKS50b2dnbGVDbGFzcyhcInVpLXN0YXRlLWFjdGl2ZVwiKTthLmJ1dHRvbkVsZW1lbnQuYXR0cihcImFyaWEtcHJlc3NlZFwiLGEuZWxlbWVudFswXS5jaGVja2VkKX0pO2Vsc2UgaWYodGhpcy50eXBlPT09XCJyYWRpb1wiKXRoaXMuYnV0dG9uRWxlbWVudC5iaW5kKFwiY2xpY2suYnV0dG9uXCIsZnVuY3Rpb24oKXtpZihjLmRpc2FibGVkfHxnKXJldHVybiBmYWxzZTtiKHRoaXMpLmFkZENsYXNzKFwidWktc3RhdGUtYWN0aXZlXCIpO2EuYnV0dG9uRWxlbWVudC5hdHRyKFwiYXJpYS1wcmVzc2VkXCIsXCJ0cnVlXCIpO1xyXG52YXIgZD1hLmVsZW1lbnRbMF07ayhkKS5ub3QoZCkubWFwKGZ1bmN0aW9uKCl7cmV0dXJuIGIodGhpcykuYnV0dG9uKFwid2lkZ2V0XCIpWzBdfSkucmVtb3ZlQ2xhc3MoXCJ1aS1zdGF0ZS1hY3RpdmVcIikuYXR0cihcImFyaWEtcHJlc3NlZFwiLFwiZmFsc2VcIil9KTtlbHNle3RoaXMuYnV0dG9uRWxlbWVudC5iaW5kKFwibW91c2Vkb3duLmJ1dHRvblwiLGZ1bmN0aW9uKCl7aWYoYy5kaXNhYmxlZClyZXR1cm4gZmFsc2U7Yih0aGlzKS5hZGRDbGFzcyhcInVpLXN0YXRlLWFjdGl2ZVwiKTtoPXRoaXM7Yihkb2N1bWVudCkub25lKFwibW91c2V1cFwiLGZ1bmN0aW9uKCl7aD1udWxsfSl9KS5iaW5kKFwibW91c2V1cC5idXR0b25cIixmdW5jdGlvbigpe2lmKGMuZGlzYWJsZWQpcmV0dXJuIGZhbHNlO2IodGhpcykucmVtb3ZlQ2xhc3MoXCJ1aS1zdGF0ZS1hY3RpdmVcIil9KS5iaW5kKFwia2V5ZG93bi5idXR0b25cIixmdW5jdGlvbihkKXtpZihjLmRpc2FibGVkKXJldHVybiBmYWxzZTtpZihkLmtleUNvZGU9PWIudWkua2V5Q29kZS5TUEFDRXx8XHJcbmQua2V5Q29kZT09Yi51aS5rZXlDb2RlLkVOVEVSKWIodGhpcykuYWRkQ2xhc3MoXCJ1aS1zdGF0ZS1hY3RpdmVcIil9KS5iaW5kKFwia2V5dXAuYnV0dG9uXCIsZnVuY3Rpb24oKXtiKHRoaXMpLnJlbW92ZUNsYXNzKFwidWktc3RhdGUtYWN0aXZlXCIpfSk7dGhpcy5idXR0b25FbGVtZW50LmlzKFwiYVwiKSYmdGhpcy5idXR0b25FbGVtZW50LmtleXVwKGZ1bmN0aW9uKGQpe2Qua2V5Q29kZT09PWIudWkua2V5Q29kZS5TUEFDRSYmYih0aGlzKS5jbGljaygpfSl9dGhpcy5fc2V0T3B0aW9uKFwiZGlzYWJsZWRcIixjLmRpc2FibGVkKTt0aGlzLl9yZXNldEJ1dHRvbigpfSxfZGV0ZXJtaW5lQnV0dG9uVHlwZTpmdW5jdGlvbigpe3RoaXMudHlwZT10aGlzLmVsZW1lbnQuaXMoXCI6Y2hlY2tib3hcIik/XCJjaGVja2JveFwiOnRoaXMuZWxlbWVudC5pcyhcIjpyYWRpb1wiKT9cInJhZGlvXCI6dGhpcy5lbGVtZW50LmlzKFwiaW5wdXRcIik/XCJpbnB1dFwiOlwiYnV0dG9uXCI7aWYodGhpcy50eXBlPT09XCJjaGVja2JveFwifHx0aGlzLnR5cGU9PT1cclxuXCJyYWRpb1wiKXt2YXIgYT10aGlzLmVsZW1lbnQucGFyZW50cygpLmZpbHRlcihcIjpsYXN0XCIpLGM9XCJsYWJlbFtmb3I9J1wiK3RoaXMuZWxlbWVudC5hdHRyKFwiaWRcIikrXCInXVwiO3RoaXMuYnV0dG9uRWxlbWVudD1hLmZpbmQoYyk7aWYoIXRoaXMuYnV0dG9uRWxlbWVudC5sZW5ndGgpe2E9YS5sZW5ndGg/YS5zaWJsaW5ncygpOnRoaXMuZWxlbWVudC5zaWJsaW5ncygpO3RoaXMuYnV0dG9uRWxlbWVudD1hLmZpbHRlcihjKTtpZighdGhpcy5idXR0b25FbGVtZW50Lmxlbmd0aCl0aGlzLmJ1dHRvbkVsZW1lbnQ9YS5maW5kKGMpfXRoaXMuZWxlbWVudC5hZGRDbGFzcyhcInVpLWhlbHBlci1oaWRkZW4tYWNjZXNzaWJsZVwiKTsoYT10aGlzLmVsZW1lbnQuaXMoXCI6Y2hlY2tlZFwiKSkmJnRoaXMuYnV0dG9uRWxlbWVudC5hZGRDbGFzcyhcInVpLXN0YXRlLWFjdGl2ZVwiKTt0aGlzLmJ1dHRvbkVsZW1lbnQuYXR0cihcImFyaWEtcHJlc3NlZFwiLGEpfWVsc2UgdGhpcy5idXR0b25FbGVtZW50PXRoaXMuZWxlbWVudH0sXHJcbndpZGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmJ1dHRvbkVsZW1lbnR9LGRlc3Ryb3k6ZnVuY3Rpb24oKXt0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoXCJ1aS1oZWxwZXItaGlkZGVuLWFjY2Vzc2libGVcIik7dGhpcy5idXR0b25FbGVtZW50LnJlbW92ZUNsYXNzKFwidWktYnV0dG9uIHVpLXdpZGdldCB1aS1zdGF0ZS1kZWZhdWx0IHVpLWNvcm5lci1hbGwgdWktc3RhdGUtaG92ZXIgdWktc3RhdGUtYWN0aXZlICB1aS1idXR0b24taWNvbnMtb25seSB1aS1idXR0b24taWNvbi1vbmx5IHVpLWJ1dHRvbi10ZXh0LWljb25zIHVpLWJ1dHRvbi10ZXh0LWljb24tcHJpbWFyeSB1aS1idXR0b24tdGV4dC1pY29uLXNlY29uZGFyeSB1aS1idXR0b24tdGV4dC1vbmx5XCIpLnJlbW92ZUF0dHIoXCJyb2xlXCIpLnJlbW92ZUF0dHIoXCJhcmlhLXByZXNzZWRcIikuaHRtbCh0aGlzLmJ1dHRvbkVsZW1lbnQuZmluZChcIi51aS1idXR0b24tdGV4dFwiKS5odG1sKCkpO3RoaXMuaGFzVGl0bGV8fHRoaXMuYnV0dG9uRWxlbWVudC5yZW1vdmVBdHRyKFwidGl0bGVcIik7XHJcbmIuV2lkZ2V0LnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyl9LF9zZXRPcHRpb246ZnVuY3Rpb24oYSxjKXtiLldpZGdldC5wcm90b3R5cGUuX3NldE9wdGlvbi5hcHBseSh0aGlzLGFyZ3VtZW50cyk7aWYoYT09PVwiZGlzYWJsZWRcIiljP3RoaXMuZWxlbWVudC5wcm9wQXR0cihcImRpc2FibGVkXCIsdHJ1ZSk6dGhpcy5lbGVtZW50LnByb3BBdHRyKFwiZGlzYWJsZWRcIixmYWxzZSk7ZWxzZSB0aGlzLl9yZXNldEJ1dHRvbigpfSxyZWZyZXNoOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5lbGVtZW50LmlzKFwiOmRpc2FibGVkXCIpO2EhPT10aGlzLm9wdGlvbnMuZGlzYWJsZWQmJnRoaXMuX3NldE9wdGlvbihcImRpc2FibGVkXCIsYSk7aWYodGhpcy50eXBlPT09XCJyYWRpb1wiKWsodGhpcy5lbGVtZW50WzBdKS5lYWNoKGZ1bmN0aW9uKCl7Yih0aGlzKS5pcyhcIjpjaGVja2VkXCIpP2IodGhpcykuYnV0dG9uKFwid2lkZ2V0XCIpLmFkZENsYXNzKFwidWktc3RhdGUtYWN0aXZlXCIpLmF0dHIoXCJhcmlhLXByZXNzZWRcIixcclxuXCJ0cnVlXCIpOmIodGhpcykuYnV0dG9uKFwid2lkZ2V0XCIpLnJlbW92ZUNsYXNzKFwidWktc3RhdGUtYWN0aXZlXCIpLmF0dHIoXCJhcmlhLXByZXNzZWRcIixcImZhbHNlXCIpfSk7ZWxzZSBpZih0aGlzLnR5cGU9PT1cImNoZWNrYm94XCIpdGhpcy5lbGVtZW50LmlzKFwiOmNoZWNrZWRcIik/dGhpcy5idXR0b25FbGVtZW50LmFkZENsYXNzKFwidWktc3RhdGUtYWN0aXZlXCIpLmF0dHIoXCJhcmlhLXByZXNzZWRcIixcInRydWVcIik6dGhpcy5idXR0b25FbGVtZW50LnJlbW92ZUNsYXNzKFwidWktc3RhdGUtYWN0aXZlXCIpLmF0dHIoXCJhcmlhLXByZXNzZWRcIixcImZhbHNlXCIpfSxfcmVzZXRCdXR0b246ZnVuY3Rpb24oKXtpZih0aGlzLnR5cGU9PT1cImlucHV0XCIpdGhpcy5vcHRpb25zLmxhYmVsJiZ0aGlzLmVsZW1lbnQudmFsKHRoaXMub3B0aW9ucy5sYWJlbCk7ZWxzZXt2YXIgYT10aGlzLmJ1dHRvbkVsZW1lbnQucmVtb3ZlQ2xhc3MoXCJ1aS1idXR0b24taWNvbnMtb25seSB1aS1idXR0b24taWNvbi1vbmx5IHVpLWJ1dHRvbi10ZXh0LWljb25zIHVpLWJ1dHRvbi10ZXh0LWljb24tcHJpbWFyeSB1aS1idXR0b24tdGV4dC1pY29uLXNlY29uZGFyeSB1aS1idXR0b24tdGV4dC1vbmx5XCIpLFxyXG5jPWIoXCI8c3Bhbj48L3NwYW4+XCIpLmFkZENsYXNzKFwidWktYnV0dG9uLXRleHRcIikuaHRtbCh0aGlzLm9wdGlvbnMubGFiZWwpLmFwcGVuZFRvKGEuZW1wdHkoKSkudGV4dCgpLGU9dGhpcy5vcHRpb25zLmljb25zLGY9ZS5wcmltYXJ5JiZlLnNlY29uZGFyeSxkPVtdO2lmKGUucHJpbWFyeXx8ZS5zZWNvbmRhcnkpe2lmKHRoaXMub3B0aW9ucy50ZXh0KWQucHVzaChcInVpLWJ1dHRvbi10ZXh0LWljb25cIisoZj9cInNcIjplLnByaW1hcnk/XCItcHJpbWFyeVwiOlwiLXNlY29uZGFyeVwiKSk7ZS5wcmltYXJ5JiZhLnByZXBlbmQoXCI8c3BhbiBjbGFzcz0ndWktYnV0dG9uLWljb24tcHJpbWFyeSB1aS1pY29uIFwiK2UucHJpbWFyeStcIic+PC9zcGFuPlwiKTtlLnNlY29uZGFyeSYmYS5hcHBlbmQoXCI8c3BhbiBjbGFzcz0ndWktYnV0dG9uLWljb24tc2Vjb25kYXJ5IHVpLWljb24gXCIrZS5zZWNvbmRhcnkrXCInPjwvc3Bhbj5cIik7aWYoIXRoaXMub3B0aW9ucy50ZXh0KXtkLnB1c2goZj9cInVpLWJ1dHRvbi1pY29ucy1vbmx5XCI6XHJcblwidWktYnV0dG9uLWljb24tb25seVwiKTt0aGlzLmhhc1RpdGxlfHxhLmF0dHIoXCJ0aXRsZVwiLGMpfX1lbHNlIGQucHVzaChcInVpLWJ1dHRvbi10ZXh0LW9ubHlcIik7YS5hZGRDbGFzcyhkLmpvaW4oXCIgXCIpKX19fSk7Yi53aWRnZXQoXCJ1aS5idXR0b25zZXRcIix7b3B0aW9uczp7aXRlbXM6XCI6YnV0dG9uLCA6c3VibWl0LCA6cmVzZXQsIDpjaGVja2JveCwgOnJhZGlvLCBhLCA6ZGF0YShidXR0b24pXCJ9LF9jcmVhdGU6ZnVuY3Rpb24oKXt0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoXCJ1aS1idXR0b25zZXRcIil9LF9pbml0OmZ1bmN0aW9uKCl7dGhpcy5yZWZyZXNoKCl9LF9zZXRPcHRpb246ZnVuY3Rpb24oYSxjKXthPT09XCJkaXNhYmxlZFwiJiZ0aGlzLmJ1dHRvbnMuYnV0dG9uKFwib3B0aW9uXCIsYSxjKTtiLldpZGdldC5wcm90b3R5cGUuX3NldE9wdGlvbi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LHJlZnJlc2g6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmVsZW1lbnQuY3NzKFwiZGlyZWN0aW9uXCIpPT09XHJcblwibHRyXCI7dGhpcy5idXR0b25zPXRoaXMuZWxlbWVudC5maW5kKHRoaXMub3B0aW9ucy5pdGVtcykuZmlsdGVyKFwiOnVpLWJ1dHRvblwiKS5idXR0b24oXCJyZWZyZXNoXCIpLmVuZCgpLm5vdChcIjp1aS1idXR0b25cIikuYnV0dG9uKCkuZW5kKCkubWFwKGZ1bmN0aW9uKCl7cmV0dXJuIGIodGhpcykuYnV0dG9uKFwid2lkZ2V0XCIpWzBdfSkucmVtb3ZlQ2xhc3MoXCJ1aS1jb3JuZXItYWxsIHVpLWNvcm5lci1sZWZ0IHVpLWNvcm5lci1yaWdodFwiKS5maWx0ZXIoXCI6Zmlyc3RcIikuYWRkQ2xhc3MoYT9cInVpLWNvcm5lci1sZWZ0XCI6XCJ1aS1jb3JuZXItcmlnaHRcIikuZW5kKCkuZmlsdGVyKFwiOmxhc3RcIikuYWRkQ2xhc3MoYT9cInVpLWNvcm5lci1yaWdodFwiOlwidWktY29ybmVyLWxlZnRcIikuZW5kKCkuZW5kKCl9LGRlc3Ryb3k6ZnVuY3Rpb24oKXt0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoXCJ1aS1idXR0b25zZXRcIik7dGhpcy5idXR0b25zLm1hcChmdW5jdGlvbigpe3JldHVybiBiKHRoaXMpLmJ1dHRvbihcIndpZGdldFwiKVswXX0pLnJlbW92ZUNsYXNzKFwidWktY29ybmVyLWxlZnQgdWktY29ybmVyLXJpZ2h0XCIpLmVuZCgpLmJ1dHRvbihcImRlc3Ryb3lcIik7XHJcbmIuV2lkZ2V0LnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyl9fSl9KShqUXVlcnkpO1xyXG47LypcclxuICogalF1ZXJ5IFVJIERpYWxvZyAxLjguMTZcclxuICpcclxuICogQ29weXJpZ2h0IDIwMTEsIEFVVEhPUlMudHh0IChodHRwOi8vanF1ZXJ5dWkuY29tL2Fib3V0KVxyXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgb3IgR1BMIFZlcnNpb24gMiBsaWNlbnNlcy5cclxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxyXG4gKlxyXG4gKiBodHRwOi8vZG9jcy5qcXVlcnkuY29tL1VJL0RpYWxvZ1xyXG4gKlxyXG4gKiBEZXBlbmRzOlxyXG4gKlx0anF1ZXJ5LnVpLmNvcmUuanNcclxuICpcdGpxdWVyeS51aS53aWRnZXQuanNcclxuICogIGpxdWVyeS51aS5idXR0b24uanNcclxuICpcdGpxdWVyeS51aS5kcmFnZ2FibGUuanNcclxuICpcdGpxdWVyeS51aS5tb3VzZS5qc1xyXG4gKlx0anF1ZXJ5LnVpLnBvc2l0aW9uLmpzXHJcbiAqXHRqcXVlcnkudWkucmVzaXphYmxlLmpzXHJcbiAqL1xyXG4oZnVuY3Rpb24oYyxsKXt2YXIgbT17YnV0dG9uczp0cnVlLGhlaWdodDp0cnVlLG1heEhlaWdodDp0cnVlLG1heFdpZHRoOnRydWUsbWluSGVpZ2h0OnRydWUsbWluV2lkdGg6dHJ1ZSx3aWR0aDp0cnVlfSxuPXttYXhIZWlnaHQ6dHJ1ZSxtYXhXaWR0aDp0cnVlLG1pbkhlaWdodDp0cnVlLG1pbldpZHRoOnRydWV9LG89Yy5hdHRyRm58fHt2YWw6dHJ1ZSxjc3M6dHJ1ZSxodG1sOnRydWUsdGV4dDp0cnVlLGRhdGE6dHJ1ZSx3aWR0aDp0cnVlLGhlaWdodDp0cnVlLG9mZnNldDp0cnVlLGNsaWNrOnRydWV9O2Mud2lkZ2V0KFwidWkuZGlhbG9nXCIse29wdGlvbnM6e2F1dG9PcGVuOnRydWUsYnV0dG9uczp7fSxjbG9zZU9uRXNjYXBlOnRydWUsY2xvc2VUZXh0OlwiY2xvc2VcIixkaWFsb2dDbGFzczpcIlwiLGRyYWdnYWJsZTp0cnVlLGhpZGU6bnVsbCxoZWlnaHQ6XCJhdXRvXCIsbWF4SGVpZ2h0OmZhbHNlLG1heFdpZHRoOmZhbHNlLG1pbkhlaWdodDoxNTAsbWluV2lkdGg6MTUwLG1vZGFsOmZhbHNlLFxyXG5wb3NpdGlvbjp7bXk6XCJjZW50ZXJcIixhdDpcImNlbnRlclwiLGNvbGxpc2lvbjpcImZpdFwiLHVzaW5nOmZ1bmN0aW9uKGEpe3ZhciBiPWModGhpcykuY3NzKGEpLm9mZnNldCgpLnRvcDtiPDAmJmModGhpcykuY3NzKFwidG9wXCIsYS50b3AtYil9fSxyZXNpemFibGU6dHJ1ZSxzaG93Om51bGwsc3RhY2s6dHJ1ZSx0aXRsZTpcIlwiLHdpZHRoOjMwMCx6SW5kZXg6MUUzfSxfY3JlYXRlOmZ1bmN0aW9uKCl7dGhpcy5vcmlnaW5hbFRpdGxlPXRoaXMuZWxlbWVudC5hdHRyKFwidGl0bGVcIik7aWYodHlwZW9mIHRoaXMub3JpZ2luYWxUaXRsZSE9PVwic3RyaW5nXCIpdGhpcy5vcmlnaW5hbFRpdGxlPVwiXCI7dGhpcy5vcHRpb25zLnRpdGxlPXRoaXMub3B0aW9ucy50aXRsZXx8dGhpcy5vcmlnaW5hbFRpdGxlO3ZhciBhPXRoaXMsYj1hLm9wdGlvbnMsZD1iLnRpdGxlfHxcIiYjMTYwO1wiLGU9Yy51aS5kaWFsb2cuZ2V0VGl0bGVJZChhLmVsZW1lbnQpLGc9KGEudWlEaWFsb2c9YyhcIjxkaXY+PC9kaXY+XCIpKS5hcHBlbmRUbyhkb2N1bWVudC5ib2R5KS5oaWRlKCkuYWRkQ2xhc3MoXCJ1aS1kaWFsb2cgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGwgXCIrXHJcbmIuZGlhbG9nQ2xhc3MpLmNzcyh7ekluZGV4OmIuekluZGV4fSkuYXR0cihcInRhYkluZGV4XCIsLTEpLmNzcyhcIm91dGxpbmVcIiwwKS5rZXlkb3duKGZ1bmN0aW9uKGkpe2lmKGIuY2xvc2VPbkVzY2FwZSYmIWkuaXNEZWZhdWx0UHJldmVudGVkKCkmJmkua2V5Q29kZSYmaS5rZXlDb2RlPT09Yy51aS5rZXlDb2RlLkVTQ0FQRSl7YS5jbG9zZShpKTtpLnByZXZlbnREZWZhdWx0KCl9fSkuYXR0cih7cm9sZTpcImRpYWxvZ1wiLFwiYXJpYS1sYWJlbGxlZGJ5XCI6ZX0pLm1vdXNlZG93bihmdW5jdGlvbihpKXthLm1vdmVUb1RvcChmYWxzZSxpKX0pO2EuZWxlbWVudC5zaG93KCkucmVtb3ZlQXR0cihcInRpdGxlXCIpLmFkZENsYXNzKFwidWktZGlhbG9nLWNvbnRlbnQgdWktd2lkZ2V0LWNvbnRlbnRcIikuYXBwZW5kVG8oZyk7dmFyIGY9KGEudWlEaWFsb2dUaXRsZWJhcj1jKFwiPGRpdj48L2Rpdj5cIikpLmFkZENsYXNzKFwidWktZGlhbG9nLXRpdGxlYmFyIHVpLXdpZGdldC1oZWFkZXIgdWktY29ybmVyLWFsbCB1aS1oZWxwZXItY2xlYXJmaXhcIikucHJlcGVuZFRvKGcpLFxyXG5oPWMoJzxhIGhyZWY9XCIjXCI+PC9hPicpLmFkZENsYXNzKFwidWktZGlhbG9nLXRpdGxlYmFyLWNsb3NlIHVpLWNvcm5lci1hbGxcIikuYXR0cihcInJvbGVcIixcImJ1dHRvblwiKS5ob3ZlcihmdW5jdGlvbigpe2guYWRkQ2xhc3MoXCJ1aS1zdGF0ZS1ob3ZlclwiKX0sZnVuY3Rpb24oKXtoLnJlbW92ZUNsYXNzKFwidWktc3RhdGUtaG92ZXJcIil9KS5mb2N1cyhmdW5jdGlvbigpe2guYWRkQ2xhc3MoXCJ1aS1zdGF0ZS1mb2N1c1wiKX0pLmJsdXIoZnVuY3Rpb24oKXtoLnJlbW92ZUNsYXNzKFwidWktc3RhdGUtZm9jdXNcIil9KS5jbGljayhmdW5jdGlvbihpKXthLmNsb3NlKGkpO3JldHVybiBmYWxzZX0pLmFwcGVuZFRvKGYpOyhhLnVpRGlhbG9nVGl0bGViYXJDbG9zZVRleHQ9YyhcIjxzcGFuPjwvc3Bhbj5cIikpLmFkZENsYXNzKFwidWktaWNvbiB1aS1pY29uLWNsb3NldGhpY2tcIikudGV4dChiLmNsb3NlVGV4dCkuYXBwZW5kVG8oaCk7YyhcIjxzcGFuPjwvc3Bhbj5cIikuYWRkQ2xhc3MoXCJ1aS1kaWFsb2ctdGl0bGVcIikuYXR0cihcImlkXCIsXHJcbmUpLmh0bWwoZCkucHJlcGVuZFRvKGYpO2lmKGMuaXNGdW5jdGlvbihiLmJlZm9yZWNsb3NlKSYmIWMuaXNGdW5jdGlvbihiLmJlZm9yZUNsb3NlKSliLmJlZm9yZUNsb3NlPWIuYmVmb3JlY2xvc2U7Zi5maW5kKFwiKlwiKS5hZGQoZikuZGlzYWJsZVNlbGVjdGlvbigpO2IuZHJhZ2dhYmxlJiZjLmZuLmRyYWdnYWJsZSYmYS5fbWFrZURyYWdnYWJsZSgpO2IucmVzaXphYmxlJiZjLmZuLnJlc2l6YWJsZSYmYS5fbWFrZVJlc2l6YWJsZSgpO2EuX2NyZWF0ZUJ1dHRvbnMoYi5idXR0b25zKTthLl9pc09wZW49ZmFsc2U7Yy5mbi5iZ2lmcmFtZSYmZy5iZ2lmcmFtZSgpfSxfaW5pdDpmdW5jdGlvbigpe3RoaXMub3B0aW9ucy5hdXRvT3BlbiYmdGhpcy5vcGVuKCl9LGRlc3Ryb3k6ZnVuY3Rpb24oKXt2YXIgYT10aGlzO2Eub3ZlcmxheSYmYS5vdmVybGF5LmRlc3Ryb3koKTthLnVpRGlhbG9nLmhpZGUoKTthLmVsZW1lbnQudW5iaW5kKFwiLmRpYWxvZ1wiKS5yZW1vdmVEYXRhKFwiZGlhbG9nXCIpLnJlbW92ZUNsYXNzKFwidWktZGlhbG9nLWNvbnRlbnQgdWktd2lkZ2V0LWNvbnRlbnRcIikuaGlkZSgpLmFwcGVuZFRvKFwiYm9keVwiKTtcclxuYS51aURpYWxvZy5yZW1vdmUoKTthLm9yaWdpbmFsVGl0bGUmJmEuZWxlbWVudC5hdHRyKFwidGl0bGVcIixhLm9yaWdpbmFsVGl0bGUpO3JldHVybiBhfSx3aWRnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51aURpYWxvZ30sY2xvc2U6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxkLGU7aWYoZmFsc2UhPT1iLl90cmlnZ2VyKFwiYmVmb3JlQ2xvc2VcIixhKSl7Yi5vdmVybGF5JiZiLm92ZXJsYXkuZGVzdHJveSgpO2IudWlEaWFsb2cudW5iaW5kKFwia2V5cHJlc3MudWktZGlhbG9nXCIpO2IuX2lzT3Blbj1mYWxzZTtpZihiLm9wdGlvbnMuaGlkZSliLnVpRGlhbG9nLmhpZGUoYi5vcHRpb25zLmhpZGUsZnVuY3Rpb24oKXtiLl90cmlnZ2VyKFwiY2xvc2VcIixhKX0pO2Vsc2V7Yi51aURpYWxvZy5oaWRlKCk7Yi5fdHJpZ2dlcihcImNsb3NlXCIsYSl9Yy51aS5kaWFsb2cub3ZlcmxheS5yZXNpemUoKTtpZihiLm9wdGlvbnMubW9kYWwpe2Q9MDtjKFwiLnVpLWRpYWxvZ1wiKS5lYWNoKGZ1bmN0aW9uKCl7aWYodGhpcyE9PVxyXG5iLnVpRGlhbG9nWzBdKXtlPWModGhpcykuY3NzKFwiei1pbmRleFwiKTtpc05hTihlKXx8KGQ9TWF0aC5tYXgoZCxlKSl9fSk7Yy51aS5kaWFsb2cubWF4Wj1kfXJldHVybiBifX0saXNPcGVuOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzT3Blbn0sbW92ZVRvVG9wOmZ1bmN0aW9uKGEsYil7dmFyIGQ9dGhpcyxlPWQub3B0aW9ucztpZihlLm1vZGFsJiYhYXx8IWUuc3RhY2smJiFlLm1vZGFsKXJldHVybiBkLl90cmlnZ2VyKFwiZm9jdXNcIixiKTtpZihlLnpJbmRleD5jLnVpLmRpYWxvZy5tYXhaKWMudWkuZGlhbG9nLm1heFo9ZS56SW5kZXg7aWYoZC5vdmVybGF5KXtjLnVpLmRpYWxvZy5tYXhaKz0xO2Qub3ZlcmxheS4kZWwuY3NzKFwiei1pbmRleFwiLGMudWkuZGlhbG9nLm92ZXJsYXkubWF4Wj1jLnVpLmRpYWxvZy5tYXhaKX1hPXtzY3JvbGxUb3A6ZC5lbGVtZW50LnNjcm9sbFRvcCgpLHNjcm9sbExlZnQ6ZC5lbGVtZW50LnNjcm9sbExlZnQoKX07Yy51aS5kaWFsb2cubWF4Wis9MTtcclxuZC51aURpYWxvZy5jc3MoXCJ6LWluZGV4XCIsYy51aS5kaWFsb2cubWF4Wik7ZC5lbGVtZW50LmF0dHIoYSk7ZC5fdHJpZ2dlcihcImZvY3VzXCIsYik7cmV0dXJuIGR9LG9wZW46ZnVuY3Rpb24oKXtpZighdGhpcy5faXNPcGVuKXt2YXIgYT10aGlzLGI9YS5vcHRpb25zLGQ9YS51aURpYWxvZzthLm92ZXJsYXk9Yi5tb2RhbD9uZXcgYy51aS5kaWFsb2cub3ZlcmxheShhKTpudWxsO2EuX3NpemUoKTthLl9wb3NpdGlvbihiLnBvc2l0aW9uKTtkLnNob3coYi5zaG93KTthLm1vdmVUb1RvcCh0cnVlKTtiLm1vZGFsJiZkLmJpbmQoXCJrZXlwcmVzcy51aS1kaWFsb2dcIixmdW5jdGlvbihlKXtpZihlLmtleUNvZGU9PT1jLnVpLmtleUNvZGUuVEFCKXt2YXIgZz1jKFwiOnRhYmJhYmxlXCIsdGhpcyksZj1nLmZpbHRlcihcIjpmaXJzdFwiKTtnPWcuZmlsdGVyKFwiOmxhc3RcIik7aWYoZS50YXJnZXQ9PT1nWzBdJiYhZS5zaGlmdEtleSl7Zi5mb2N1cygxKTtyZXR1cm4gZmFsc2V9ZWxzZSBpZihlLnRhcmdldD09PVxyXG5mWzBdJiZlLnNoaWZ0S2V5KXtnLmZvY3VzKDEpO3JldHVybiBmYWxzZX19fSk7YyhhLmVsZW1lbnQuZmluZChcIjp0YWJiYWJsZVwiKS5nZXQoKS5jb25jYXQoZC5maW5kKFwiLnVpLWRpYWxvZy1idXR0b25wYW5lIDp0YWJiYWJsZVwiKS5nZXQoKS5jb25jYXQoZC5nZXQoKSkpKS5lcSgwKS5mb2N1cygpO2EuX2lzT3Blbj10cnVlO2EuX3RyaWdnZXIoXCJvcGVuXCIpO3JldHVybiBhfX0sX2NyZWF0ZUJ1dHRvbnM6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxkPWZhbHNlLGU9YyhcIjxkaXY+PC9kaXY+XCIpLmFkZENsYXNzKFwidWktZGlhbG9nLWJ1dHRvbnBhbmUgdWktd2lkZ2V0LWNvbnRlbnQgdWktaGVscGVyLWNsZWFyZml4XCIpLGc9YyhcIjxkaXY+PC9kaXY+XCIpLmFkZENsYXNzKFwidWktZGlhbG9nLWJ1dHRvbnNldFwiKS5hcHBlbmRUbyhlKTtiLnVpRGlhbG9nLmZpbmQoXCIudWktZGlhbG9nLWJ1dHRvbnBhbmVcIikucmVtb3ZlKCk7dHlwZW9mIGE9PT1cIm9iamVjdFwiJiZhIT09bnVsbCYmYy5lYWNoKGEsXHJcbmZ1bmN0aW9uKCl7cmV0dXJuIShkPXRydWUpfSk7aWYoZCl7Yy5lYWNoKGEsZnVuY3Rpb24oZixoKXtoPWMuaXNGdW5jdGlvbihoKT97Y2xpY2s6aCx0ZXh0OmZ9Omg7dmFyIGk9YygnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCI+PC9idXR0b24+JykuY2xpY2soZnVuY3Rpb24oKXtoLmNsaWNrLmFwcGx5KGIuZWxlbWVudFswXSxhcmd1bWVudHMpfSkuYXBwZW5kVG8oZyk7Yy5lYWNoKGgsZnVuY3Rpb24oaixrKXtpZihqIT09XCJjbGlja1wiKWogaW4gbz9pW2pdKGspOmkuYXR0cihqLGspfSk7Yy5mbi5idXR0b24mJmkuYnV0dG9uKCl9KTtlLmFwcGVuZFRvKGIudWlEaWFsb2cpfX0sX21ha2VEcmFnZ2FibGU6ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGYpe3JldHVybntwb3NpdGlvbjpmLnBvc2l0aW9uLG9mZnNldDpmLm9mZnNldH19dmFyIGI9dGhpcyxkPWIub3B0aW9ucyxlPWMoZG9jdW1lbnQpLGc7Yi51aURpYWxvZy5kcmFnZ2FibGUoe2NhbmNlbDpcIi51aS1kaWFsb2ctY29udGVudCwgLnVpLWRpYWxvZy10aXRsZWJhci1jbG9zZVwiLFxyXG5oYW5kbGU6XCIudWktZGlhbG9nLXRpdGxlYmFyXCIsY29udGFpbm1lbnQ6XCJkb2N1bWVudFwiLHN0YXJ0OmZ1bmN0aW9uKGYsaCl7Zz1kLmhlaWdodD09PVwiYXV0b1wiP1wiYXV0b1wiOmModGhpcykuaGVpZ2h0KCk7Yyh0aGlzKS5oZWlnaHQoYyh0aGlzKS5oZWlnaHQoKSkuYWRkQ2xhc3MoXCJ1aS1kaWFsb2ctZHJhZ2dpbmdcIik7Yi5fdHJpZ2dlcihcImRyYWdTdGFydFwiLGYsYShoKSl9LGRyYWc6ZnVuY3Rpb24oZixoKXtiLl90cmlnZ2VyKFwiZHJhZ1wiLGYsYShoKSl9LHN0b3A6ZnVuY3Rpb24oZixoKXtkLnBvc2l0aW9uPVtoLnBvc2l0aW9uLmxlZnQtZS5zY3JvbGxMZWZ0KCksaC5wb3NpdGlvbi50b3AtZS5zY3JvbGxUb3AoKV07Yyh0aGlzKS5yZW1vdmVDbGFzcyhcInVpLWRpYWxvZy1kcmFnZ2luZ1wiKS5oZWlnaHQoZyk7Yi5fdHJpZ2dlcihcImRyYWdTdG9wXCIsZixhKGgpKTtjLnVpLmRpYWxvZy5vdmVybGF5LnJlc2l6ZSgpfX0pfSxfbWFrZVJlc2l6YWJsZTpmdW5jdGlvbihhKXtmdW5jdGlvbiBiKGYpe3JldHVybntvcmlnaW5hbFBvc2l0aW9uOmYub3JpZ2luYWxQb3NpdGlvbixcclxub3JpZ2luYWxTaXplOmYub3JpZ2luYWxTaXplLHBvc2l0aW9uOmYucG9zaXRpb24sc2l6ZTpmLnNpemV9fWE9YT09PWw/dGhpcy5vcHRpb25zLnJlc2l6YWJsZTphO3ZhciBkPXRoaXMsZT1kLm9wdGlvbnMsZz1kLnVpRGlhbG9nLmNzcyhcInBvc2l0aW9uXCIpO2E9dHlwZW9mIGE9PT1cInN0cmluZ1wiP2E6XCJuLGUscyx3LHNlLHN3LG5lLG53XCI7ZC51aURpYWxvZy5yZXNpemFibGUoe2NhbmNlbDpcIi51aS1kaWFsb2ctY29udGVudFwiLGNvbnRhaW5tZW50OlwiZG9jdW1lbnRcIixhbHNvUmVzaXplOmQuZWxlbWVudCxtYXhXaWR0aDplLm1heFdpZHRoLG1heEhlaWdodDplLm1heEhlaWdodCxtaW5XaWR0aDplLm1pbldpZHRoLG1pbkhlaWdodDpkLl9taW5IZWlnaHQoKSxoYW5kbGVzOmEsc3RhcnQ6ZnVuY3Rpb24oZixoKXtjKHRoaXMpLmFkZENsYXNzKFwidWktZGlhbG9nLXJlc2l6aW5nXCIpO2QuX3RyaWdnZXIoXCJyZXNpemVTdGFydFwiLGYsYihoKSl9LHJlc2l6ZTpmdW5jdGlvbihmLGgpe2QuX3RyaWdnZXIoXCJyZXNpemVcIixcclxuZixiKGgpKX0sc3RvcDpmdW5jdGlvbihmLGgpe2ModGhpcykucmVtb3ZlQ2xhc3MoXCJ1aS1kaWFsb2ctcmVzaXppbmdcIik7ZS5oZWlnaHQ9Yyh0aGlzKS5oZWlnaHQoKTtlLndpZHRoPWModGhpcykud2lkdGgoKTtkLl90cmlnZ2VyKFwicmVzaXplU3RvcFwiLGYsYihoKSk7Yy51aS5kaWFsb2cub3ZlcmxheS5yZXNpemUoKX19KS5jc3MoXCJwb3NpdGlvblwiLGcpLmZpbmQoXCIudWktcmVzaXphYmxlLXNlXCIpLmFkZENsYXNzKFwidWktaWNvbiB1aS1pY29uLWdyaXAtZGlhZ29uYWwtc2VcIil9LF9taW5IZWlnaHQ6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLm9wdGlvbnM7cmV0dXJuIGEuaGVpZ2h0PT09XCJhdXRvXCI/YS5taW5IZWlnaHQ6TWF0aC5taW4oYS5taW5IZWlnaHQsYS5oZWlnaHQpfSxfcG9zaXRpb246ZnVuY3Rpb24oYSl7dmFyIGI9W10sZD1bMCwwXSxlO2lmKGEpe2lmKHR5cGVvZiBhPT09XCJzdHJpbmdcInx8dHlwZW9mIGE9PT1cIm9iamVjdFwiJiZcIjBcImluIGEpe2I9YS5zcGxpdD9hLnNwbGl0KFwiIFwiKTpcclxuW2FbMF0sYVsxXV07aWYoYi5sZW5ndGg9PT0xKWJbMV09YlswXTtjLmVhY2goW1wibGVmdFwiLFwidG9wXCJdLGZ1bmN0aW9uKGcsZil7aWYoK2JbZ109PT1iW2ddKXtkW2ddPWJbZ107YltnXT1mfX0pO2E9e215OmIuam9pbihcIiBcIiksYXQ6Yi5qb2luKFwiIFwiKSxvZmZzZXQ6ZC5qb2luKFwiIFwiKX19YT1jLmV4dGVuZCh7fSxjLnVpLmRpYWxvZy5wcm90b3R5cGUub3B0aW9ucy5wb3NpdGlvbixhKX1lbHNlIGE9Yy51aS5kaWFsb2cucHJvdG90eXBlLm9wdGlvbnMucG9zaXRpb247KGU9dGhpcy51aURpYWxvZy5pcyhcIjp2aXNpYmxlXCIpKXx8dGhpcy51aURpYWxvZy5zaG93KCk7dGhpcy51aURpYWxvZy5jc3Moe3RvcDowLGxlZnQ6MH0pLnBvc2l0aW9uKGMuZXh0ZW5kKHtvZjp3aW5kb3d9LGEpKTtlfHx0aGlzLnVpRGlhbG9nLmhpZGUoKX0sX3NldE9wdGlvbnM6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxkPXt9LGU9ZmFsc2U7Yy5lYWNoKGEsZnVuY3Rpb24oZyxmKXtiLl9zZXRPcHRpb24oZyxmKTtcclxuaWYoZyBpbiBtKWU9dHJ1ZTtpZihnIGluIG4pZFtnXT1mfSk7ZSYmdGhpcy5fc2l6ZSgpO3RoaXMudWlEaWFsb2cuaXMoXCI6ZGF0YShyZXNpemFibGUpXCIpJiZ0aGlzLnVpRGlhbG9nLnJlc2l6YWJsZShcIm9wdGlvblwiLGQpfSxfc2V0T3B0aW9uOmZ1bmN0aW9uKGEsYil7dmFyIGQ9dGhpcyxlPWQudWlEaWFsb2c7c3dpdGNoKGEpe2Nhc2UgXCJiZWZvcmVjbG9zZVwiOmE9XCJiZWZvcmVDbG9zZVwiO2JyZWFrO2Nhc2UgXCJidXR0b25zXCI6ZC5fY3JlYXRlQnV0dG9ucyhiKTticmVhaztjYXNlIFwiY2xvc2VUZXh0XCI6ZC51aURpYWxvZ1RpdGxlYmFyQ2xvc2VUZXh0LnRleHQoXCJcIitiKTticmVhaztjYXNlIFwiZGlhbG9nQ2xhc3NcIjplLnJlbW92ZUNsYXNzKGQub3B0aW9ucy5kaWFsb2dDbGFzcykuYWRkQ2xhc3MoXCJ1aS1kaWFsb2cgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGwgXCIrYik7YnJlYWs7Y2FzZSBcImRpc2FibGVkXCI6Yj9lLmFkZENsYXNzKFwidWktZGlhbG9nLWRpc2FibGVkXCIpOlxyXG5lLnJlbW92ZUNsYXNzKFwidWktZGlhbG9nLWRpc2FibGVkXCIpO2JyZWFrO2Nhc2UgXCJkcmFnZ2FibGVcIjp2YXIgZz1lLmlzKFwiOmRhdGEoZHJhZ2dhYmxlKVwiKTtnJiYhYiYmZS5kcmFnZ2FibGUoXCJkZXN0cm95XCIpOyFnJiZiJiZkLl9tYWtlRHJhZ2dhYmxlKCk7YnJlYWs7Y2FzZSBcInBvc2l0aW9uXCI6ZC5fcG9zaXRpb24oYik7YnJlYWs7Y2FzZSBcInJlc2l6YWJsZVwiOihnPWUuaXMoXCI6ZGF0YShyZXNpemFibGUpXCIpKSYmIWImJmUucmVzaXphYmxlKFwiZGVzdHJveVwiKTtnJiZ0eXBlb2YgYj09PVwic3RyaW5nXCImJmUucmVzaXphYmxlKFwib3B0aW9uXCIsXCJoYW5kbGVzXCIsYik7IWcmJmIhPT1mYWxzZSYmZC5fbWFrZVJlc2l6YWJsZShiKTticmVhaztjYXNlIFwidGl0bGVcIjpjKFwiLnVpLWRpYWxvZy10aXRsZVwiLGQudWlEaWFsb2dUaXRsZWJhcikuaHRtbChcIlwiKyhifHxcIiYjMTYwO1wiKSk7YnJlYWt9Yy5XaWRnZXQucHJvdG90eXBlLl9zZXRPcHRpb24uYXBwbHkoZCxhcmd1bWVudHMpfSxfc2l6ZTpmdW5jdGlvbigpe3ZhciBhPVxyXG50aGlzLm9wdGlvbnMsYixkLGU9dGhpcy51aURpYWxvZy5pcyhcIjp2aXNpYmxlXCIpO3RoaXMuZWxlbWVudC5zaG93KCkuY3NzKHt3aWR0aDpcImF1dG9cIixtaW5IZWlnaHQ6MCxoZWlnaHQ6MH0pO2lmKGEubWluV2lkdGg+YS53aWR0aClhLndpZHRoPWEubWluV2lkdGg7Yj10aGlzLnVpRGlhbG9nLmNzcyh7aGVpZ2h0OlwiYXV0b1wiLHdpZHRoOmEud2lkdGh9KS5oZWlnaHQoKTtkPU1hdGgubWF4KDAsYS5taW5IZWlnaHQtYik7aWYoYS5oZWlnaHQ9PT1cImF1dG9cIilpZihjLnN1cHBvcnQubWluSGVpZ2h0KXRoaXMuZWxlbWVudC5jc3Moe21pbkhlaWdodDpkLGhlaWdodDpcImF1dG9cIn0pO2Vsc2V7dGhpcy51aURpYWxvZy5zaG93KCk7YT10aGlzLmVsZW1lbnQuY3NzKFwiaGVpZ2h0XCIsXCJhdXRvXCIpLmhlaWdodCgpO2V8fHRoaXMudWlEaWFsb2cuaGlkZSgpO3RoaXMuZWxlbWVudC5oZWlnaHQoTWF0aC5tYXgoYSxkKSl9ZWxzZSB0aGlzLmVsZW1lbnQuaGVpZ2h0KE1hdGgubWF4KGEuaGVpZ2h0LVxyXG5iLDApKTt0aGlzLnVpRGlhbG9nLmlzKFwiOmRhdGEocmVzaXphYmxlKVwiKSYmdGhpcy51aURpYWxvZy5yZXNpemFibGUoXCJvcHRpb25cIixcIm1pbkhlaWdodFwiLHRoaXMuX21pbkhlaWdodCgpKX19KTtjLmV4dGVuZChjLnVpLmRpYWxvZyx7dmVyc2lvbjpcIjEuOC4xNlwiLHV1aWQ6MCxtYXhaOjAsZ2V0VGl0bGVJZDpmdW5jdGlvbihhKXthPWEuYXR0cihcImlkXCIpO2lmKCFhKXt0aGlzLnV1aWQrPTE7YT10aGlzLnV1aWR9cmV0dXJuXCJ1aS1kaWFsb2ctdGl0bGUtXCIrYX0sb3ZlcmxheTpmdW5jdGlvbihhKXt0aGlzLiRlbD1jLnVpLmRpYWxvZy5vdmVybGF5LmNyZWF0ZShhKX19KTtjLmV4dGVuZChjLnVpLmRpYWxvZy5vdmVybGF5LHtpbnN0YW5jZXM6W10sb2xkSW5zdGFuY2VzOltdLG1heFo6MCxldmVudHM6Yy5tYXAoXCJmb2N1cyxtb3VzZWRvd24sbW91c2V1cCxrZXlkb3duLGtleXByZXNzLGNsaWNrXCIuc3BsaXQoXCIsXCIpLGZ1bmN0aW9uKGEpe3JldHVybiBhK1wiLmRpYWxvZy1vdmVybGF5XCJ9KS5qb2luKFwiIFwiKSxcclxuY3JlYXRlOmZ1bmN0aW9uKGEpe2lmKHRoaXMuaW5zdGFuY2VzLmxlbmd0aD09PTApe3NldFRpbWVvdXQoZnVuY3Rpb24oKXtjLnVpLmRpYWxvZy5vdmVybGF5Lmluc3RhbmNlcy5sZW5ndGgmJmMoZG9jdW1lbnQpLmJpbmQoYy51aS5kaWFsb2cub3ZlcmxheS5ldmVudHMsZnVuY3Rpb24oZCl7aWYoYyhkLnRhcmdldCkuekluZGV4KCk8Yy51aS5kaWFsb2cub3ZlcmxheS5tYXhaKXJldHVybiBmYWxzZX0pfSwxKTtjKGRvY3VtZW50KS5iaW5kKFwia2V5ZG93bi5kaWFsb2ctb3ZlcmxheVwiLGZ1bmN0aW9uKGQpe2lmKGEub3B0aW9ucy5jbG9zZU9uRXNjYXBlJiYhZC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSYmZC5rZXlDb2RlJiZkLmtleUNvZGU9PT1jLnVpLmtleUNvZGUuRVNDQVBFKXthLmNsb3NlKGQpO2QucHJldmVudERlZmF1bHQoKX19KTtjKHdpbmRvdykuYmluZChcInJlc2l6ZS5kaWFsb2ctb3ZlcmxheVwiLGMudWkuZGlhbG9nLm92ZXJsYXkucmVzaXplKX12YXIgYj0odGhpcy5vbGRJbnN0YW5jZXMucG9wKCl8fFxyXG5jKFwiPGRpdj48L2Rpdj5cIikuYWRkQ2xhc3MoXCJ1aS13aWRnZXQtb3ZlcmxheVwiKSkuYXBwZW5kVG8oZG9jdW1lbnQuYm9keSkuY3NzKHt3aWR0aDp0aGlzLndpZHRoKCksaGVpZ2h0OnRoaXMuaGVpZ2h0KCl9KTtjLmZuLmJnaWZyYW1lJiZiLmJnaWZyYW1lKCk7dGhpcy5pbnN0YW5jZXMucHVzaChiKTtyZXR1cm4gYn0sZGVzdHJveTpmdW5jdGlvbihhKXt2YXIgYj1jLmluQXJyYXkoYSx0aGlzLmluc3RhbmNlcyk7YiE9LTEmJnRoaXMub2xkSW5zdGFuY2VzLnB1c2godGhpcy5pbnN0YW5jZXMuc3BsaWNlKGIsMSlbMF0pO3RoaXMuaW5zdGFuY2VzLmxlbmd0aD09PTAmJmMoW2RvY3VtZW50LHdpbmRvd10pLnVuYmluZChcIi5kaWFsb2ctb3ZlcmxheVwiKTthLnJlbW92ZSgpO3ZhciBkPTA7Yy5lYWNoKHRoaXMuaW5zdGFuY2VzLGZ1bmN0aW9uKCl7ZD1NYXRoLm1heChkLHRoaXMuY3NzKFwiei1pbmRleFwiKSl9KTt0aGlzLm1heFo9ZH0saGVpZ2h0OmZ1bmN0aW9uKCl7dmFyIGEsYjtpZihjLmJyb3dzZXIubXNpZSYmXHJcbmMuYnJvd3Nlci52ZXJzaW9uPDcpe2E9TWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodCxkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCk7Yj1NYXRoLm1heChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0LGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0KTtyZXR1cm4gYTxiP2Mod2luZG93KS5oZWlnaHQoKStcInB4XCI6YStcInB4XCJ9ZWxzZSByZXR1cm4gYyhkb2N1bWVudCkuaGVpZ2h0KCkrXCJweFwifSx3aWR0aDpmdW5jdGlvbigpe3ZhciBhLGI7aWYoYy5icm93c2VyLm1zaWUpe2E9TWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFdpZHRoLGRvY3VtZW50LmJvZHkuc2Nyb2xsV2lkdGgpO2I9TWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9mZnNldFdpZHRoLGRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGgpO3JldHVybiBhPGI/Yyh3aW5kb3cpLndpZHRoKCkrXCJweFwiOmErXCJweFwifWVsc2UgcmV0dXJuIGMoZG9jdW1lbnQpLndpZHRoKCkrXHJcblwicHhcIn0scmVzaXplOmZ1bmN0aW9uKCl7dmFyIGE9YyhbXSk7Yy5lYWNoKGMudWkuZGlhbG9nLm92ZXJsYXkuaW5zdGFuY2VzLGZ1bmN0aW9uKCl7YT1hLmFkZCh0aGlzKX0pO2EuY3NzKHt3aWR0aDowLGhlaWdodDowfSkuY3NzKHt3aWR0aDpjLnVpLmRpYWxvZy5vdmVybGF5LndpZHRoKCksaGVpZ2h0OmMudWkuZGlhbG9nLm92ZXJsYXkuaGVpZ2h0KCl9KX19KTtjLmV4dGVuZChjLnVpLmRpYWxvZy5vdmVybGF5LnByb3RvdHlwZSx7ZGVzdHJveTpmdW5jdGlvbigpe2MudWkuZGlhbG9nLm92ZXJsYXkuZGVzdHJveSh0aGlzLiRlbCl9fSl9KShqUXVlcnkpO1xyXG47LypcclxuICogalF1ZXJ5IFVJIFNsaWRlciAxLjguMTZcclxuICpcclxuICogQ29weXJpZ2h0IDIwMTEsIEFVVEhPUlMudHh0IChodHRwOi8vanF1ZXJ5dWkuY29tL2Fib3V0KVxyXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgb3IgR1BMIFZlcnNpb24gMiBsaWNlbnNlcy5cclxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxyXG4gKlxyXG4gKiBodHRwOi8vZG9jcy5qcXVlcnkuY29tL1VJL1NsaWRlclxyXG4gKlxyXG4gKiBEZXBlbmRzOlxyXG4gKlx0anF1ZXJ5LnVpLmNvcmUuanNcclxuICpcdGpxdWVyeS51aS5tb3VzZS5qc1xyXG4gKlx0anF1ZXJ5LnVpLndpZGdldC5qc1xyXG4gKi9cclxuKGZ1bmN0aW9uKGQpe2Qud2lkZ2V0KFwidWkuc2xpZGVyXCIsZC51aS5tb3VzZSx7d2lkZ2V0RXZlbnRQcmVmaXg6XCJzbGlkZVwiLG9wdGlvbnM6e2FuaW1hdGU6ZmFsc2UsZGlzdGFuY2U6MCxtYXg6MTAwLG1pbjowLG9yaWVudGF0aW9uOlwiaG9yaXpvbnRhbFwiLHJhbmdlOmZhbHNlLHN0ZXA6MSx2YWx1ZTowLHZhbHVlczpudWxsfSxfY3JlYXRlOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPXRoaXMub3B0aW9ucyxjPXRoaXMuZWxlbWVudC5maW5kKFwiLnVpLXNsaWRlci1oYW5kbGVcIikuYWRkQ2xhc3MoXCJ1aS1zdGF0ZS1kZWZhdWx0IHVpLWNvcm5lci1hbGxcIiksZj1iLnZhbHVlcyYmYi52YWx1ZXMubGVuZ3RofHwxLGU9W107dGhpcy5fbW91c2VTbGlkaW5nPXRoaXMuX2tleVNsaWRpbmc9ZmFsc2U7dGhpcy5fYW5pbWF0ZU9mZj10cnVlO3RoaXMuX2hhbmRsZUluZGV4PW51bGw7dGhpcy5fZGV0ZWN0T3JpZW50YXRpb24oKTt0aGlzLl9tb3VzZUluaXQoKTt0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoXCJ1aS1zbGlkZXIgdWktc2xpZGVyLVwiK1xyXG50aGlzLm9yaWVudGF0aW9uK1wiIHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsXCIrKGIuZGlzYWJsZWQ/XCIgdWktc2xpZGVyLWRpc2FibGVkIHVpLWRpc2FibGVkXCI6XCJcIikpO3RoaXMucmFuZ2U9ZChbXSk7aWYoYi5yYW5nZSl7aWYoYi5yYW5nZT09PXRydWUpe2lmKCFiLnZhbHVlcyliLnZhbHVlcz1bdGhpcy5fdmFsdWVNaW4oKSx0aGlzLl92YWx1ZU1pbigpXTtpZihiLnZhbHVlcy5sZW5ndGgmJmIudmFsdWVzLmxlbmd0aCE9PTIpYi52YWx1ZXM9W2IudmFsdWVzWzBdLGIudmFsdWVzWzBdXX10aGlzLnJhbmdlPWQoXCI8ZGl2PjwvZGl2PlwiKS5hcHBlbmRUbyh0aGlzLmVsZW1lbnQpLmFkZENsYXNzKFwidWktc2xpZGVyLXJhbmdlIHVpLXdpZGdldC1oZWFkZXJcIisoYi5yYW5nZT09PVwibWluXCJ8fGIucmFuZ2U9PT1cIm1heFwiP1wiIHVpLXNsaWRlci1yYW5nZS1cIitiLnJhbmdlOlwiXCIpKX1mb3IodmFyIGo9Yy5sZW5ndGg7ajxmO2orPTEpZS5wdXNoKFwiPGEgY2xhc3M9J3VpLXNsaWRlci1oYW5kbGUgdWktc3RhdGUtZGVmYXVsdCB1aS1jb3JuZXItYWxsJyBocmVmPScjJz48L2E+XCIpO1xyXG50aGlzLmhhbmRsZXM9Yy5hZGQoZChlLmpvaW4oXCJcIikpLmFwcGVuZFRvKGEuZWxlbWVudCkpO3RoaXMuaGFuZGxlPXRoaXMuaGFuZGxlcy5lcSgwKTt0aGlzLmhhbmRsZXMuYWRkKHRoaXMucmFuZ2UpLmZpbHRlcihcImFcIikuY2xpY2soZnVuY3Rpb24oZyl7Zy5wcmV2ZW50RGVmYXVsdCgpfSkuaG92ZXIoZnVuY3Rpb24oKXtiLmRpc2FibGVkfHxkKHRoaXMpLmFkZENsYXNzKFwidWktc3RhdGUtaG92ZXJcIil9LGZ1bmN0aW9uKCl7ZCh0aGlzKS5yZW1vdmVDbGFzcyhcInVpLXN0YXRlLWhvdmVyXCIpfSkuZm9jdXMoZnVuY3Rpb24oKXtpZihiLmRpc2FibGVkKWQodGhpcykuYmx1cigpO2Vsc2V7ZChcIi51aS1zbGlkZXIgLnVpLXN0YXRlLWZvY3VzXCIpLnJlbW92ZUNsYXNzKFwidWktc3RhdGUtZm9jdXNcIik7ZCh0aGlzKS5hZGRDbGFzcyhcInVpLXN0YXRlLWZvY3VzXCIpfX0pLmJsdXIoZnVuY3Rpb24oKXtkKHRoaXMpLnJlbW92ZUNsYXNzKFwidWktc3RhdGUtZm9jdXNcIil9KTt0aGlzLmhhbmRsZXMuZWFjaChmdW5jdGlvbihnKXtkKHRoaXMpLmRhdGEoXCJpbmRleC51aS1zbGlkZXItaGFuZGxlXCIsXHJcbmcpfSk7dGhpcy5oYW5kbGVzLmtleWRvd24oZnVuY3Rpb24oZyl7dmFyIGs9dHJ1ZSxsPWQodGhpcykuZGF0YShcImluZGV4LnVpLXNsaWRlci1oYW5kbGVcIiksaSxoLG07aWYoIWEub3B0aW9ucy5kaXNhYmxlZCl7c3dpdGNoKGcua2V5Q29kZSl7Y2FzZSBkLnVpLmtleUNvZGUuSE9NRTpjYXNlIGQudWkua2V5Q29kZS5FTkQ6Y2FzZSBkLnVpLmtleUNvZGUuUEFHRV9VUDpjYXNlIGQudWkua2V5Q29kZS5QQUdFX0RPV046Y2FzZSBkLnVpLmtleUNvZGUuVVA6Y2FzZSBkLnVpLmtleUNvZGUuUklHSFQ6Y2FzZSBkLnVpLmtleUNvZGUuRE9XTjpjYXNlIGQudWkua2V5Q29kZS5MRUZUOms9ZmFsc2U7aWYoIWEuX2tleVNsaWRpbmcpe2EuX2tleVNsaWRpbmc9dHJ1ZTtkKHRoaXMpLmFkZENsYXNzKFwidWktc3RhdGUtYWN0aXZlXCIpO2k9YS5fc3RhcnQoZyxsKTtpZihpPT09ZmFsc2UpcmV0dXJufWJyZWFrfW09YS5vcHRpb25zLnN0ZXA7aT1hLm9wdGlvbnMudmFsdWVzJiZhLm9wdGlvbnMudmFsdWVzLmxlbmd0aD9cclxuKGg9YS52YWx1ZXMobCkpOihoPWEudmFsdWUoKSk7c3dpdGNoKGcua2V5Q29kZSl7Y2FzZSBkLnVpLmtleUNvZGUuSE9NRTpoPWEuX3ZhbHVlTWluKCk7YnJlYWs7Y2FzZSBkLnVpLmtleUNvZGUuRU5EOmg9YS5fdmFsdWVNYXgoKTticmVhaztjYXNlIGQudWkua2V5Q29kZS5QQUdFX1VQOmg9YS5fdHJpbUFsaWduVmFsdWUoaSsoYS5fdmFsdWVNYXgoKS1hLl92YWx1ZU1pbigpKS81KTticmVhaztjYXNlIGQudWkua2V5Q29kZS5QQUdFX0RPV046aD1hLl90cmltQWxpZ25WYWx1ZShpLShhLl92YWx1ZU1heCgpLWEuX3ZhbHVlTWluKCkpLzUpO2JyZWFrO2Nhc2UgZC51aS5rZXlDb2RlLlVQOmNhc2UgZC51aS5rZXlDb2RlLlJJR0hUOmlmKGk9PT1hLl92YWx1ZU1heCgpKXJldHVybjtoPWEuX3RyaW1BbGlnblZhbHVlKGkrbSk7YnJlYWs7Y2FzZSBkLnVpLmtleUNvZGUuRE9XTjpjYXNlIGQudWkua2V5Q29kZS5MRUZUOmlmKGk9PT1hLl92YWx1ZU1pbigpKXJldHVybjtoPWEuX3RyaW1BbGlnblZhbHVlKGktXHJcbm0pO2JyZWFrfWEuX3NsaWRlKGcsbCxoKTtyZXR1cm4ga319KS5rZXl1cChmdW5jdGlvbihnKXt2YXIgaz1kKHRoaXMpLmRhdGEoXCJpbmRleC51aS1zbGlkZXItaGFuZGxlXCIpO2lmKGEuX2tleVNsaWRpbmcpe2EuX2tleVNsaWRpbmc9ZmFsc2U7YS5fc3RvcChnLGspO2EuX2NoYW5nZShnLGspO2QodGhpcykucmVtb3ZlQ2xhc3MoXCJ1aS1zdGF0ZS1hY3RpdmVcIil9fSk7dGhpcy5fcmVmcmVzaFZhbHVlKCk7dGhpcy5fYW5pbWF0ZU9mZj1mYWxzZX0sZGVzdHJveTpmdW5jdGlvbigpe3RoaXMuaGFuZGxlcy5yZW1vdmUoKTt0aGlzLnJhbmdlLnJlbW92ZSgpO3RoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyhcInVpLXNsaWRlciB1aS1zbGlkZXItaG9yaXpvbnRhbCB1aS1zbGlkZXItdmVydGljYWwgdWktc2xpZGVyLWRpc2FibGVkIHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsXCIpLnJlbW92ZURhdGEoXCJzbGlkZXJcIikudW5iaW5kKFwiLnNsaWRlclwiKTt0aGlzLl9tb3VzZURlc3Ryb3koKTtcclxucmV0dXJuIHRoaXN9LF9tb3VzZUNhcHR1cmU6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5vcHRpb25zLGMsZixlLGosZztpZihiLmRpc2FibGVkKXJldHVybiBmYWxzZTt0aGlzLmVsZW1lbnRTaXplPXt3aWR0aDp0aGlzLmVsZW1lbnQub3V0ZXJXaWR0aCgpLGhlaWdodDp0aGlzLmVsZW1lbnQub3V0ZXJIZWlnaHQoKX07dGhpcy5lbGVtZW50T2Zmc2V0PXRoaXMuZWxlbWVudC5vZmZzZXQoKTtjPXRoaXMuX25vcm1WYWx1ZUZyb21Nb3VzZSh7eDphLnBhZ2VYLHk6YS5wYWdlWX0pO2Y9dGhpcy5fdmFsdWVNYXgoKS10aGlzLl92YWx1ZU1pbigpKzE7aj10aGlzO3RoaXMuaGFuZGxlcy5lYWNoKGZ1bmN0aW9uKGspe3ZhciBsPU1hdGguYWJzKGMtai52YWx1ZXMoaykpO2lmKGY+bCl7Zj1sO2U9ZCh0aGlzKTtnPWt9fSk7aWYoYi5yYW5nZT09PXRydWUmJnRoaXMudmFsdWVzKDEpPT09Yi5taW4pe2crPTE7ZT1kKHRoaXMuaGFuZGxlc1tnXSl9aWYodGhpcy5fc3RhcnQoYSxnKT09PWZhbHNlKXJldHVybiBmYWxzZTtcclxudGhpcy5fbW91c2VTbGlkaW5nPXRydWU7ai5faGFuZGxlSW5kZXg9ZztlLmFkZENsYXNzKFwidWktc3RhdGUtYWN0aXZlXCIpLmZvY3VzKCk7Yj1lLm9mZnNldCgpO3RoaXMuX2NsaWNrT2Zmc2V0PSFkKGEudGFyZ2V0KS5wYXJlbnRzKCkuYW5kU2VsZigpLmlzKFwiLnVpLXNsaWRlci1oYW5kbGVcIik/e2xlZnQ6MCx0b3A6MH06e2xlZnQ6YS5wYWdlWC1iLmxlZnQtZS53aWR0aCgpLzIsdG9wOmEucGFnZVktYi50b3AtZS5oZWlnaHQoKS8yLShwYXJzZUludChlLmNzcyhcImJvcmRlclRvcFdpZHRoXCIpLDEwKXx8MCktKHBhcnNlSW50KGUuY3NzKFwiYm9yZGVyQm90dG9tV2lkdGhcIiksMTApfHwwKSsocGFyc2VJbnQoZS5jc3MoXCJtYXJnaW5Ub3BcIiksMTApfHwwKX07dGhpcy5oYW5kbGVzLmhhc0NsYXNzKFwidWktc3RhdGUtaG92ZXJcIil8fHRoaXMuX3NsaWRlKGEsZyxjKTtyZXR1cm4gdGhpcy5fYW5pbWF0ZU9mZj10cnVlfSxfbW91c2VTdGFydDpmdW5jdGlvbigpe3JldHVybiB0cnVlfSxfbW91c2VEcmFnOmZ1bmN0aW9uKGEpe3ZhciBiPVxyXG50aGlzLl9ub3JtVmFsdWVGcm9tTW91c2Uoe3g6YS5wYWdlWCx5OmEucGFnZVl9KTt0aGlzLl9zbGlkZShhLHRoaXMuX2hhbmRsZUluZGV4LGIpO3JldHVybiBmYWxzZX0sX21vdXNlU3RvcDpmdW5jdGlvbihhKXt0aGlzLmhhbmRsZXMucmVtb3ZlQ2xhc3MoXCJ1aS1zdGF0ZS1hY3RpdmVcIik7dGhpcy5fbW91c2VTbGlkaW5nPWZhbHNlO3RoaXMuX3N0b3AoYSx0aGlzLl9oYW5kbGVJbmRleCk7dGhpcy5fY2hhbmdlKGEsdGhpcy5faGFuZGxlSW5kZXgpO3RoaXMuX2NsaWNrT2Zmc2V0PXRoaXMuX2hhbmRsZUluZGV4PW51bGw7cmV0dXJuIHRoaXMuX2FuaW1hdGVPZmY9ZmFsc2V9LF9kZXRlY3RPcmllbnRhdGlvbjpmdW5jdGlvbigpe3RoaXMub3JpZW50YXRpb249dGhpcy5vcHRpb25zLm9yaWVudGF0aW9uPT09XCJ2ZXJ0aWNhbFwiP1widmVydGljYWxcIjpcImhvcml6b250YWxcIn0sX25vcm1WYWx1ZUZyb21Nb3VzZTpmdW5jdGlvbihhKXt2YXIgYjtpZih0aGlzLm9yaWVudGF0aW9uPT09XCJob3Jpem9udGFsXCIpe2I9XHJcbnRoaXMuZWxlbWVudFNpemUud2lkdGg7YT1hLngtdGhpcy5lbGVtZW50T2Zmc2V0LmxlZnQtKHRoaXMuX2NsaWNrT2Zmc2V0P3RoaXMuX2NsaWNrT2Zmc2V0LmxlZnQ6MCl9ZWxzZXtiPXRoaXMuZWxlbWVudFNpemUuaGVpZ2h0O2E9YS55LXRoaXMuZWxlbWVudE9mZnNldC50b3AtKHRoaXMuX2NsaWNrT2Zmc2V0P3RoaXMuX2NsaWNrT2Zmc2V0LnRvcDowKX1iPWEvYjtpZihiPjEpYj0xO2lmKGI8MCliPTA7aWYodGhpcy5vcmllbnRhdGlvbj09PVwidmVydGljYWxcIiliPTEtYjthPXRoaXMuX3ZhbHVlTWF4KCktdGhpcy5fdmFsdWVNaW4oKTtyZXR1cm4gdGhpcy5fdHJpbUFsaWduVmFsdWUodGhpcy5fdmFsdWVNaW4oKStiKmEpfSxfc3RhcnQ6ZnVuY3Rpb24oYSxiKXt2YXIgYz17aGFuZGxlOnRoaXMuaGFuZGxlc1tiXSx2YWx1ZTp0aGlzLnZhbHVlKCl9O2lmKHRoaXMub3B0aW9ucy52YWx1ZXMmJnRoaXMub3B0aW9ucy52YWx1ZXMubGVuZ3RoKXtjLnZhbHVlPXRoaXMudmFsdWVzKGIpO1xyXG5jLnZhbHVlcz10aGlzLnZhbHVlcygpfXJldHVybiB0aGlzLl90cmlnZ2VyKFwic3RhcnRcIixhLGMpfSxfc2xpZGU6ZnVuY3Rpb24oYSxiLGMpe3ZhciBmO2lmKHRoaXMub3B0aW9ucy52YWx1ZXMmJnRoaXMub3B0aW9ucy52YWx1ZXMubGVuZ3RoKXtmPXRoaXMudmFsdWVzKGI/MDoxKTtpZih0aGlzLm9wdGlvbnMudmFsdWVzLmxlbmd0aD09PTImJnRoaXMub3B0aW9ucy5yYW5nZT09PXRydWUmJihiPT09MCYmYz5mfHxiPT09MSYmYzxmKSljPWY7aWYoYyE9PXRoaXMudmFsdWVzKGIpKXtmPXRoaXMudmFsdWVzKCk7ZltiXT1jO2E9dGhpcy5fdHJpZ2dlcihcInNsaWRlXCIsYSx7aGFuZGxlOnRoaXMuaGFuZGxlc1tiXSx2YWx1ZTpjLHZhbHVlczpmfSk7dGhpcy52YWx1ZXMoYj8wOjEpO2EhPT1mYWxzZSYmdGhpcy52YWx1ZXMoYixjLHRydWUpfX1lbHNlIGlmKGMhPT10aGlzLnZhbHVlKCkpe2E9dGhpcy5fdHJpZ2dlcihcInNsaWRlXCIsYSx7aGFuZGxlOnRoaXMuaGFuZGxlc1tiXSx2YWx1ZTpjfSk7XHJcbmEhPT1mYWxzZSYmdGhpcy52YWx1ZShjKX19LF9zdG9wOmZ1bmN0aW9uKGEsYil7dmFyIGM9e2hhbmRsZTp0aGlzLmhhbmRsZXNbYl0sdmFsdWU6dGhpcy52YWx1ZSgpfTtpZih0aGlzLm9wdGlvbnMudmFsdWVzJiZ0aGlzLm9wdGlvbnMudmFsdWVzLmxlbmd0aCl7Yy52YWx1ZT10aGlzLnZhbHVlcyhiKTtjLnZhbHVlcz10aGlzLnZhbHVlcygpfXRoaXMuX3RyaWdnZXIoXCJzdG9wXCIsYSxjKX0sX2NoYW5nZTpmdW5jdGlvbihhLGIpe2lmKCF0aGlzLl9rZXlTbGlkaW5nJiYhdGhpcy5fbW91c2VTbGlkaW5nKXt2YXIgYz17aGFuZGxlOnRoaXMuaGFuZGxlc1tiXSx2YWx1ZTp0aGlzLnZhbHVlKCl9O2lmKHRoaXMub3B0aW9ucy52YWx1ZXMmJnRoaXMub3B0aW9ucy52YWx1ZXMubGVuZ3RoKXtjLnZhbHVlPXRoaXMudmFsdWVzKGIpO2MudmFsdWVzPXRoaXMudmFsdWVzKCl9dGhpcy5fdHJpZ2dlcihcImNoYW5nZVwiLGEsYyl9fSx2YWx1ZTpmdW5jdGlvbihhKXtpZihhcmd1bWVudHMubGVuZ3RoKXt0aGlzLm9wdGlvbnMudmFsdWU9XHJcbnRoaXMuX3RyaW1BbGlnblZhbHVlKGEpO3RoaXMuX3JlZnJlc2hWYWx1ZSgpO3RoaXMuX2NoYW5nZShudWxsLDApfWVsc2UgcmV0dXJuIHRoaXMuX3ZhbHVlKCl9LHZhbHVlczpmdW5jdGlvbihhLGIpe3ZhciBjLGYsZTtpZihhcmd1bWVudHMubGVuZ3RoPjEpe3RoaXMub3B0aW9ucy52YWx1ZXNbYV09dGhpcy5fdHJpbUFsaWduVmFsdWUoYik7dGhpcy5fcmVmcmVzaFZhbHVlKCk7dGhpcy5fY2hhbmdlKG51bGwsYSl9ZWxzZSBpZihhcmd1bWVudHMubGVuZ3RoKWlmKGQuaXNBcnJheShhcmd1bWVudHNbMF0pKXtjPXRoaXMub3B0aW9ucy52YWx1ZXM7Zj1hcmd1bWVudHNbMF07Zm9yKGU9MDtlPGMubGVuZ3RoO2UrPTEpe2NbZV09dGhpcy5fdHJpbUFsaWduVmFsdWUoZltlXSk7dGhpcy5fY2hhbmdlKG51bGwsZSl9dGhpcy5fcmVmcmVzaFZhbHVlKCl9ZWxzZSByZXR1cm4gdGhpcy5vcHRpb25zLnZhbHVlcyYmdGhpcy5vcHRpb25zLnZhbHVlcy5sZW5ndGg/dGhpcy5fdmFsdWVzKGEpOlxyXG50aGlzLnZhbHVlKCk7ZWxzZSByZXR1cm4gdGhpcy5fdmFsdWVzKCl9LF9zZXRPcHRpb246ZnVuY3Rpb24oYSxiKXt2YXIgYyxmPTA7aWYoZC5pc0FycmF5KHRoaXMub3B0aW9ucy52YWx1ZXMpKWY9dGhpcy5vcHRpb25zLnZhbHVlcy5sZW5ndGg7ZC5XaWRnZXQucHJvdG90eXBlLl9zZXRPcHRpb24uYXBwbHkodGhpcyxhcmd1bWVudHMpO3N3aXRjaChhKXtjYXNlIFwiZGlzYWJsZWRcIjppZihiKXt0aGlzLmhhbmRsZXMuZmlsdGVyKFwiLnVpLXN0YXRlLWZvY3VzXCIpLmJsdXIoKTt0aGlzLmhhbmRsZXMucmVtb3ZlQ2xhc3MoXCJ1aS1zdGF0ZS1ob3ZlclwiKTt0aGlzLmhhbmRsZXMucHJvcEF0dHIoXCJkaXNhYmxlZFwiLHRydWUpO3RoaXMuZWxlbWVudC5hZGRDbGFzcyhcInVpLWRpc2FibGVkXCIpfWVsc2V7dGhpcy5oYW5kbGVzLnByb3BBdHRyKFwiZGlzYWJsZWRcIixmYWxzZSk7dGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKFwidWktZGlzYWJsZWRcIil9YnJlYWs7Y2FzZSBcIm9yaWVudGF0aW9uXCI6dGhpcy5fZGV0ZWN0T3JpZW50YXRpb24oKTtcclxudGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKFwidWktc2xpZGVyLWhvcml6b250YWwgdWktc2xpZGVyLXZlcnRpY2FsXCIpLmFkZENsYXNzKFwidWktc2xpZGVyLVwiK3RoaXMub3JpZW50YXRpb24pO3RoaXMuX3JlZnJlc2hWYWx1ZSgpO2JyZWFrO2Nhc2UgXCJ2YWx1ZVwiOnRoaXMuX2FuaW1hdGVPZmY9dHJ1ZTt0aGlzLl9yZWZyZXNoVmFsdWUoKTt0aGlzLl9jaGFuZ2UobnVsbCwwKTt0aGlzLl9hbmltYXRlT2ZmPWZhbHNlO2JyZWFrO2Nhc2UgXCJ2YWx1ZXNcIjp0aGlzLl9hbmltYXRlT2ZmPXRydWU7dGhpcy5fcmVmcmVzaFZhbHVlKCk7Zm9yKGM9MDtjPGY7Yys9MSl0aGlzLl9jaGFuZ2UobnVsbCxjKTt0aGlzLl9hbmltYXRlT2ZmPWZhbHNlO2JyZWFrfX0sX3ZhbHVlOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5vcHRpb25zLnZhbHVlO3JldHVybiBhPXRoaXMuX3RyaW1BbGlnblZhbHVlKGEpfSxfdmFsdWVzOmZ1bmN0aW9uKGEpe3ZhciBiLGM7aWYoYXJndW1lbnRzLmxlbmd0aCl7Yj10aGlzLm9wdGlvbnMudmFsdWVzW2FdO1xyXG5yZXR1cm4gYj10aGlzLl90cmltQWxpZ25WYWx1ZShiKX1lbHNle2I9dGhpcy5vcHRpb25zLnZhbHVlcy5zbGljZSgpO2ZvcihjPTA7YzxiLmxlbmd0aDtjKz0xKWJbY109dGhpcy5fdHJpbUFsaWduVmFsdWUoYltjXSk7cmV0dXJuIGJ9fSxfdHJpbUFsaWduVmFsdWU6ZnVuY3Rpb24oYSl7aWYoYTw9dGhpcy5fdmFsdWVNaW4oKSlyZXR1cm4gdGhpcy5fdmFsdWVNaW4oKTtpZihhPj10aGlzLl92YWx1ZU1heCgpKXJldHVybiB0aGlzLl92YWx1ZU1heCgpO3ZhciBiPXRoaXMub3B0aW9ucy5zdGVwPjA/dGhpcy5vcHRpb25zLnN0ZXA6MSxjPShhLXRoaXMuX3ZhbHVlTWluKCkpJWI7YT1hLWM7aWYoTWF0aC5hYnMoYykqMj49YilhKz1jPjA/YjotYjtyZXR1cm4gcGFyc2VGbG9hdChhLnRvRml4ZWQoNSkpfSxfdmFsdWVNaW46ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vcHRpb25zLm1pbn0sX3ZhbHVlTWF4OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3B0aW9ucy5tYXh9LF9yZWZyZXNoVmFsdWU6ZnVuY3Rpb24oKXt2YXIgYT1cclxudGhpcy5vcHRpb25zLnJhbmdlLGI9dGhpcy5vcHRpb25zLGM9dGhpcyxmPSF0aGlzLl9hbmltYXRlT2ZmP2IuYW5pbWF0ZTpmYWxzZSxlLGo9e30sZyxrLGwsaTtpZih0aGlzLm9wdGlvbnMudmFsdWVzJiZ0aGlzLm9wdGlvbnMudmFsdWVzLmxlbmd0aCl0aGlzLmhhbmRsZXMuZWFjaChmdW5jdGlvbihoKXtlPShjLnZhbHVlcyhoKS1jLl92YWx1ZU1pbigpKS8oYy5fdmFsdWVNYXgoKS1jLl92YWx1ZU1pbigpKSoxMDA7altjLm9yaWVudGF0aW9uPT09XCJob3Jpem9udGFsXCI/XCJsZWZ0XCI6XCJib3R0b21cIl09ZStcIiVcIjtkKHRoaXMpLnN0b3AoMSwxKVtmP1wiYW5pbWF0ZVwiOlwiY3NzXCJdKGosYi5hbmltYXRlKTtpZihjLm9wdGlvbnMucmFuZ2U9PT10cnVlKWlmKGMub3JpZW50YXRpb249PT1cImhvcml6b250YWxcIil7aWYoaD09PTApYy5yYW5nZS5zdG9wKDEsMSlbZj9cImFuaW1hdGVcIjpcImNzc1wiXSh7bGVmdDplK1wiJVwifSxiLmFuaW1hdGUpO2lmKGg9PT0xKWMucmFuZ2VbZj9cImFuaW1hdGVcIjpcImNzc1wiXSh7d2lkdGg6ZS1cclxuZytcIiVcIn0se3F1ZXVlOmZhbHNlLGR1cmF0aW9uOmIuYW5pbWF0ZX0pfWVsc2V7aWYoaD09PTApYy5yYW5nZS5zdG9wKDEsMSlbZj9cImFuaW1hdGVcIjpcImNzc1wiXSh7Ym90dG9tOmUrXCIlXCJ9LGIuYW5pbWF0ZSk7aWYoaD09PTEpYy5yYW5nZVtmP1wiYW5pbWF0ZVwiOlwiY3NzXCJdKHtoZWlnaHQ6ZS1nK1wiJVwifSx7cXVldWU6ZmFsc2UsZHVyYXRpb246Yi5hbmltYXRlfSl9Zz1lfSk7ZWxzZXtrPXRoaXMudmFsdWUoKTtsPXRoaXMuX3ZhbHVlTWluKCk7aT10aGlzLl92YWx1ZU1heCgpO2U9aSE9PWw/KGstbCkvKGktbCkqMTAwOjA7altjLm9yaWVudGF0aW9uPT09XCJob3Jpem9udGFsXCI/XCJsZWZ0XCI6XCJib3R0b21cIl09ZStcIiVcIjt0aGlzLmhhbmRsZS5zdG9wKDEsMSlbZj9cImFuaW1hdGVcIjpcImNzc1wiXShqLGIuYW5pbWF0ZSk7aWYoYT09PVwibWluXCImJnRoaXMub3JpZW50YXRpb249PT1cImhvcml6b250YWxcIil0aGlzLnJhbmdlLnN0b3AoMSwxKVtmP1wiYW5pbWF0ZVwiOlwiY3NzXCJdKHt3aWR0aDplK1wiJVwifSxcclxuYi5hbmltYXRlKTtpZihhPT09XCJtYXhcIiYmdGhpcy5vcmllbnRhdGlvbj09PVwiaG9yaXpvbnRhbFwiKXRoaXMucmFuZ2VbZj9cImFuaW1hdGVcIjpcImNzc1wiXSh7d2lkdGg6MTAwLWUrXCIlXCJ9LHtxdWV1ZTpmYWxzZSxkdXJhdGlvbjpiLmFuaW1hdGV9KTtpZihhPT09XCJtaW5cIiYmdGhpcy5vcmllbnRhdGlvbj09PVwidmVydGljYWxcIil0aGlzLnJhbmdlLnN0b3AoMSwxKVtmP1wiYW5pbWF0ZVwiOlwiY3NzXCJdKHtoZWlnaHQ6ZStcIiVcIn0sYi5hbmltYXRlKTtpZihhPT09XCJtYXhcIiYmdGhpcy5vcmllbnRhdGlvbj09PVwidmVydGljYWxcIil0aGlzLnJhbmdlW2Y/XCJhbmltYXRlXCI6XCJjc3NcIl0oe2hlaWdodDoxMDAtZStcIiVcIn0se3F1ZXVlOmZhbHNlLGR1cmF0aW9uOmIuYW5pbWF0ZX0pfX19KTtkLmV4dGVuZChkLnVpLnNsaWRlcix7dmVyc2lvbjpcIjEuOC4xNlwifSl9KShqUXVlcnkpO1xyXG47LypcclxuICogalF1ZXJ5IFVJIFRhYnMgMS44LjE2XHJcbiAqXHJcbiAqIENvcHlyaWdodCAyMDExLCBBVVRIT1JTLnR4dCAoaHR0cDovL2pxdWVyeXVpLmNvbS9hYm91dClcclxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIG9yIEdQTCBWZXJzaW9uIDIgbGljZW5zZXMuXHJcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcclxuICpcclxuICogaHR0cDovL2RvY3MuanF1ZXJ5LmNvbS9VSS9UYWJzXHJcbiAqXHJcbiAqIERlcGVuZHM6XHJcbiAqXHRqcXVlcnkudWkuY29yZS5qc1xyXG4gKlx0anF1ZXJ5LnVpLndpZGdldC5qc1xyXG4gKi9cclxuKGZ1bmN0aW9uKGQscCl7ZnVuY3Rpb24gdSgpe3JldHVybisrdn1mdW5jdGlvbiB3KCl7cmV0dXJuKyt4fXZhciB2PTAseD0wO2Qud2lkZ2V0KFwidWkudGFic1wiLHtvcHRpb25zOnthZGQ6bnVsbCxhamF4T3B0aW9uczpudWxsLGNhY2hlOmZhbHNlLGNvb2tpZTpudWxsLGNvbGxhcHNpYmxlOmZhbHNlLGRpc2FibGU6bnVsbCxkaXNhYmxlZDpbXSxlbmFibGU6bnVsbCxldmVudDpcImNsaWNrXCIsZng6bnVsbCxpZFByZWZpeDpcInVpLXRhYnMtXCIsbG9hZDpudWxsLHBhbmVsVGVtcGxhdGU6XCI8ZGl2PjwvZGl2PlwiLHJlbW92ZTpudWxsLHNlbGVjdDpudWxsLHNob3c6bnVsbCxzcGlubmVyOlwiPGVtPkxvYWRpbmcmIzgyMzA7PC9lbT5cIix0YWJUZW1wbGF0ZTpcIjxsaT48YSBocmVmPScje2hyZWZ9Jz48c3Bhbj4je2xhYmVsfTwvc3Bhbj48L2E+PC9saT5cIn0sX2NyZWF0ZTpmdW5jdGlvbigpe3RoaXMuX3RhYmlmeSh0cnVlKX0sX3NldE9wdGlvbjpmdW5jdGlvbihiLGUpe2lmKGI9PVwic2VsZWN0ZWRcIil0aGlzLm9wdGlvbnMuY29sbGFwc2libGUmJlxyXG5lPT10aGlzLm9wdGlvbnMuc2VsZWN0ZWR8fHRoaXMuc2VsZWN0KGUpO2Vsc2V7dGhpcy5vcHRpb25zW2JdPWU7dGhpcy5fdGFiaWZ5KCl9fSxfdGFiSWQ6ZnVuY3Rpb24oYil7cmV0dXJuIGIudGl0bGUmJmIudGl0bGUucmVwbGFjZSgvXFxzL2csXCJfXCIpLnJlcGxhY2UoL1teXFx3XFx1MDBjMC1cXHVGRkZGLV0vZyxcIlwiKXx8dGhpcy5vcHRpb25zLmlkUHJlZml4K3UoKX0sX3Nhbml0aXplU2VsZWN0b3I6ZnVuY3Rpb24oYil7cmV0dXJuIGIucmVwbGFjZSgvOi9nLFwiXFxcXDpcIil9LF9jb29raWU6ZnVuY3Rpb24oKXt2YXIgYj10aGlzLmNvb2tpZXx8KHRoaXMuY29va2llPXRoaXMub3B0aW9ucy5jb29raWUubmFtZXx8XCJ1aS10YWJzLVwiK3coKSk7cmV0dXJuIGQuY29va2llLmFwcGx5KG51bGwsW2JdLmNvbmNhdChkLm1ha2VBcnJheShhcmd1bWVudHMpKSl9LF91aTpmdW5jdGlvbihiLGUpe3JldHVybnt0YWI6YixwYW5lbDplLGluZGV4OnRoaXMuYW5jaG9ycy5pbmRleChiKX19LF9jbGVhbnVwOmZ1bmN0aW9uKCl7dGhpcy5saXMuZmlsdGVyKFwiLnVpLXN0YXRlLXByb2Nlc3NpbmdcIikucmVtb3ZlQ2xhc3MoXCJ1aS1zdGF0ZS1wcm9jZXNzaW5nXCIpLmZpbmQoXCJzcGFuOmRhdGEobGFiZWwudGFicylcIikuZWFjaChmdW5jdGlvbigpe3ZhciBiPVxyXG5kKHRoaXMpO2IuaHRtbChiLmRhdGEoXCJsYWJlbC50YWJzXCIpKS5yZW1vdmVEYXRhKFwibGFiZWwudGFic1wiKX0pfSxfdGFiaWZ5OmZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGUoZyxmKXtnLmNzcyhcImRpc3BsYXlcIixcIlwiKTshZC5zdXBwb3J0Lm9wYWNpdHkmJmYub3BhY2l0eSYmZ1swXS5zdHlsZS5yZW1vdmVBdHRyaWJ1dGUoXCJmaWx0ZXJcIil9dmFyIGE9dGhpcyxjPXRoaXMub3B0aW9ucyxoPS9eIy4rLzt0aGlzLmxpc3Q9dGhpcy5lbGVtZW50LmZpbmQoXCJvbCx1bFwiKS5lcSgwKTt0aGlzLmxpcz1kKFwiID4gbGk6aGFzKGFbaHJlZl0pXCIsdGhpcy5saXN0KTt0aGlzLmFuY2hvcnM9dGhpcy5saXMubWFwKGZ1bmN0aW9uKCl7cmV0dXJuIGQoXCJhXCIsdGhpcylbMF19KTt0aGlzLnBhbmVscz1kKFtdKTt0aGlzLmFuY2hvcnMuZWFjaChmdW5jdGlvbihnLGYpe3ZhciBpPWQoZikuYXR0cihcImhyZWZcIiksbD1pLnNwbGl0KFwiI1wiKVswXSxxO2lmKGwmJihsPT09bG9jYXRpb24udG9TdHJpbmcoKS5zcGxpdChcIiNcIilbMF18fFxyXG4ocT1kKFwiYmFzZVwiKVswXSkmJmw9PT1xLmhyZWYpKXtpPWYuaGFzaDtmLmhyZWY9aX1pZihoLnRlc3QoaSkpYS5wYW5lbHM9YS5wYW5lbHMuYWRkKGEuZWxlbWVudC5maW5kKGEuX3Nhbml0aXplU2VsZWN0b3IoaSkpKTtlbHNlIGlmKGkmJmkhPT1cIiNcIil7ZC5kYXRhKGYsXCJocmVmLnRhYnNcIixpKTtkLmRhdGEoZixcImxvYWQudGFic1wiLGkucmVwbGFjZSgvIy4qJC8sXCJcIikpO2k9YS5fdGFiSWQoZik7Zi5ocmVmPVwiI1wiK2k7Zj1hLmVsZW1lbnQuZmluZChcIiNcIitpKTtpZighZi5sZW5ndGgpe2Y9ZChjLnBhbmVsVGVtcGxhdGUpLmF0dHIoXCJpZFwiLGkpLmFkZENsYXNzKFwidWktdGFicy1wYW5lbCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYm90dG9tXCIpLmluc2VydEFmdGVyKGEucGFuZWxzW2ctMV18fGEubGlzdCk7Zi5kYXRhKFwiZGVzdHJveS50YWJzXCIsdHJ1ZSl9YS5wYW5lbHM9YS5wYW5lbHMuYWRkKGYpfWVsc2UgYy5kaXNhYmxlZC5wdXNoKGcpfSk7aWYoYil7dGhpcy5lbGVtZW50LmFkZENsYXNzKFwidWktdGFicyB1aS13aWRnZXQgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWFsbFwiKTtcclxudGhpcy5saXN0LmFkZENsYXNzKFwidWktdGFicy1uYXYgdWktaGVscGVyLXJlc2V0IHVpLWhlbHBlci1jbGVhcmZpeCB1aS13aWRnZXQtaGVhZGVyIHVpLWNvcm5lci1hbGxcIik7dGhpcy5saXMuYWRkQ2xhc3MoXCJ1aS1zdGF0ZS1kZWZhdWx0IHVpLWNvcm5lci10b3BcIik7dGhpcy5wYW5lbHMuYWRkQ2xhc3MoXCJ1aS10YWJzLXBhbmVsIHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1ib3R0b21cIik7aWYoYy5zZWxlY3RlZD09PXApe2xvY2F0aW9uLmhhc2gmJnRoaXMuYW5jaG9ycy5lYWNoKGZ1bmN0aW9uKGcsZil7aWYoZi5oYXNoPT1sb2NhdGlvbi5oYXNoKXtjLnNlbGVjdGVkPWc7cmV0dXJuIGZhbHNlfX0pO2lmKHR5cGVvZiBjLnNlbGVjdGVkIT09XCJudW1iZXJcIiYmYy5jb29raWUpYy5zZWxlY3RlZD1wYXJzZUludChhLl9jb29raWUoKSwxMCk7aWYodHlwZW9mIGMuc2VsZWN0ZWQhPT1cIm51bWJlclwiJiZ0aGlzLmxpcy5maWx0ZXIoXCIudWktdGFicy1zZWxlY3RlZFwiKS5sZW5ndGgpYy5zZWxlY3RlZD1cclxudGhpcy5saXMuaW5kZXgodGhpcy5saXMuZmlsdGVyKFwiLnVpLXRhYnMtc2VsZWN0ZWRcIikpO2Muc2VsZWN0ZWQ9Yy5zZWxlY3RlZHx8KHRoaXMubGlzLmxlbmd0aD8wOi0xKX1lbHNlIGlmKGMuc2VsZWN0ZWQ9PT1udWxsKWMuc2VsZWN0ZWQ9LTE7Yy5zZWxlY3RlZD1jLnNlbGVjdGVkPj0wJiZ0aGlzLmFuY2hvcnNbYy5zZWxlY3RlZF18fGMuc2VsZWN0ZWQ8MD9jLnNlbGVjdGVkOjA7Yy5kaXNhYmxlZD1kLnVuaXF1ZShjLmRpc2FibGVkLmNvbmNhdChkLm1hcCh0aGlzLmxpcy5maWx0ZXIoXCIudWktc3RhdGUtZGlzYWJsZWRcIiksZnVuY3Rpb24oZyl7cmV0dXJuIGEubGlzLmluZGV4KGcpfSkpKS5zb3J0KCk7ZC5pbkFycmF5KGMuc2VsZWN0ZWQsYy5kaXNhYmxlZCkhPS0xJiZjLmRpc2FibGVkLnNwbGljZShkLmluQXJyYXkoYy5zZWxlY3RlZCxjLmRpc2FibGVkKSwxKTt0aGlzLnBhbmVscy5hZGRDbGFzcyhcInVpLXRhYnMtaGlkZVwiKTt0aGlzLmxpcy5yZW1vdmVDbGFzcyhcInVpLXRhYnMtc2VsZWN0ZWQgdWktc3RhdGUtYWN0aXZlXCIpO1xyXG5pZihjLnNlbGVjdGVkPj0wJiZ0aGlzLmFuY2hvcnMubGVuZ3RoKXthLmVsZW1lbnQuZmluZChhLl9zYW5pdGl6ZVNlbGVjdG9yKGEuYW5jaG9yc1tjLnNlbGVjdGVkXS5oYXNoKSkucmVtb3ZlQ2xhc3MoXCJ1aS10YWJzLWhpZGVcIik7dGhpcy5saXMuZXEoYy5zZWxlY3RlZCkuYWRkQ2xhc3MoXCJ1aS10YWJzLXNlbGVjdGVkIHVpLXN0YXRlLWFjdGl2ZVwiKTthLmVsZW1lbnQucXVldWUoXCJ0YWJzXCIsZnVuY3Rpb24oKXthLl90cmlnZ2VyKFwic2hvd1wiLG51bGwsYS5fdWkoYS5hbmNob3JzW2Muc2VsZWN0ZWRdLGEuZWxlbWVudC5maW5kKGEuX3Nhbml0aXplU2VsZWN0b3IoYS5hbmNob3JzW2Muc2VsZWN0ZWRdLmhhc2gpKVswXSkpfSk7dGhpcy5sb2FkKGMuc2VsZWN0ZWQpfWQod2luZG93KS5iaW5kKFwidW5sb2FkXCIsZnVuY3Rpb24oKXthLmxpcy5hZGQoYS5hbmNob3JzKS51bmJpbmQoXCIudGFic1wiKTthLmxpcz1hLmFuY2hvcnM9YS5wYW5lbHM9bnVsbH0pfWVsc2UgYy5zZWxlY3RlZD10aGlzLmxpcy5pbmRleCh0aGlzLmxpcy5maWx0ZXIoXCIudWktdGFicy1zZWxlY3RlZFwiKSk7XHJcbnRoaXMuZWxlbWVudFtjLmNvbGxhcHNpYmxlP1wiYWRkQ2xhc3NcIjpcInJlbW92ZUNsYXNzXCJdKFwidWktdGFicy1jb2xsYXBzaWJsZVwiKTtjLmNvb2tpZSYmdGhpcy5fY29va2llKGMuc2VsZWN0ZWQsYy5jb29raWUpO2I9MDtmb3IodmFyIGo7aj10aGlzLmxpc1tiXTtiKyspZChqKVtkLmluQXJyYXkoYixjLmRpc2FibGVkKSE9LTEmJiFkKGopLmhhc0NsYXNzKFwidWktdGFicy1zZWxlY3RlZFwiKT9cImFkZENsYXNzXCI6XCJyZW1vdmVDbGFzc1wiXShcInVpLXN0YXRlLWRpc2FibGVkXCIpO2MuY2FjaGU9PT1mYWxzZSYmdGhpcy5hbmNob3JzLnJlbW92ZURhdGEoXCJjYWNoZS50YWJzXCIpO3RoaXMubGlzLmFkZCh0aGlzLmFuY2hvcnMpLnVuYmluZChcIi50YWJzXCIpO2lmKGMuZXZlbnQhPT1cIm1vdXNlb3ZlclwiKXt2YXIgaz1mdW5jdGlvbihnLGYpe2YuaXMoXCI6bm90KC51aS1zdGF0ZS1kaXNhYmxlZClcIikmJmYuYWRkQ2xhc3MoXCJ1aS1zdGF0ZS1cIitnKX0sbj1mdW5jdGlvbihnLGYpe2YucmVtb3ZlQ2xhc3MoXCJ1aS1zdGF0ZS1cIitcclxuZyl9O3RoaXMubGlzLmJpbmQoXCJtb3VzZW92ZXIudGFic1wiLGZ1bmN0aW9uKCl7ayhcImhvdmVyXCIsZCh0aGlzKSl9KTt0aGlzLmxpcy5iaW5kKFwibW91c2VvdXQudGFic1wiLGZ1bmN0aW9uKCl7bihcImhvdmVyXCIsZCh0aGlzKSl9KTt0aGlzLmFuY2hvcnMuYmluZChcImZvY3VzLnRhYnNcIixmdW5jdGlvbigpe2soXCJmb2N1c1wiLGQodGhpcykuY2xvc2VzdChcImxpXCIpKX0pO3RoaXMuYW5jaG9ycy5iaW5kKFwiYmx1ci50YWJzXCIsZnVuY3Rpb24oKXtuKFwiZm9jdXNcIixkKHRoaXMpLmNsb3Nlc3QoXCJsaVwiKSl9KX12YXIgbSxvO2lmKGMuZngpaWYoZC5pc0FycmF5KGMuZngpKXttPWMuZnhbMF07bz1jLmZ4WzFdfWVsc2UgbT1vPWMuZng7dmFyIHI9bz9mdW5jdGlvbihnLGYpe2QoZykuY2xvc2VzdChcImxpXCIpLmFkZENsYXNzKFwidWktdGFicy1zZWxlY3RlZCB1aS1zdGF0ZS1hY3RpdmVcIik7Zi5oaWRlKCkucmVtb3ZlQ2xhc3MoXCJ1aS10YWJzLWhpZGVcIikuYW5pbWF0ZShvLG8uZHVyYXRpb258fFwibm9ybWFsXCIsXHJcbmZ1bmN0aW9uKCl7ZShmLG8pO2EuX3RyaWdnZXIoXCJzaG93XCIsbnVsbCxhLl91aShnLGZbMF0pKX0pfTpmdW5jdGlvbihnLGYpe2QoZykuY2xvc2VzdChcImxpXCIpLmFkZENsYXNzKFwidWktdGFicy1zZWxlY3RlZCB1aS1zdGF0ZS1hY3RpdmVcIik7Zi5yZW1vdmVDbGFzcyhcInVpLXRhYnMtaGlkZVwiKTthLl90cmlnZ2VyKFwic2hvd1wiLG51bGwsYS5fdWkoZyxmWzBdKSl9LHM9bT9mdW5jdGlvbihnLGYpe2YuYW5pbWF0ZShtLG0uZHVyYXRpb258fFwibm9ybWFsXCIsZnVuY3Rpb24oKXthLmxpcy5yZW1vdmVDbGFzcyhcInVpLXRhYnMtc2VsZWN0ZWQgdWktc3RhdGUtYWN0aXZlXCIpO2YuYWRkQ2xhc3MoXCJ1aS10YWJzLWhpZGVcIik7ZShmLG0pO2EuZWxlbWVudC5kZXF1ZXVlKFwidGFic1wiKX0pfTpmdW5jdGlvbihnLGYpe2EubGlzLnJlbW92ZUNsYXNzKFwidWktdGFicy1zZWxlY3RlZCB1aS1zdGF0ZS1hY3RpdmVcIik7Zi5hZGRDbGFzcyhcInVpLXRhYnMtaGlkZVwiKTthLmVsZW1lbnQuZGVxdWV1ZShcInRhYnNcIil9O1xyXG50aGlzLmFuY2hvcnMuYmluZChjLmV2ZW50K1wiLnRhYnNcIixmdW5jdGlvbigpe3ZhciBnPXRoaXMsZj1kKGcpLmNsb3Nlc3QoXCJsaVwiKSxpPWEucGFuZWxzLmZpbHRlcihcIjpub3QoLnVpLXRhYnMtaGlkZSlcIiksbD1hLmVsZW1lbnQuZmluZChhLl9zYW5pdGl6ZVNlbGVjdG9yKGcuaGFzaCkpO2lmKGYuaGFzQ2xhc3MoXCJ1aS10YWJzLXNlbGVjdGVkXCIpJiYhYy5jb2xsYXBzaWJsZXx8Zi5oYXNDbGFzcyhcInVpLXN0YXRlLWRpc2FibGVkXCIpfHxmLmhhc0NsYXNzKFwidWktc3RhdGUtcHJvY2Vzc2luZ1wiKXx8YS5wYW5lbHMuZmlsdGVyKFwiOmFuaW1hdGVkXCIpLmxlbmd0aHx8YS5fdHJpZ2dlcihcInNlbGVjdFwiLG51bGwsYS5fdWkodGhpcyxsWzBdKSk9PT1mYWxzZSl7dGhpcy5ibHVyKCk7cmV0dXJuIGZhbHNlfWMuc2VsZWN0ZWQ9YS5hbmNob3JzLmluZGV4KHRoaXMpO2EuYWJvcnQoKTtpZihjLmNvbGxhcHNpYmxlKWlmKGYuaGFzQ2xhc3MoXCJ1aS10YWJzLXNlbGVjdGVkXCIpKXtjLnNlbGVjdGVkPVxyXG4tMTtjLmNvb2tpZSYmYS5fY29va2llKGMuc2VsZWN0ZWQsYy5jb29raWUpO2EuZWxlbWVudC5xdWV1ZShcInRhYnNcIixmdW5jdGlvbigpe3MoZyxpKX0pLmRlcXVldWUoXCJ0YWJzXCIpO3RoaXMuYmx1cigpO3JldHVybiBmYWxzZX1lbHNlIGlmKCFpLmxlbmd0aCl7Yy5jb29raWUmJmEuX2Nvb2tpZShjLnNlbGVjdGVkLGMuY29va2llKTthLmVsZW1lbnQucXVldWUoXCJ0YWJzXCIsZnVuY3Rpb24oKXtyKGcsbCl9KTthLmxvYWQoYS5hbmNob3JzLmluZGV4KHRoaXMpKTt0aGlzLmJsdXIoKTtyZXR1cm4gZmFsc2V9Yy5jb29raWUmJmEuX2Nvb2tpZShjLnNlbGVjdGVkLGMuY29va2llKTtpZihsLmxlbmd0aCl7aS5sZW5ndGgmJmEuZWxlbWVudC5xdWV1ZShcInRhYnNcIixmdW5jdGlvbigpe3MoZyxpKX0pO2EuZWxlbWVudC5xdWV1ZShcInRhYnNcIixmdW5jdGlvbigpe3IoZyxsKX0pO2EubG9hZChhLmFuY2hvcnMuaW5kZXgodGhpcykpfWVsc2UgdGhyb3dcImpRdWVyeSBVSSBUYWJzOiBNaXNtYXRjaGluZyBmcmFnbWVudCBpZGVudGlmaWVyLlwiO1xyXG5kLmJyb3dzZXIubXNpZSYmdGhpcy5ibHVyKCl9KTt0aGlzLmFuY2hvcnMuYmluZChcImNsaWNrLnRhYnNcIixmdW5jdGlvbigpe3JldHVybiBmYWxzZX0pfSxfZ2V0SW5kZXg6ZnVuY3Rpb24oYil7aWYodHlwZW9mIGI9PVwic3RyaW5nXCIpYj10aGlzLmFuY2hvcnMuaW5kZXgodGhpcy5hbmNob3JzLmZpbHRlcihcIltocmVmJD1cIitiK1wiXVwiKSk7cmV0dXJuIGJ9LGRlc3Ryb3k6ZnVuY3Rpb24oKXt2YXIgYj10aGlzLm9wdGlvbnM7dGhpcy5hYm9ydCgpO3RoaXMuZWxlbWVudC51bmJpbmQoXCIudGFic1wiKS5yZW1vdmVDbGFzcyhcInVpLXRhYnMgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGwgdWktdGFicy1jb2xsYXBzaWJsZVwiKS5yZW1vdmVEYXRhKFwidGFic1wiKTt0aGlzLmxpc3QucmVtb3ZlQ2xhc3MoXCJ1aS10YWJzLW5hdiB1aS1oZWxwZXItcmVzZXQgdWktaGVscGVyLWNsZWFyZml4IHVpLXdpZGdldC1oZWFkZXIgdWktY29ybmVyLWFsbFwiKTt0aGlzLmFuY2hvcnMuZWFjaChmdW5jdGlvbigpe3ZhciBlPVxyXG5kLmRhdGEodGhpcyxcImhyZWYudGFic1wiKTtpZihlKXRoaXMuaHJlZj1lO3ZhciBhPWQodGhpcykudW5iaW5kKFwiLnRhYnNcIik7ZC5lYWNoKFtcImhyZWZcIixcImxvYWRcIixcImNhY2hlXCJdLGZ1bmN0aW9uKGMsaCl7YS5yZW1vdmVEYXRhKGgrXCIudGFic1wiKX0pfSk7dGhpcy5saXMudW5iaW5kKFwiLnRhYnNcIikuYWRkKHRoaXMucGFuZWxzKS5lYWNoKGZ1bmN0aW9uKCl7ZC5kYXRhKHRoaXMsXCJkZXN0cm95LnRhYnNcIik/ZCh0aGlzKS5yZW1vdmUoKTpkKHRoaXMpLnJlbW92ZUNsYXNzKFwidWktc3RhdGUtZGVmYXVsdCB1aS1jb3JuZXItdG9wIHVpLXRhYnMtc2VsZWN0ZWQgdWktc3RhdGUtYWN0aXZlIHVpLXN0YXRlLWhvdmVyIHVpLXN0YXRlLWZvY3VzIHVpLXN0YXRlLWRpc2FibGVkIHVpLXRhYnMtcGFuZWwgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWJvdHRvbSB1aS10YWJzLWhpZGVcIil9KTtiLmNvb2tpZSYmdGhpcy5fY29va2llKG51bGwsYi5jb29raWUpO3JldHVybiB0aGlzfSxhZGQ6ZnVuY3Rpb24oYixcclxuZSxhKXtpZihhPT09cClhPXRoaXMuYW5jaG9ycy5sZW5ndGg7dmFyIGM9dGhpcyxoPXRoaXMub3B0aW9ucztlPWQoaC50YWJUZW1wbGF0ZS5yZXBsYWNlKC8jXFx7aHJlZlxcfS9nLGIpLnJlcGxhY2UoLyNcXHtsYWJlbFxcfS9nLGUpKTtiPSFiLmluZGV4T2YoXCIjXCIpP2IucmVwbGFjZShcIiNcIixcIlwiKTp0aGlzLl90YWJJZChkKFwiYVwiLGUpWzBdKTtlLmFkZENsYXNzKFwidWktc3RhdGUtZGVmYXVsdCB1aS1jb3JuZXItdG9wXCIpLmRhdGEoXCJkZXN0cm95LnRhYnNcIix0cnVlKTt2YXIgaj1jLmVsZW1lbnQuZmluZChcIiNcIitiKTtqLmxlbmd0aHx8KGo9ZChoLnBhbmVsVGVtcGxhdGUpLmF0dHIoXCJpZFwiLGIpLmRhdGEoXCJkZXN0cm95LnRhYnNcIix0cnVlKSk7ai5hZGRDbGFzcyhcInVpLXRhYnMtcGFuZWwgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWJvdHRvbSB1aS10YWJzLWhpZGVcIik7aWYoYT49dGhpcy5saXMubGVuZ3RoKXtlLmFwcGVuZFRvKHRoaXMubGlzdCk7ai5hcHBlbmRUbyh0aGlzLmxpc3RbMF0ucGFyZW50Tm9kZSl9ZWxzZXtlLmluc2VydEJlZm9yZSh0aGlzLmxpc1thXSk7XHJcbmouaW5zZXJ0QmVmb3JlKHRoaXMucGFuZWxzW2FdKX1oLmRpc2FibGVkPWQubWFwKGguZGlzYWJsZWQsZnVuY3Rpb24oayl7cmV0dXJuIGs+PWE/KytrOmt9KTt0aGlzLl90YWJpZnkoKTtpZih0aGlzLmFuY2hvcnMubGVuZ3RoPT0xKXtoLnNlbGVjdGVkPTA7ZS5hZGRDbGFzcyhcInVpLXRhYnMtc2VsZWN0ZWQgdWktc3RhdGUtYWN0aXZlXCIpO2oucmVtb3ZlQ2xhc3MoXCJ1aS10YWJzLWhpZGVcIik7dGhpcy5lbGVtZW50LnF1ZXVlKFwidGFic1wiLGZ1bmN0aW9uKCl7Yy5fdHJpZ2dlcihcInNob3dcIixudWxsLGMuX3VpKGMuYW5jaG9yc1swXSxjLnBhbmVsc1swXSkpfSk7dGhpcy5sb2FkKDApfXRoaXMuX3RyaWdnZXIoXCJhZGRcIixudWxsLHRoaXMuX3VpKHRoaXMuYW5jaG9yc1thXSx0aGlzLnBhbmVsc1thXSkpO3JldHVybiB0aGlzfSxyZW1vdmU6ZnVuY3Rpb24oYil7Yj10aGlzLl9nZXRJbmRleChiKTt2YXIgZT10aGlzLm9wdGlvbnMsYT10aGlzLmxpcy5lcShiKS5yZW1vdmUoKSxjPXRoaXMucGFuZWxzLmVxKGIpLnJlbW92ZSgpO1xyXG5pZihhLmhhc0NsYXNzKFwidWktdGFicy1zZWxlY3RlZFwiKSYmdGhpcy5hbmNob3JzLmxlbmd0aD4xKXRoaXMuc2VsZWN0KGIrKGIrMTx0aGlzLmFuY2hvcnMubGVuZ3RoPzE6LTEpKTtlLmRpc2FibGVkPWQubWFwKGQuZ3JlcChlLmRpc2FibGVkLGZ1bmN0aW9uKGgpe3JldHVybiBoIT1ifSksZnVuY3Rpb24oaCl7cmV0dXJuIGg+PWI/LS1oOmh9KTt0aGlzLl90YWJpZnkoKTt0aGlzLl90cmlnZ2VyKFwicmVtb3ZlXCIsbnVsbCx0aGlzLl91aShhLmZpbmQoXCJhXCIpWzBdLGNbMF0pKTtyZXR1cm4gdGhpc30sZW5hYmxlOmZ1bmN0aW9uKGIpe2I9dGhpcy5fZ2V0SW5kZXgoYik7dmFyIGU9dGhpcy5vcHRpb25zO2lmKGQuaW5BcnJheShiLGUuZGlzYWJsZWQpIT0tMSl7dGhpcy5saXMuZXEoYikucmVtb3ZlQ2xhc3MoXCJ1aS1zdGF0ZS1kaXNhYmxlZFwiKTtlLmRpc2FibGVkPWQuZ3JlcChlLmRpc2FibGVkLGZ1bmN0aW9uKGEpe3JldHVybiBhIT1ifSk7dGhpcy5fdHJpZ2dlcihcImVuYWJsZVwiLG51bGwsXHJcbnRoaXMuX3VpKHRoaXMuYW5jaG9yc1tiXSx0aGlzLnBhbmVsc1tiXSkpO3JldHVybiB0aGlzfX0sZGlzYWJsZTpmdW5jdGlvbihiKXtiPXRoaXMuX2dldEluZGV4KGIpO3ZhciBlPXRoaXMub3B0aW9ucztpZihiIT1lLnNlbGVjdGVkKXt0aGlzLmxpcy5lcShiKS5hZGRDbGFzcyhcInVpLXN0YXRlLWRpc2FibGVkXCIpO2UuZGlzYWJsZWQucHVzaChiKTtlLmRpc2FibGVkLnNvcnQoKTt0aGlzLl90cmlnZ2VyKFwiZGlzYWJsZVwiLG51bGwsdGhpcy5fdWkodGhpcy5hbmNob3JzW2JdLHRoaXMucGFuZWxzW2JdKSl9cmV0dXJuIHRoaXN9LHNlbGVjdDpmdW5jdGlvbihiKXtiPXRoaXMuX2dldEluZGV4KGIpO2lmKGI9PS0xKWlmKHRoaXMub3B0aW9ucy5jb2xsYXBzaWJsZSYmdGhpcy5vcHRpb25zLnNlbGVjdGVkIT0tMSliPXRoaXMub3B0aW9ucy5zZWxlY3RlZDtlbHNlIHJldHVybiB0aGlzO3RoaXMuYW5jaG9ycy5lcShiKS50cmlnZ2VyKHRoaXMub3B0aW9ucy5ldmVudCtcIi50YWJzXCIpO3JldHVybiB0aGlzfSxcclxubG9hZDpmdW5jdGlvbihiKXtiPXRoaXMuX2dldEluZGV4KGIpO3ZhciBlPXRoaXMsYT10aGlzLm9wdGlvbnMsYz10aGlzLmFuY2hvcnMuZXEoYilbMF0saD1kLmRhdGEoYyxcImxvYWQudGFic1wiKTt0aGlzLmFib3J0KCk7aWYoIWh8fHRoaXMuZWxlbWVudC5xdWV1ZShcInRhYnNcIikubGVuZ3RoIT09MCYmZC5kYXRhKGMsXCJjYWNoZS50YWJzXCIpKXRoaXMuZWxlbWVudC5kZXF1ZXVlKFwidGFic1wiKTtlbHNle3RoaXMubGlzLmVxKGIpLmFkZENsYXNzKFwidWktc3RhdGUtcHJvY2Vzc2luZ1wiKTtpZihhLnNwaW5uZXIpe3ZhciBqPWQoXCJzcGFuXCIsYyk7ai5kYXRhKFwibGFiZWwudGFic1wiLGouaHRtbCgpKS5odG1sKGEuc3Bpbm5lcil9dGhpcy54aHI9ZC5hamF4KGQuZXh0ZW5kKHt9LGEuYWpheE9wdGlvbnMse3VybDpoLHN1Y2Nlc3M6ZnVuY3Rpb24oayxuKXtlLmVsZW1lbnQuZmluZChlLl9zYW5pdGl6ZVNlbGVjdG9yKGMuaGFzaCkpLmh0bWwoayk7ZS5fY2xlYW51cCgpO2EuY2FjaGUmJmQuZGF0YShjLFxyXG5cImNhY2hlLnRhYnNcIix0cnVlKTtlLl90cmlnZ2VyKFwibG9hZFwiLG51bGwsZS5fdWkoZS5hbmNob3JzW2JdLGUucGFuZWxzW2JdKSk7dHJ5e2EuYWpheE9wdGlvbnMuc3VjY2VzcyhrLG4pfWNhdGNoKG0pe319LGVycm9yOmZ1bmN0aW9uKGssbil7ZS5fY2xlYW51cCgpO2UuX3RyaWdnZXIoXCJsb2FkXCIsbnVsbCxlLl91aShlLmFuY2hvcnNbYl0sZS5wYW5lbHNbYl0pKTt0cnl7YS5hamF4T3B0aW9ucy5lcnJvcihrLG4sYixjKX1jYXRjaChtKXt9fX0pKTtlLmVsZW1lbnQuZGVxdWV1ZShcInRhYnNcIik7cmV0dXJuIHRoaXN9fSxhYm9ydDpmdW5jdGlvbigpe3RoaXMuZWxlbWVudC5xdWV1ZShbXSk7dGhpcy5wYW5lbHMuc3RvcChmYWxzZSx0cnVlKTt0aGlzLmVsZW1lbnQucXVldWUoXCJ0YWJzXCIsdGhpcy5lbGVtZW50LnF1ZXVlKFwidGFic1wiKS5zcGxpY2UoLTIsMikpO2lmKHRoaXMueGhyKXt0aGlzLnhoci5hYm9ydCgpO2RlbGV0ZSB0aGlzLnhocn10aGlzLl9jbGVhbnVwKCk7cmV0dXJuIHRoaXN9LFxyXG51cmw6ZnVuY3Rpb24oYixlKXt0aGlzLmFuY2hvcnMuZXEoYikucmVtb3ZlRGF0YShcImNhY2hlLnRhYnNcIikuZGF0YShcImxvYWQudGFic1wiLGUpO3JldHVybiB0aGlzfSxsZW5ndGg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hbmNob3JzLmxlbmd0aH19KTtkLmV4dGVuZChkLnVpLnRhYnMse3ZlcnNpb246XCIxLjguMTZcIn0pO2QuZXh0ZW5kKGQudWkudGFicy5wcm90b3R5cGUse3JvdGF0aW9uOm51bGwscm90YXRlOmZ1bmN0aW9uKGIsZSl7dmFyIGE9dGhpcyxjPXRoaXMub3B0aW9ucyxoPWEuX3JvdGF0ZXx8KGEuX3JvdGF0ZT1mdW5jdGlvbihqKXtjbGVhclRpbWVvdXQoYS5yb3RhdGlvbik7YS5yb3RhdGlvbj1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dmFyIGs9Yy5zZWxlY3RlZDthLnNlbGVjdCgrK2s8YS5hbmNob3JzLmxlbmd0aD9rOjApfSxiKTtqJiZqLnN0b3BQcm9wYWdhdGlvbigpfSk7ZT1hLl91bnJvdGF0ZXx8KGEuX3Vucm90YXRlPSFlP2Z1bmN0aW9uKGope2ouY2xpZW50WCYmXHJcbmEucm90YXRlKG51bGwpfTpmdW5jdGlvbigpe3Q9Yy5zZWxlY3RlZDtoKCl9KTtpZihiKXt0aGlzLmVsZW1lbnQuYmluZChcInRhYnNzaG93XCIsaCk7dGhpcy5hbmNob3JzLmJpbmQoYy5ldmVudCtcIi50YWJzXCIsZSk7aCgpfWVsc2V7Y2xlYXJUaW1lb3V0KGEucm90YXRpb24pO3RoaXMuZWxlbWVudC51bmJpbmQoXCJ0YWJzc2hvd1wiLGgpO3RoaXMuYW5jaG9ycy51bmJpbmQoYy5ldmVudCtcIi50YWJzXCIsZSk7ZGVsZXRlIHRoaXMuX3JvdGF0ZTtkZWxldGUgdGhpcy5fdW5yb3RhdGV9cmV0dXJuIHRoaXN9fSl9KShqUXVlcnkpO1xyXG47LypcclxuICogalF1ZXJ5IFVJIERhdGVwaWNrZXIgMS44LjE2XHJcbiAqXHJcbiAqIENvcHlyaWdodCAyMDExLCBBVVRIT1JTLnR4dCAoaHR0cDovL2pxdWVyeXVpLmNvbS9hYm91dClcclxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIG9yIEdQTCBWZXJzaW9uIDIgbGljZW5zZXMuXHJcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcclxuICpcclxuICogaHR0cDovL2RvY3MuanF1ZXJ5LmNvbS9VSS9EYXRlcGlja2VyXHJcbiAqXHJcbiAqIERlcGVuZHM6XHJcbiAqXHRqcXVlcnkudWkuY29yZS5qc1xyXG4gKi9cclxuKGZ1bmN0aW9uKGQsQyl7ZnVuY3Rpb24gTSgpe3RoaXMuZGVidWc9ZmFsc2U7dGhpcy5fY3VySW5zdD1udWxsO3RoaXMuX2tleUV2ZW50PWZhbHNlO3RoaXMuX2Rpc2FibGVkSW5wdXRzPVtdO3RoaXMuX2luRGlhbG9nPXRoaXMuX2RhdGVwaWNrZXJTaG93aW5nPWZhbHNlO3RoaXMuX21haW5EaXZJZD1cInVpLWRhdGVwaWNrZXItZGl2XCI7dGhpcy5faW5saW5lQ2xhc3M9XCJ1aS1kYXRlcGlja2VyLWlubGluZVwiO3RoaXMuX2FwcGVuZENsYXNzPVwidWktZGF0ZXBpY2tlci1hcHBlbmRcIjt0aGlzLl90cmlnZ2VyQ2xhc3M9XCJ1aS1kYXRlcGlja2VyLXRyaWdnZXJcIjt0aGlzLl9kaWFsb2dDbGFzcz1cInVpLWRhdGVwaWNrZXItZGlhbG9nXCI7dGhpcy5fZGlzYWJsZUNsYXNzPVwidWktZGF0ZXBpY2tlci1kaXNhYmxlZFwiO3RoaXMuX3Vuc2VsZWN0YWJsZUNsYXNzPVwidWktZGF0ZXBpY2tlci11bnNlbGVjdGFibGVcIjt0aGlzLl9jdXJyZW50Q2xhc3M9XCJ1aS1kYXRlcGlja2VyLWN1cnJlbnQtZGF5XCI7dGhpcy5fZGF5T3ZlckNsYXNzPVxyXG5cInVpLWRhdGVwaWNrZXItZGF5cy1jZWxsLW92ZXJcIjt0aGlzLnJlZ2lvbmFsPVtdO3RoaXMucmVnaW9uYWxbXCJcIl09e2Nsb3NlVGV4dDpcIkRvbmVcIixwcmV2VGV4dDpcIlByZXZcIixuZXh0VGV4dDpcIk5leHRcIixjdXJyZW50VGV4dDpcIlRvZGF5XCIsbW9udGhOYW1lczpbXCJKYW51YXJ5XCIsXCJGZWJydWFyeVwiLFwiTWFyY2hcIixcIkFwcmlsXCIsXCJNYXlcIixcIkp1bmVcIixcIkp1bHlcIixcIkF1Z3VzdFwiLFwiU2VwdGVtYmVyXCIsXCJPY3RvYmVyXCIsXCJOb3ZlbWJlclwiLFwiRGVjZW1iZXJcIl0sbW9udGhOYW1lc1Nob3J0OltcIkphblwiLFwiRmViXCIsXCJNYXJcIixcIkFwclwiLFwiTWF5XCIsXCJKdW5cIixcIkp1bFwiLFwiQXVnXCIsXCJTZXBcIixcIk9jdFwiLFwiTm92XCIsXCJEZWNcIl0sZGF5TmFtZXM6W1wiU3VuZGF5XCIsXCJNb25kYXlcIixcIlR1ZXNkYXlcIixcIldlZG5lc2RheVwiLFwiVGh1cnNkYXlcIixcIkZyaWRheVwiLFwiU2F0dXJkYXlcIl0sZGF5TmFtZXNTaG9ydDpbXCJTdW5cIixcIk1vblwiLFwiVHVlXCIsXCJXZWRcIixcIlRodVwiLFwiRnJpXCIsXCJTYXRcIl0sZGF5TmFtZXNNaW46W1wiU3VcIixcclxuXCJNb1wiLFwiVHVcIixcIldlXCIsXCJUaFwiLFwiRnJcIixcIlNhXCJdLHdlZWtIZWFkZXI6XCJXa1wiLGRhdGVGb3JtYXQ6XCJtbS9kZC95eVwiLGZpcnN0RGF5OjAsaXNSVEw6ZmFsc2Usc2hvd01vbnRoQWZ0ZXJZZWFyOmZhbHNlLHllYXJTdWZmaXg6XCJcIn07dGhpcy5fZGVmYXVsdHM9e3Nob3dPbjpcImZvY3VzXCIsc2hvd0FuaW06XCJmYWRlSW5cIixzaG93T3B0aW9uczp7fSxkZWZhdWx0RGF0ZTpudWxsLGFwcGVuZFRleHQ6XCJcIixidXR0b25UZXh0OlwiLi4uXCIsYnV0dG9uSW1hZ2U6XCJcIixidXR0b25JbWFnZU9ubHk6ZmFsc2UsaGlkZUlmTm9QcmV2TmV4dDpmYWxzZSxuYXZpZ2F0aW9uQXNEYXRlRm9ybWF0OmZhbHNlLGdvdG9DdXJyZW50OmZhbHNlLGNoYW5nZU1vbnRoOmZhbHNlLGNoYW5nZVllYXI6ZmFsc2UseWVhclJhbmdlOlwiYy0xMDpjKzEwXCIsc2hvd090aGVyTW9udGhzOmZhbHNlLHNlbGVjdE90aGVyTW9udGhzOmZhbHNlLHNob3dXZWVrOmZhbHNlLGNhbGN1bGF0ZVdlZWs6dGhpcy5pc284NjAxV2VlayxzaG9ydFllYXJDdXRvZmY6XCIrMTBcIixcclxubWluRGF0ZTpudWxsLG1heERhdGU6bnVsbCxkdXJhdGlvbjpcImZhc3RcIixiZWZvcmVTaG93RGF5Om51bGwsYmVmb3JlU2hvdzpudWxsLG9uU2VsZWN0Om51bGwsb25DaGFuZ2VNb250aFllYXI6bnVsbCxvbkNsb3NlOm51bGwsbnVtYmVyT2ZNb250aHM6MSxzaG93Q3VycmVudEF0UG9zOjAsc3RlcE1vbnRoczoxLHN0ZXBCaWdNb250aHM6MTIsYWx0RmllbGQ6XCJcIixhbHRGb3JtYXQ6XCJcIixjb25zdHJhaW5JbnB1dDp0cnVlLHNob3dCdXR0b25QYW5lbDpmYWxzZSxhdXRvU2l6ZTpmYWxzZSxkaXNhYmxlZDpmYWxzZX07ZC5leHRlbmQodGhpcy5fZGVmYXVsdHMsdGhpcy5yZWdpb25hbFtcIlwiXSk7dGhpcy5kcERpdj1OKGQoJzxkaXYgaWQ9XCInK3RoaXMuX21haW5EaXZJZCsnXCIgY2xhc3M9XCJ1aS1kYXRlcGlja2VyIHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1oZWxwZXItY2xlYXJmaXggdWktY29ybmVyLWFsbFwiPjwvZGl2PicpKX1mdW5jdGlvbiBOKGEpe3JldHVybiBhLmJpbmQoXCJtb3VzZW91dFwiLFxyXG5mdW5jdGlvbihiKXtiPWQoYi50YXJnZXQpLmNsb3Nlc3QoXCJidXR0b24sIC51aS1kYXRlcGlja2VyLXByZXYsIC51aS1kYXRlcGlja2VyLW5leHQsIC51aS1kYXRlcGlja2VyLWNhbGVuZGFyIHRkIGFcIik7Yi5sZW5ndGgmJmIucmVtb3ZlQ2xhc3MoXCJ1aS1zdGF0ZS1ob3ZlciB1aS1kYXRlcGlja2VyLXByZXYtaG92ZXIgdWktZGF0ZXBpY2tlci1uZXh0LWhvdmVyXCIpfSkuYmluZChcIm1vdXNlb3ZlclwiLGZ1bmN0aW9uKGIpe2I9ZChiLnRhcmdldCkuY2xvc2VzdChcImJ1dHRvbiwgLnVpLWRhdGVwaWNrZXItcHJldiwgLnVpLWRhdGVwaWNrZXItbmV4dCwgLnVpLWRhdGVwaWNrZXItY2FsZW5kYXIgdGQgYVwiKTtpZighKGQuZGF0ZXBpY2tlci5faXNEaXNhYmxlZERhdGVwaWNrZXIoSi5pbmxpbmU/YS5wYXJlbnQoKVswXTpKLmlucHV0WzBdKXx8IWIubGVuZ3RoKSl7Yi5wYXJlbnRzKFwiLnVpLWRhdGVwaWNrZXItY2FsZW5kYXJcIikuZmluZChcImFcIikucmVtb3ZlQ2xhc3MoXCJ1aS1zdGF0ZS1ob3ZlclwiKTtcclxuYi5hZGRDbGFzcyhcInVpLXN0YXRlLWhvdmVyXCIpO2IuaGFzQ2xhc3MoXCJ1aS1kYXRlcGlja2VyLXByZXZcIikmJmIuYWRkQ2xhc3MoXCJ1aS1kYXRlcGlja2VyLXByZXYtaG92ZXJcIik7Yi5oYXNDbGFzcyhcInVpLWRhdGVwaWNrZXItbmV4dFwiKSYmYi5hZGRDbGFzcyhcInVpLWRhdGVwaWNrZXItbmV4dC1ob3ZlclwiKX19KX1mdW5jdGlvbiBIKGEsYil7ZC5leHRlbmQoYSxiKTtmb3IodmFyIGMgaW4gYilpZihiW2NdPT1udWxsfHxiW2NdPT1DKWFbY109YltjXTtyZXR1cm4gYX1kLmV4dGVuZChkLnVpLHtkYXRlcGlja2VyOnt2ZXJzaW9uOlwiMS44LjE2XCJ9fSk7dmFyIEI9KG5ldyBEYXRlKS5nZXRUaW1lKCksSjtkLmV4dGVuZChNLnByb3RvdHlwZSx7bWFya2VyQ2xhc3NOYW1lOlwiaGFzRGF0ZXBpY2tlclwiLG1heFJvd3M6NCxsb2c6ZnVuY3Rpb24oKXt0aGlzLmRlYnVnJiZjb25zb2xlLmxvZy5hcHBseShcIlwiLGFyZ3VtZW50cyl9LF93aWRnZXREYXRlcGlja2VyOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZHBEaXZ9LFxyXG5zZXREZWZhdWx0czpmdW5jdGlvbihhKXtIKHRoaXMuX2RlZmF1bHRzLGF8fHt9KTtyZXR1cm4gdGhpc30sX2F0dGFjaERhdGVwaWNrZXI6ZnVuY3Rpb24oYSxiKXt2YXIgYz1udWxsO2Zvcih2YXIgZSBpbiB0aGlzLl9kZWZhdWx0cyl7dmFyIGY9YS5nZXRBdHRyaWJ1dGUoXCJkYXRlOlwiK2UpO2lmKGYpe2M9Y3x8e307dHJ5e2NbZV09ZXZhbChmKX1jYXRjaChoKXtjW2VdPWZ9fX1lPWEubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtmPWU9PVwiZGl2XCJ8fGU9PVwic3BhblwiO2lmKCFhLmlkKXt0aGlzLnV1aWQrPTE7YS5pZD1cImRwXCIrdGhpcy51dWlkfXZhciBpPXRoaXMuX25ld0luc3QoZChhKSxmKTtpLnNldHRpbmdzPWQuZXh0ZW5kKHt9LGJ8fHt9LGN8fHt9KTtpZihlPT1cImlucHV0XCIpdGhpcy5fY29ubmVjdERhdGVwaWNrZXIoYSxpKTtlbHNlIGYmJnRoaXMuX2lubGluZURhdGVwaWNrZXIoYSxpKX0sX25ld0luc3Q6ZnVuY3Rpb24oYSxiKXtyZXR1cm57aWQ6YVswXS5pZC5yZXBsYWNlKC8oW15BLVphLXowLTlfLV0pL2csXHJcblwiXFxcXFxcXFwkMVwiKSxpbnB1dDphLHNlbGVjdGVkRGF5OjAsc2VsZWN0ZWRNb250aDowLHNlbGVjdGVkWWVhcjowLGRyYXdNb250aDowLGRyYXdZZWFyOjAsaW5saW5lOmIsZHBEaXY6IWI/dGhpcy5kcERpdjpOKGQoJzxkaXYgY2xhc3M9XCInK3RoaXMuX2lubGluZUNsYXNzKycgdWktZGF0ZXBpY2tlciB1aS13aWRnZXQgdWktd2lkZ2V0LWNvbnRlbnQgdWktaGVscGVyLWNsZWFyZml4IHVpLWNvcm5lci1hbGxcIj48L2Rpdj4nKSl9fSxfY29ubmVjdERhdGVwaWNrZXI6ZnVuY3Rpb24oYSxiKXt2YXIgYz1kKGEpO2IuYXBwZW5kPWQoW10pO2IudHJpZ2dlcj1kKFtdKTtpZighYy5oYXNDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkpe3RoaXMuX2F0dGFjaG1lbnRzKGMsYik7Yy5hZGRDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkua2V5ZG93bih0aGlzLl9kb0tleURvd24pLmtleXByZXNzKHRoaXMuX2RvS2V5UHJlc3MpLmtleXVwKHRoaXMuX2RvS2V5VXApLmJpbmQoXCJzZXREYXRhLmRhdGVwaWNrZXJcIixcclxuZnVuY3Rpb24oZSxmLGgpe2Iuc2V0dGluZ3NbZl09aH0pLmJpbmQoXCJnZXREYXRhLmRhdGVwaWNrZXJcIixmdW5jdGlvbihlLGYpe3JldHVybiB0aGlzLl9nZXQoYixmKX0pO3RoaXMuX2F1dG9TaXplKGIpO2QuZGF0YShhLFwiZGF0ZXBpY2tlclwiLGIpO2Iuc2V0dGluZ3MuZGlzYWJsZWQmJnRoaXMuX2Rpc2FibGVEYXRlcGlja2VyKGEpfX0sX2F0dGFjaG1lbnRzOmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5fZ2V0KGIsXCJhcHBlbmRUZXh0XCIpLGU9dGhpcy5fZ2V0KGIsXCJpc1JUTFwiKTtiLmFwcGVuZCYmYi5hcHBlbmQucmVtb3ZlKCk7aWYoYyl7Yi5hcHBlbmQ9ZCgnPHNwYW4gY2xhc3M9XCInK3RoaXMuX2FwcGVuZENsYXNzKydcIj4nK2MrXCI8L3NwYW4+XCIpO2FbZT9cImJlZm9yZVwiOlwiYWZ0ZXJcIl0oYi5hcHBlbmQpfWEudW5iaW5kKFwiZm9jdXNcIix0aGlzLl9zaG93RGF0ZXBpY2tlcik7Yi50cmlnZ2VyJiZiLnRyaWdnZXIucmVtb3ZlKCk7Yz10aGlzLl9nZXQoYixcInNob3dPblwiKTtpZihjPT1cclxuXCJmb2N1c1wifHxjPT1cImJvdGhcIilhLmZvY3VzKHRoaXMuX3Nob3dEYXRlcGlja2VyKTtpZihjPT1cImJ1dHRvblwifHxjPT1cImJvdGhcIil7Yz10aGlzLl9nZXQoYixcImJ1dHRvblRleHRcIik7dmFyIGY9dGhpcy5fZ2V0KGIsXCJidXR0b25JbWFnZVwiKTtiLnRyaWdnZXI9ZCh0aGlzLl9nZXQoYixcImJ1dHRvbkltYWdlT25seVwiKT9kKFwiPGltZy8+XCIpLmFkZENsYXNzKHRoaXMuX3RyaWdnZXJDbGFzcykuYXR0cih7c3JjOmYsYWx0OmMsdGl0bGU6Y30pOmQoJzxidXR0b24gdHlwZT1cImJ1dHRvblwiPjwvYnV0dG9uPicpLmFkZENsYXNzKHRoaXMuX3RyaWdnZXJDbGFzcykuaHRtbChmPT1cIlwiP2M6ZChcIjxpbWcvPlwiKS5hdHRyKHtzcmM6ZixhbHQ6Yyx0aXRsZTpjfSkpKTthW2U/XCJiZWZvcmVcIjpcImFmdGVyXCJdKGIudHJpZ2dlcik7Yi50cmlnZ2VyLmNsaWNrKGZ1bmN0aW9uKCl7ZC5kYXRlcGlja2VyLl9kYXRlcGlja2VyU2hvd2luZyYmZC5kYXRlcGlja2VyLl9sYXN0SW5wdXQ9PWFbMF0/ZC5kYXRlcGlja2VyLl9oaWRlRGF0ZXBpY2tlcigpOlxyXG5kLmRhdGVwaWNrZXIuX3Nob3dEYXRlcGlja2VyKGFbMF0pO3JldHVybiBmYWxzZX0pfX0sX2F1dG9TaXplOmZ1bmN0aW9uKGEpe2lmKHRoaXMuX2dldChhLFwiYXV0b1NpemVcIikmJiFhLmlubGluZSl7dmFyIGI9bmV3IERhdGUoMjAwOSwxMSwyMCksYz10aGlzLl9nZXQoYSxcImRhdGVGb3JtYXRcIik7aWYoYy5tYXRjaCgvW0RNXS8pKXt2YXIgZT1mdW5jdGlvbihmKXtmb3IodmFyIGg9MCxpPTAsZz0wO2c8Zi5sZW5ndGg7ZysrKWlmKGZbZ10ubGVuZ3RoPmgpe2g9ZltnXS5sZW5ndGg7aT1nfXJldHVybiBpfTtiLnNldE1vbnRoKGUodGhpcy5fZ2V0KGEsYy5tYXRjaCgvTU0vKT9cIm1vbnRoTmFtZXNcIjpcIm1vbnRoTmFtZXNTaG9ydFwiKSkpO2Iuc2V0RGF0ZShlKHRoaXMuX2dldChhLGMubWF0Y2goL0RELyk/XCJkYXlOYW1lc1wiOlwiZGF5TmFtZXNTaG9ydFwiKSkrMjAtYi5nZXREYXkoKSl9YS5pbnB1dC5hdHRyKFwic2l6ZVwiLHRoaXMuX2Zvcm1hdERhdGUoYSxiKS5sZW5ndGgpfX0sX2lubGluZURhdGVwaWNrZXI6ZnVuY3Rpb24oYSxcclxuYil7dmFyIGM9ZChhKTtpZighYy5oYXNDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkpe2MuYWRkQ2xhc3ModGhpcy5tYXJrZXJDbGFzc05hbWUpLmFwcGVuZChiLmRwRGl2KS5iaW5kKFwic2V0RGF0YS5kYXRlcGlja2VyXCIsZnVuY3Rpb24oZSxmLGgpe2Iuc2V0dGluZ3NbZl09aH0pLmJpbmQoXCJnZXREYXRhLmRhdGVwaWNrZXJcIixmdW5jdGlvbihlLGYpe3JldHVybiB0aGlzLl9nZXQoYixmKX0pO2QuZGF0YShhLFwiZGF0ZXBpY2tlclwiLGIpO3RoaXMuX3NldERhdGUoYix0aGlzLl9nZXREZWZhdWx0RGF0ZShiKSx0cnVlKTt0aGlzLl91cGRhdGVEYXRlcGlja2VyKGIpO3RoaXMuX3VwZGF0ZUFsdGVybmF0ZShiKTtiLnNldHRpbmdzLmRpc2FibGVkJiZ0aGlzLl9kaXNhYmxlRGF0ZXBpY2tlcihhKTtiLmRwRGl2LmNzcyhcImRpc3BsYXlcIixcImJsb2NrXCIpfX0sX2RpYWxvZ0RhdGVwaWNrZXI6ZnVuY3Rpb24oYSxiLGMsZSxmKXthPXRoaXMuX2RpYWxvZ0luc3Q7aWYoIWEpe3RoaXMudXVpZCs9XHJcbjE7dGhpcy5fZGlhbG9nSW5wdXQ9ZCgnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgaWQ9XCInKyhcImRwXCIrdGhpcy51dWlkKSsnXCIgc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogLTEwMHB4OyB3aWR0aDogMHB4OyB6LWluZGV4OiAtMTA7XCIvPicpO3RoaXMuX2RpYWxvZ0lucHV0LmtleWRvd24odGhpcy5fZG9LZXlEb3duKTtkKFwiYm9keVwiKS5hcHBlbmQodGhpcy5fZGlhbG9nSW5wdXQpO2E9dGhpcy5fZGlhbG9nSW5zdD10aGlzLl9uZXdJbnN0KHRoaXMuX2RpYWxvZ0lucHV0LGZhbHNlKTthLnNldHRpbmdzPXt9O2QuZGF0YSh0aGlzLl9kaWFsb2dJbnB1dFswXSxcImRhdGVwaWNrZXJcIixhKX1IKGEuc2V0dGluZ3MsZXx8e30pO2I9YiYmYi5jb25zdHJ1Y3Rvcj09RGF0ZT90aGlzLl9mb3JtYXREYXRlKGEsYik6Yjt0aGlzLl9kaWFsb2dJbnB1dC52YWwoYik7dGhpcy5fcG9zPWY/Zi5sZW5ndGg/ZjpbZi5wYWdlWCxmLnBhZ2VZXTpudWxsO2lmKCF0aGlzLl9wb3MpdGhpcy5fcG9zPVtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgvXHJcbjItMTAwKyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdHx8ZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0KSxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0LzItMTUwKyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wfHxkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCldO3RoaXMuX2RpYWxvZ0lucHV0LmNzcyhcImxlZnRcIix0aGlzLl9wb3NbMF0rMjArXCJweFwiKS5jc3MoXCJ0b3BcIix0aGlzLl9wb3NbMV0rXCJweFwiKTthLnNldHRpbmdzLm9uU2VsZWN0PWM7dGhpcy5faW5EaWFsb2c9dHJ1ZTt0aGlzLmRwRGl2LmFkZENsYXNzKHRoaXMuX2RpYWxvZ0NsYXNzKTt0aGlzLl9zaG93RGF0ZXBpY2tlcih0aGlzLl9kaWFsb2dJbnB1dFswXSk7ZC5ibG9ja1VJJiZkLmJsb2NrVUkodGhpcy5kcERpdik7ZC5kYXRhKHRoaXMuX2RpYWxvZ0lucHV0WzBdLFwiZGF0ZXBpY2tlclwiLGEpO3JldHVybiB0aGlzfSxfZGVzdHJveURhdGVwaWNrZXI6ZnVuY3Rpb24oYSl7dmFyIGI9XHJcbmQoYSksYz1kLmRhdGEoYSxcImRhdGVwaWNrZXJcIik7aWYoYi5oYXNDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkpe3ZhciBlPWEubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtkLnJlbW92ZURhdGEoYSxcImRhdGVwaWNrZXJcIik7aWYoZT09XCJpbnB1dFwiKXtjLmFwcGVuZC5yZW1vdmUoKTtjLnRyaWdnZXIucmVtb3ZlKCk7Yi5yZW1vdmVDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkudW5iaW5kKFwiZm9jdXNcIix0aGlzLl9zaG93RGF0ZXBpY2tlcikudW5iaW5kKFwia2V5ZG93blwiLHRoaXMuX2RvS2V5RG93bikudW5iaW5kKFwia2V5cHJlc3NcIix0aGlzLl9kb0tleVByZXNzKS51bmJpbmQoXCJrZXl1cFwiLHRoaXMuX2RvS2V5VXApfWVsc2UgaWYoZT09XCJkaXZcInx8ZT09XCJzcGFuXCIpYi5yZW1vdmVDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkuZW1wdHkoKX19LF9lbmFibGVEYXRlcGlja2VyOmZ1bmN0aW9uKGEpe3ZhciBiPWQoYSksYz1kLmRhdGEoYSxcImRhdGVwaWNrZXJcIik7aWYoYi5oYXNDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkpe3ZhciBlPVxyXG5hLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7aWYoZT09XCJpbnB1dFwiKXthLmRpc2FibGVkPWZhbHNlO2MudHJpZ2dlci5maWx0ZXIoXCJidXR0b25cIikuZWFjaChmdW5jdGlvbigpe3RoaXMuZGlzYWJsZWQ9ZmFsc2V9KS5lbmQoKS5maWx0ZXIoXCJpbWdcIikuY3NzKHtvcGFjaXR5OlwiMS4wXCIsY3Vyc29yOlwiXCJ9KX1lbHNlIGlmKGU9PVwiZGl2XCJ8fGU9PVwic3BhblwiKXtiPWIuY2hpbGRyZW4oXCIuXCIrdGhpcy5faW5saW5lQ2xhc3MpO2IuY2hpbGRyZW4oKS5yZW1vdmVDbGFzcyhcInVpLXN0YXRlLWRpc2FibGVkXCIpO2IuZmluZChcInNlbGVjdC51aS1kYXRlcGlja2VyLW1vbnRoLCBzZWxlY3QudWktZGF0ZXBpY2tlci15ZWFyXCIpLnJlbW92ZUF0dHIoXCJkaXNhYmxlZFwiKX10aGlzLl9kaXNhYmxlZElucHV0cz1kLm1hcCh0aGlzLl9kaXNhYmxlZElucHV0cyxmdW5jdGlvbihmKXtyZXR1cm4gZj09YT9udWxsOmZ9KX19LF9kaXNhYmxlRGF0ZXBpY2tlcjpmdW5jdGlvbihhKXt2YXIgYj1kKGEpLGM9ZC5kYXRhKGEsXHJcblwiZGF0ZXBpY2tlclwiKTtpZihiLmhhc0NsYXNzKHRoaXMubWFya2VyQ2xhc3NOYW1lKSl7dmFyIGU9YS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO2lmKGU9PVwiaW5wdXRcIil7YS5kaXNhYmxlZD10cnVlO2MudHJpZ2dlci5maWx0ZXIoXCJidXR0b25cIikuZWFjaChmdW5jdGlvbigpe3RoaXMuZGlzYWJsZWQ9dHJ1ZX0pLmVuZCgpLmZpbHRlcihcImltZ1wiKS5jc3Moe29wYWNpdHk6XCIwLjVcIixjdXJzb3I6XCJkZWZhdWx0XCJ9KX1lbHNlIGlmKGU9PVwiZGl2XCJ8fGU9PVwic3BhblwiKXtiPWIuY2hpbGRyZW4oXCIuXCIrdGhpcy5faW5saW5lQ2xhc3MpO2IuY2hpbGRyZW4oKS5hZGRDbGFzcyhcInVpLXN0YXRlLWRpc2FibGVkXCIpO2IuZmluZChcInNlbGVjdC51aS1kYXRlcGlja2VyLW1vbnRoLCBzZWxlY3QudWktZGF0ZXBpY2tlci15ZWFyXCIpLmF0dHIoXCJkaXNhYmxlZFwiLFwiZGlzYWJsZWRcIil9dGhpcy5fZGlzYWJsZWRJbnB1dHM9ZC5tYXAodGhpcy5fZGlzYWJsZWRJbnB1dHMsZnVuY3Rpb24oZil7cmV0dXJuIGY9PVxyXG5hP251bGw6Zn0pO3RoaXMuX2Rpc2FibGVkSW5wdXRzW3RoaXMuX2Rpc2FibGVkSW5wdXRzLmxlbmd0aF09YX19LF9pc0Rpc2FibGVkRGF0ZXBpY2tlcjpmdW5jdGlvbihhKXtpZighYSlyZXR1cm4gZmFsc2U7Zm9yKHZhciBiPTA7Yjx0aGlzLl9kaXNhYmxlZElucHV0cy5sZW5ndGg7YisrKWlmKHRoaXMuX2Rpc2FibGVkSW5wdXRzW2JdPT1hKXJldHVybiB0cnVlO3JldHVybiBmYWxzZX0sX2dldEluc3Q6ZnVuY3Rpb24oYSl7dHJ5e3JldHVybiBkLmRhdGEoYSxcImRhdGVwaWNrZXJcIil9Y2F0Y2goYil7dGhyb3dcIk1pc3NpbmcgaW5zdGFuY2UgZGF0YSBmb3IgdGhpcyBkYXRlcGlja2VyXCI7fX0sX29wdGlvbkRhdGVwaWNrZXI6ZnVuY3Rpb24oYSxiLGMpe3ZhciBlPXRoaXMuX2dldEluc3QoYSk7aWYoYXJndW1lbnRzLmxlbmd0aD09MiYmdHlwZW9mIGI9PVwic3RyaW5nXCIpcmV0dXJuIGI9PVwiZGVmYXVsdHNcIj9kLmV4dGVuZCh7fSxkLmRhdGVwaWNrZXIuX2RlZmF1bHRzKTplP2I9PVwiYWxsXCI/XHJcbmQuZXh0ZW5kKHt9LGUuc2V0dGluZ3MpOnRoaXMuX2dldChlLGIpOm51bGw7dmFyIGY9Ynx8e307aWYodHlwZW9mIGI9PVwic3RyaW5nXCIpe2Y9e307ZltiXT1jfWlmKGUpe3RoaXMuX2N1ckluc3Q9PWUmJnRoaXMuX2hpZGVEYXRlcGlja2VyKCk7dmFyIGg9dGhpcy5fZ2V0RGF0ZURhdGVwaWNrZXIoYSx0cnVlKSxpPXRoaXMuX2dldE1pbk1heERhdGUoZSxcIm1pblwiKSxnPXRoaXMuX2dldE1pbk1heERhdGUoZSxcIm1heFwiKTtIKGUuc2V0dGluZ3MsZik7aWYoaSE9PW51bGwmJmYuZGF0ZUZvcm1hdCE9PUMmJmYubWluRGF0ZT09PUMpZS5zZXR0aW5ncy5taW5EYXRlPXRoaXMuX2Zvcm1hdERhdGUoZSxpKTtpZihnIT09bnVsbCYmZi5kYXRlRm9ybWF0IT09QyYmZi5tYXhEYXRlPT09QyllLnNldHRpbmdzLm1heERhdGU9dGhpcy5fZm9ybWF0RGF0ZShlLGcpO3RoaXMuX2F0dGFjaG1lbnRzKGQoYSksZSk7dGhpcy5fYXV0b1NpemUoZSk7dGhpcy5fc2V0RGF0ZShlLGgpO3RoaXMuX3VwZGF0ZUFsdGVybmF0ZShlKTtcclxudGhpcy5fdXBkYXRlRGF0ZXBpY2tlcihlKX19LF9jaGFuZ2VEYXRlcGlja2VyOmZ1bmN0aW9uKGEsYixjKXt0aGlzLl9vcHRpb25EYXRlcGlja2VyKGEsYixjKX0sX3JlZnJlc2hEYXRlcGlja2VyOmZ1bmN0aW9uKGEpeyhhPXRoaXMuX2dldEluc3QoYSkpJiZ0aGlzLl91cGRhdGVEYXRlcGlja2VyKGEpfSxfc2V0RGF0ZURhdGVwaWNrZXI6ZnVuY3Rpb24oYSxiKXtpZihhPXRoaXMuX2dldEluc3QoYSkpe3RoaXMuX3NldERhdGUoYSxiKTt0aGlzLl91cGRhdGVEYXRlcGlja2VyKGEpO3RoaXMuX3VwZGF0ZUFsdGVybmF0ZShhKX19LF9nZXREYXRlRGF0ZXBpY2tlcjpmdW5jdGlvbihhLGIpeyhhPXRoaXMuX2dldEluc3QoYSkpJiYhYS5pbmxpbmUmJnRoaXMuX3NldERhdGVGcm9tRmllbGQoYSxiKTtyZXR1cm4gYT90aGlzLl9nZXREYXRlKGEpOm51bGx9LF9kb0tleURvd246ZnVuY3Rpb24oYSl7dmFyIGI9ZC5kYXRlcGlja2VyLl9nZXRJbnN0KGEudGFyZ2V0KSxjPXRydWUsZT1iLmRwRGl2LmlzKFwiLnVpLWRhdGVwaWNrZXItcnRsXCIpO1xyXG5iLl9rZXlFdmVudD10cnVlO2lmKGQuZGF0ZXBpY2tlci5fZGF0ZXBpY2tlclNob3dpbmcpc3dpdGNoKGEua2V5Q29kZSl7Y2FzZSA5OmQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoKTtjPWZhbHNlO2JyZWFrO2Nhc2UgMTM6Yz1kKFwidGQuXCIrZC5kYXRlcGlja2VyLl9kYXlPdmVyQ2xhc3MrXCI6bm90KC5cIitkLmRhdGVwaWNrZXIuX2N1cnJlbnRDbGFzcytcIilcIixiLmRwRGl2KTtjWzBdJiZkLmRhdGVwaWNrZXIuX3NlbGVjdERheShhLnRhcmdldCxiLnNlbGVjdGVkTW9udGgsYi5zZWxlY3RlZFllYXIsY1swXSk7aWYoYT1kLmRhdGVwaWNrZXIuX2dldChiLFwib25TZWxlY3RcIikpe2M9ZC5kYXRlcGlja2VyLl9mb3JtYXREYXRlKGIpO2EuYXBwbHkoYi5pbnB1dD9iLmlucHV0WzBdOm51bGwsW2MsYl0pfWVsc2UgZC5kYXRlcGlja2VyLl9oaWRlRGF0ZXBpY2tlcigpO3JldHVybiBmYWxzZTtjYXNlIDI3OmQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoKTticmVhaztjYXNlIDMzOmQuZGF0ZXBpY2tlci5fYWRqdXN0RGF0ZShhLnRhcmdldCxcclxuYS5jdHJsS2V5Py1kLmRhdGVwaWNrZXIuX2dldChiLFwic3RlcEJpZ01vbnRoc1wiKTotZC5kYXRlcGlja2VyLl9nZXQoYixcInN0ZXBNb250aHNcIiksXCJNXCIpO2JyZWFrO2Nhc2UgMzQ6ZC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGEudGFyZ2V0LGEuY3RybEtleT8rZC5kYXRlcGlja2VyLl9nZXQoYixcInN0ZXBCaWdNb250aHNcIik6K2QuZGF0ZXBpY2tlci5fZ2V0KGIsXCJzdGVwTW9udGhzXCIpLFwiTVwiKTticmVhaztjYXNlIDM1OmlmKGEuY3RybEtleXx8YS5tZXRhS2V5KWQuZGF0ZXBpY2tlci5fY2xlYXJEYXRlKGEudGFyZ2V0KTtjPWEuY3RybEtleXx8YS5tZXRhS2V5O2JyZWFrO2Nhc2UgMzY6aWYoYS5jdHJsS2V5fHxhLm1ldGFLZXkpZC5kYXRlcGlja2VyLl9nb3RvVG9kYXkoYS50YXJnZXQpO2M9YS5jdHJsS2V5fHxhLm1ldGFLZXk7YnJlYWs7Y2FzZSAzNzppZihhLmN0cmxLZXl8fGEubWV0YUtleSlkLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoYS50YXJnZXQsZT8rMTotMSxcIkRcIik7Yz1cclxuYS5jdHJsS2V5fHxhLm1ldGFLZXk7aWYoYS5vcmlnaW5hbEV2ZW50LmFsdEtleSlkLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoYS50YXJnZXQsYS5jdHJsS2V5Py1kLmRhdGVwaWNrZXIuX2dldChiLFwic3RlcEJpZ01vbnRoc1wiKTotZC5kYXRlcGlja2VyLl9nZXQoYixcInN0ZXBNb250aHNcIiksXCJNXCIpO2JyZWFrO2Nhc2UgMzg6aWYoYS5jdHJsS2V5fHxhLm1ldGFLZXkpZC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGEudGFyZ2V0LC03LFwiRFwiKTtjPWEuY3RybEtleXx8YS5tZXRhS2V5O2JyZWFrO2Nhc2UgMzk6aWYoYS5jdHJsS2V5fHxhLm1ldGFLZXkpZC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGEudGFyZ2V0LGU/LTE6KzEsXCJEXCIpO2M9YS5jdHJsS2V5fHxhLm1ldGFLZXk7aWYoYS5vcmlnaW5hbEV2ZW50LmFsdEtleSlkLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoYS50YXJnZXQsYS5jdHJsS2V5PytkLmRhdGVwaWNrZXIuX2dldChiLFwic3RlcEJpZ01vbnRoc1wiKTorZC5kYXRlcGlja2VyLl9nZXQoYixcclxuXCJzdGVwTW9udGhzXCIpLFwiTVwiKTticmVhaztjYXNlIDQwOmlmKGEuY3RybEtleXx8YS5tZXRhS2V5KWQuZGF0ZXBpY2tlci5fYWRqdXN0RGF0ZShhLnRhcmdldCwrNyxcIkRcIik7Yz1hLmN0cmxLZXl8fGEubWV0YUtleTticmVhaztkZWZhdWx0OmM9ZmFsc2V9ZWxzZSBpZihhLmtleUNvZGU9PTM2JiZhLmN0cmxLZXkpZC5kYXRlcGlja2VyLl9zaG93RGF0ZXBpY2tlcih0aGlzKTtlbHNlIGM9ZmFsc2U7aWYoYyl7YS5wcmV2ZW50RGVmYXVsdCgpO2Euc3RvcFByb3BhZ2F0aW9uKCl9fSxfZG9LZXlQcmVzczpmdW5jdGlvbihhKXt2YXIgYj1kLmRhdGVwaWNrZXIuX2dldEluc3QoYS50YXJnZXQpO2lmKGQuZGF0ZXBpY2tlci5fZ2V0KGIsXCJjb25zdHJhaW5JbnB1dFwiKSl7Yj1kLmRhdGVwaWNrZXIuX3Bvc3NpYmxlQ2hhcnMoZC5kYXRlcGlja2VyLl9nZXQoYixcImRhdGVGb3JtYXRcIikpO3ZhciBjPVN0cmluZy5mcm9tQ2hhckNvZGUoYS5jaGFyQ29kZT09Qz9hLmtleUNvZGU6YS5jaGFyQ29kZSk7XHJcbnJldHVybiBhLmN0cmxLZXl8fGEubWV0YUtleXx8YzxcIiBcInx8IWJ8fGIuaW5kZXhPZihjKT4tMX19LF9kb0tleVVwOmZ1bmN0aW9uKGEpe2E9ZC5kYXRlcGlja2VyLl9nZXRJbnN0KGEudGFyZ2V0KTtpZihhLmlucHV0LnZhbCgpIT1hLmxhc3RWYWwpdHJ5e2lmKGQuZGF0ZXBpY2tlci5wYXJzZURhdGUoZC5kYXRlcGlja2VyLl9nZXQoYSxcImRhdGVGb3JtYXRcIiksYS5pbnB1dD9hLmlucHV0LnZhbCgpOm51bGwsZC5kYXRlcGlja2VyLl9nZXRGb3JtYXRDb25maWcoYSkpKXtkLmRhdGVwaWNrZXIuX3NldERhdGVGcm9tRmllbGQoYSk7ZC5kYXRlcGlja2VyLl91cGRhdGVBbHRlcm5hdGUoYSk7ZC5kYXRlcGlja2VyLl91cGRhdGVEYXRlcGlja2VyKGEpfX1jYXRjaChiKXtkLmRhdGVwaWNrZXIubG9nKGIpfXJldHVybiB0cnVlfSxfc2hvd0RhdGVwaWNrZXI6ZnVuY3Rpb24oYSl7YT1hLnRhcmdldHx8YTtpZihhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkhPVwiaW5wdXRcIilhPWQoXCJpbnB1dFwiLFxyXG5hLnBhcmVudE5vZGUpWzBdO2lmKCEoZC5kYXRlcGlja2VyLl9pc0Rpc2FibGVkRGF0ZXBpY2tlcihhKXx8ZC5kYXRlcGlja2VyLl9sYXN0SW5wdXQ9PWEpKXt2YXIgYj1kLmRhdGVwaWNrZXIuX2dldEluc3QoYSk7aWYoZC5kYXRlcGlja2VyLl9jdXJJbnN0JiZkLmRhdGVwaWNrZXIuX2N1ckluc3QhPWIpe2QuZGF0ZXBpY2tlci5fZGF0ZXBpY2tlclNob3dpbmcmJmQuZGF0ZXBpY2tlci5fdHJpZ2dlck9uQ2xvc2UoZC5kYXRlcGlja2VyLl9jdXJJbnN0KTtkLmRhdGVwaWNrZXIuX2N1ckluc3QuZHBEaXYuc3RvcCh0cnVlLHRydWUpfXZhciBjPWQuZGF0ZXBpY2tlci5fZ2V0KGIsXCJiZWZvcmVTaG93XCIpO2M9Yz9jLmFwcGx5KGEsW2EsYl0pOnt9O2lmKGMhPT1mYWxzZSl7SChiLnNldHRpbmdzLGMpO2IubGFzdFZhbD1udWxsO2QuZGF0ZXBpY2tlci5fbGFzdElucHV0PWE7ZC5kYXRlcGlja2VyLl9zZXREYXRlRnJvbUZpZWxkKGIpO2lmKGQuZGF0ZXBpY2tlci5faW5EaWFsb2cpYS52YWx1ZT1cclxuXCJcIjtpZighZC5kYXRlcGlja2VyLl9wb3Mpe2QuZGF0ZXBpY2tlci5fcG9zPWQuZGF0ZXBpY2tlci5fZmluZFBvcyhhKTtkLmRhdGVwaWNrZXIuX3Bvc1sxXSs9YS5vZmZzZXRIZWlnaHR9dmFyIGU9ZmFsc2U7ZChhKS5wYXJlbnRzKCkuZWFjaChmdW5jdGlvbigpe2V8PWQodGhpcykuY3NzKFwicG9zaXRpb25cIik9PVwiZml4ZWRcIjtyZXR1cm4hZX0pO2lmKGUmJmQuYnJvd3Nlci5vcGVyYSl7ZC5kYXRlcGlja2VyLl9wb3NbMF0tPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0O2QuZGF0ZXBpY2tlci5fcG9zWzFdLT1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wfWM9e2xlZnQ6ZC5kYXRlcGlja2VyLl9wb3NbMF0sdG9wOmQuZGF0ZXBpY2tlci5fcG9zWzFdfTtkLmRhdGVwaWNrZXIuX3Bvcz1udWxsO2IuZHBEaXYuZW1wdHkoKTtiLmRwRGl2LmNzcyh7cG9zaXRpb246XCJhYnNvbHV0ZVwiLGRpc3BsYXk6XCJibG9ja1wiLHRvcDpcIi0xMDAwcHhcIn0pO2QuZGF0ZXBpY2tlci5fdXBkYXRlRGF0ZXBpY2tlcihiKTtcclxuYz1kLmRhdGVwaWNrZXIuX2NoZWNrT2Zmc2V0KGIsYyxlKTtiLmRwRGl2LmNzcyh7cG9zaXRpb246ZC5kYXRlcGlja2VyLl9pbkRpYWxvZyYmZC5ibG9ja1VJP1wic3RhdGljXCI6ZT9cImZpeGVkXCI6XCJhYnNvbHV0ZVwiLGRpc3BsYXk6XCJub25lXCIsbGVmdDpjLmxlZnQrXCJweFwiLHRvcDpjLnRvcCtcInB4XCJ9KTtpZighYi5pbmxpbmUpe2M9ZC5kYXRlcGlja2VyLl9nZXQoYixcInNob3dBbmltXCIpO3ZhciBmPWQuZGF0ZXBpY2tlci5fZ2V0KGIsXCJkdXJhdGlvblwiKSxoPWZ1bmN0aW9uKCl7dmFyIGk9Yi5kcERpdi5maW5kKFwiaWZyYW1lLnVpLWRhdGVwaWNrZXItY292ZXJcIik7aWYoaS5sZW5ndGgpe3ZhciBnPWQuZGF0ZXBpY2tlci5fZ2V0Qm9yZGVycyhiLmRwRGl2KTtpLmNzcyh7bGVmdDotZ1swXSx0b3A6LWdbMV0sd2lkdGg6Yi5kcERpdi5vdXRlcldpZHRoKCksaGVpZ2h0OmIuZHBEaXYub3V0ZXJIZWlnaHQoKX0pfX07Yi5kcERpdi56SW5kZXgoZChhKS56SW5kZXgoKSsxKTtkLmRhdGVwaWNrZXIuX2RhdGVwaWNrZXJTaG93aW5nPVxyXG50cnVlO2QuZWZmZWN0cyYmZC5lZmZlY3RzW2NdP2IuZHBEaXYuc2hvdyhjLGQuZGF0ZXBpY2tlci5fZ2V0KGIsXCJzaG93T3B0aW9uc1wiKSxmLGgpOmIuZHBEaXZbY3x8XCJzaG93XCJdKGM/ZjpudWxsLGgpO2lmKCFjfHwhZiloKCk7Yi5pbnB1dC5pcyhcIjp2aXNpYmxlXCIpJiYhYi5pbnB1dC5pcyhcIjpkaXNhYmxlZFwiKSYmYi5pbnB1dC5mb2N1cygpO2QuZGF0ZXBpY2tlci5fY3VySW5zdD1ifX19fSxfdXBkYXRlRGF0ZXBpY2tlcjpmdW5jdGlvbihhKXt0aGlzLm1heFJvd3M9NDt2YXIgYj1kLmRhdGVwaWNrZXIuX2dldEJvcmRlcnMoYS5kcERpdik7Sj1hO2EuZHBEaXYuZW1wdHkoKS5hcHBlbmQodGhpcy5fZ2VuZXJhdGVIVE1MKGEpKTt2YXIgYz1hLmRwRGl2LmZpbmQoXCJpZnJhbWUudWktZGF0ZXBpY2tlci1jb3ZlclwiKTtjLmxlbmd0aCYmYy5jc3Moe2xlZnQ6LWJbMF0sdG9wOi1iWzFdLHdpZHRoOmEuZHBEaXYub3V0ZXJXaWR0aCgpLGhlaWdodDphLmRwRGl2Lm91dGVySGVpZ2h0KCl9KTtcclxuYS5kcERpdi5maW5kKFwiLlwiK3RoaXMuX2RheU92ZXJDbGFzcytcIiBhXCIpLm1vdXNlb3ZlcigpO2I9dGhpcy5fZ2V0TnVtYmVyT2ZNb250aHMoYSk7Yz1iWzFdO2EuZHBEaXYucmVtb3ZlQ2xhc3MoXCJ1aS1kYXRlcGlja2VyLW11bHRpLTIgdWktZGF0ZXBpY2tlci1tdWx0aS0zIHVpLWRhdGVwaWNrZXItbXVsdGktNFwiKS53aWR0aChcIlwiKTtjPjEmJmEuZHBEaXYuYWRkQ2xhc3MoXCJ1aS1kYXRlcGlja2VyLW11bHRpLVwiK2MpLmNzcyhcIndpZHRoXCIsMTcqYytcImVtXCIpO2EuZHBEaXZbKGJbMF0hPTF8fGJbMV0hPTE/XCJhZGRcIjpcInJlbW92ZVwiKStcIkNsYXNzXCJdKFwidWktZGF0ZXBpY2tlci1tdWx0aVwiKTthLmRwRGl2Wyh0aGlzLl9nZXQoYSxcImlzUlRMXCIpP1wiYWRkXCI6XCJyZW1vdmVcIikrXCJDbGFzc1wiXShcInVpLWRhdGVwaWNrZXItcnRsXCIpO2E9PWQuZGF0ZXBpY2tlci5fY3VySW5zdCYmZC5kYXRlcGlja2VyLl9kYXRlcGlja2VyU2hvd2luZyYmYS5pbnB1dCYmYS5pbnB1dC5pcyhcIjp2aXNpYmxlXCIpJiZcclxuIWEuaW5wdXQuaXMoXCI6ZGlzYWJsZWRcIikmJmEuaW5wdXRbMF0hPWRvY3VtZW50LmFjdGl2ZUVsZW1lbnQmJmEuaW5wdXQuZm9jdXMoKTtpZihhLnllYXJzaHRtbCl7dmFyIGU9YS55ZWFyc2h0bWw7c2V0VGltZW91dChmdW5jdGlvbigpe2U9PT1hLnllYXJzaHRtbCYmYS55ZWFyc2h0bWwmJmEuZHBEaXYuZmluZChcInNlbGVjdC51aS1kYXRlcGlja2VyLXllYXI6Zmlyc3RcIikucmVwbGFjZVdpdGgoYS55ZWFyc2h0bWwpO2U9YS55ZWFyc2h0bWw9bnVsbH0sMCl9fSxfZ2V0Qm9yZGVyczpmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbihjKXtyZXR1cm57dGhpbjoxLG1lZGl1bToyLHRoaWNrOjN9W2NdfHxjfTtyZXR1cm5bcGFyc2VGbG9hdChiKGEuY3NzKFwiYm9yZGVyLWxlZnQtd2lkdGhcIikpKSxwYXJzZUZsb2F0KGIoYS5jc3MoXCJib3JkZXItdG9wLXdpZHRoXCIpKSldfSxfY2hlY2tPZmZzZXQ6ZnVuY3Rpb24oYSxiLGMpe3ZhciBlPWEuZHBEaXYub3V0ZXJXaWR0aCgpLGY9YS5kcERpdi5vdXRlckhlaWdodCgpLFxyXG5oPWEuaW5wdXQ/YS5pbnB1dC5vdXRlcldpZHRoKCk6MCxpPWEuaW5wdXQ/YS5pbnB1dC5vdXRlckhlaWdodCgpOjAsZz1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgrZChkb2N1bWVudCkuc2Nyb2xsTGVmdCgpLGo9ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCtkKGRvY3VtZW50KS5zY3JvbGxUb3AoKTtiLmxlZnQtPXRoaXMuX2dldChhLFwiaXNSVExcIik/ZS1oOjA7Yi5sZWZ0LT1jJiZiLmxlZnQ9PWEuaW5wdXQub2Zmc2V0KCkubGVmdD9kKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCk6MDtiLnRvcC09YyYmYi50b3A9PWEuaW5wdXQub2Zmc2V0KCkudG9wK2k/ZChkb2N1bWVudCkuc2Nyb2xsVG9wKCk6MDtiLmxlZnQtPU1hdGgubWluKGIubGVmdCxiLmxlZnQrZT5nJiZnPmU/TWF0aC5hYnMoYi5sZWZ0K2UtZyk6MCk7Yi50b3AtPU1hdGgubWluKGIudG9wLGIudG9wK2Y+aiYmaj5mP01hdGguYWJzKGYraSk6MCk7cmV0dXJuIGJ9LF9maW5kUG9zOmZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1cclxudGhpcy5fZ2V0KHRoaXMuX2dldEluc3QoYSksXCJpc1JUTFwiKTthJiYoYS50eXBlPT1cImhpZGRlblwifHxhLm5vZGVUeXBlIT0xfHxkLmV4cHIuZmlsdGVycy5oaWRkZW4oYSkpOylhPWFbYj9cInByZXZpb3VzU2libGluZ1wiOlwibmV4dFNpYmxpbmdcIl07YT1kKGEpLm9mZnNldCgpO3JldHVyblthLmxlZnQsYS50b3BdfSxfdHJpZ2dlck9uQ2xvc2U6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5fZ2V0KGEsXCJvbkNsb3NlXCIpO2lmKGIpYi5hcHBseShhLmlucHV0P2EuaW5wdXRbMF06bnVsbCxbYS5pbnB1dD9hLmlucHV0LnZhbCgpOlwiXCIsYV0pfSxfaGlkZURhdGVwaWNrZXI6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5fY3VySW5zdDtpZighKCFifHxhJiZiIT1kLmRhdGEoYSxcImRhdGVwaWNrZXJcIikpKWlmKHRoaXMuX2RhdGVwaWNrZXJTaG93aW5nKXthPXRoaXMuX2dldChiLFwic2hvd0FuaW1cIik7dmFyIGM9dGhpcy5fZ2V0KGIsXCJkdXJhdGlvblwiKSxlPWZ1bmN0aW9uKCl7ZC5kYXRlcGlja2VyLl90aWR5RGlhbG9nKGIpO1xyXG50aGlzLl9jdXJJbnN0PW51bGx9O2QuZWZmZWN0cyYmZC5lZmZlY3RzW2FdP2IuZHBEaXYuaGlkZShhLGQuZGF0ZXBpY2tlci5fZ2V0KGIsXCJzaG93T3B0aW9uc1wiKSxjLGUpOmIuZHBEaXZbYT09XCJzbGlkZURvd25cIj9cInNsaWRlVXBcIjphPT1cImZhZGVJblwiP1wiZmFkZU91dFwiOlwiaGlkZVwiXShhP2M6bnVsbCxlKTthfHxlKCk7ZC5kYXRlcGlja2VyLl90cmlnZ2VyT25DbG9zZShiKTt0aGlzLl9kYXRlcGlja2VyU2hvd2luZz1mYWxzZTt0aGlzLl9sYXN0SW5wdXQ9bnVsbDtpZih0aGlzLl9pbkRpYWxvZyl7dGhpcy5fZGlhbG9nSW5wdXQuY3NzKHtwb3NpdGlvbjpcImFic29sdXRlXCIsbGVmdDpcIjBcIix0b3A6XCItMTAwcHhcIn0pO2lmKGQuYmxvY2tVSSl7ZC51bmJsb2NrVUkoKTtkKFwiYm9keVwiKS5hcHBlbmQodGhpcy5kcERpdil9fXRoaXMuX2luRGlhbG9nPWZhbHNlfX0sX3RpZHlEaWFsb2c6ZnVuY3Rpb24oYSl7YS5kcERpdi5yZW1vdmVDbGFzcyh0aGlzLl9kaWFsb2dDbGFzcykudW5iaW5kKFwiLnVpLWRhdGVwaWNrZXItY2FsZW5kYXJcIil9LFxyXG5fY2hlY2tFeHRlcm5hbENsaWNrOmZ1bmN0aW9uKGEpe2lmKGQuZGF0ZXBpY2tlci5fY3VySW5zdCl7YT1kKGEudGFyZ2V0KTthWzBdLmlkIT1kLmRhdGVwaWNrZXIuX21haW5EaXZJZCYmYS5wYXJlbnRzKFwiI1wiK2QuZGF0ZXBpY2tlci5fbWFpbkRpdklkKS5sZW5ndGg9PTAmJiFhLmhhc0NsYXNzKGQuZGF0ZXBpY2tlci5tYXJrZXJDbGFzc05hbWUpJiYhYS5oYXNDbGFzcyhkLmRhdGVwaWNrZXIuX3RyaWdnZXJDbGFzcykmJmQuZGF0ZXBpY2tlci5fZGF0ZXBpY2tlclNob3dpbmcmJiEoZC5kYXRlcGlja2VyLl9pbkRpYWxvZyYmZC5ibG9ja1VJKSYmZC5kYXRlcGlja2VyLl9oaWRlRGF0ZXBpY2tlcigpfX0sX2FkanVzdERhdGU6ZnVuY3Rpb24oYSxiLGMpe2E9ZChhKTt2YXIgZT10aGlzLl9nZXRJbnN0KGFbMF0pO2lmKCF0aGlzLl9pc0Rpc2FibGVkRGF0ZXBpY2tlcihhWzBdKSl7dGhpcy5fYWRqdXN0SW5zdERhdGUoZSxiKyhjPT1cIk1cIj90aGlzLl9nZXQoZSxcInNob3dDdXJyZW50QXRQb3NcIik6XHJcbjApLGMpO3RoaXMuX3VwZGF0ZURhdGVwaWNrZXIoZSl9fSxfZ290b1RvZGF5OmZ1bmN0aW9uKGEpe2E9ZChhKTt2YXIgYj10aGlzLl9nZXRJbnN0KGFbMF0pO2lmKHRoaXMuX2dldChiLFwiZ290b0N1cnJlbnRcIikmJmIuY3VycmVudERheSl7Yi5zZWxlY3RlZERheT1iLmN1cnJlbnREYXk7Yi5kcmF3TW9udGg9Yi5zZWxlY3RlZE1vbnRoPWIuY3VycmVudE1vbnRoO2IuZHJhd1llYXI9Yi5zZWxlY3RlZFllYXI9Yi5jdXJyZW50WWVhcn1lbHNle3ZhciBjPW5ldyBEYXRlO2Iuc2VsZWN0ZWREYXk9Yy5nZXREYXRlKCk7Yi5kcmF3TW9udGg9Yi5zZWxlY3RlZE1vbnRoPWMuZ2V0TW9udGgoKTtiLmRyYXdZZWFyPWIuc2VsZWN0ZWRZZWFyPWMuZ2V0RnVsbFllYXIoKX10aGlzLl9ub3RpZnlDaGFuZ2UoYik7dGhpcy5fYWRqdXN0RGF0ZShhKX0sX3NlbGVjdE1vbnRoWWVhcjpmdW5jdGlvbihhLGIsYyl7YT1kKGEpO3ZhciBlPXRoaXMuX2dldEluc3QoYVswXSk7ZVtcInNlbGVjdGVkXCIrKGM9PVwiTVwiP1xyXG5cIk1vbnRoXCI6XCJZZWFyXCIpXT1lW1wiZHJhd1wiKyhjPT1cIk1cIj9cIk1vbnRoXCI6XCJZZWFyXCIpXT1wYXJzZUludChiLm9wdGlvbnNbYi5zZWxlY3RlZEluZGV4XS52YWx1ZSwxMCk7dGhpcy5fbm90aWZ5Q2hhbmdlKGUpO3RoaXMuX2FkanVzdERhdGUoYSl9LF9zZWxlY3REYXk6ZnVuY3Rpb24oYSxiLGMsZSl7dmFyIGY9ZChhKTtpZighKGQoZSkuaGFzQ2xhc3ModGhpcy5fdW5zZWxlY3RhYmxlQ2xhc3MpfHx0aGlzLl9pc0Rpc2FibGVkRGF0ZXBpY2tlcihmWzBdKSkpe2Y9dGhpcy5fZ2V0SW5zdChmWzBdKTtmLnNlbGVjdGVkRGF5PWYuY3VycmVudERheT1kKFwiYVwiLGUpLmh0bWwoKTtmLnNlbGVjdGVkTW9udGg9Zi5jdXJyZW50TW9udGg9YjtmLnNlbGVjdGVkWWVhcj1mLmN1cnJlbnRZZWFyPWM7dGhpcy5fc2VsZWN0RGF0ZShhLHRoaXMuX2Zvcm1hdERhdGUoZixmLmN1cnJlbnREYXksZi5jdXJyZW50TW9udGgsZi5jdXJyZW50WWVhcikpfX0sX2NsZWFyRGF0ZTpmdW5jdGlvbihhKXthPWQoYSk7XHJcbnRoaXMuX2dldEluc3QoYVswXSk7dGhpcy5fc2VsZWN0RGF0ZShhLFwiXCIpfSxfc2VsZWN0RGF0ZTpmdW5jdGlvbihhLGIpe2E9dGhpcy5fZ2V0SW5zdChkKGEpWzBdKTtiPWIhPW51bGw/Yjp0aGlzLl9mb3JtYXREYXRlKGEpO2EuaW5wdXQmJmEuaW5wdXQudmFsKGIpO3RoaXMuX3VwZGF0ZUFsdGVybmF0ZShhKTt2YXIgYz10aGlzLl9nZXQoYSxcIm9uU2VsZWN0XCIpO2lmKGMpYy5hcHBseShhLmlucHV0P2EuaW5wdXRbMF06bnVsbCxbYixhXSk7ZWxzZSBhLmlucHV0JiZhLmlucHV0LnRyaWdnZXIoXCJjaGFuZ2VcIik7aWYoYS5pbmxpbmUpdGhpcy5fdXBkYXRlRGF0ZXBpY2tlcihhKTtlbHNle3RoaXMuX2hpZGVEYXRlcGlja2VyKCk7dGhpcy5fbGFzdElucHV0PWEuaW5wdXRbMF07dHlwZW9mIGEuaW5wdXRbMF0hPVwib2JqZWN0XCImJmEuaW5wdXQuZm9jdXMoKTt0aGlzLl9sYXN0SW5wdXQ9bnVsbH19LF91cGRhdGVBbHRlcm5hdGU6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5fZ2V0KGEsXCJhbHRGaWVsZFwiKTtcclxuaWYoYil7dmFyIGM9dGhpcy5fZ2V0KGEsXCJhbHRGb3JtYXRcIil8fHRoaXMuX2dldChhLFwiZGF0ZUZvcm1hdFwiKSxlPXRoaXMuX2dldERhdGUoYSksZj10aGlzLmZvcm1hdERhdGUoYyxlLHRoaXMuX2dldEZvcm1hdENvbmZpZyhhKSk7ZChiKS5lYWNoKGZ1bmN0aW9uKCl7ZCh0aGlzKS52YWwoZil9KX19LG5vV2Vla2VuZHM6ZnVuY3Rpb24oYSl7YT1hLmdldERheSgpO3JldHVyblthPjAmJmE8NixcIlwiXX0saXNvODYwMVdlZWs6ZnVuY3Rpb24oYSl7YT1uZXcgRGF0ZShhLmdldFRpbWUoKSk7YS5zZXREYXRlKGEuZ2V0RGF0ZSgpKzQtKGEuZ2V0RGF5KCl8fDcpKTt2YXIgYj1hLmdldFRpbWUoKTthLnNldE1vbnRoKDApO2Euc2V0RGF0ZSgxKTtyZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJvdW5kKChiLWEpLzg2NEU1KS83KSsxfSxwYXJzZURhdGU6ZnVuY3Rpb24oYSxiLGMpe2lmKGE9PW51bGx8fGI9PW51bGwpdGhyb3dcIkludmFsaWQgYXJndW1lbnRzXCI7Yj10eXBlb2YgYj09XCJvYmplY3RcIj9cclxuYi50b1N0cmluZygpOmIrXCJcIjtpZihiPT1cIlwiKXJldHVybiBudWxsO3ZhciBlPShjP2Muc2hvcnRZZWFyQ3V0b2ZmOm51bGwpfHx0aGlzLl9kZWZhdWx0cy5zaG9ydFllYXJDdXRvZmY7ZT10eXBlb2YgZSE9XCJzdHJpbmdcIj9lOihuZXcgRGF0ZSkuZ2V0RnVsbFllYXIoKSUxMDArcGFyc2VJbnQoZSwxMCk7Zm9yKHZhciBmPShjP2MuZGF5TmFtZXNTaG9ydDpudWxsKXx8dGhpcy5fZGVmYXVsdHMuZGF5TmFtZXNTaG9ydCxoPShjP2MuZGF5TmFtZXM6bnVsbCl8fHRoaXMuX2RlZmF1bHRzLmRheU5hbWVzLGk9KGM/Yy5tb250aE5hbWVzU2hvcnQ6bnVsbCl8fHRoaXMuX2RlZmF1bHRzLm1vbnRoTmFtZXNTaG9ydCxnPShjP2MubW9udGhOYW1lczpudWxsKXx8dGhpcy5fZGVmYXVsdHMubW9udGhOYW1lcyxqPWM9LTEsbD0tMSx1PS0xLGs9ZmFsc2Usbz1mdW5jdGlvbihwKXsocD1BKzE8YS5sZW5ndGgmJmEuY2hhckF0KEErMSk9PXApJiZBKys7cmV0dXJuIHB9LG09ZnVuY3Rpb24ocCl7dmFyIEQ9XHJcbm8ocCk7cD1uZXcgUmVnRXhwKFwiXlxcXFxkezEsXCIrKHA9PVwiQFwiPzE0OnA9PVwiIVwiPzIwOnA9PVwieVwiJiZEPzQ6cD09XCJvXCI/MzoyKStcIn1cIik7cD1iLnN1YnN0cmluZyhxKS5tYXRjaChwKTtpZighcCl0aHJvd1wiTWlzc2luZyBudW1iZXIgYXQgcG9zaXRpb24gXCIrcTtxKz1wWzBdLmxlbmd0aDtyZXR1cm4gcGFyc2VJbnQocFswXSwxMCl9LG49ZnVuY3Rpb24ocCxELEspe3A9ZC5tYXAobyhwKT9LOkQsZnVuY3Rpb24odyx4KXtyZXR1cm5bW3gsd11dfSkuc29ydChmdW5jdGlvbih3LHgpe3JldHVybi0od1sxXS5sZW5ndGgteFsxXS5sZW5ndGgpfSk7dmFyIEU9LTE7ZC5lYWNoKHAsZnVuY3Rpb24odyx4KXt3PXhbMV07aWYoYi5zdWJzdHIocSx3Lmxlbmd0aCkudG9Mb3dlckNhc2UoKT09dy50b0xvd2VyQ2FzZSgpKXtFPXhbMF07cSs9dy5sZW5ndGg7cmV0dXJuIGZhbHNlfX0pO2lmKEUhPS0xKXJldHVybiBFKzE7ZWxzZSB0aHJvd1wiVW5rbm93biBuYW1lIGF0IHBvc2l0aW9uIFwiK3E7fSxzPVxyXG5mdW5jdGlvbigpe2lmKGIuY2hhckF0KHEpIT1hLmNoYXJBdChBKSl0aHJvd1wiVW5leHBlY3RlZCBsaXRlcmFsIGF0IHBvc2l0aW9uIFwiK3E7cSsrfSxxPTAsQT0wO0E8YS5sZW5ndGg7QSsrKWlmKGspaWYoYS5jaGFyQXQoQSk9PVwiJ1wiJiYhbyhcIidcIikpaz1mYWxzZTtlbHNlIHMoKTtlbHNlIHN3aXRjaChhLmNoYXJBdChBKSl7Y2FzZSBcImRcIjpsPW0oXCJkXCIpO2JyZWFrO2Nhc2UgXCJEXCI6bihcIkRcIixmLGgpO2JyZWFrO2Nhc2UgXCJvXCI6dT1tKFwib1wiKTticmVhaztjYXNlIFwibVwiOmo9bShcIm1cIik7YnJlYWs7Y2FzZSBcIk1cIjpqPW4oXCJNXCIsaSxnKTticmVhaztjYXNlIFwieVwiOmM9bShcInlcIik7YnJlYWs7Y2FzZSBcIkBcIjp2YXIgdj1uZXcgRGF0ZShtKFwiQFwiKSk7Yz12LmdldEZ1bGxZZWFyKCk7aj12LmdldE1vbnRoKCkrMTtsPXYuZ2V0RGF0ZSgpO2JyZWFrO2Nhc2UgXCIhXCI6dj1uZXcgRGF0ZSgobShcIiFcIiktdGhpcy5fdGlja3NUbzE5NzApLzFFNCk7Yz12LmdldEZ1bGxZZWFyKCk7aj12LmdldE1vbnRoKCkrXHJcbjE7bD12LmdldERhdGUoKTticmVhaztjYXNlIFwiJ1wiOmlmKG8oXCInXCIpKXMoKTtlbHNlIGs9dHJ1ZTticmVhaztkZWZhdWx0OnMoKX1pZihxPGIubGVuZ3RoKXRocm93XCJFeHRyYS91bnBhcnNlZCBjaGFyYWN0ZXJzIGZvdW5kIGluIGRhdGU6IFwiK2Iuc3Vic3RyaW5nKHEpO2lmKGM9PS0xKWM9KG5ldyBEYXRlKS5nZXRGdWxsWWVhcigpO2Vsc2UgaWYoYzwxMDApYys9KG5ldyBEYXRlKS5nZXRGdWxsWWVhcigpLShuZXcgRGF0ZSkuZ2V0RnVsbFllYXIoKSUxMDArKGM8PWU/MDotMTAwKTtpZih1Pi0xKXtqPTE7bD11O2Rve2U9dGhpcy5fZ2V0RGF5c0luTW9udGgoYyxqLTEpO2lmKGw8PWUpYnJlYWs7aisrO2wtPWV9d2hpbGUoMSl9dj10aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZShjLGotMSxsKSk7aWYodi5nZXRGdWxsWWVhcigpIT1jfHx2LmdldE1vbnRoKCkrMSE9anx8di5nZXREYXRlKCkhPWwpdGhyb3dcIkludmFsaWQgZGF0ZVwiO3JldHVybiB2fSxBVE9NOlwieXktbW0tZGRcIixcclxuQ09PS0lFOlwiRCwgZGQgTSB5eVwiLElTT184NjAxOlwieXktbW0tZGRcIixSRkNfODIyOlwiRCwgZCBNIHlcIixSRkNfODUwOlwiREQsIGRkLU0teVwiLFJGQ18xMDM2OlwiRCwgZCBNIHlcIixSRkNfMTEyMzpcIkQsIGQgTSB5eVwiLFJGQ18yODIyOlwiRCwgZCBNIHl5XCIsUlNTOlwiRCwgZCBNIHlcIixUSUNLUzpcIiFcIixUSU1FU1RBTVA6XCJAXCIsVzNDOlwieXktbW0tZGRcIixfdGlja3NUbzE5NzA6KDcxODY4NStNYXRoLmZsb29yKDQ5Mi41KS1NYXRoLmZsb29yKDE5LjcpK01hdGguZmxvb3IoNC45MjUpKSoyNCo2MCo2MCoxRTcsZm9ybWF0RGF0ZTpmdW5jdGlvbihhLGIsYyl7aWYoIWIpcmV0dXJuXCJcIjt2YXIgZT0oYz9jLmRheU5hbWVzU2hvcnQ6bnVsbCl8fHRoaXMuX2RlZmF1bHRzLmRheU5hbWVzU2hvcnQsZj0oYz9jLmRheU5hbWVzOm51bGwpfHx0aGlzLl9kZWZhdWx0cy5kYXlOYW1lcyxoPShjP2MubW9udGhOYW1lc1Nob3J0Om51bGwpfHx0aGlzLl9kZWZhdWx0cy5tb250aE5hbWVzU2hvcnQ7Yz0oYz9jLm1vbnRoTmFtZXM6XHJcbm51bGwpfHx0aGlzLl9kZWZhdWx0cy5tb250aE5hbWVzO3ZhciBpPWZ1bmN0aW9uKG8peyhvPWsrMTxhLmxlbmd0aCYmYS5jaGFyQXQoaysxKT09bykmJmsrKztyZXR1cm4gb30sZz1mdW5jdGlvbihvLG0sbil7bT1cIlwiK207aWYoaShvKSlmb3IoO20ubGVuZ3RoPG47KW09XCIwXCIrbTtyZXR1cm4gbX0saj1mdW5jdGlvbihvLG0sbixzKXtyZXR1cm4gaShvKT9zW21dOm5bbV19LGw9XCJcIix1PWZhbHNlO2lmKGIpZm9yKHZhciBrPTA7azxhLmxlbmd0aDtrKyspaWYodSlpZihhLmNoYXJBdChrKT09XCInXCImJiFpKFwiJ1wiKSl1PWZhbHNlO2Vsc2UgbCs9YS5jaGFyQXQoayk7ZWxzZSBzd2l0Y2goYS5jaGFyQXQoaykpe2Nhc2UgXCJkXCI6bCs9ZyhcImRcIixiLmdldERhdGUoKSwyKTticmVhaztjYXNlIFwiRFwiOmwrPWooXCJEXCIsYi5nZXREYXkoKSxlLGYpO2JyZWFrO2Nhc2UgXCJvXCI6bCs9ZyhcIm9cIixNYXRoLnJvdW5kKCgobmV3IERhdGUoYi5nZXRGdWxsWWVhcigpLGIuZ2V0TW9udGgoKSxiLmdldERhdGUoKSkpLmdldFRpbWUoKS1cclxuKG5ldyBEYXRlKGIuZ2V0RnVsbFllYXIoKSwwLDApKS5nZXRUaW1lKCkpLzg2NEU1KSwzKTticmVhaztjYXNlIFwibVwiOmwrPWcoXCJtXCIsYi5nZXRNb250aCgpKzEsMik7YnJlYWs7Y2FzZSBcIk1cIjpsKz1qKFwiTVwiLGIuZ2V0TW9udGgoKSxoLGMpO2JyZWFrO2Nhc2UgXCJ5XCI6bCs9aShcInlcIik/Yi5nZXRGdWxsWWVhcigpOihiLmdldFllYXIoKSUxMDA8MTA/XCIwXCI6XCJcIikrYi5nZXRZZWFyKCklMTAwO2JyZWFrO2Nhc2UgXCJAXCI6bCs9Yi5nZXRUaW1lKCk7YnJlYWs7Y2FzZSBcIiFcIjpsKz1iLmdldFRpbWUoKSoxRTQrdGhpcy5fdGlja3NUbzE5NzA7YnJlYWs7Y2FzZSBcIidcIjppZihpKFwiJ1wiKSlsKz1cIidcIjtlbHNlIHU9dHJ1ZTticmVhaztkZWZhdWx0OmwrPWEuY2hhckF0KGspfXJldHVybiBsfSxfcG9zc2libGVDaGFyczpmdW5jdGlvbihhKXtmb3IodmFyIGI9XCJcIixjPWZhbHNlLGU9ZnVuY3Rpb24oaCl7KGg9ZisxPGEubGVuZ3RoJiZhLmNoYXJBdChmKzEpPT1oKSYmZisrO3JldHVybiBofSxmPVxyXG4wO2Y8YS5sZW5ndGg7ZisrKWlmKGMpaWYoYS5jaGFyQXQoZik9PVwiJ1wiJiYhZShcIidcIikpYz1mYWxzZTtlbHNlIGIrPWEuY2hhckF0KGYpO2Vsc2Ugc3dpdGNoKGEuY2hhckF0KGYpKXtjYXNlIFwiZFwiOmNhc2UgXCJtXCI6Y2FzZSBcInlcIjpjYXNlIFwiQFwiOmIrPVwiMDEyMzQ1Njc4OVwiO2JyZWFrO2Nhc2UgXCJEXCI6Y2FzZSBcIk1cIjpyZXR1cm4gbnVsbDtjYXNlIFwiJ1wiOmlmKGUoXCInXCIpKWIrPVwiJ1wiO2Vsc2UgYz10cnVlO2JyZWFrO2RlZmF1bHQ6Yis9YS5jaGFyQXQoZil9cmV0dXJuIGJ9LF9nZXQ6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS5zZXR0aW5nc1tiXSE9PUM/YS5zZXR0aW5nc1tiXTp0aGlzLl9kZWZhdWx0c1tiXX0sX3NldERhdGVGcm9tRmllbGQ6ZnVuY3Rpb24oYSxiKXtpZihhLmlucHV0LnZhbCgpIT1hLmxhc3RWYWwpe3ZhciBjPXRoaXMuX2dldChhLFwiZGF0ZUZvcm1hdFwiKSxlPWEubGFzdFZhbD1hLmlucHV0P2EuaW5wdXQudmFsKCk6bnVsbCxmLGg7Zj1oPXRoaXMuX2dldERlZmF1bHREYXRlKGEpO1xyXG52YXIgaT10aGlzLl9nZXRGb3JtYXRDb25maWcoYSk7dHJ5e2Y9dGhpcy5wYXJzZURhdGUoYyxlLGkpfHxofWNhdGNoKGcpe3RoaXMubG9nKGcpO2U9Yj9cIlwiOmV9YS5zZWxlY3RlZERheT1mLmdldERhdGUoKTthLmRyYXdNb250aD1hLnNlbGVjdGVkTW9udGg9Zi5nZXRNb250aCgpO2EuZHJhd1llYXI9YS5zZWxlY3RlZFllYXI9Zi5nZXRGdWxsWWVhcigpO2EuY3VycmVudERheT1lP2YuZ2V0RGF0ZSgpOjA7YS5jdXJyZW50TW9udGg9ZT9mLmdldE1vbnRoKCk6MDthLmN1cnJlbnRZZWFyPWU/Zi5nZXRGdWxsWWVhcigpOjA7dGhpcy5fYWRqdXN0SW5zdERhdGUoYSl9fSxfZ2V0RGVmYXVsdERhdGU6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuX3Jlc3RyaWN0TWluTWF4KGEsdGhpcy5fZGV0ZXJtaW5lRGF0ZShhLHRoaXMuX2dldChhLFwiZGVmYXVsdERhdGVcIiksbmV3IERhdGUpKX0sX2RldGVybWluZURhdGU6ZnVuY3Rpb24oYSxiLGMpe3ZhciBlPWZ1bmN0aW9uKGgpe3ZhciBpPW5ldyBEYXRlO1xyXG5pLnNldERhdGUoaS5nZXREYXRlKCkraCk7cmV0dXJuIGl9LGY9ZnVuY3Rpb24oaCl7dHJ5e3JldHVybiBkLmRhdGVwaWNrZXIucGFyc2VEYXRlKGQuZGF0ZXBpY2tlci5fZ2V0KGEsXCJkYXRlRm9ybWF0XCIpLGgsZC5kYXRlcGlja2VyLl9nZXRGb3JtYXRDb25maWcoYSkpfWNhdGNoKGkpe312YXIgZz0oaC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9eYy8pP2QuZGF0ZXBpY2tlci5fZ2V0RGF0ZShhKTpudWxsKXx8bmV3IERhdGUsaj1nLmdldEZ1bGxZZWFyKCksbD1nLmdldE1vbnRoKCk7Zz1nLmdldERhdGUoKTtmb3IodmFyIHU9LyhbKy1dP1swLTldKylcXHMqKGR8RHx3fFd8bXxNfHl8WSk/L2csaz11LmV4ZWMoaCk7azspe3N3aXRjaChrWzJdfHxcImRcIil7Y2FzZSBcImRcIjpjYXNlIFwiRFwiOmcrPXBhcnNlSW50KGtbMV0sMTApO2JyZWFrO2Nhc2UgXCJ3XCI6Y2FzZSBcIldcIjpnKz1wYXJzZUludChrWzFdLDEwKSo3O2JyZWFrO2Nhc2UgXCJtXCI6Y2FzZSBcIk1cIjpsKz1wYXJzZUludChrWzFdLDEwKTtnPVxyXG5NYXRoLm1pbihnLGQuZGF0ZXBpY2tlci5fZ2V0RGF5c0luTW9udGgoaixsKSk7YnJlYWs7Y2FzZSBcInlcIjpjYXNlIFwiWVwiOmorPXBhcnNlSW50KGtbMV0sMTApO2c9TWF0aC5taW4oZyxkLmRhdGVwaWNrZXIuX2dldERheXNJbk1vbnRoKGosbCkpO2JyZWFrfWs9dS5leGVjKGgpfXJldHVybiBuZXcgRGF0ZShqLGwsZyl9O2lmKGI9KGI9Yj09bnVsbHx8Yj09PVwiXCI/Yzp0eXBlb2YgYj09XCJzdHJpbmdcIj9mKGIpOnR5cGVvZiBiPT1cIm51bWJlclwiP2lzTmFOKGIpP2M6ZShiKTpuZXcgRGF0ZShiLmdldFRpbWUoKSkpJiZiLnRvU3RyaW5nKCk9PVwiSW52YWxpZCBEYXRlXCI/YzpiKXtiLnNldEhvdXJzKDApO2Iuc2V0TWludXRlcygwKTtiLnNldFNlY29uZHMoMCk7Yi5zZXRNaWxsaXNlY29uZHMoMCl9cmV0dXJuIHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KGIpfSxfZGF5bGlnaHRTYXZpbmdBZGp1c3Q6ZnVuY3Rpb24oYSl7aWYoIWEpcmV0dXJuIG51bGw7YS5zZXRIb3VycyhhLmdldEhvdXJzKCk+XHJcbjEyP2EuZ2V0SG91cnMoKSsyOjApO3JldHVybiBhfSxfc2V0RGF0ZTpmdW5jdGlvbihhLGIsYyl7dmFyIGU9IWIsZj1hLnNlbGVjdGVkTW9udGgsaD1hLnNlbGVjdGVkWWVhcjtiPXRoaXMuX3Jlc3RyaWN0TWluTWF4KGEsdGhpcy5fZGV0ZXJtaW5lRGF0ZShhLGIsbmV3IERhdGUpKTthLnNlbGVjdGVkRGF5PWEuY3VycmVudERheT1iLmdldERhdGUoKTthLmRyYXdNb250aD1hLnNlbGVjdGVkTW9udGg9YS5jdXJyZW50TW9udGg9Yi5nZXRNb250aCgpO2EuZHJhd1llYXI9YS5zZWxlY3RlZFllYXI9YS5jdXJyZW50WWVhcj1iLmdldEZ1bGxZZWFyKCk7aWYoKGYhPWEuc2VsZWN0ZWRNb250aHx8aCE9YS5zZWxlY3RlZFllYXIpJiYhYyl0aGlzLl9ub3RpZnlDaGFuZ2UoYSk7dGhpcy5fYWRqdXN0SW5zdERhdGUoYSk7aWYoYS5pbnB1dClhLmlucHV0LnZhbChlP1wiXCI6dGhpcy5fZm9ybWF0RGF0ZShhKSl9LF9nZXREYXRlOmZ1bmN0aW9uKGEpe3JldHVybiFhLmN1cnJlbnRZZWFyfHxhLmlucHV0JiZcclxuYS5pbnB1dC52YWwoKT09XCJcIj9udWxsOnRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKGEuY3VycmVudFllYXIsYS5jdXJyZW50TW9udGgsYS5jdXJyZW50RGF5KSl9LF9nZW5lcmF0ZUhUTUw6ZnVuY3Rpb24oYSl7dmFyIGI9bmV3IERhdGU7Yj10aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZShiLmdldEZ1bGxZZWFyKCksYi5nZXRNb250aCgpLGIuZ2V0RGF0ZSgpKSk7dmFyIGM9dGhpcy5fZ2V0KGEsXCJpc1JUTFwiKSxlPXRoaXMuX2dldChhLFwic2hvd0J1dHRvblBhbmVsXCIpLGY9dGhpcy5fZ2V0KGEsXCJoaWRlSWZOb1ByZXZOZXh0XCIpLGg9dGhpcy5fZ2V0KGEsXCJuYXZpZ2F0aW9uQXNEYXRlRm9ybWF0XCIpLGk9dGhpcy5fZ2V0TnVtYmVyT2ZNb250aHMoYSksZz10aGlzLl9nZXQoYSxcInNob3dDdXJyZW50QXRQb3NcIiksaj10aGlzLl9nZXQoYSxcInN0ZXBNb250aHNcIiksbD1pWzBdIT0xfHxpWzFdIT0xLHU9dGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QoIWEuY3VycmVudERheT9cclxubmV3IERhdGUoOTk5OSw5LDkpOm5ldyBEYXRlKGEuY3VycmVudFllYXIsYS5jdXJyZW50TW9udGgsYS5jdXJyZW50RGF5KSksaz10aGlzLl9nZXRNaW5NYXhEYXRlKGEsXCJtaW5cIiksbz10aGlzLl9nZXRNaW5NYXhEYXRlKGEsXCJtYXhcIik7Zz1hLmRyYXdNb250aC1nO3ZhciBtPWEuZHJhd1llYXI7aWYoZzwwKXtnKz0xMjttLS19aWYobyl7dmFyIG49dGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoby5nZXRGdWxsWWVhcigpLG8uZ2V0TW9udGgoKS1pWzBdKmlbMV0rMSxvLmdldERhdGUoKSkpO2ZvcihuPWsmJm48az9rOm47dGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUobSxnLDEpKT5uOyl7Zy0tO2lmKGc8MCl7Zz0xMTttLS19fX1hLmRyYXdNb250aD1nO2EuZHJhd1llYXI9bTtuPXRoaXMuX2dldChhLFwicHJldlRleHRcIik7bj0haD9uOnRoaXMuZm9ybWF0RGF0ZShuLHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKG0sZy1qLDEpKSx0aGlzLl9nZXRGb3JtYXRDb25maWcoYSkpO1xyXG5uPXRoaXMuX2NhbkFkanVzdE1vbnRoKGEsLTEsbSxnKT8nPGEgY2xhc3M9XCJ1aS1kYXRlcGlja2VyLXByZXYgdWktY29ybmVyLWFsbFwiIG9uY2xpY2s9XCJEUF9qUXVlcnlfJytCK1wiLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoJyNcIithLmlkK1wiJywgLVwiK2orXCIsICdNJyk7XFxcIiB0aXRsZT1cXFwiXCIrbisnXCI+PHNwYW4gY2xhc3M9XCJ1aS1pY29uIHVpLWljb24tY2lyY2xlLXRyaWFuZ2xlLScrKGM/XCJlXCI6XCJ3XCIpKydcIj4nK24rXCI8L3NwYW4+PC9hPlwiOmY/XCJcIjonPGEgY2xhc3M9XCJ1aS1kYXRlcGlja2VyLXByZXYgdWktY29ybmVyLWFsbCB1aS1zdGF0ZS1kaXNhYmxlZFwiIHRpdGxlPVwiJytuKydcIj48c3BhbiBjbGFzcz1cInVpLWljb24gdWktaWNvbi1jaXJjbGUtdHJpYW5nbGUtJysoYz9cImVcIjpcIndcIikrJ1wiPicrbitcIjwvc3Bhbj48L2E+XCI7dmFyIHM9dGhpcy5fZ2V0KGEsXCJuZXh0VGV4dFwiKTtzPSFoP3M6dGhpcy5mb3JtYXREYXRlKHMsdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUobSxcclxuZytqLDEpKSx0aGlzLl9nZXRGb3JtYXRDb25maWcoYSkpO2Y9dGhpcy5fY2FuQWRqdXN0TW9udGgoYSwrMSxtLGcpPyc8YSBjbGFzcz1cInVpLWRhdGVwaWNrZXItbmV4dCB1aS1jb3JuZXItYWxsXCIgb25jbGljaz1cIkRQX2pRdWVyeV8nK0IrXCIuZGF0ZXBpY2tlci5fYWRqdXN0RGF0ZSgnI1wiK2EuaWQrXCInLCArXCIraitcIiwgJ00nKTtcXFwiIHRpdGxlPVxcXCJcIitzKydcIj48c3BhbiBjbGFzcz1cInVpLWljb24gdWktaWNvbi1jaXJjbGUtdHJpYW5nbGUtJysoYz9cIndcIjpcImVcIikrJ1wiPicrcytcIjwvc3Bhbj48L2E+XCI6Zj9cIlwiOic8YSBjbGFzcz1cInVpLWRhdGVwaWNrZXItbmV4dCB1aS1jb3JuZXItYWxsIHVpLXN0YXRlLWRpc2FibGVkXCIgdGl0bGU9XCInK3MrJ1wiPjxzcGFuIGNsYXNzPVwidWktaWNvbiB1aS1pY29uLWNpcmNsZS10cmlhbmdsZS0nKyhjP1wid1wiOlwiZVwiKSsnXCI+JytzK1wiPC9zcGFuPjwvYT5cIjtqPXRoaXMuX2dldChhLFwiY3VycmVudFRleHRcIik7cz10aGlzLl9nZXQoYSxcImdvdG9DdXJyZW50XCIpJiZcclxuYS5jdXJyZW50RGF5P3U6YjtqPSFoP2o6dGhpcy5mb3JtYXREYXRlKGoscyx0aGlzLl9nZXRGb3JtYXRDb25maWcoYSkpO2g9IWEuaW5saW5lPyc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cInVpLWRhdGVwaWNrZXItY2xvc2UgdWktc3RhdGUtZGVmYXVsdCB1aS1wcmlvcml0eS1wcmltYXJ5IHVpLWNvcm5lci1hbGxcIiBvbmNsaWNrPVwiRFBfalF1ZXJ5XycrQisnLmRhdGVwaWNrZXIuX2hpZGVEYXRlcGlja2VyKCk7XCI+Jyt0aGlzLl9nZXQoYSxcImNsb3NlVGV4dFwiKStcIjwvYnV0dG9uPlwiOlwiXCI7ZT1lPyc8ZGl2IGNsYXNzPVwidWktZGF0ZXBpY2tlci1idXR0b25wYW5lIHVpLXdpZGdldC1jb250ZW50XCI+JysoYz9oOlwiXCIpKyh0aGlzLl9pc0luUmFuZ2UoYSxzKT8nPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJ1aS1kYXRlcGlja2VyLWN1cnJlbnQgdWktc3RhdGUtZGVmYXVsdCB1aS1wcmlvcml0eS1zZWNvbmRhcnkgdWktY29ybmVyLWFsbFwiIG9uY2xpY2s9XCJEUF9qUXVlcnlfJytcclxuQitcIi5kYXRlcGlja2VyLl9nb3RvVG9kYXkoJyNcIithLmlkK1wiJyk7XFxcIj5cIitqK1wiPC9idXR0b24+XCI6XCJcIikrKGM/XCJcIjpoKStcIjwvZGl2PlwiOlwiXCI7aD1wYXJzZUludCh0aGlzLl9nZXQoYSxcImZpcnN0RGF5XCIpLDEwKTtoPWlzTmFOKGgpPzA6aDtqPXRoaXMuX2dldChhLFwic2hvd1dlZWtcIik7cz10aGlzLl9nZXQoYSxcImRheU5hbWVzXCIpO3RoaXMuX2dldChhLFwiZGF5TmFtZXNTaG9ydFwiKTt2YXIgcT10aGlzLl9nZXQoYSxcImRheU5hbWVzTWluXCIpLEE9dGhpcy5fZ2V0KGEsXCJtb250aE5hbWVzXCIpLHY9dGhpcy5fZ2V0KGEsXCJtb250aE5hbWVzU2hvcnRcIikscD10aGlzLl9nZXQoYSxcImJlZm9yZVNob3dEYXlcIiksRD10aGlzLl9nZXQoYSxcInNob3dPdGhlck1vbnRoc1wiKSxLPXRoaXMuX2dldChhLFwic2VsZWN0T3RoZXJNb250aHNcIik7dGhpcy5fZ2V0KGEsXCJjYWxjdWxhdGVXZWVrXCIpO2Zvcih2YXIgRT10aGlzLl9nZXREZWZhdWx0RGF0ZShhKSx3PVwiXCIseD0wO3g8aVswXTt4Kyspe3ZhciBPPVxyXG5cIlwiO3RoaXMubWF4Um93cz00O2Zvcih2YXIgRz0wO0c8aVsxXTtHKyspe3ZhciBQPXRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKG0sZyxhLnNlbGVjdGVkRGF5KSksdD1cIiB1aS1jb3JuZXItYWxsXCIseT1cIlwiO2lmKGwpe3krPSc8ZGl2IGNsYXNzPVwidWktZGF0ZXBpY2tlci1ncm91cCc7aWYoaVsxXT4xKXN3aXRjaChHKXtjYXNlIDA6eSs9XCIgdWktZGF0ZXBpY2tlci1ncm91cC1maXJzdFwiO3Q9XCIgdWktY29ybmVyLVwiKyhjP1wicmlnaHRcIjpcImxlZnRcIik7YnJlYWs7Y2FzZSBpWzFdLTE6eSs9XCIgdWktZGF0ZXBpY2tlci1ncm91cC1sYXN0XCI7dD1cIiB1aS1jb3JuZXItXCIrKGM/XCJsZWZ0XCI6XCJyaWdodFwiKTticmVhaztkZWZhdWx0OnkrPVwiIHVpLWRhdGVwaWNrZXItZ3JvdXAtbWlkZGxlXCI7dD1cIlwiO2JyZWFrfXkrPSdcIj4nfXkrPSc8ZGl2IGNsYXNzPVwidWktZGF0ZXBpY2tlci1oZWFkZXIgdWktd2lkZ2V0LWhlYWRlciB1aS1oZWxwZXItY2xlYXJmaXgnK3QrJ1wiPicrKC9hbGx8bGVmdC8udGVzdCh0KSYmXHJcbng9PTA/Yz9mOm46XCJcIikrKC9hbGx8cmlnaHQvLnRlc3QodCkmJng9PTA/Yz9uOmY6XCJcIikrdGhpcy5fZ2VuZXJhdGVNb250aFllYXJIZWFkZXIoYSxnLG0sayxvLHg+MHx8Rz4wLEEsdikrJzwvZGl2Pjx0YWJsZSBjbGFzcz1cInVpLWRhdGVwaWNrZXItY2FsZW5kYXJcIj48dGhlYWQ+PHRyPic7dmFyIHo9aj8nPHRoIGNsYXNzPVwidWktZGF0ZXBpY2tlci13ZWVrLWNvbFwiPicrdGhpcy5fZ2V0KGEsXCJ3ZWVrSGVhZGVyXCIpK1wiPC90aD5cIjpcIlwiO2Zvcih0PTA7dDw3O3QrKyl7dmFyIHI9KHQraCklNzt6Kz1cIjx0aFwiKygodCtoKzYpJTc+PTU/JyBjbGFzcz1cInVpLWRhdGVwaWNrZXItd2Vlay1lbmRcIic6XCJcIikrJz48c3BhbiB0aXRsZT1cIicrc1tyXSsnXCI+JytxW3JdK1wiPC9zcGFuPjwvdGg+XCJ9eSs9eitcIjwvdHI+PC90aGVhZD48dGJvZHk+XCI7ej10aGlzLl9nZXREYXlzSW5Nb250aChtLGcpO2lmKG09PWEuc2VsZWN0ZWRZZWFyJiZnPT1hLnNlbGVjdGVkTW9udGgpYS5zZWxlY3RlZERheT1NYXRoLm1pbihhLnNlbGVjdGVkRGF5LFxyXG56KTt0PSh0aGlzLl9nZXRGaXJzdERheU9mTW9udGgobSxnKS1oKzcpJTc7ej1NYXRoLmNlaWwoKHQreikvNyk7dGhpcy5tYXhSb3dzPXo9bD90aGlzLm1heFJvd3M+ej90aGlzLm1heFJvd3M6ejp6O3I9dGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUobSxnLDEtdCkpO2Zvcih2YXIgUT0wO1E8ejtRKyspe3krPVwiPHRyPlwiO3ZhciBSPSFqP1wiXCI6Jzx0ZCBjbGFzcz1cInVpLWRhdGVwaWNrZXItd2Vlay1jb2xcIj4nK3RoaXMuX2dldChhLFwiY2FsY3VsYXRlV2Vla1wiKShyKStcIjwvdGQ+XCI7Zm9yKHQ9MDt0PDc7dCsrKXt2YXIgST1wP3AuYXBwbHkoYS5pbnB1dD9hLmlucHV0WzBdOm51bGwsW3JdKTpbdHJ1ZSxcIlwiXSxGPXIuZ2V0TW9udGgoKSE9ZyxMPUYmJiFLfHwhSVswXXx8ayYmcjxrfHxvJiZyPm87Uis9Jzx0ZCBjbGFzcz1cIicrKCh0K2grNiklNz49NT9cIiB1aS1kYXRlcGlja2VyLXdlZWstZW5kXCI6XCJcIikrKEY/XCIgdWktZGF0ZXBpY2tlci1vdGhlci1tb250aFwiOlwiXCIpKyhyLmdldFRpbWUoKT09XHJcblAuZ2V0VGltZSgpJiZnPT1hLnNlbGVjdGVkTW9udGgmJmEuX2tleUV2ZW50fHxFLmdldFRpbWUoKT09ci5nZXRUaW1lKCkmJkUuZ2V0VGltZSgpPT1QLmdldFRpbWUoKT9cIiBcIit0aGlzLl9kYXlPdmVyQ2xhc3M6XCJcIikrKEw/XCIgXCIrdGhpcy5fdW5zZWxlY3RhYmxlQ2xhc3MrXCIgdWktc3RhdGUtZGlzYWJsZWRcIjpcIlwiKSsoRiYmIUQ/XCJcIjpcIiBcIitJWzFdKyhyLmdldFRpbWUoKT09dS5nZXRUaW1lKCk/XCIgXCIrdGhpcy5fY3VycmVudENsYXNzOlwiXCIpKyhyLmdldFRpbWUoKT09Yi5nZXRUaW1lKCk/XCIgdWktZGF0ZXBpY2tlci10b2RheVwiOlwiXCIpKSsnXCInKygoIUZ8fEQpJiZJWzJdPycgdGl0bGU9XCInK0lbMl0rJ1wiJzpcIlwiKSsoTD9cIlwiOicgb25jbGljaz1cIkRQX2pRdWVyeV8nK0IrXCIuZGF0ZXBpY2tlci5fc2VsZWN0RGF5KCcjXCIrYS5pZCtcIicsXCIrci5nZXRNb250aCgpK1wiLFwiK3IuZ2V0RnVsbFllYXIoKSsnLCB0aGlzKTtyZXR1cm4gZmFsc2U7XCInKStcIj5cIisoRiYmIUQ/XCImI3hhMDtcIjpMPyc8c3BhbiBjbGFzcz1cInVpLXN0YXRlLWRlZmF1bHRcIj4nK1xyXG5yLmdldERhdGUoKStcIjwvc3Bhbj5cIjonPGEgY2xhc3M9XCJ1aS1zdGF0ZS1kZWZhdWx0Jysoci5nZXRUaW1lKCk9PWIuZ2V0VGltZSgpP1wiIHVpLXN0YXRlLWhpZ2hsaWdodFwiOlwiXCIpKyhyLmdldFRpbWUoKT09dS5nZXRUaW1lKCk/XCIgdWktc3RhdGUtYWN0aXZlXCI6XCJcIikrKEY/XCIgdWktcHJpb3JpdHktc2Vjb25kYXJ5XCI6XCJcIikrJ1wiIGhyZWY9XCIjXCI+JytyLmdldERhdGUoKStcIjwvYT5cIikrXCI8L3RkPlwiO3Iuc2V0RGF0ZShyLmdldERhdGUoKSsxKTtyPXRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KHIpfXkrPVIrXCI8L3RyPlwifWcrKztpZihnPjExKXtnPTA7bSsrfXkrPVwiPC90Ym9keT48L3RhYmxlPlwiKyhsP1wiPC9kaXY+XCIrKGlbMF0+MCYmRz09aVsxXS0xPyc8ZGl2IGNsYXNzPVwidWktZGF0ZXBpY2tlci1yb3ctYnJlYWtcIj48L2Rpdj4nOlwiXCIpOlwiXCIpO08rPXl9dys9T313Kz1lKyhkLmJyb3dzZXIubXNpZSYmcGFyc2VJbnQoZC5icm93c2VyLnZlcnNpb24sMTApPDcmJiFhLmlubGluZT8nPGlmcmFtZSBzcmM9XCJqYXZhc2NyaXB0OmZhbHNlO1wiIGNsYXNzPVwidWktZGF0ZXBpY2tlci1jb3ZlclwiIGZyYW1lYm9yZGVyPVwiMFwiPjwvaWZyYW1lPic6XHJcblwiXCIpO2EuX2tleUV2ZW50PWZhbHNlO3JldHVybiB3fSxfZ2VuZXJhdGVNb250aFllYXJIZWFkZXI6ZnVuY3Rpb24oYSxiLGMsZSxmLGgsaSxnKXt2YXIgaj10aGlzLl9nZXQoYSxcImNoYW5nZU1vbnRoXCIpLGw9dGhpcy5fZ2V0KGEsXCJjaGFuZ2VZZWFyXCIpLHU9dGhpcy5fZ2V0KGEsXCJzaG93TW9udGhBZnRlclllYXJcIiksaz0nPGRpdiBjbGFzcz1cInVpLWRhdGVwaWNrZXItdGl0bGVcIj4nLG89XCJcIjtpZihofHwhailvKz0nPHNwYW4gY2xhc3M9XCJ1aS1kYXRlcGlja2VyLW1vbnRoXCI+JytpW2JdK1wiPC9zcGFuPlwiO2Vsc2V7aT1lJiZlLmdldEZ1bGxZZWFyKCk9PWM7dmFyIG09ZiYmZi5nZXRGdWxsWWVhcigpPT1jO28rPSc8c2VsZWN0IGNsYXNzPVwidWktZGF0ZXBpY2tlci1tb250aFwiIG9uY2hhbmdlPVwiRFBfalF1ZXJ5XycrQitcIi5kYXRlcGlja2VyLl9zZWxlY3RNb250aFllYXIoJyNcIithLmlkK1wiJywgdGhpcywgJ00nKTtcXFwiID5cIjtmb3IodmFyIG49MDtuPDEyO24rKylpZigoIWl8fG4+PWUuZ2V0TW9udGgoKSkmJlxyXG4oIW18fG48PWYuZ2V0TW9udGgoKSkpbys9JzxvcHRpb24gdmFsdWU9XCInK24rJ1wiJysobj09Yj8nIHNlbGVjdGVkPVwic2VsZWN0ZWRcIic6XCJcIikrXCI+XCIrZ1tuXStcIjwvb3B0aW9uPlwiO28rPVwiPC9zZWxlY3Q+XCJ9dXx8KGsrPW8rKGh8fCEoaiYmbCk/XCImI3hhMDtcIjpcIlwiKSk7aWYoIWEueWVhcnNodG1sKXthLnllYXJzaHRtbD1cIlwiO2lmKGh8fCFsKWsrPSc8c3BhbiBjbGFzcz1cInVpLWRhdGVwaWNrZXIteWVhclwiPicrYytcIjwvc3Bhbj5cIjtlbHNle2c9dGhpcy5fZ2V0KGEsXCJ5ZWFyUmFuZ2VcIikuc3BsaXQoXCI6XCIpO3ZhciBzPShuZXcgRGF0ZSkuZ2V0RnVsbFllYXIoKTtpPWZ1bmN0aW9uKHEpe3E9cS5tYXRjaCgvY1srLV0uKi8pP2MrcGFyc2VJbnQocS5zdWJzdHJpbmcoMSksMTApOnEubWF0Y2goL1srLV0uKi8pP3MrcGFyc2VJbnQocSwxMCk6cGFyc2VJbnQocSwxMCk7cmV0dXJuIGlzTmFOKHEpP3M6cX07Yj1pKGdbMF0pO2c9TWF0aC5tYXgoYixpKGdbMV18fFwiXCIpKTtiPWU/TWF0aC5tYXgoYixcclxuZS5nZXRGdWxsWWVhcigpKTpiO2c9Zj9NYXRoLm1pbihnLGYuZ2V0RnVsbFllYXIoKSk6Zztmb3IoYS55ZWFyc2h0bWwrPSc8c2VsZWN0IGNsYXNzPVwidWktZGF0ZXBpY2tlci15ZWFyXCIgb25jaGFuZ2U9XCJEUF9qUXVlcnlfJytCK1wiLmRhdGVwaWNrZXIuX3NlbGVjdE1vbnRoWWVhcignI1wiK2EuaWQrXCInLCB0aGlzLCAnWScpO1xcXCIgPlwiO2I8PWc7YisrKWEueWVhcnNodG1sKz0nPG9wdGlvbiB2YWx1ZT1cIicrYisnXCInKyhiPT1jPycgc2VsZWN0ZWQ9XCJzZWxlY3RlZFwiJzpcIlwiKStcIj5cIitiK1wiPC9vcHRpb24+XCI7YS55ZWFyc2h0bWwrPVwiPC9zZWxlY3Q+XCI7ays9YS55ZWFyc2h0bWw7YS55ZWFyc2h0bWw9bnVsbH19ays9dGhpcy5fZ2V0KGEsXCJ5ZWFyU3VmZml4XCIpO2lmKHUpays9KGh8fCEoaiYmbCk/XCImI3hhMDtcIjpcIlwiKStvO2srPVwiPC9kaXY+XCI7cmV0dXJuIGt9LF9hZGp1c3RJbnN0RGF0ZTpmdW5jdGlvbihhLGIsYyl7dmFyIGU9YS5kcmF3WWVhcisoYz09XCJZXCI/YjowKSxmPWEuZHJhd01vbnRoK1xyXG4oYz09XCJNXCI/YjowKTtiPU1hdGgubWluKGEuc2VsZWN0ZWREYXksdGhpcy5fZ2V0RGF5c0luTW9udGgoZSxmKSkrKGM9PVwiRFwiP2I6MCk7ZT10aGlzLl9yZXN0cmljdE1pbk1heChhLHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKGUsZixiKSkpO2Euc2VsZWN0ZWREYXk9ZS5nZXREYXRlKCk7YS5kcmF3TW9udGg9YS5zZWxlY3RlZE1vbnRoPWUuZ2V0TW9udGgoKTthLmRyYXdZZWFyPWEuc2VsZWN0ZWRZZWFyPWUuZ2V0RnVsbFllYXIoKTtpZihjPT1cIk1cInx8Yz09XCJZXCIpdGhpcy5fbm90aWZ5Q2hhbmdlKGEpfSxfcmVzdHJpY3RNaW5NYXg6ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLl9nZXRNaW5NYXhEYXRlKGEsXCJtaW5cIik7YT10aGlzLl9nZXRNaW5NYXhEYXRlKGEsXCJtYXhcIik7Yj1jJiZiPGM/YzpiO3JldHVybiBiPWEmJmI+YT9hOmJ9LF9ub3RpZnlDaGFuZ2U6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5fZ2V0KGEsXCJvbkNoYW5nZU1vbnRoWWVhclwiKTtpZihiKWIuYXBwbHkoYS5pbnB1dD9cclxuYS5pbnB1dFswXTpudWxsLFthLnNlbGVjdGVkWWVhcixhLnNlbGVjdGVkTW9udGgrMSxhXSl9LF9nZXROdW1iZXJPZk1vbnRoczpmdW5jdGlvbihhKXthPXRoaXMuX2dldChhLFwibnVtYmVyT2ZNb250aHNcIik7cmV0dXJuIGE9PW51bGw/WzEsMV06dHlwZW9mIGE9PVwibnVtYmVyXCI/WzEsYV06YX0sX2dldE1pbk1heERhdGU6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5fZGV0ZXJtaW5lRGF0ZShhLHRoaXMuX2dldChhLGIrXCJEYXRlXCIpLG51bGwpfSxfZ2V0RGF5c0luTW9udGg6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gMzItdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoYSxiLDMyKSkuZ2V0RGF0ZSgpfSxfZ2V0Rmlyc3REYXlPZk1vbnRoOmZ1bmN0aW9uKGEsYil7cmV0dXJuKG5ldyBEYXRlKGEsYiwxKSkuZ2V0RGF5KCl9LF9jYW5BZGp1c3RNb250aDpmdW5jdGlvbihhLGIsYyxlKXt2YXIgZj10aGlzLl9nZXROdW1iZXJPZk1vbnRocyhhKTtjPXRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKGMsXHJcbmUrKGI8MD9iOmZbMF0qZlsxXSksMSkpO2I8MCYmYy5zZXREYXRlKHRoaXMuX2dldERheXNJbk1vbnRoKGMuZ2V0RnVsbFllYXIoKSxjLmdldE1vbnRoKCkpKTtyZXR1cm4gdGhpcy5faXNJblJhbmdlKGEsYyl9LF9pc0luUmFuZ2U6ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLl9nZXRNaW5NYXhEYXRlKGEsXCJtaW5cIik7YT10aGlzLl9nZXRNaW5NYXhEYXRlKGEsXCJtYXhcIik7cmV0dXJuKCFjfHxiLmdldFRpbWUoKT49Yy5nZXRUaW1lKCkpJiYoIWF8fGIuZ2V0VGltZSgpPD1hLmdldFRpbWUoKSl9LF9nZXRGb3JtYXRDb25maWc6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5fZ2V0KGEsXCJzaG9ydFllYXJDdXRvZmZcIik7Yj10eXBlb2YgYiE9XCJzdHJpbmdcIj9iOihuZXcgRGF0ZSkuZ2V0RnVsbFllYXIoKSUxMDArcGFyc2VJbnQoYiwxMCk7cmV0dXJue3Nob3J0WWVhckN1dG9mZjpiLGRheU5hbWVzU2hvcnQ6dGhpcy5fZ2V0KGEsXCJkYXlOYW1lc1Nob3J0XCIpLGRheU5hbWVzOnRoaXMuX2dldChhLFxyXG5cImRheU5hbWVzXCIpLG1vbnRoTmFtZXNTaG9ydDp0aGlzLl9nZXQoYSxcIm1vbnRoTmFtZXNTaG9ydFwiKSxtb250aE5hbWVzOnRoaXMuX2dldChhLFwibW9udGhOYW1lc1wiKX19LF9mb3JtYXREYXRlOmZ1bmN0aW9uKGEsYixjLGUpe2lmKCFiKXthLmN1cnJlbnREYXk9YS5zZWxlY3RlZERheTthLmN1cnJlbnRNb250aD1hLnNlbGVjdGVkTW9udGg7YS5jdXJyZW50WWVhcj1hLnNlbGVjdGVkWWVhcn1iPWI/dHlwZW9mIGI9PVwib2JqZWN0XCI/Yjp0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZShlLGMsYikpOnRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKGEuY3VycmVudFllYXIsYS5jdXJyZW50TW9udGgsYS5jdXJyZW50RGF5KSk7cmV0dXJuIHRoaXMuZm9ybWF0RGF0ZSh0aGlzLl9nZXQoYSxcImRhdGVGb3JtYXRcIiksYix0aGlzLl9nZXRGb3JtYXRDb25maWcoYSkpfX0pO2QuZm4uZGF0ZXBpY2tlcj1mdW5jdGlvbihhKXtpZighdGhpcy5sZW5ndGgpcmV0dXJuIHRoaXM7XHJcbmlmKCFkLmRhdGVwaWNrZXIuaW5pdGlhbGl6ZWQpe2QoZG9jdW1lbnQpLm1vdXNlZG93bihkLmRhdGVwaWNrZXIuX2NoZWNrRXh0ZXJuYWxDbGljaykuZmluZChcImJvZHlcIikuYXBwZW5kKGQuZGF0ZXBpY2tlci5kcERpdik7ZC5kYXRlcGlja2VyLmluaXRpYWxpemVkPXRydWV9dmFyIGI9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpO2lmKHR5cGVvZiBhPT1cInN0cmluZ1wiJiYoYT09XCJpc0Rpc2FibGVkXCJ8fGE9PVwiZ2V0RGF0ZVwifHxhPT1cIndpZGdldFwiKSlyZXR1cm4gZC5kYXRlcGlja2VyW1wiX1wiK2ErXCJEYXRlcGlja2VyXCJdLmFwcGx5KGQuZGF0ZXBpY2tlcixbdGhpc1swXV0uY29uY2F0KGIpKTtpZihhPT1cIm9wdGlvblwiJiZhcmd1bWVudHMubGVuZ3RoPT0yJiZ0eXBlb2YgYXJndW1lbnRzWzFdPT1cInN0cmluZ1wiKXJldHVybiBkLmRhdGVwaWNrZXJbXCJfXCIrYStcIkRhdGVwaWNrZXJcIl0uYXBwbHkoZC5kYXRlcGlja2VyLFt0aGlzWzBdXS5jb25jYXQoYikpO3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt0eXBlb2YgYT09XHJcblwic3RyaW5nXCI/ZC5kYXRlcGlja2VyW1wiX1wiK2ErXCJEYXRlcGlja2VyXCJdLmFwcGx5KGQuZGF0ZXBpY2tlcixbdGhpc10uY29uY2F0KGIpKTpkLmRhdGVwaWNrZXIuX2F0dGFjaERhdGVwaWNrZXIodGhpcyxhKX0pfTtkLmRhdGVwaWNrZXI9bmV3IE07ZC5kYXRlcGlja2VyLmluaXRpYWxpemVkPWZhbHNlO2QuZGF0ZXBpY2tlci51dWlkPShuZXcgRGF0ZSkuZ2V0VGltZSgpO2QuZGF0ZXBpY2tlci52ZXJzaW9uPVwiMS44LjE2XCI7d2luZG93W1wiRFBfalF1ZXJ5X1wiK0JdPWR9KShqUXVlcnkpO1xyXG47LypcclxuICogalF1ZXJ5IFVJIFByb2dyZXNzYmFyIDEuOC4xNlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgMjAxMSwgQVVUSE9SUy50eHQgKGh0dHA6Ly9qcXVlcnl1aS5jb20vYWJvdXQpXHJcbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBvciBHUEwgVmVyc2lvbiAyIGxpY2Vuc2VzLlxyXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXHJcbiAqXHJcbiAqIGh0dHA6Ly9kb2NzLmpxdWVyeS5jb20vVUkvUHJvZ3Jlc3NiYXJcclxuICpcclxuICogRGVwZW5kczpcclxuICogICBqcXVlcnkudWkuY29yZS5qc1xyXG4gKiAgIGpxdWVyeS51aS53aWRnZXQuanNcclxuICovXHJcbihmdW5jdGlvbihiLGQpe2Iud2lkZ2V0KFwidWkucHJvZ3Jlc3NiYXJcIix7b3B0aW9uczp7dmFsdWU6MCxtYXg6MTAwfSxtaW46MCxfY3JlYXRlOmZ1bmN0aW9uKCl7dGhpcy5lbGVtZW50LmFkZENsYXNzKFwidWktcHJvZ3Jlc3NiYXIgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGxcIikuYXR0cih7cm9sZTpcInByb2dyZXNzYmFyXCIsXCJhcmlhLXZhbHVlbWluXCI6dGhpcy5taW4sXCJhcmlhLXZhbHVlbWF4XCI6dGhpcy5vcHRpb25zLm1heCxcImFyaWEtdmFsdWVub3dcIjp0aGlzLl92YWx1ZSgpfSk7dGhpcy52YWx1ZURpdj1iKFwiPGRpdiBjbGFzcz0ndWktcHJvZ3Jlc3NiYXItdmFsdWUgdWktd2lkZ2V0LWhlYWRlciB1aS1jb3JuZXItbGVmdCc+PC9kaXY+XCIpLmFwcGVuZFRvKHRoaXMuZWxlbWVudCk7dGhpcy5vbGRWYWx1ZT10aGlzLl92YWx1ZSgpO3RoaXMuX3JlZnJlc2hWYWx1ZSgpfSxkZXN0cm95OmZ1bmN0aW9uKCl7dGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKFwidWktcHJvZ3Jlc3NiYXIgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGxcIikucmVtb3ZlQXR0cihcInJvbGVcIikucmVtb3ZlQXR0cihcImFyaWEtdmFsdWVtaW5cIikucmVtb3ZlQXR0cihcImFyaWEtdmFsdWVtYXhcIikucmVtb3ZlQXR0cihcImFyaWEtdmFsdWVub3dcIik7XHJcbnRoaXMudmFsdWVEaXYucmVtb3ZlKCk7Yi5XaWRnZXQucHJvdG90eXBlLmRlc3Ryb3kuYXBwbHkodGhpcyxhcmd1bWVudHMpfSx2YWx1ZTpmdW5jdGlvbihhKXtpZihhPT09ZClyZXR1cm4gdGhpcy5fdmFsdWUoKTt0aGlzLl9zZXRPcHRpb24oXCJ2YWx1ZVwiLGEpO3JldHVybiB0aGlzfSxfc2V0T3B0aW9uOmZ1bmN0aW9uKGEsYyl7aWYoYT09PVwidmFsdWVcIil7dGhpcy5vcHRpb25zLnZhbHVlPWM7dGhpcy5fcmVmcmVzaFZhbHVlKCk7dGhpcy5fdmFsdWUoKT09PXRoaXMub3B0aW9ucy5tYXgmJnRoaXMuX3RyaWdnZXIoXCJjb21wbGV0ZVwiKX1iLldpZGdldC5wcm90b3R5cGUuX3NldE9wdGlvbi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LF92YWx1ZTpmdW5jdGlvbigpe3ZhciBhPXRoaXMub3B0aW9ucy52YWx1ZTtpZih0eXBlb2YgYSE9PVwibnVtYmVyXCIpYT0wO3JldHVybiBNYXRoLm1pbih0aGlzLm9wdGlvbnMubWF4LE1hdGgubWF4KHRoaXMubWluLGEpKX0sX3BlcmNlbnRhZ2U6ZnVuY3Rpb24oKXtyZXR1cm4gMTAwKlxyXG50aGlzLl92YWx1ZSgpL3RoaXMub3B0aW9ucy5tYXh9LF9yZWZyZXNoVmFsdWU6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnZhbHVlKCksYz10aGlzLl9wZXJjZW50YWdlKCk7aWYodGhpcy5vbGRWYWx1ZSE9PWEpe3RoaXMub2xkVmFsdWU9YTt0aGlzLl90cmlnZ2VyKFwiY2hhbmdlXCIpfXRoaXMudmFsdWVEaXYudG9nZ2xlKGE+dGhpcy5taW4pLnRvZ2dsZUNsYXNzKFwidWktY29ybmVyLXJpZ2h0XCIsYT09PXRoaXMub3B0aW9ucy5tYXgpLndpZHRoKGMudG9GaXhlZCgwKStcIiVcIik7dGhpcy5lbGVtZW50LmF0dHIoXCJhcmlhLXZhbHVlbm93XCIsYSl9fSk7Yi5leHRlbmQoYi51aS5wcm9ncmVzc2Jhcix7dmVyc2lvbjpcIjEuOC4xNlwifSl9KShqUXVlcnkpO1xyXG47LypcclxuICogalF1ZXJ5IFVJIEVmZmVjdHMgMS44LjE2XHJcbiAqXHJcbiAqIENvcHlyaWdodCAyMDExLCBBVVRIT1JTLnR4dCAoaHR0cDovL2pxdWVyeXVpLmNvbS9hYm91dClcclxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIG9yIEdQTCBWZXJzaW9uIDIgbGljZW5zZXMuXHJcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcclxuICpcclxuICogaHR0cDovL2RvY3MuanF1ZXJ5LmNvbS9VSS9FZmZlY3RzL1xyXG4gKi9cclxualF1ZXJ5LmVmZmVjdHN8fGZ1bmN0aW9uKGYsail7ZnVuY3Rpb24gbShjKXt2YXIgYTtpZihjJiZjLmNvbnN0cnVjdG9yPT1BcnJheSYmYy5sZW5ndGg9PTMpcmV0dXJuIGM7aWYoYT0vcmdiXFwoXFxzKihbMC05XXsxLDN9KVxccyosXFxzKihbMC05XXsxLDN9KVxccyosXFxzKihbMC05XXsxLDN9KVxccypcXCkvLmV4ZWMoYykpcmV0dXJuW3BhcnNlSW50KGFbMV0sMTApLHBhcnNlSW50KGFbMl0sMTApLHBhcnNlSW50KGFbM10sMTApXTtpZihhPS9yZ2JcXChcXHMqKFswLTldKyg/OlxcLlswLTldKyk/KVxcJVxccyosXFxzKihbMC05XSsoPzpcXC5bMC05XSspPylcXCVcXHMqLFxccyooWzAtOV0rKD86XFwuWzAtOV0rKT8pXFwlXFxzKlxcKS8uZXhlYyhjKSlyZXR1cm5bcGFyc2VGbG9hdChhWzFdKSoyLjU1LHBhcnNlRmxvYXQoYVsyXSkqMi41NSxwYXJzZUZsb2F0KGFbM10pKjIuNTVdO2lmKGE9LyMoW2EtZkEtRjAtOV17Mn0pKFthLWZBLUYwLTldezJ9KShbYS1mQS1GMC05XXsyfSkvLmV4ZWMoYykpcmV0dXJuW3BhcnNlSW50KGFbMV0sXHJcbjE2KSxwYXJzZUludChhWzJdLDE2KSxwYXJzZUludChhWzNdLDE2KV07aWYoYT0vIyhbYS1mQS1GMC05XSkoW2EtZkEtRjAtOV0pKFthLWZBLUYwLTldKS8uZXhlYyhjKSlyZXR1cm5bcGFyc2VJbnQoYVsxXSthWzFdLDE2KSxwYXJzZUludChhWzJdK2FbMl0sMTYpLHBhcnNlSW50KGFbM10rYVszXSwxNildO2lmKC9yZ2JhXFwoMCwgMCwgMCwgMFxcKS8uZXhlYyhjKSlyZXR1cm4gbi50cmFuc3BhcmVudDtyZXR1cm4gbltmLnRyaW0oYykudG9Mb3dlckNhc2UoKV19ZnVuY3Rpb24gcyhjLGEpe3ZhciBiO2Rve2I9Zi5jdXJDU1MoYyxhKTtpZihiIT1cIlwiJiZiIT1cInRyYW5zcGFyZW50XCJ8fGYubm9kZU5hbWUoYyxcImJvZHlcIikpYnJlYWs7YT1cImJhY2tncm91bmRDb2xvclwifXdoaWxlKGM9Yy5wYXJlbnROb2RlKTtyZXR1cm4gbShiKX1mdW5jdGlvbiBvKCl7dmFyIGM9ZG9jdW1lbnQuZGVmYXVsdFZpZXc/ZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLG51bGwpOnRoaXMuY3VycmVudFN0eWxlLFxyXG5hPXt9LGIsZDtpZihjJiZjLmxlbmd0aCYmY1swXSYmY1tjWzBdXSlmb3IodmFyIGU9Yy5sZW5ndGg7ZS0tOyl7Yj1jW2VdO2lmKHR5cGVvZiBjW2JdPT1cInN0cmluZ1wiKXtkPWIucmVwbGFjZSgvXFwtKFxcdykvZyxmdW5jdGlvbihnLGgpe3JldHVybiBoLnRvVXBwZXJDYXNlKCl9KTthW2RdPWNbYl19fWVsc2UgZm9yKGIgaW4gYylpZih0eXBlb2YgY1tiXT09PVwic3RyaW5nXCIpYVtiXT1jW2JdO3JldHVybiBhfWZ1bmN0aW9uIHAoYyl7dmFyIGEsYjtmb3IoYSBpbiBjKXtiPWNbYV07aWYoYj09bnVsbHx8Zi5pc0Z1bmN0aW9uKGIpfHxhIGluIHR8fC9zY3JvbGxiYXIvLnRlc3QoYSl8fCEvY29sb3IvaS50ZXN0KGEpJiZpc05hTihwYXJzZUZsb2F0KGIpKSlkZWxldGUgY1thXX1yZXR1cm4gY31mdW5jdGlvbiB1KGMsYSl7dmFyIGI9e186MH0sZDtmb3IoZCBpbiBhKWlmKGNbZF0hPWFbZF0pYltkXT1hW2RdO3JldHVybiBifWZ1bmN0aW9uIGsoYyxhLGIsZCl7aWYodHlwZW9mIGM9PVwib2JqZWN0XCIpe2Q9XHJcbmE7Yj1udWxsO2E9YztjPWEuZWZmZWN0fWlmKGYuaXNGdW5jdGlvbihhKSl7ZD1hO2I9bnVsbDthPXt9fWlmKHR5cGVvZiBhPT1cIm51bWJlclwifHxmLmZ4LnNwZWVkc1thXSl7ZD1iO2I9YTthPXt9fWlmKGYuaXNGdW5jdGlvbihiKSl7ZD1iO2I9bnVsbH1hPWF8fHt9O2I9Ynx8YS5kdXJhdGlvbjtiPWYuZngub2ZmPzA6dHlwZW9mIGI9PVwibnVtYmVyXCI/YjpiIGluIGYuZnguc3BlZWRzP2YuZnguc3BlZWRzW2JdOmYuZnguc3BlZWRzLl9kZWZhdWx0O2Q9ZHx8YS5jb21wbGV0ZTtyZXR1cm5bYyxhLGIsZF19ZnVuY3Rpb24gbChjKXtpZighY3x8dHlwZW9mIGM9PT1cIm51bWJlclwifHxmLmZ4LnNwZWVkc1tjXSlyZXR1cm4gdHJ1ZTtpZih0eXBlb2YgYz09PVwic3RyaW5nXCImJiFmLmVmZmVjdHNbY10pcmV0dXJuIHRydWU7cmV0dXJuIGZhbHNlfWYuZWZmZWN0cz17fTtmLmVhY2goW1wiYmFja2dyb3VuZENvbG9yXCIsXCJib3JkZXJCb3R0b21Db2xvclwiLFwiYm9yZGVyTGVmdENvbG9yXCIsXCJib3JkZXJSaWdodENvbG9yXCIsXHJcblwiYm9yZGVyVG9wQ29sb3JcIixcImJvcmRlckNvbG9yXCIsXCJjb2xvclwiLFwib3V0bGluZUNvbG9yXCJdLGZ1bmN0aW9uKGMsYSl7Zi5meC5zdGVwW2FdPWZ1bmN0aW9uKGIpe2lmKCFiLmNvbG9ySW5pdCl7Yi5zdGFydD1zKGIuZWxlbSxhKTtiLmVuZD1tKGIuZW5kKTtiLmNvbG9ySW5pdD10cnVlfWIuZWxlbS5zdHlsZVthXT1cInJnYihcIitNYXRoLm1heChNYXRoLm1pbihwYXJzZUludChiLnBvcyooYi5lbmRbMF0tYi5zdGFydFswXSkrYi5zdGFydFswXSwxMCksMjU1KSwwKStcIixcIitNYXRoLm1heChNYXRoLm1pbihwYXJzZUludChiLnBvcyooYi5lbmRbMV0tYi5zdGFydFsxXSkrYi5zdGFydFsxXSwxMCksMjU1KSwwKStcIixcIitNYXRoLm1heChNYXRoLm1pbihwYXJzZUludChiLnBvcyooYi5lbmRbMl0tYi5zdGFydFsyXSkrYi5zdGFydFsyXSwxMCksMjU1KSwwKStcIilcIn19KTt2YXIgbj17YXF1YTpbMCwyNTUsMjU1XSxhenVyZTpbMjQwLDI1NSwyNTVdLGJlaWdlOlsyNDUsMjQ1LDIyMF0sYmxhY2s6WzAsXHJcbjAsMF0sYmx1ZTpbMCwwLDI1NV0sYnJvd246WzE2NSw0Miw0Ml0sY3lhbjpbMCwyNTUsMjU1XSxkYXJrYmx1ZTpbMCwwLDEzOV0sZGFya2N5YW46WzAsMTM5LDEzOV0sZGFya2dyZXk6WzE2OSwxNjksMTY5XSxkYXJrZ3JlZW46WzAsMTAwLDBdLGRhcmtraGFraTpbMTg5LDE4MywxMDddLGRhcmttYWdlbnRhOlsxMzksMCwxMzldLGRhcmtvbGl2ZWdyZWVuOls4NSwxMDcsNDddLGRhcmtvcmFuZ2U6WzI1NSwxNDAsMF0sZGFya29yY2hpZDpbMTUzLDUwLDIwNF0sZGFya3JlZDpbMTM5LDAsMF0sZGFya3NhbG1vbjpbMjMzLDE1MCwxMjJdLGRhcmt2aW9sZXQ6WzE0OCwwLDIxMV0sZnVjaHNpYTpbMjU1LDAsMjU1XSxnb2xkOlsyNTUsMjE1LDBdLGdyZWVuOlswLDEyOCwwXSxpbmRpZ286Wzc1LDAsMTMwXSxraGFraTpbMjQwLDIzMCwxNDBdLGxpZ2h0Ymx1ZTpbMTczLDIxNiwyMzBdLGxpZ2h0Y3lhbjpbMjI0LDI1NSwyNTVdLGxpZ2h0Z3JlZW46WzE0NCwyMzgsMTQ0XSxsaWdodGdyZXk6WzIxMSxcclxuMjExLDIxMV0sbGlnaHRwaW5rOlsyNTUsMTgyLDE5M10sbGlnaHR5ZWxsb3c6WzI1NSwyNTUsMjI0XSxsaW1lOlswLDI1NSwwXSxtYWdlbnRhOlsyNTUsMCwyNTVdLG1hcm9vbjpbMTI4LDAsMF0sbmF2eTpbMCwwLDEyOF0sb2xpdmU6WzEyOCwxMjgsMF0sb3JhbmdlOlsyNTUsMTY1LDBdLHBpbms6WzI1NSwxOTIsMjAzXSxwdXJwbGU6WzEyOCwwLDEyOF0sdmlvbGV0OlsxMjgsMCwxMjhdLHJlZDpbMjU1LDAsMF0sc2lsdmVyOlsxOTIsMTkyLDE5Ml0sd2hpdGU6WzI1NSwyNTUsMjU1XSx5ZWxsb3c6WzI1NSwyNTUsMF0sdHJhbnNwYXJlbnQ6WzI1NSwyNTUsMjU1XX0scT1bXCJhZGRcIixcInJlbW92ZVwiLFwidG9nZ2xlXCJdLHQ9e2JvcmRlcjoxLGJvcmRlckJvdHRvbToxLGJvcmRlckNvbG9yOjEsYm9yZGVyTGVmdDoxLGJvcmRlclJpZ2h0OjEsYm9yZGVyVG9wOjEsYm9yZGVyV2lkdGg6MSxtYXJnaW46MSxwYWRkaW5nOjF9O2YuZWZmZWN0cy5hbmltYXRlQ2xhc3M9ZnVuY3Rpb24oYyxhLGIsXHJcbmQpe2lmKGYuaXNGdW5jdGlvbihiKSl7ZD1iO2I9bnVsbH1yZXR1cm4gdGhpcy5xdWV1ZShmdW5jdGlvbigpe3ZhciBlPWYodGhpcyksZz1lLmF0dHIoXCJzdHlsZVwiKXx8XCIgXCIsaD1wKG8uY2FsbCh0aGlzKSkscix2PWUuYXR0cihcImNsYXNzXCIpO2YuZWFjaChxLGZ1bmN0aW9uKHcsaSl7Y1tpXSYmZVtpK1wiQ2xhc3NcIl0oY1tpXSl9KTtyPXAoby5jYWxsKHRoaXMpKTtlLmF0dHIoXCJjbGFzc1wiLHYpO2UuYW5pbWF0ZSh1KGgscikse3F1ZXVlOmZhbHNlLGR1cmF0aW9uOmEsZWFzaW5nOmIsY29tcGxldGU6ZnVuY3Rpb24oKXtmLmVhY2gocSxmdW5jdGlvbih3LGkpe2NbaV0mJmVbaStcIkNsYXNzXCJdKGNbaV0pfSk7aWYodHlwZW9mIGUuYXR0cihcInN0eWxlXCIpPT1cIm9iamVjdFwiKXtlLmF0dHIoXCJzdHlsZVwiKS5jc3NUZXh0PVwiXCI7ZS5hdHRyKFwic3R5bGVcIikuY3NzVGV4dD1nfWVsc2UgZS5hdHRyKFwic3R5bGVcIixnKTtkJiZkLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtmLmRlcXVldWUodGhpcyl9fSl9KX07XHJcbmYuZm4uZXh0ZW5kKHtfYWRkQ2xhc3M6Zi5mbi5hZGRDbGFzcyxhZGRDbGFzczpmdW5jdGlvbihjLGEsYixkKXtyZXR1cm4gYT9mLmVmZmVjdHMuYW5pbWF0ZUNsYXNzLmFwcGx5KHRoaXMsW3thZGQ6Y30sYSxiLGRdKTp0aGlzLl9hZGRDbGFzcyhjKX0sX3JlbW92ZUNsYXNzOmYuZm4ucmVtb3ZlQ2xhc3MscmVtb3ZlQ2xhc3M6ZnVuY3Rpb24oYyxhLGIsZCl7cmV0dXJuIGE/Zi5lZmZlY3RzLmFuaW1hdGVDbGFzcy5hcHBseSh0aGlzLFt7cmVtb3ZlOmN9LGEsYixkXSk6dGhpcy5fcmVtb3ZlQ2xhc3MoYyl9LF90b2dnbGVDbGFzczpmLmZuLnRvZ2dsZUNsYXNzLHRvZ2dsZUNsYXNzOmZ1bmN0aW9uKGMsYSxiLGQsZSl7cmV0dXJuIHR5cGVvZiBhPT1cImJvb2xlYW5cInx8YT09PWo/Yj9mLmVmZmVjdHMuYW5pbWF0ZUNsYXNzLmFwcGx5KHRoaXMsW2E/e2FkZDpjfTp7cmVtb3ZlOmN9LGIsZCxlXSk6dGhpcy5fdG9nZ2xlQ2xhc3MoYyxhKTpmLmVmZmVjdHMuYW5pbWF0ZUNsYXNzLmFwcGx5KHRoaXMsXHJcblt7dG9nZ2xlOmN9LGEsYixkXSl9LHN3aXRjaENsYXNzOmZ1bmN0aW9uKGMsYSxiLGQsZSl7cmV0dXJuIGYuZWZmZWN0cy5hbmltYXRlQ2xhc3MuYXBwbHkodGhpcyxbe2FkZDphLHJlbW92ZTpjfSxiLGQsZV0pfX0pO2YuZXh0ZW5kKGYuZWZmZWN0cyx7dmVyc2lvbjpcIjEuOC4xNlwiLHNhdmU6ZnVuY3Rpb24oYyxhKXtmb3IodmFyIGI9MDtiPGEubGVuZ3RoO2IrKylhW2JdIT09bnVsbCYmYy5kYXRhKFwiZWMuc3RvcmFnZS5cIithW2JdLGNbMF0uc3R5bGVbYVtiXV0pfSxyZXN0b3JlOmZ1bmN0aW9uKGMsYSl7Zm9yKHZhciBiPTA7YjxhLmxlbmd0aDtiKyspYVtiXSE9PW51bGwmJmMuY3NzKGFbYl0sYy5kYXRhKFwiZWMuc3RvcmFnZS5cIithW2JdKSl9LHNldE1vZGU6ZnVuY3Rpb24oYyxhKXtpZihhPT1cInRvZ2dsZVwiKWE9Yy5pcyhcIjpoaWRkZW5cIik/XCJzaG93XCI6XCJoaWRlXCI7cmV0dXJuIGF9LGdldEJhc2VsaW5lOmZ1bmN0aW9uKGMsYSl7dmFyIGI7c3dpdGNoKGNbMF0pe2Nhc2UgXCJ0b3BcIjpiPVxyXG4wO2JyZWFrO2Nhc2UgXCJtaWRkbGVcIjpiPTAuNTticmVhaztjYXNlIFwiYm90dG9tXCI6Yj0xO2JyZWFrO2RlZmF1bHQ6Yj1jWzBdL2EuaGVpZ2h0fXN3aXRjaChjWzFdKXtjYXNlIFwibGVmdFwiOmM9MDticmVhaztjYXNlIFwiY2VudGVyXCI6Yz0wLjU7YnJlYWs7Y2FzZSBcInJpZ2h0XCI6Yz0xO2JyZWFrO2RlZmF1bHQ6Yz1jWzFdL2Eud2lkdGh9cmV0dXJue3g6Yyx5OmJ9fSxjcmVhdGVXcmFwcGVyOmZ1bmN0aW9uKGMpe2lmKGMucGFyZW50KCkuaXMoXCIudWktZWZmZWN0cy13cmFwcGVyXCIpKXJldHVybiBjLnBhcmVudCgpO3ZhciBhPXt3aWR0aDpjLm91dGVyV2lkdGgodHJ1ZSksaGVpZ2h0OmMub3V0ZXJIZWlnaHQodHJ1ZSksXCJmbG9hdFwiOmMuY3NzKFwiZmxvYXRcIil9LGI9ZihcIjxkaXY+PC9kaXY+XCIpLmFkZENsYXNzKFwidWktZWZmZWN0cy13cmFwcGVyXCIpLmNzcyh7Zm9udFNpemU6XCIxMDAlXCIsYmFja2dyb3VuZDpcInRyYW5zcGFyZW50XCIsYm9yZGVyOlwibm9uZVwiLG1hcmdpbjowLHBhZGRpbmc6MH0pLFxyXG5kPWRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7Yy53cmFwKGIpO2lmKGNbMF09PT1kfHxmLmNvbnRhaW5zKGNbMF0sZCkpZihkKS5mb2N1cygpO2I9Yy5wYXJlbnQoKTtpZihjLmNzcyhcInBvc2l0aW9uXCIpPT1cInN0YXRpY1wiKXtiLmNzcyh7cG9zaXRpb246XCJyZWxhdGl2ZVwifSk7Yy5jc3Moe3Bvc2l0aW9uOlwicmVsYXRpdmVcIn0pfWVsc2V7Zi5leHRlbmQoYSx7cG9zaXRpb246Yy5jc3MoXCJwb3NpdGlvblwiKSx6SW5kZXg6Yy5jc3MoXCJ6LWluZGV4XCIpfSk7Zi5lYWNoKFtcInRvcFwiLFwibGVmdFwiLFwiYm90dG9tXCIsXCJyaWdodFwiXSxmdW5jdGlvbihlLGcpe2FbZ109Yy5jc3MoZyk7aWYoaXNOYU4ocGFyc2VJbnQoYVtnXSwxMCkpKWFbZ109XCJhdXRvXCJ9KTtjLmNzcyh7cG9zaXRpb246XCJyZWxhdGl2ZVwiLHRvcDowLGxlZnQ6MCxyaWdodDpcImF1dG9cIixib3R0b206XCJhdXRvXCJ9KX1yZXR1cm4gYi5jc3MoYSkuc2hvdygpfSxyZW1vdmVXcmFwcGVyOmZ1bmN0aW9uKGMpe3ZhciBhLGI9ZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcclxuaWYoYy5wYXJlbnQoKS5pcyhcIi51aS1lZmZlY3RzLXdyYXBwZXJcIikpe2E9Yy5wYXJlbnQoKS5yZXBsYWNlV2l0aChjKTtpZihjWzBdPT09Ynx8Zi5jb250YWlucyhjWzBdLGIpKWYoYikuZm9jdXMoKTtyZXR1cm4gYX1yZXR1cm4gY30sc2V0VHJhbnNpdGlvbjpmdW5jdGlvbihjLGEsYixkKXtkPWR8fHt9O2YuZWFjaChhLGZ1bmN0aW9uKGUsZyl7dW5pdD1jLmNzc1VuaXQoZyk7aWYodW5pdFswXT4wKWRbZ109dW5pdFswXSpiK3VuaXRbMV19KTtyZXR1cm4gZH19KTtmLmZuLmV4dGVuZCh7ZWZmZWN0OmZ1bmN0aW9uKGMpe3ZhciBhPWsuYXBwbHkodGhpcyxhcmd1bWVudHMpLGI9e29wdGlvbnM6YVsxXSxkdXJhdGlvbjphWzJdLGNhbGxiYWNrOmFbM119O2E9Yi5vcHRpb25zLm1vZGU7dmFyIGQ9Zi5lZmZlY3RzW2NdO2lmKGYuZngub2ZmfHwhZClyZXR1cm4gYT90aGlzW2FdKGIuZHVyYXRpb24sYi5jYWxsYmFjayk6dGhpcy5lYWNoKGZ1bmN0aW9uKCl7Yi5jYWxsYmFjayYmYi5jYWxsYmFjay5jYWxsKHRoaXMpfSk7XHJcbnJldHVybiBkLmNhbGwodGhpcyxiKX0sX3Nob3c6Zi5mbi5zaG93LHNob3c6ZnVuY3Rpb24oYyl7aWYobChjKSlyZXR1cm4gdGhpcy5fc2hvdy5hcHBseSh0aGlzLGFyZ3VtZW50cyk7ZWxzZXt2YXIgYT1rLmFwcGx5KHRoaXMsYXJndW1lbnRzKTthWzFdLm1vZGU9XCJzaG93XCI7cmV0dXJuIHRoaXMuZWZmZWN0LmFwcGx5KHRoaXMsYSl9fSxfaGlkZTpmLmZuLmhpZGUsaGlkZTpmdW5jdGlvbihjKXtpZihsKGMpKXJldHVybiB0aGlzLl9oaWRlLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtlbHNle3ZhciBhPWsuYXBwbHkodGhpcyxhcmd1bWVudHMpO2FbMV0ubW9kZT1cImhpZGVcIjtyZXR1cm4gdGhpcy5lZmZlY3QuYXBwbHkodGhpcyxhKX19LF9fdG9nZ2xlOmYuZm4udG9nZ2xlLHRvZ2dsZTpmdW5jdGlvbihjKXtpZihsKGMpfHx0eXBlb2YgYz09PVwiYm9vbGVhblwifHxmLmlzRnVuY3Rpb24oYykpcmV0dXJuIHRoaXMuX190b2dnbGUuYXBwbHkodGhpcyxhcmd1bWVudHMpO2Vsc2V7dmFyIGE9ay5hcHBseSh0aGlzLFxyXG5hcmd1bWVudHMpO2FbMV0ubW9kZT1cInRvZ2dsZVwiO3JldHVybiB0aGlzLmVmZmVjdC5hcHBseSh0aGlzLGEpfX0sY3NzVW5pdDpmdW5jdGlvbihjKXt2YXIgYT10aGlzLmNzcyhjKSxiPVtdO2YuZWFjaChbXCJlbVwiLFwicHhcIixcIiVcIixcInB0XCJdLGZ1bmN0aW9uKGQsZSl7aWYoYS5pbmRleE9mKGUpPjApYj1bcGFyc2VGbG9hdChhKSxlXX0pO3JldHVybiBifX0pO2YuZWFzaW5nLmpzd2luZz1mLmVhc2luZy5zd2luZztmLmV4dGVuZChmLmVhc2luZyx7ZGVmOlwiZWFzZU91dFF1YWRcIixzd2luZzpmdW5jdGlvbihjLGEsYixkLGUpe3JldHVybiBmLmVhc2luZ1tmLmVhc2luZy5kZWZdKGMsYSxiLGQsZSl9LGVhc2VJblF1YWQ6ZnVuY3Rpb24oYyxhLGIsZCxlKXtyZXR1cm4gZCooYS89ZSkqYStifSxlYXNlT3V0UXVhZDpmdW5jdGlvbihjLGEsYixkLGUpe3JldHVybi1kKihhLz1lKSooYS0yKStifSxlYXNlSW5PdXRRdWFkOmZ1bmN0aW9uKGMsYSxiLGQsZSl7aWYoKGEvPWUvMik8MSlyZXR1cm4gZC9cclxuMiphKmErYjtyZXR1cm4tZC8yKigtLWEqKGEtMiktMSkrYn0sZWFzZUluQ3ViaWM6ZnVuY3Rpb24oYyxhLGIsZCxlKXtyZXR1cm4gZCooYS89ZSkqYSphK2J9LGVhc2VPdXRDdWJpYzpmdW5jdGlvbihjLGEsYixkLGUpe3JldHVybiBkKigoYT1hL2UtMSkqYSphKzEpK2J9LGVhc2VJbk91dEN1YmljOmZ1bmN0aW9uKGMsYSxiLGQsZSl7aWYoKGEvPWUvMik8MSlyZXR1cm4gZC8yKmEqYSphK2I7cmV0dXJuIGQvMiooKGEtPTIpKmEqYSsyKStifSxlYXNlSW5RdWFydDpmdW5jdGlvbihjLGEsYixkLGUpe3JldHVybiBkKihhLz1lKSphKmEqYStifSxlYXNlT3V0UXVhcnQ6ZnVuY3Rpb24oYyxhLGIsZCxlKXtyZXR1cm4tZCooKGE9YS9lLTEpKmEqYSphLTEpK2J9LGVhc2VJbk91dFF1YXJ0OmZ1bmN0aW9uKGMsYSxiLGQsZSl7aWYoKGEvPWUvMik8MSlyZXR1cm4gZC8yKmEqYSphKmErYjtyZXR1cm4tZC8yKigoYS09MikqYSphKmEtMikrYn0sZWFzZUluUXVpbnQ6ZnVuY3Rpb24oYyxhLGIsXHJcbmQsZSl7cmV0dXJuIGQqKGEvPWUpKmEqYSphKmErYn0sZWFzZU91dFF1aW50OmZ1bmN0aW9uKGMsYSxiLGQsZSl7cmV0dXJuIGQqKChhPWEvZS0xKSphKmEqYSphKzEpK2J9LGVhc2VJbk91dFF1aW50OmZ1bmN0aW9uKGMsYSxiLGQsZSl7aWYoKGEvPWUvMik8MSlyZXR1cm4gZC8yKmEqYSphKmEqYStiO3JldHVybiBkLzIqKChhLT0yKSphKmEqYSphKzIpK2J9LGVhc2VJblNpbmU6ZnVuY3Rpb24oYyxhLGIsZCxlKXtyZXR1cm4tZCpNYXRoLmNvcyhhL2UqKE1hdGguUEkvMikpK2QrYn0sZWFzZU91dFNpbmU6ZnVuY3Rpb24oYyxhLGIsZCxlKXtyZXR1cm4gZCpNYXRoLnNpbihhL2UqKE1hdGguUEkvMikpK2J9LGVhc2VJbk91dFNpbmU6ZnVuY3Rpb24oYyxhLGIsZCxlKXtyZXR1cm4tZC8yKihNYXRoLmNvcyhNYXRoLlBJKmEvZSktMSkrYn0sZWFzZUluRXhwbzpmdW5jdGlvbihjLGEsYixkLGUpe3JldHVybiBhPT0wP2I6ZCpNYXRoLnBvdygyLDEwKihhL2UtMSkpK2J9LGVhc2VPdXRFeHBvOmZ1bmN0aW9uKGMsXHJcbmEsYixkLGUpe3JldHVybiBhPT1lP2IrZDpkKigtTWF0aC5wb3coMiwtMTAqYS9lKSsxKStifSxlYXNlSW5PdXRFeHBvOmZ1bmN0aW9uKGMsYSxiLGQsZSl7aWYoYT09MClyZXR1cm4gYjtpZihhPT1lKXJldHVybiBiK2Q7aWYoKGEvPWUvMik8MSlyZXR1cm4gZC8yKk1hdGgucG93KDIsMTAqKGEtMSkpK2I7cmV0dXJuIGQvMiooLU1hdGgucG93KDIsLTEwKi0tYSkrMikrYn0sZWFzZUluQ2lyYzpmdW5jdGlvbihjLGEsYixkLGUpe3JldHVybi1kKihNYXRoLnNxcnQoMS0oYS89ZSkqYSktMSkrYn0sZWFzZU91dENpcmM6ZnVuY3Rpb24oYyxhLGIsZCxlKXtyZXR1cm4gZCpNYXRoLnNxcnQoMS0oYT1hL2UtMSkqYSkrYn0sZWFzZUluT3V0Q2lyYzpmdW5jdGlvbihjLGEsYixkLGUpe2lmKChhLz1lLzIpPDEpcmV0dXJuLWQvMiooTWF0aC5zcXJ0KDEtYSphKS0xKStiO3JldHVybiBkLzIqKE1hdGguc3FydCgxLShhLT0yKSphKSsxKStifSxlYXNlSW5FbGFzdGljOmZ1bmN0aW9uKGMsYSxiLFxyXG5kLGUpe2M9MS43MDE1ODt2YXIgZz0wLGg9ZDtpZihhPT0wKXJldHVybiBiO2lmKChhLz1lKT09MSlyZXR1cm4gYitkO2d8fChnPWUqMC4zKTtpZihoPE1hdGguYWJzKGQpKXtoPWQ7Yz1nLzR9ZWxzZSBjPWcvKDIqTWF0aC5QSSkqTWF0aC5hc2luKGQvaCk7cmV0dXJuLShoKk1hdGgucG93KDIsMTAqKGEtPTEpKSpNYXRoLnNpbigoYSplLWMpKjIqTWF0aC5QSS9nKSkrYn0sZWFzZU91dEVsYXN0aWM6ZnVuY3Rpb24oYyxhLGIsZCxlKXtjPTEuNzAxNTg7dmFyIGc9MCxoPWQ7aWYoYT09MClyZXR1cm4gYjtpZigoYS89ZSk9PTEpcmV0dXJuIGIrZDtnfHwoZz1lKjAuMyk7aWYoaDxNYXRoLmFicyhkKSl7aD1kO2M9Zy80fWVsc2UgYz1nLygyKk1hdGguUEkpKk1hdGguYXNpbihkL2gpO3JldHVybiBoKk1hdGgucG93KDIsLTEwKmEpKk1hdGguc2luKChhKmUtYykqMipNYXRoLlBJL2cpK2QrYn0sZWFzZUluT3V0RWxhc3RpYzpmdW5jdGlvbihjLGEsYixkLGUpe2M9MS43MDE1ODt2YXIgZz1cclxuMCxoPWQ7aWYoYT09MClyZXR1cm4gYjtpZigoYS89ZS8yKT09MilyZXR1cm4gYitkO2d8fChnPWUqMC4zKjEuNSk7aWYoaDxNYXRoLmFicyhkKSl7aD1kO2M9Zy80fWVsc2UgYz1nLygyKk1hdGguUEkpKk1hdGguYXNpbihkL2gpO2lmKGE8MSlyZXR1cm4tMC41KmgqTWF0aC5wb3coMiwxMCooYS09MSkpKk1hdGguc2luKChhKmUtYykqMipNYXRoLlBJL2cpK2I7cmV0dXJuIGgqTWF0aC5wb3coMiwtMTAqKGEtPTEpKSpNYXRoLnNpbigoYSplLWMpKjIqTWF0aC5QSS9nKSowLjUrZCtifSxlYXNlSW5CYWNrOmZ1bmN0aW9uKGMsYSxiLGQsZSxnKXtpZihnPT1qKWc9MS43MDE1ODtyZXR1cm4gZCooYS89ZSkqYSooKGcrMSkqYS1nKStifSxlYXNlT3V0QmFjazpmdW5jdGlvbihjLGEsYixkLGUsZyl7aWYoZz09ailnPTEuNzAxNTg7cmV0dXJuIGQqKChhPWEvZS0xKSphKigoZysxKSphK2cpKzEpK2J9LGVhc2VJbk91dEJhY2s6ZnVuY3Rpb24oYyxhLGIsZCxlLGcpe2lmKGc9PWopZz0xLjcwMTU4O1xyXG5pZigoYS89ZS8yKTwxKXJldHVybiBkLzIqYSphKigoKGcqPTEuNTI1KSsxKSphLWcpK2I7cmV0dXJuIGQvMiooKGEtPTIpKmEqKCgoZyo9MS41MjUpKzEpKmErZykrMikrYn0sZWFzZUluQm91bmNlOmZ1bmN0aW9uKGMsYSxiLGQsZSl7cmV0dXJuIGQtZi5lYXNpbmcuZWFzZU91dEJvdW5jZShjLGUtYSwwLGQsZSkrYn0sZWFzZU91dEJvdW5jZTpmdW5jdGlvbihjLGEsYixkLGUpe3JldHVybihhLz1lKTwxLzIuNzU/ZCo3LjU2MjUqYSphK2I6YTwyLzIuNzU/ZCooNy41NjI1KihhLT0xLjUvMi43NSkqYSswLjc1KStiOmE8Mi41LzIuNzU/ZCooNy41NjI1KihhLT0yLjI1LzIuNzUpKmErMC45Mzc1KStiOmQqKDcuNTYyNSooYS09Mi42MjUvMi43NSkqYSswLjk4NDM3NSkrYn0sZWFzZUluT3V0Qm91bmNlOmZ1bmN0aW9uKGMsYSxiLGQsZSl7aWYoYTxlLzIpcmV0dXJuIGYuZWFzaW5nLmVhc2VJbkJvdW5jZShjLGEqMiwwLGQsZSkqMC41K2I7cmV0dXJuIGYuZWFzaW5nLmVhc2VPdXRCb3VuY2UoYyxcclxuYSoyLWUsMCxkLGUpKjAuNStkKjAuNStifX0pfShqUXVlcnkpO1xyXG47LypcclxuICogalF1ZXJ5IFVJIEVmZmVjdHMgQmxpbmQgMS44LjE2XHJcbiAqXHJcbiAqIENvcHlyaWdodCAyMDExLCBBVVRIT1JTLnR4dCAoaHR0cDovL2pxdWVyeXVpLmNvbS9hYm91dClcclxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIG9yIEdQTCBWZXJzaW9uIDIgbGljZW5zZXMuXHJcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcclxuICpcclxuICogaHR0cDovL2RvY3MuanF1ZXJ5LmNvbS9VSS9FZmZlY3RzL0JsaW5kXHJcbiAqXHJcbiAqIERlcGVuZHM6XHJcbiAqXHRqcXVlcnkuZWZmZWN0cy5jb3JlLmpzXHJcbiAqL1xyXG4oZnVuY3Rpb24oYil7Yi5lZmZlY3RzLmJsaW5kPWZ1bmN0aW9uKGMpe3JldHVybiB0aGlzLnF1ZXVlKGZ1bmN0aW9uKCl7dmFyIGE9Yih0aGlzKSxnPVtcInBvc2l0aW9uXCIsXCJ0b3BcIixcImJvdHRvbVwiLFwibGVmdFwiLFwicmlnaHRcIl0sZj1iLmVmZmVjdHMuc2V0TW9kZShhLGMub3B0aW9ucy5tb2RlfHxcImhpZGVcIiksZD1jLm9wdGlvbnMuZGlyZWN0aW9ufHxcInZlcnRpY2FsXCI7Yi5lZmZlY3RzLnNhdmUoYSxnKTthLnNob3coKTt2YXIgZT1iLmVmZmVjdHMuY3JlYXRlV3JhcHBlcihhKS5jc3Moe292ZXJmbG93OlwiaGlkZGVuXCJ9KSxoPWQ9PVwidmVydGljYWxcIj9cImhlaWdodFwiOlwid2lkdGhcIjtkPWQ9PVwidmVydGljYWxcIj9lLmhlaWdodCgpOmUud2lkdGgoKTtmPT1cInNob3dcIiYmZS5jc3MoaCwwKTt2YXIgaT17fTtpW2hdPWY9PVwic2hvd1wiP2Q6MDtlLmFuaW1hdGUoaSxjLmR1cmF0aW9uLGMub3B0aW9ucy5lYXNpbmcsZnVuY3Rpb24oKXtmPT1cImhpZGVcIiYmYS5oaWRlKCk7Yi5lZmZlY3RzLnJlc3RvcmUoYSxcclxuZyk7Yi5lZmZlY3RzLnJlbW92ZVdyYXBwZXIoYSk7Yy5jYWxsYmFjayYmYy5jYWxsYmFjay5hcHBseShhWzBdLGFyZ3VtZW50cyk7YS5kZXF1ZXVlKCl9KX0pfX0pKGpRdWVyeSk7XHJcbjsvKlxyXG4gKiBqUXVlcnkgVUkgRWZmZWN0cyBCb3VuY2UgMS44LjE2XHJcbiAqXHJcbiAqIENvcHlyaWdodCAyMDExLCBBVVRIT1JTLnR4dCAoaHR0cDovL2pxdWVyeXVpLmNvbS9hYm91dClcclxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIG9yIEdQTCBWZXJzaW9uIDIgbGljZW5zZXMuXHJcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcclxuICpcclxuICogaHR0cDovL2RvY3MuanF1ZXJ5LmNvbS9VSS9FZmZlY3RzL0JvdW5jZVxyXG4gKlxyXG4gKiBEZXBlbmRzOlxyXG4gKlx0anF1ZXJ5LmVmZmVjdHMuY29yZS5qc1xyXG4gKi9cclxuKGZ1bmN0aW9uKGUpe2UuZWZmZWN0cy5ib3VuY2U9ZnVuY3Rpb24oYil7cmV0dXJuIHRoaXMucXVldWUoZnVuY3Rpb24oKXt2YXIgYT1lKHRoaXMpLGw9W1wicG9zaXRpb25cIixcInRvcFwiLFwiYm90dG9tXCIsXCJsZWZ0XCIsXCJyaWdodFwiXSxoPWUuZWZmZWN0cy5zZXRNb2RlKGEsYi5vcHRpb25zLm1vZGV8fFwiZWZmZWN0XCIpLGQ9Yi5vcHRpb25zLmRpcmVjdGlvbnx8XCJ1cFwiLGM9Yi5vcHRpb25zLmRpc3RhbmNlfHwyMCxtPWIub3B0aW9ucy50aW1lc3x8NSxpPWIuZHVyYXRpb258fDI1MDsvc2hvd3xoaWRlLy50ZXN0KGgpJiZsLnB1c2goXCJvcGFjaXR5XCIpO2UuZWZmZWN0cy5zYXZlKGEsbCk7YS5zaG93KCk7ZS5lZmZlY3RzLmNyZWF0ZVdyYXBwZXIoYSk7dmFyIGY9ZD09XCJ1cFwifHxkPT1cImRvd25cIj9cInRvcFwiOlwibGVmdFwiO2Q9ZD09XCJ1cFwifHxkPT1cImxlZnRcIj9cInBvc1wiOlwibmVnXCI7Yz1iLm9wdGlvbnMuZGlzdGFuY2V8fChmPT1cInRvcFwiP2Eub3V0ZXJIZWlnaHQoe21hcmdpbjp0cnVlfSkvMzphLm91dGVyV2lkdGgoe21hcmdpbjp0cnVlfSkvXHJcbjMpO2lmKGg9PVwic2hvd1wiKWEuY3NzKFwib3BhY2l0eVwiLDApLmNzcyhmLGQ9PVwicG9zXCI/LWM6Yyk7aWYoaD09XCJoaWRlXCIpYy89bSoyO2ghPVwiaGlkZVwiJiZtLS07aWYoaD09XCJzaG93XCIpe3ZhciBnPXtvcGFjaXR5OjF9O2dbZl09KGQ9PVwicG9zXCI/XCIrPVwiOlwiLT1cIikrYzthLmFuaW1hdGUoZyxpLzIsYi5vcHRpb25zLmVhc2luZyk7Yy89MjttLS19Zm9yKGc9MDtnPG07ZysrKXt2YXIgaj17fSxrPXt9O2pbZl09KGQ9PVwicG9zXCI/XCItPVwiOlwiKz1cIikrYztrW2ZdPShkPT1cInBvc1wiP1wiKz1cIjpcIi09XCIpK2M7YS5hbmltYXRlKGosaS8yLGIub3B0aW9ucy5lYXNpbmcpLmFuaW1hdGUoayxpLzIsYi5vcHRpb25zLmVhc2luZyk7Yz1oPT1cImhpZGVcIj9jKjI6Yy8yfWlmKGg9PVwiaGlkZVwiKXtnPXtvcGFjaXR5OjB9O2dbZl09KGQ9PVwicG9zXCI/XCItPVwiOlwiKz1cIikrYzthLmFuaW1hdGUoZyxpLzIsYi5vcHRpb25zLmVhc2luZyxmdW5jdGlvbigpe2EuaGlkZSgpO2UuZWZmZWN0cy5yZXN0b3JlKGEsbCk7ZS5lZmZlY3RzLnJlbW92ZVdyYXBwZXIoYSk7XHJcbmIuY2FsbGJhY2smJmIuY2FsbGJhY2suYXBwbHkodGhpcyxhcmd1bWVudHMpfSl9ZWxzZXtqPXt9O2s9e307altmXT0oZD09XCJwb3NcIj9cIi09XCI6XCIrPVwiKStjO2tbZl09KGQ9PVwicG9zXCI/XCIrPVwiOlwiLT1cIikrYzthLmFuaW1hdGUoaixpLzIsYi5vcHRpb25zLmVhc2luZykuYW5pbWF0ZShrLGkvMixiLm9wdGlvbnMuZWFzaW5nLGZ1bmN0aW9uKCl7ZS5lZmZlY3RzLnJlc3RvcmUoYSxsKTtlLmVmZmVjdHMucmVtb3ZlV3JhcHBlcihhKTtiLmNhbGxiYWNrJiZiLmNhbGxiYWNrLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pfWEucXVldWUoXCJmeFwiLGZ1bmN0aW9uKCl7YS5kZXF1ZXVlKCl9KTthLmRlcXVldWUoKX0pfX0pKGpRdWVyeSk7XHJcbjsvKlxyXG4gKiBqUXVlcnkgVUkgRWZmZWN0cyBDbGlwIDEuOC4xNlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgMjAxMSwgQVVUSE9SUy50eHQgKGh0dHA6Ly9qcXVlcnl1aS5jb20vYWJvdXQpXHJcbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBvciBHUEwgVmVyc2lvbiAyIGxpY2Vuc2VzLlxyXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXHJcbiAqXHJcbiAqIGh0dHA6Ly9kb2NzLmpxdWVyeS5jb20vVUkvRWZmZWN0cy9DbGlwXHJcbiAqXHJcbiAqIERlcGVuZHM6XHJcbiAqXHRqcXVlcnkuZWZmZWN0cy5jb3JlLmpzXHJcbiAqL1xyXG4oZnVuY3Rpb24oYil7Yi5lZmZlY3RzLmNsaXA9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucXVldWUoZnVuY3Rpb24oKXt2YXIgYT1iKHRoaXMpLGk9W1wicG9zaXRpb25cIixcInRvcFwiLFwiYm90dG9tXCIsXCJsZWZ0XCIsXCJyaWdodFwiLFwiaGVpZ2h0XCIsXCJ3aWR0aFwiXSxmPWIuZWZmZWN0cy5zZXRNb2RlKGEsZS5vcHRpb25zLm1vZGV8fFwiaGlkZVwiKSxjPWUub3B0aW9ucy5kaXJlY3Rpb258fFwidmVydGljYWxcIjtiLmVmZmVjdHMuc2F2ZShhLGkpO2Euc2hvdygpO3ZhciBkPWIuZWZmZWN0cy5jcmVhdGVXcmFwcGVyKGEpLmNzcyh7b3ZlcmZsb3c6XCJoaWRkZW5cIn0pO2Q9YVswXS50YWdOYW1lPT1cIklNR1wiP2Q6YTt2YXIgZz17c2l6ZTpjPT1cInZlcnRpY2FsXCI/XCJoZWlnaHRcIjpcIndpZHRoXCIscG9zaXRpb246Yz09XCJ2ZXJ0aWNhbFwiP1widG9wXCI6XCJsZWZ0XCJ9O2M9Yz09XCJ2ZXJ0aWNhbFwiP2QuaGVpZ2h0KCk6ZC53aWR0aCgpO2lmKGY9PVwic2hvd1wiKXtkLmNzcyhnLnNpemUsMCk7ZC5jc3MoZy5wb3NpdGlvbixcclxuYy8yKX12YXIgaD17fTtoW2cuc2l6ZV09Zj09XCJzaG93XCI/YzowO2hbZy5wb3NpdGlvbl09Zj09XCJzaG93XCI/MDpjLzI7ZC5hbmltYXRlKGgse3F1ZXVlOmZhbHNlLGR1cmF0aW9uOmUuZHVyYXRpb24sZWFzaW5nOmUub3B0aW9ucy5lYXNpbmcsY29tcGxldGU6ZnVuY3Rpb24oKXtmPT1cImhpZGVcIiYmYS5oaWRlKCk7Yi5lZmZlY3RzLnJlc3RvcmUoYSxpKTtiLmVmZmVjdHMucmVtb3ZlV3JhcHBlcihhKTtlLmNhbGxiYWNrJiZlLmNhbGxiYWNrLmFwcGx5KGFbMF0sYXJndW1lbnRzKTthLmRlcXVldWUoKX19KX0pfX0pKGpRdWVyeSk7XHJcbjsvKlxyXG4gKiBqUXVlcnkgVUkgRWZmZWN0cyBEcm9wIDEuOC4xNlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgMjAxMSwgQVVUSE9SUy50eHQgKGh0dHA6Ly9qcXVlcnl1aS5jb20vYWJvdXQpXHJcbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBvciBHUEwgVmVyc2lvbiAyIGxpY2Vuc2VzLlxyXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXHJcbiAqXHJcbiAqIGh0dHA6Ly9kb2NzLmpxdWVyeS5jb20vVUkvRWZmZWN0cy9Ecm9wXHJcbiAqXHJcbiAqIERlcGVuZHM6XHJcbiAqXHRqcXVlcnkuZWZmZWN0cy5jb3JlLmpzXHJcbiAqL1xyXG4oZnVuY3Rpb24oYyl7Yy5lZmZlY3RzLmRyb3A9ZnVuY3Rpb24oZCl7cmV0dXJuIHRoaXMucXVldWUoZnVuY3Rpb24oKXt2YXIgYT1jKHRoaXMpLGg9W1wicG9zaXRpb25cIixcInRvcFwiLFwiYm90dG9tXCIsXCJsZWZ0XCIsXCJyaWdodFwiLFwib3BhY2l0eVwiXSxlPWMuZWZmZWN0cy5zZXRNb2RlKGEsZC5vcHRpb25zLm1vZGV8fFwiaGlkZVwiKSxiPWQub3B0aW9ucy5kaXJlY3Rpb258fFwibGVmdFwiO2MuZWZmZWN0cy5zYXZlKGEsaCk7YS5zaG93KCk7Yy5lZmZlY3RzLmNyZWF0ZVdyYXBwZXIoYSk7dmFyIGY9Yj09XCJ1cFwifHxiPT1cImRvd25cIj9cInRvcFwiOlwibGVmdFwiO2I9Yj09XCJ1cFwifHxiPT1cImxlZnRcIj9cInBvc1wiOlwibmVnXCI7dmFyIGc9ZC5vcHRpb25zLmRpc3RhbmNlfHwoZj09XCJ0b3BcIj9hLm91dGVySGVpZ2h0KHttYXJnaW46dHJ1ZX0pLzI6YS5vdXRlcldpZHRoKHttYXJnaW46dHJ1ZX0pLzIpO2lmKGU9PVwic2hvd1wiKWEuY3NzKFwib3BhY2l0eVwiLDApLmNzcyhmLGI9PVwicG9zXCI/LWc6Zyk7dmFyIGk9e29wYWNpdHk6ZT09XHJcblwic2hvd1wiPzE6MH07aVtmXT0oZT09XCJzaG93XCI/Yj09XCJwb3NcIj9cIis9XCI6XCItPVwiOmI9PVwicG9zXCI/XCItPVwiOlwiKz1cIikrZzthLmFuaW1hdGUoaSx7cXVldWU6ZmFsc2UsZHVyYXRpb246ZC5kdXJhdGlvbixlYXNpbmc6ZC5vcHRpb25zLmVhc2luZyxjb21wbGV0ZTpmdW5jdGlvbigpe2U9PVwiaGlkZVwiJiZhLmhpZGUoKTtjLmVmZmVjdHMucmVzdG9yZShhLGgpO2MuZWZmZWN0cy5yZW1vdmVXcmFwcGVyKGEpO2QuY2FsbGJhY2smJmQuY2FsbGJhY2suYXBwbHkodGhpcyxhcmd1bWVudHMpO2EuZGVxdWV1ZSgpfX0pfSl9fSkoalF1ZXJ5KTtcclxuOy8qXHJcbiAqIGpRdWVyeSBVSSBFZmZlY3RzIEV4cGxvZGUgMS44LjE2XHJcbiAqXHJcbiAqIENvcHlyaWdodCAyMDExLCBBVVRIT1JTLnR4dCAoaHR0cDovL2pxdWVyeXVpLmNvbS9hYm91dClcclxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIG9yIEdQTCBWZXJzaW9uIDIgbGljZW5zZXMuXHJcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcclxuICpcclxuICogaHR0cDovL2RvY3MuanF1ZXJ5LmNvbS9VSS9FZmZlY3RzL0V4cGxvZGVcclxuICpcclxuICogRGVwZW5kczpcclxuICpcdGpxdWVyeS5lZmZlY3RzLmNvcmUuanNcclxuICovXHJcbihmdW5jdGlvbihqKXtqLmVmZmVjdHMuZXhwbG9kZT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5xdWV1ZShmdW5jdGlvbigpe3ZhciBjPWEub3B0aW9ucy5waWVjZXM/TWF0aC5yb3VuZChNYXRoLnNxcnQoYS5vcHRpb25zLnBpZWNlcykpOjMsZD1hLm9wdGlvbnMucGllY2VzP01hdGgucm91bmQoTWF0aC5zcXJ0KGEub3B0aW9ucy5waWVjZXMpKTozO2Eub3B0aW9ucy5tb2RlPWEub3B0aW9ucy5tb2RlPT1cInRvZ2dsZVwiP2oodGhpcykuaXMoXCI6dmlzaWJsZVwiKT9cImhpZGVcIjpcInNob3dcIjphLm9wdGlvbnMubW9kZTt2YXIgYj1qKHRoaXMpLnNob3coKS5jc3MoXCJ2aXNpYmlsaXR5XCIsXCJoaWRkZW5cIiksZz1iLm9mZnNldCgpO2cudG9wLT1wYXJzZUludChiLmNzcyhcIm1hcmdpblRvcFwiKSwxMCl8fDA7Zy5sZWZ0LT1wYXJzZUludChiLmNzcyhcIm1hcmdpbkxlZnRcIiksMTApfHwwO2Zvcih2YXIgaD1iLm91dGVyV2lkdGgodHJ1ZSksaT1iLm91dGVySGVpZ2h0KHRydWUpLGU9MDtlPGM7ZSsrKWZvcih2YXIgZj1cclxuMDtmPGQ7ZisrKWIuY2xvbmUoKS5hcHBlbmRUbyhcImJvZHlcIikud3JhcChcIjxkaXY+PC9kaXY+XCIpLmNzcyh7cG9zaXRpb246XCJhYnNvbHV0ZVwiLHZpc2liaWxpdHk6XCJ2aXNpYmxlXCIsbGVmdDotZiooaC9kKSx0b3A6LWUqKGkvYyl9KS5wYXJlbnQoKS5hZGRDbGFzcyhcInVpLWVmZmVjdHMtZXhwbG9kZVwiKS5jc3Moe3Bvc2l0aW9uOlwiYWJzb2x1dGVcIixvdmVyZmxvdzpcImhpZGRlblwiLHdpZHRoOmgvZCxoZWlnaHQ6aS9jLGxlZnQ6Zy5sZWZ0K2YqKGgvZCkrKGEub3B0aW9ucy5tb2RlPT1cInNob3dcIj8oZi1NYXRoLmZsb29yKGQvMikpKihoL2QpOjApLHRvcDpnLnRvcCtlKihpL2MpKyhhLm9wdGlvbnMubW9kZT09XCJzaG93XCI/KGUtTWF0aC5mbG9vcihjLzIpKSooaS9jKTowKSxvcGFjaXR5OmEub3B0aW9ucy5tb2RlPT1cInNob3dcIj8wOjF9KS5hbmltYXRlKHtsZWZ0OmcubGVmdCtmKihoL2QpKyhhLm9wdGlvbnMubW9kZT09XCJzaG93XCI/MDooZi1NYXRoLmZsb29yKGQvMikpKihoL2QpKSx0b3A6Zy50b3ArXHJcbmUqKGkvYykrKGEub3B0aW9ucy5tb2RlPT1cInNob3dcIj8wOihlLU1hdGguZmxvb3IoYy8yKSkqKGkvYykpLG9wYWNpdHk6YS5vcHRpb25zLm1vZGU9PVwic2hvd1wiPzE6MH0sYS5kdXJhdGlvbnx8NTAwKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YS5vcHRpb25zLm1vZGU9PVwic2hvd1wiP2IuY3NzKHt2aXNpYmlsaXR5OlwidmlzaWJsZVwifSk6Yi5jc3Moe3Zpc2liaWxpdHk6XCJ2aXNpYmxlXCJ9KS5oaWRlKCk7YS5jYWxsYmFjayYmYS5jYWxsYmFjay5hcHBseShiWzBdKTtiLmRlcXVldWUoKTtqKFwiZGl2LnVpLWVmZmVjdHMtZXhwbG9kZVwiKS5yZW1vdmUoKX0sYS5kdXJhdGlvbnx8NTAwKX0pfX0pKGpRdWVyeSk7XHJcbjsvKlxyXG4gKiBqUXVlcnkgVUkgRWZmZWN0cyBGYWRlIDEuOC4xNlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgMjAxMSwgQVVUSE9SUy50eHQgKGh0dHA6Ly9qcXVlcnl1aS5jb20vYWJvdXQpXHJcbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBvciBHUEwgVmVyc2lvbiAyIGxpY2Vuc2VzLlxyXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXHJcbiAqXHJcbiAqIGh0dHA6Ly9kb2NzLmpxdWVyeS5jb20vVUkvRWZmZWN0cy9GYWRlXHJcbiAqXHJcbiAqIERlcGVuZHM6XHJcbiAqXHRqcXVlcnkuZWZmZWN0cy5jb3JlLmpzXHJcbiAqL1xyXG4oZnVuY3Rpb24oYil7Yi5lZmZlY3RzLmZhZGU9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMucXVldWUoZnVuY3Rpb24oKXt2YXIgYz1iKHRoaXMpLGQ9Yi5lZmZlY3RzLnNldE1vZGUoYyxhLm9wdGlvbnMubW9kZXx8XCJoaWRlXCIpO2MuYW5pbWF0ZSh7b3BhY2l0eTpkfSx7cXVldWU6ZmFsc2UsZHVyYXRpb246YS5kdXJhdGlvbixlYXNpbmc6YS5vcHRpb25zLmVhc2luZyxjb21wbGV0ZTpmdW5jdGlvbigpe2EuY2FsbGJhY2smJmEuY2FsbGJhY2suYXBwbHkodGhpcyxhcmd1bWVudHMpO2MuZGVxdWV1ZSgpfX0pfSl9fSkoalF1ZXJ5KTtcclxuOy8qXHJcbiAqIGpRdWVyeSBVSSBFZmZlY3RzIEZvbGQgMS44LjE2XHJcbiAqXHJcbiAqIENvcHlyaWdodCAyMDExLCBBVVRIT1JTLnR4dCAoaHR0cDovL2pxdWVyeXVpLmNvbS9hYm91dClcclxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIG9yIEdQTCBWZXJzaW9uIDIgbGljZW5zZXMuXHJcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcclxuICpcclxuICogaHR0cDovL2RvY3MuanF1ZXJ5LmNvbS9VSS9FZmZlY3RzL0ZvbGRcclxuICpcclxuICogRGVwZW5kczpcclxuICpcdGpxdWVyeS5lZmZlY3RzLmNvcmUuanNcclxuICovXHJcbihmdW5jdGlvbihjKXtjLmVmZmVjdHMuZm9sZD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5xdWV1ZShmdW5jdGlvbigpe3ZhciBiPWModGhpcyksaj1bXCJwb3NpdGlvblwiLFwidG9wXCIsXCJib3R0b21cIixcImxlZnRcIixcInJpZ2h0XCJdLGQ9Yy5lZmZlY3RzLnNldE1vZGUoYixhLm9wdGlvbnMubW9kZXx8XCJoaWRlXCIpLGc9YS5vcHRpb25zLnNpemV8fDE1LGg9ISFhLm9wdGlvbnMuaG9yaXpGaXJzdCxrPWEuZHVyYXRpb24/YS5kdXJhdGlvbi8yOmMuZnguc3BlZWRzLl9kZWZhdWx0LzI7Yy5lZmZlY3RzLnNhdmUoYixqKTtiLnNob3coKTt2YXIgZT1jLmVmZmVjdHMuY3JlYXRlV3JhcHBlcihiKS5jc3Moe292ZXJmbG93OlwiaGlkZGVuXCJ9KSxmPWQ9PVwic2hvd1wiIT1oLGw9Zj9bXCJ3aWR0aFwiLFwiaGVpZ2h0XCJdOltcImhlaWdodFwiLFwid2lkdGhcIl07Zj1mP1tlLndpZHRoKCksZS5oZWlnaHQoKV06W2UuaGVpZ2h0KCksZS53aWR0aCgpXTt2YXIgaT0vKFswLTldKyklLy5leGVjKGcpO2lmKGkpZz1wYXJzZUludChpWzFdLFxyXG4xMCkvMTAwKmZbZD09XCJoaWRlXCI/MDoxXTtpZihkPT1cInNob3dcIillLmNzcyhoP3toZWlnaHQ6MCx3aWR0aDpnfTp7aGVpZ2h0Omcsd2lkdGg6MH0pO2g9e307aT17fTtoW2xbMF1dPWQ9PVwic2hvd1wiP2ZbMF06ZztpW2xbMV1dPWQ9PVwic2hvd1wiP2ZbMV06MDtlLmFuaW1hdGUoaCxrLGEub3B0aW9ucy5lYXNpbmcpLmFuaW1hdGUoaSxrLGEub3B0aW9ucy5lYXNpbmcsZnVuY3Rpb24oKXtkPT1cImhpZGVcIiYmYi5oaWRlKCk7Yy5lZmZlY3RzLnJlc3RvcmUoYixqKTtjLmVmZmVjdHMucmVtb3ZlV3JhcHBlcihiKTthLmNhbGxiYWNrJiZhLmNhbGxiYWNrLmFwcGx5KGJbMF0sYXJndW1lbnRzKTtiLmRlcXVldWUoKX0pfSl9fSkoalF1ZXJ5KTtcclxuOy8qXHJcbiAqIGpRdWVyeSBVSSBFZmZlY3RzIEhpZ2hsaWdodCAxLjguMTZcclxuICpcclxuICogQ29weXJpZ2h0IDIwMTEsIEFVVEhPUlMudHh0IChodHRwOi8vanF1ZXJ5dWkuY29tL2Fib3V0KVxyXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgb3IgR1BMIFZlcnNpb24gMiBsaWNlbnNlcy5cclxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxyXG4gKlxyXG4gKiBodHRwOi8vZG9jcy5qcXVlcnkuY29tL1VJL0VmZmVjdHMvSGlnaGxpZ2h0XHJcbiAqXHJcbiAqIERlcGVuZHM6XHJcbiAqXHRqcXVlcnkuZWZmZWN0cy5jb3JlLmpzXHJcbiAqL1xyXG4oZnVuY3Rpb24oYil7Yi5lZmZlY3RzLmhpZ2hsaWdodD1mdW5jdGlvbihjKXtyZXR1cm4gdGhpcy5xdWV1ZShmdW5jdGlvbigpe3ZhciBhPWIodGhpcyksZT1bXCJiYWNrZ3JvdW5kSW1hZ2VcIixcImJhY2tncm91bmRDb2xvclwiLFwib3BhY2l0eVwiXSxkPWIuZWZmZWN0cy5zZXRNb2RlKGEsYy5vcHRpb25zLm1vZGV8fFwic2hvd1wiKSxmPXtiYWNrZ3JvdW5kQ29sb3I6YS5jc3MoXCJiYWNrZ3JvdW5kQ29sb3JcIil9O2lmKGQ9PVwiaGlkZVwiKWYub3BhY2l0eT0wO2IuZWZmZWN0cy5zYXZlKGEsZSk7YS5zaG93KCkuY3NzKHtiYWNrZ3JvdW5kSW1hZ2U6XCJub25lXCIsYmFja2dyb3VuZENvbG9yOmMub3B0aW9ucy5jb2xvcnx8XCIjZmZmZjk5XCJ9KS5hbmltYXRlKGYse3F1ZXVlOmZhbHNlLGR1cmF0aW9uOmMuZHVyYXRpb24sZWFzaW5nOmMub3B0aW9ucy5lYXNpbmcsY29tcGxldGU6ZnVuY3Rpb24oKXtkPT1cImhpZGVcIiYmYS5oaWRlKCk7Yi5lZmZlY3RzLnJlc3RvcmUoYSxlKTtkPT1cInNob3dcIiYmIWIuc3VwcG9ydC5vcGFjaXR5JiZcclxudGhpcy5zdHlsZS5yZW1vdmVBdHRyaWJ1dGUoXCJmaWx0ZXJcIik7Yy5jYWxsYmFjayYmYy5jYWxsYmFjay5hcHBseSh0aGlzLGFyZ3VtZW50cyk7YS5kZXF1ZXVlKCl9fSl9KX19KShqUXVlcnkpO1xyXG47LypcclxuICogalF1ZXJ5IFVJIEVmZmVjdHMgUHVsc2F0ZSAxLjguMTZcclxuICpcclxuICogQ29weXJpZ2h0IDIwMTEsIEFVVEhPUlMudHh0IChodHRwOi8vanF1ZXJ5dWkuY29tL2Fib3V0KVxyXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgb3IgR1BMIFZlcnNpb24gMiBsaWNlbnNlcy5cclxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxyXG4gKlxyXG4gKiBodHRwOi8vZG9jcy5qcXVlcnkuY29tL1VJL0VmZmVjdHMvUHVsc2F0ZVxyXG4gKlxyXG4gKiBEZXBlbmRzOlxyXG4gKlx0anF1ZXJ5LmVmZmVjdHMuY29yZS5qc1xyXG4gKi9cclxuKGZ1bmN0aW9uKGQpe2QuZWZmZWN0cy5wdWxzYXRlPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnF1ZXVlKGZ1bmN0aW9uKCl7dmFyIGI9ZCh0aGlzKSxjPWQuZWZmZWN0cy5zZXRNb2RlKGIsYS5vcHRpb25zLm1vZGV8fFwic2hvd1wiKTt0aW1lcz0oYS5vcHRpb25zLnRpbWVzfHw1KSoyLTE7ZHVyYXRpb249YS5kdXJhdGlvbj9hLmR1cmF0aW9uLzI6ZC5meC5zcGVlZHMuX2RlZmF1bHQvMjtpc1Zpc2libGU9Yi5pcyhcIjp2aXNpYmxlXCIpO2FuaW1hdGVUbz0wO2lmKCFpc1Zpc2libGUpe2IuY3NzKFwib3BhY2l0eVwiLDApLnNob3coKTthbmltYXRlVG89MX1pZihjPT1cImhpZGVcIiYmaXNWaXNpYmxlfHxjPT1cInNob3dcIiYmIWlzVmlzaWJsZSl0aW1lcy0tO2ZvcihjPTA7Yzx0aW1lcztjKyspe2IuYW5pbWF0ZSh7b3BhY2l0eTphbmltYXRlVG99LGR1cmF0aW9uLGEub3B0aW9ucy5lYXNpbmcpO2FuaW1hdGVUbz0oYW5pbWF0ZVRvKzEpJTJ9Yi5hbmltYXRlKHtvcGFjaXR5OmFuaW1hdGVUb30sZHVyYXRpb24sXHJcbmEub3B0aW9ucy5lYXNpbmcsZnVuY3Rpb24oKXthbmltYXRlVG89PTAmJmIuaGlkZSgpO2EuY2FsbGJhY2smJmEuY2FsbGJhY2suYXBwbHkodGhpcyxhcmd1bWVudHMpfSk7Yi5xdWV1ZShcImZ4XCIsZnVuY3Rpb24oKXtiLmRlcXVldWUoKX0pLmRlcXVldWUoKX0pfX0pKGpRdWVyeSk7XHJcbjsvKlxyXG4gKiBqUXVlcnkgVUkgRWZmZWN0cyBTY2FsZSAxLjguMTZcclxuICpcclxuICogQ29weXJpZ2h0IDIwMTEsIEFVVEhPUlMudHh0IChodHRwOi8vanF1ZXJ5dWkuY29tL2Fib3V0KVxyXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgb3IgR1BMIFZlcnNpb24gMiBsaWNlbnNlcy5cclxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxyXG4gKlxyXG4gKiBodHRwOi8vZG9jcy5qcXVlcnkuY29tL1VJL0VmZmVjdHMvU2NhbGVcclxuICpcclxuICogRGVwZW5kczpcclxuICpcdGpxdWVyeS5lZmZlY3RzLmNvcmUuanNcclxuICovXHJcbihmdW5jdGlvbihjKXtjLmVmZmVjdHMucHVmZj1mdW5jdGlvbihiKXtyZXR1cm4gdGhpcy5xdWV1ZShmdW5jdGlvbigpe3ZhciBhPWModGhpcyksZT1jLmVmZmVjdHMuc2V0TW9kZShhLGIub3B0aW9ucy5tb2RlfHxcImhpZGVcIiksZz1wYXJzZUludChiLm9wdGlvbnMucGVyY2VudCwxMCl8fDE1MCxoPWcvMTAwLGk9e2hlaWdodDphLmhlaWdodCgpLHdpZHRoOmEud2lkdGgoKX07Yy5leHRlbmQoYi5vcHRpb25zLHtmYWRlOnRydWUsbW9kZTplLHBlcmNlbnQ6ZT09XCJoaWRlXCI/ZzoxMDAsZnJvbTplPT1cImhpZGVcIj9pOntoZWlnaHQ6aS5oZWlnaHQqaCx3aWR0aDppLndpZHRoKmh9fSk7YS5lZmZlY3QoXCJzY2FsZVwiLGIub3B0aW9ucyxiLmR1cmF0aW9uLGIuY2FsbGJhY2spO2EuZGVxdWV1ZSgpfSl9O2MuZWZmZWN0cy5zY2FsZT1mdW5jdGlvbihiKXtyZXR1cm4gdGhpcy5xdWV1ZShmdW5jdGlvbigpe3ZhciBhPWModGhpcyksZT1jLmV4dGVuZCh0cnVlLHt9LGIub3B0aW9ucyksZz1jLmVmZmVjdHMuc2V0TW9kZShhLFxyXG5iLm9wdGlvbnMubW9kZXx8XCJlZmZlY3RcIiksaD1wYXJzZUludChiLm9wdGlvbnMucGVyY2VudCwxMCl8fChwYXJzZUludChiLm9wdGlvbnMucGVyY2VudCwxMCk9PTA/MDpnPT1cImhpZGVcIj8wOjEwMCksaT1iLm9wdGlvbnMuZGlyZWN0aW9ufHxcImJvdGhcIixmPWIub3B0aW9ucy5vcmlnaW47aWYoZyE9XCJlZmZlY3RcIil7ZS5vcmlnaW49Znx8W1wibWlkZGxlXCIsXCJjZW50ZXJcIl07ZS5yZXN0b3JlPXRydWV9Zj17aGVpZ2h0OmEuaGVpZ2h0KCksd2lkdGg6YS53aWR0aCgpfTthLmZyb209Yi5vcHRpb25zLmZyb218fChnPT1cInNob3dcIj97aGVpZ2h0OjAsd2lkdGg6MH06Zik7aD17eTppIT1cImhvcml6b250YWxcIj9oLzEwMDoxLHg6aSE9XCJ2ZXJ0aWNhbFwiP2gvMTAwOjF9O2EudG89e2hlaWdodDpmLmhlaWdodCpoLnksd2lkdGg6Zi53aWR0aCpoLnh9O2lmKGIub3B0aW9ucy5mYWRlKXtpZihnPT1cInNob3dcIil7YS5mcm9tLm9wYWNpdHk9MDthLnRvLm9wYWNpdHk9MX1pZihnPT1cImhpZGVcIil7YS5mcm9tLm9wYWNpdHk9XHJcbjE7YS50by5vcGFjaXR5PTB9fWUuZnJvbT1hLmZyb207ZS50bz1hLnRvO2UubW9kZT1nO2EuZWZmZWN0KFwic2l6ZVwiLGUsYi5kdXJhdGlvbixiLmNhbGxiYWNrKTthLmRlcXVldWUoKX0pfTtjLmVmZmVjdHMuc2l6ZT1mdW5jdGlvbihiKXtyZXR1cm4gdGhpcy5xdWV1ZShmdW5jdGlvbigpe3ZhciBhPWModGhpcyksZT1bXCJwb3NpdGlvblwiLFwidG9wXCIsXCJib3R0b21cIixcImxlZnRcIixcInJpZ2h0XCIsXCJ3aWR0aFwiLFwiaGVpZ2h0XCIsXCJvdmVyZmxvd1wiLFwib3BhY2l0eVwiXSxnPVtcInBvc2l0aW9uXCIsXCJ0b3BcIixcImJvdHRvbVwiLFwibGVmdFwiLFwicmlnaHRcIixcIm92ZXJmbG93XCIsXCJvcGFjaXR5XCJdLGg9W1wid2lkdGhcIixcImhlaWdodFwiLFwib3ZlcmZsb3dcIl0saT1bXCJmb250U2l6ZVwiXSxmPVtcImJvcmRlclRvcFdpZHRoXCIsXCJib3JkZXJCb3R0b21XaWR0aFwiLFwicGFkZGluZ1RvcFwiLFwicGFkZGluZ0JvdHRvbVwiXSxrPVtcImJvcmRlckxlZnRXaWR0aFwiLFwiYm9yZGVyUmlnaHRXaWR0aFwiLFwicGFkZGluZ0xlZnRcIixcInBhZGRpbmdSaWdodFwiXSxcclxucD1jLmVmZmVjdHMuc2V0TW9kZShhLGIub3B0aW9ucy5tb2RlfHxcImVmZmVjdFwiKSxuPWIub3B0aW9ucy5yZXN0b3JlfHxmYWxzZSxtPWIub3B0aW9ucy5zY2FsZXx8XCJib3RoXCIsbD1iLm9wdGlvbnMub3JpZ2luLGo9e2hlaWdodDphLmhlaWdodCgpLHdpZHRoOmEud2lkdGgoKX07YS5mcm9tPWIub3B0aW9ucy5mcm9tfHxqO2EudG89Yi5vcHRpb25zLnRvfHxqO2lmKGwpe2w9Yy5lZmZlY3RzLmdldEJhc2VsaW5lKGwsaik7YS5mcm9tLnRvcD0oai5oZWlnaHQtYS5mcm9tLmhlaWdodCkqbC55O2EuZnJvbS5sZWZ0PShqLndpZHRoLWEuZnJvbS53aWR0aCkqbC54O2EudG8udG9wPShqLmhlaWdodC1hLnRvLmhlaWdodCkqbC55O2EudG8ubGVmdD0oai53aWR0aC1hLnRvLndpZHRoKSpsLnh9dmFyIGQ9e2Zyb206e3k6YS5mcm9tLmhlaWdodC9qLmhlaWdodCx4OmEuZnJvbS53aWR0aC9qLndpZHRofSx0bzp7eTphLnRvLmhlaWdodC9qLmhlaWdodCx4OmEudG8ud2lkdGgvai53aWR0aH19O1xyXG5pZihtPT1cImJveFwifHxtPT1cImJvdGhcIil7aWYoZC5mcm9tLnkhPWQudG8ueSl7ZT1lLmNvbmNhdChmKTthLmZyb209Yy5lZmZlY3RzLnNldFRyYW5zaXRpb24oYSxmLGQuZnJvbS55LGEuZnJvbSk7YS50bz1jLmVmZmVjdHMuc2V0VHJhbnNpdGlvbihhLGYsZC50by55LGEudG8pfWlmKGQuZnJvbS54IT1kLnRvLngpe2U9ZS5jb25jYXQoayk7YS5mcm9tPWMuZWZmZWN0cy5zZXRUcmFuc2l0aW9uKGEsayxkLmZyb20ueCxhLmZyb20pO2EudG89Yy5lZmZlY3RzLnNldFRyYW5zaXRpb24oYSxrLGQudG8ueCxhLnRvKX19aWYobT09XCJjb250ZW50XCJ8fG09PVwiYm90aFwiKWlmKGQuZnJvbS55IT1kLnRvLnkpe2U9ZS5jb25jYXQoaSk7YS5mcm9tPWMuZWZmZWN0cy5zZXRUcmFuc2l0aW9uKGEsaSxkLmZyb20ueSxhLmZyb20pO2EudG89Yy5lZmZlY3RzLnNldFRyYW5zaXRpb24oYSxpLGQudG8ueSxhLnRvKX1jLmVmZmVjdHMuc2F2ZShhLG4/ZTpnKTthLnNob3coKTtjLmVmZmVjdHMuY3JlYXRlV3JhcHBlcihhKTtcclxuYS5jc3MoXCJvdmVyZmxvd1wiLFwiaGlkZGVuXCIpLmNzcyhhLmZyb20pO2lmKG09PVwiY29udGVudFwifHxtPT1cImJvdGhcIil7Zj1mLmNvbmNhdChbXCJtYXJnaW5Ub3BcIixcIm1hcmdpbkJvdHRvbVwiXSkuY29uY2F0KGkpO2s9ay5jb25jYXQoW1wibWFyZ2luTGVmdFwiLFwibWFyZ2luUmlnaHRcIl0pO2g9ZS5jb25jYXQoZikuY29uY2F0KGspO2EuZmluZChcIipbd2lkdGhdXCIpLmVhY2goZnVuY3Rpb24oKXtjaGlsZD1jKHRoaXMpO24mJmMuZWZmZWN0cy5zYXZlKGNoaWxkLGgpO3ZhciBvPXtoZWlnaHQ6Y2hpbGQuaGVpZ2h0KCksd2lkdGg6Y2hpbGQud2lkdGgoKX07Y2hpbGQuZnJvbT17aGVpZ2h0Om8uaGVpZ2h0KmQuZnJvbS55LHdpZHRoOm8ud2lkdGgqZC5mcm9tLnh9O2NoaWxkLnRvPXtoZWlnaHQ6by5oZWlnaHQqZC50by55LHdpZHRoOm8ud2lkdGgqZC50by54fTtpZihkLmZyb20ueSE9ZC50by55KXtjaGlsZC5mcm9tPWMuZWZmZWN0cy5zZXRUcmFuc2l0aW9uKGNoaWxkLGYsZC5mcm9tLnksY2hpbGQuZnJvbSk7XHJcbmNoaWxkLnRvPWMuZWZmZWN0cy5zZXRUcmFuc2l0aW9uKGNoaWxkLGYsZC50by55LGNoaWxkLnRvKX1pZihkLmZyb20ueCE9ZC50by54KXtjaGlsZC5mcm9tPWMuZWZmZWN0cy5zZXRUcmFuc2l0aW9uKGNoaWxkLGssZC5mcm9tLngsY2hpbGQuZnJvbSk7Y2hpbGQudG89Yy5lZmZlY3RzLnNldFRyYW5zaXRpb24oY2hpbGQsayxkLnRvLngsY2hpbGQudG8pfWNoaWxkLmNzcyhjaGlsZC5mcm9tKTtjaGlsZC5hbmltYXRlKGNoaWxkLnRvLGIuZHVyYXRpb24sYi5vcHRpb25zLmVhc2luZyxmdW5jdGlvbigpe24mJmMuZWZmZWN0cy5yZXN0b3JlKGNoaWxkLGgpfSl9KX1hLmFuaW1hdGUoYS50byx7cXVldWU6ZmFsc2UsZHVyYXRpb246Yi5kdXJhdGlvbixlYXNpbmc6Yi5vcHRpb25zLmVhc2luZyxjb21wbGV0ZTpmdW5jdGlvbigpe2EudG8ub3BhY2l0eT09PTAmJmEuY3NzKFwib3BhY2l0eVwiLGEuZnJvbS5vcGFjaXR5KTtwPT1cImhpZGVcIiYmYS5oaWRlKCk7Yy5lZmZlY3RzLnJlc3RvcmUoYSxcclxubj9lOmcpO2MuZWZmZWN0cy5yZW1vdmVXcmFwcGVyKGEpO2IuY2FsbGJhY2smJmIuY2FsbGJhY2suYXBwbHkodGhpcyxhcmd1bWVudHMpO2EuZGVxdWV1ZSgpfX0pfSl9fSkoalF1ZXJ5KTtcclxuOy8qXHJcbiAqIGpRdWVyeSBVSSBFZmZlY3RzIFNoYWtlIDEuOC4xNlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgMjAxMSwgQVVUSE9SUy50eHQgKGh0dHA6Ly9qcXVlcnl1aS5jb20vYWJvdXQpXHJcbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBvciBHUEwgVmVyc2lvbiAyIGxpY2Vuc2VzLlxyXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXHJcbiAqXHJcbiAqIGh0dHA6Ly9kb2NzLmpxdWVyeS5jb20vVUkvRWZmZWN0cy9TaGFrZVxyXG4gKlxyXG4gKiBEZXBlbmRzOlxyXG4gKlx0anF1ZXJ5LmVmZmVjdHMuY29yZS5qc1xyXG4gKi9cclxuKGZ1bmN0aW9uKGQpe2QuZWZmZWN0cy5zaGFrZT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5xdWV1ZShmdW5jdGlvbigpe3ZhciBiPWQodGhpcyksaj1bXCJwb3NpdGlvblwiLFwidG9wXCIsXCJib3R0b21cIixcImxlZnRcIixcInJpZ2h0XCJdO2QuZWZmZWN0cy5zZXRNb2RlKGIsYS5vcHRpb25zLm1vZGV8fFwiZWZmZWN0XCIpO3ZhciBjPWEub3B0aW9ucy5kaXJlY3Rpb258fFwibGVmdFwiLGU9YS5vcHRpb25zLmRpc3RhbmNlfHwyMCxsPWEub3B0aW9ucy50aW1lc3x8MyxmPWEuZHVyYXRpb258fGEub3B0aW9ucy5kdXJhdGlvbnx8MTQwO2QuZWZmZWN0cy5zYXZlKGIsaik7Yi5zaG93KCk7ZC5lZmZlY3RzLmNyZWF0ZVdyYXBwZXIoYik7dmFyIGc9Yz09XCJ1cFwifHxjPT1cImRvd25cIj9cInRvcFwiOlwibGVmdFwiLGg9Yz09XCJ1cFwifHxjPT1cImxlZnRcIj9cInBvc1wiOlwibmVnXCI7Yz17fTt2YXIgaT17fSxrPXt9O2NbZ109KGg9PVwicG9zXCI/XCItPVwiOlwiKz1cIikrZTtpW2ddPShoPT1cInBvc1wiP1wiKz1cIjpcIi09XCIpK2UqMjtrW2ddPVxyXG4oaD09XCJwb3NcIj9cIi09XCI6XCIrPVwiKStlKjI7Yi5hbmltYXRlKGMsZixhLm9wdGlvbnMuZWFzaW5nKTtmb3IoZT0xO2U8bDtlKyspYi5hbmltYXRlKGksZixhLm9wdGlvbnMuZWFzaW5nKS5hbmltYXRlKGssZixhLm9wdGlvbnMuZWFzaW5nKTtiLmFuaW1hdGUoaSxmLGEub3B0aW9ucy5lYXNpbmcpLmFuaW1hdGUoYyxmLzIsYS5vcHRpb25zLmVhc2luZyxmdW5jdGlvbigpe2QuZWZmZWN0cy5yZXN0b3JlKGIsaik7ZC5lZmZlY3RzLnJlbW92ZVdyYXBwZXIoYik7YS5jYWxsYmFjayYmYS5jYWxsYmFjay5hcHBseSh0aGlzLGFyZ3VtZW50cyl9KTtiLnF1ZXVlKFwiZnhcIixmdW5jdGlvbigpe2IuZGVxdWV1ZSgpfSk7Yi5kZXF1ZXVlKCl9KX19KShqUXVlcnkpO1xyXG47LypcclxuICogalF1ZXJ5IFVJIEVmZmVjdHMgU2xpZGUgMS44LjE2XHJcbiAqXHJcbiAqIENvcHlyaWdodCAyMDExLCBBVVRIT1JTLnR4dCAoaHR0cDovL2pxdWVyeXVpLmNvbS9hYm91dClcclxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIG9yIEdQTCBWZXJzaW9uIDIgbGljZW5zZXMuXHJcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcclxuICpcclxuICogaHR0cDovL2RvY3MuanF1ZXJ5LmNvbS9VSS9FZmZlY3RzL1NsaWRlXHJcbiAqXHJcbiAqIERlcGVuZHM6XHJcbiAqXHRqcXVlcnkuZWZmZWN0cy5jb3JlLmpzXHJcbiAqL1xyXG4oZnVuY3Rpb24oYyl7Yy5lZmZlY3RzLnNsaWRlPWZ1bmN0aW9uKGQpe3JldHVybiB0aGlzLnF1ZXVlKGZ1bmN0aW9uKCl7dmFyIGE9Yyh0aGlzKSxoPVtcInBvc2l0aW9uXCIsXCJ0b3BcIixcImJvdHRvbVwiLFwibGVmdFwiLFwicmlnaHRcIl0sZj1jLmVmZmVjdHMuc2V0TW9kZShhLGQub3B0aW9ucy5tb2RlfHxcInNob3dcIiksYj1kLm9wdGlvbnMuZGlyZWN0aW9ufHxcImxlZnRcIjtjLmVmZmVjdHMuc2F2ZShhLGgpO2Euc2hvdygpO2MuZWZmZWN0cy5jcmVhdGVXcmFwcGVyKGEpLmNzcyh7b3ZlcmZsb3c6XCJoaWRkZW5cIn0pO3ZhciBnPWI9PVwidXBcInx8Yj09XCJkb3duXCI/XCJ0b3BcIjpcImxlZnRcIjtiPWI9PVwidXBcInx8Yj09XCJsZWZ0XCI/XCJwb3NcIjpcIm5lZ1wiO3ZhciBlPWQub3B0aW9ucy5kaXN0YW5jZXx8KGc9PVwidG9wXCI/YS5vdXRlckhlaWdodCh7bWFyZ2luOnRydWV9KTphLm91dGVyV2lkdGgoe21hcmdpbjp0cnVlfSkpO2lmKGY9PVwic2hvd1wiKWEuY3NzKGcsYj09XCJwb3NcIj9pc05hTihlKT9cIi1cIitlOi1lOmUpO1xyXG52YXIgaT17fTtpW2ddPShmPT1cInNob3dcIj9iPT1cInBvc1wiP1wiKz1cIjpcIi09XCI6Yj09XCJwb3NcIj9cIi09XCI6XCIrPVwiKStlO2EuYW5pbWF0ZShpLHtxdWV1ZTpmYWxzZSxkdXJhdGlvbjpkLmR1cmF0aW9uLGVhc2luZzpkLm9wdGlvbnMuZWFzaW5nLGNvbXBsZXRlOmZ1bmN0aW9uKCl7Zj09XCJoaWRlXCImJmEuaGlkZSgpO2MuZWZmZWN0cy5yZXN0b3JlKGEsaCk7Yy5lZmZlY3RzLnJlbW92ZVdyYXBwZXIoYSk7ZC5jYWxsYmFjayYmZC5jYWxsYmFjay5hcHBseSh0aGlzLGFyZ3VtZW50cyk7YS5kZXF1ZXVlKCl9fSl9KX19KShqUXVlcnkpO1xyXG47LypcclxuICogalF1ZXJ5IFVJIEVmZmVjdHMgVHJhbnNmZXIgMS44LjE2XHJcbiAqXHJcbiAqIENvcHlyaWdodCAyMDExLCBBVVRIT1JTLnR4dCAoaHR0cDovL2pxdWVyeXVpLmNvbS9hYm91dClcclxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIG9yIEdQTCBWZXJzaW9uIDIgbGljZW5zZXMuXHJcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcclxuICpcclxuICogaHR0cDovL2RvY3MuanF1ZXJ5LmNvbS9VSS9FZmZlY3RzL1RyYW5zZmVyXHJcbiAqXHJcbiAqIERlcGVuZHM6XHJcbiAqXHRqcXVlcnkuZWZmZWN0cy5jb3JlLmpzXHJcbiAqL1xyXG4oZnVuY3Rpb24oZSl7ZS5lZmZlY3RzLnRyYW5zZmVyPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnF1ZXVlKGZ1bmN0aW9uKCl7dmFyIGI9ZSh0aGlzKSxjPWUoYS5vcHRpb25zLnRvKSxkPWMub2Zmc2V0KCk7Yz17dG9wOmQudG9wLGxlZnQ6ZC5sZWZ0LGhlaWdodDpjLmlubmVySGVpZ2h0KCksd2lkdGg6Yy5pbm5lcldpZHRoKCl9O2Q9Yi5vZmZzZXQoKTt2YXIgZj1lKCc8ZGl2IGNsYXNzPVwidWktZWZmZWN0cy10cmFuc2ZlclwiPjwvZGl2PicpLmFwcGVuZFRvKGRvY3VtZW50LmJvZHkpLmFkZENsYXNzKGEub3B0aW9ucy5jbGFzc05hbWUpLmNzcyh7dG9wOmQudG9wLGxlZnQ6ZC5sZWZ0LGhlaWdodDpiLmlubmVySGVpZ2h0KCksd2lkdGg6Yi5pbm5lcldpZHRoKCkscG9zaXRpb246XCJhYnNvbHV0ZVwifSkuYW5pbWF0ZShjLGEuZHVyYXRpb24sYS5vcHRpb25zLmVhc2luZyxmdW5jdGlvbigpe2YucmVtb3ZlKCk7YS5jYWxsYmFjayYmYS5jYWxsYmFjay5hcHBseShiWzBdLGFyZ3VtZW50cyk7XHJcbmIuZGVxdWV1ZSgpfSl9KX19KShqUXVlcnkpO1xyXG47IiwiXHJcbihmdW5jdGlvbigkKXskLnRvSlNPTj1mdW5jdGlvbihvKVxyXG57aWYodHlwZW9mKEpTT04pPT0nb2JqZWN0JyYmSlNPTi5zdHJpbmdpZnkpXHJcbnJldHVybiBKU09OLnN0cmluZ2lmeShvKTt2YXIgdHlwZT10eXBlb2Yobyk7aWYobz09PW51bGwpXHJcbnJldHVyblwibnVsbFwiO2lmKHR5cGU9PVwidW5kZWZpbmVkXCIpXHJcbnJldHVybiB1bmRlZmluZWQ7aWYodHlwZT09XCJudW1iZXJcInx8dHlwZT09XCJib29sZWFuXCIpXHJcbnJldHVybiBvK1wiXCI7aWYodHlwZT09XCJzdHJpbmdcIilcclxucmV0dXJuICQucXVvdGVTdHJpbmcobyk7aWYodHlwZT09J29iamVjdCcpXHJcbntpZih0eXBlb2Ygby50b0pTT049PVwiZnVuY3Rpb25cIilcclxucmV0dXJuICQudG9KU09OKG8udG9KU09OKCkpO2lmKG8uY29uc3RydWN0b3I9PT1EYXRlKVxyXG57dmFyIG1vbnRoPW8uZ2V0VVRDTW9udGgoKSsxO2lmKG1vbnRoPDEwKW1vbnRoPScwJyttb250aDt2YXIgZGF5PW8uZ2V0VVRDRGF0ZSgpO2lmKGRheTwxMClkYXk9JzAnK2RheTt2YXIgeWVhcj1vLmdldFVUQ0Z1bGxZZWFyKCk7dmFyIGhvdXJzPW8uZ2V0VVRDSG91cnMoKTtpZihob3VyczwxMClob3Vycz0nMCcraG91cnM7dmFyIG1pbnV0ZXM9by5nZXRVVENNaW51dGVzKCk7aWYobWludXRlczwxMCltaW51dGVzPScwJyttaW51dGVzO3ZhciBzZWNvbmRzPW8uZ2V0VVRDU2Vjb25kcygpO2lmKHNlY29uZHM8MTApc2Vjb25kcz0nMCcrc2Vjb25kczt2YXIgbWlsbGk9by5nZXRVVENNaWxsaXNlY29uZHMoKTtpZihtaWxsaTwxMDApbWlsbGk9JzAnK21pbGxpO2lmKG1pbGxpPDEwKW1pbGxpPScwJyttaWxsaTtyZXR1cm4nXCInK3llYXIrJy0nK21vbnRoKyctJytkYXkrJ1QnK1xyXG5ob3VycysnOicrbWludXRlcysnOicrc2Vjb25kcysnLicrbWlsbGkrJ1pcIic7fVxyXG5pZihvLmNvbnN0cnVjdG9yPT09QXJyYXkpXHJcbnt2YXIgcmV0PVtdO2Zvcih2YXIgaT0wO2k8by5sZW5ndGg7aSsrKVxyXG5yZXQucHVzaCgkLnRvSlNPTihvW2ldKXx8XCJudWxsXCIpO3JldHVyblwiW1wiK3JldC5qb2luKFwiLFwiKStcIl1cIjt9XHJcbnZhciBwYWlycz1bXTtmb3IodmFyIGsgaW4gbyl7dmFyIG5hbWU7dmFyIHR5cGU9dHlwZW9mIGs7aWYodHlwZT09XCJudW1iZXJcIilcclxubmFtZT0nXCInK2srJ1wiJztlbHNlIGlmKHR5cGU9PVwic3RyaW5nXCIpXHJcbm5hbWU9JC5xdW90ZVN0cmluZyhrKTtlbHNlXHJcbmNvbnRpbnVlO2lmKHR5cGVvZiBvW2tdPT1cImZ1bmN0aW9uXCIpXHJcbmNvbnRpbnVlO3ZhciB2YWw9JC50b0pTT04ob1trXSk7cGFpcnMucHVzaChuYW1lK1wiOlwiK3ZhbCk7fVxyXG5yZXR1cm5cIntcIitwYWlycy5qb2luKFwiLCBcIikrXCJ9XCI7fX07JC5ldmFsSlNPTj1mdW5jdGlvbihzcmMpXHJcbntpZih0eXBlb2YoSlNPTik9PSdvYmplY3QnJiZKU09OLnBhcnNlKVxyXG5yZXR1cm4gSlNPTi5wYXJzZShzcmMpO3JldHVybiBldmFsKFwiKFwiK3NyYytcIilcIik7fTskLnNlY3VyZUV2YWxKU09OPWZ1bmN0aW9uKHNyYylcclxue2lmKHR5cGVvZihKU09OKT09J29iamVjdCcmJkpTT04ucGFyc2UpXHJcbnJldHVybiBKU09OLnBhcnNlKHNyYyk7dmFyIGZpbHRlcmVkPXNyYztmaWx0ZXJlZD1maWx0ZXJlZC5yZXBsYWNlKC9cXFxcW1wiXFxcXFxcL2JmbnJ0dV0vZywnQCcpO2ZpbHRlcmVkPWZpbHRlcmVkLnJlcGxhY2UoL1wiW15cIlxcXFxcXG5cXHJdKlwifHRydWV8ZmFsc2V8bnVsbHwtP1xcZCsoPzpcXC5cXGQqKT8oPzpbZUVdWytcXC1dP1xcZCspPy9nLCddJyk7ZmlsdGVyZWQ9ZmlsdGVyZWQucmVwbGFjZSgvKD86Xnw6fCwpKD86XFxzKlxcWykrL2csJycpO2lmKC9eW1xcXSw6e31cXHNdKiQvLnRlc3QoZmlsdGVyZWQpKVxyXG5yZXR1cm4gZXZhbChcIihcIitzcmMrXCIpXCIpO2Vsc2VcclxudGhyb3cgbmV3IFN5bnRheEVycm9yKFwiRXJyb3IgcGFyc2luZyBKU09OLCBzb3VyY2UgaXMgbm90IHZhbGlkLlwiKTt9OyQucXVvdGVTdHJpbmc9ZnVuY3Rpb24oc3RyaW5nKVxyXG57aWYoc3RyaW5nLm1hdGNoKF9lc2NhcGVhYmxlKSlcclxue3JldHVybidcIicrc3RyaW5nLnJlcGxhY2UoX2VzY2FwZWFibGUsZnVuY3Rpb24oYSlcclxue3ZhciBjPV9tZXRhW2FdO2lmKHR5cGVvZiBjPT09J3N0cmluZycpcmV0dXJuIGM7Yz1hLmNoYXJDb2RlQXQoKTtyZXR1cm4nXFxcXHUwMCcrTWF0aC5mbG9vcihjLzE2KS50b1N0cmluZygxNikrKGMlMTYpLnRvU3RyaW5nKDE2KTt9KSsnXCInO31cclxucmV0dXJuJ1wiJytzdHJpbmcrJ1wiJzt9O3ZhciBfZXNjYXBlYWJsZT0vW1wiXFxcXFxceDAwLVxceDFmXFx4N2YtXFx4OWZdL2c7dmFyIF9tZXRhPXsnXFxiJzonXFxcXGInLCdcXHQnOidcXFxcdCcsJ1xcbic6J1xcXFxuJywnXFxmJzonXFxcXGYnLCdcXHInOidcXFxccicsJ1wiJzonXFxcXFwiJywnXFxcXCc6J1xcXFxcXFxcJ307fSkoalF1ZXJ5KTsiLCIvKipcclxuICogc3ByaW50ZiBhbmQgdnNwcmludGYgZm9yIGpRdWVyeVxyXG4gKiBzb21ld2hhdCBiYXNlZCBvbiBodHRwOi8vamFuLm1vZXNlbi5udS9jb2RlL2phdmFzY3JpcHQvc3ByaW50Zi1hbmQtcHJpbnRmLWluLWphdmFzY3JpcHQvXHJcbiAqIFxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDggU2FiaW4gSWFjb2IgKG0wbjV0M3IpIDxpYWNvYnNAbTBuNXQzci5pbmZvPlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxyXG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxyXG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxyXG4gKiAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxyXG4gKlxyXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcclxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcclxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxyXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLiBcclxuICpcclxuICogQGxpY2Vuc2UgaHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzL2dwbC5odG1sIFxyXG4gKiBAcHJvamVjdCBqcXVlcnkuc3ByaW50ZlxyXG4gKi9cclxuKGZ1bmN0aW9uKCQpe1xyXG5cdHZhciBmb3JtYXRzID0ge1xyXG5cdFx0J2InOiBmdW5jdGlvbih2YWwpIHtyZXR1cm4gcGFyc2VJbnQodmFsLCAxMCkudG9TdHJpbmcoMik7fSxcclxuXHRcdCdjJzogZnVuY3Rpb24odmFsKSB7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQodmFsLCAxMCkpO30sXHJcblx0XHQnZCc6IGZ1bmN0aW9uKHZhbCkge3JldHVybiBwYXJzZUludCh2YWwsIDEwKTt9LFxyXG5cdFx0J3UnOiBmdW5jdGlvbih2YWwpIHtyZXR1cm4gTWF0aC5hYnModmFsKTt9LFxyXG5cdFx0J2YnOiBmdW5jdGlvbih2YWwsIHApIHtcclxuXHRcdFx0cCA9IHBhcnNlSW50KHAsIDEwKTsgXHJcblx0XHRcdHZhbCA9IHBhcnNlRmxvYXQodmFsKTtcclxuXHRcdFx0aWYoaXNOYU4ocCAmJiB2YWwpKSB7XHJcblx0XHRcdFx0cmV0dXJuIE5hTjtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gcCAmJiB2YWwudG9GaXhlZChwKSB8fCB2YWw7XHJcblx0XHR9LFxyXG5cdFx0J28nOiBmdW5jdGlvbih2YWwpIHtyZXR1cm4gcGFyc2VJbnQodmFsLCAxMCkudG9TdHJpbmcoOCk7fSxcclxuXHRcdCdzJzogZnVuY3Rpb24odmFsKSB7cmV0dXJuIHZhbDt9LFxyXG5cdFx0J3gnOiBmdW5jdGlvbih2YWwpIHtyZXR1cm4gKCcnICsgcGFyc2VJbnQodmFsLCAxMCkudG9TdHJpbmcoMTYpKS50b0xvd2VyQ2FzZSgpO30sXHJcblx0XHQnWCc6IGZ1bmN0aW9uKHZhbCkge3JldHVybiAoJycgKyBwYXJzZUludCh2YWwsIDEwKS50b1N0cmluZygxNikpLnRvVXBwZXJDYXNlKCk7fVxyXG5cdH07XHJcblxyXG5cdHZhciByZSA9IC8lKD86KFxcZCspPyg/OlxcLihcXGQrKSk/fFxcKChbXildKylcXCkpKFslYmNkdWZvc3hYXSkvZztcclxuXHJcblx0dmFyIGRpc3BhdGNoID0gZnVuY3Rpb24oZGF0YSl7XHJcblx0XHRpZihkYXRhLmxlbmd0aCA9PSAxICYmIHR5cGVvZiBkYXRhWzBdID09ICdvYmplY3QnKSB7IC8vcHl0aG9uLXN0eWxlIHByaW50ZlxyXG5cdFx0XHRkYXRhID0gZGF0YVswXTtcclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKG1hdGNoLCB3LCBwLCBsYmwsIGZtdCwgb2ZmLCBzdHIpIHtcclxuXHRcdFx0XHRyZXR1cm4gZm9ybWF0c1tmbXRdKGRhdGFbbGJsXSk7XHJcblx0XHRcdH07XHJcblx0XHR9IGVsc2UgeyAvLyByZWd1bGFyLCBzb21ld2hhdCBpbmNvbXBsZXRlLCBwcmludGZcclxuXHRcdFx0dmFyIGlkeCA9IDA7IFxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24obWF0Y2gsIHcsIHAsIGxibCwgZm10LCBvZmYsIHN0cikge1xyXG5cdFx0XHRcdGlmKGZtdCA9PSAnJScpIHtcclxuXHRcdFx0XHRcdHJldHVybiAnJSc7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBmb3JtYXRzW2ZtdF0oZGF0YVtpZHgrK10sIHApO1xyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdCQuZXh0ZW5kKHtcclxuXHRcdHNwcmludGY6IGZ1bmN0aW9uKGZvcm1hdCkge1xyXG5cdFx0XHR2YXIgYXJndiA9IEFycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cykuc2xpY2UoMSk7XHJcblx0XHRcdHJldHVybiBmb3JtYXQucmVwbGFjZShyZSwgZGlzcGF0Y2goYXJndikpO1xyXG5cdFx0fSxcclxuXHRcdHZzcHJpbnRmOiBmdW5jdGlvbihmb3JtYXQsIGRhdGEpIHtcclxuXHRcdFx0cmV0dXJuIGZvcm1hdC5yZXBsYWNlKHJlLCBkaXNwYXRjaChkYXRhKSk7XHJcblx0XHR9XHJcblx0fSk7XHJcbn0pKGpRdWVyeSk7XHJcbiIsIi8qIGh0dHA6Ly9rZWl0aC13b29kLm5hbWUvc3ZnLmh0bWxcclxuICAgU1ZHIGZvciBqUXVlcnkgdjEuNC4zLlxyXG4gICBXcml0dGVuIGJ5IEtlaXRoIFdvb2QgKGtid29vZHthdH1paW5ldC5jb20uYXUpIEF1Z3VzdCAyMDA3LlxyXG4gICBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBHUEwgKGh0dHA6Ly9kZXYuanF1ZXJ5LmNvbS9icm93c2VyL3RydW5rL2pxdWVyeS9HUEwtTElDRU5TRS50eHQpIGFuZCBcclxuICAgTUlUIChodHRwOi8vZGV2LmpxdWVyeS5jb20vYnJvd3Nlci90cnVuay9qcXVlcnkvTUlULUxJQ0VOU0UudHh0KSBsaWNlbnNlcy4gXHJcbiAgIFBsZWFzZSBhdHRyaWJ1dGUgdGhlIGF1dGhvciBpZiB5b3UgdXNlIGl0LiAqL1xyXG4oZnVuY3Rpb24oJCl7ZnVuY3Rpb24gU1ZHTWFuYWdlcigpe3RoaXMuX3NldHRpbmdzPVtdO3RoaXMuX2V4dGVuc2lvbnM9W107dGhpcy5yZWdpb25hbD1bXTt0aGlzLnJlZ2lvbmFsWycnXT17ZXJyb3JMb2FkaW5nVGV4dDonRXJyb3IgbG9hZGluZycsbm90U3VwcG9ydGVkVGV4dDonVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgU1ZHJ307dGhpcy5sb2NhbD10aGlzLnJlZ2lvbmFsWycnXTt0aGlzLl91dWlkPW5ldyBEYXRlKCkuZ2V0VGltZSgpO3RoaXMuX3JlbmVzaXM9ZGV0ZWN0QWN0aXZlWCgnUmVuZXNpc1guUmVuZXNpc0N0cmwnKX1mdW5jdGlvbiBkZXRlY3RBY3RpdmVYKGEpe3RyeXtyZXR1cm4hISh3aW5kb3cuQWN0aXZlWE9iamVjdCYmbmV3IEFjdGl2ZVhPYmplY3QoYSkpfWNhdGNoKGUpe3JldHVybiBmYWxzZX19dmFyIHA9J3N2Z3dyYXBwZXInOyQuZXh0ZW5kKFNWR01hbmFnZXIucHJvdG90eXBlLHttYXJrZXJDbGFzc05hbWU6J2hhc1NWRycsc3ZnTlM6J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyx4bGlua05TOidodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxfd3JhcHBlckNsYXNzOlNWR1dyYXBwZXIsX2F0dHJOYW1lczp7Y2xhc3NfOidjbGFzcycsaW5fOidpbicsYWxpZ25tZW50QmFzZWxpbmU6J2FsaWdubWVudC1iYXNlbGluZScsYmFzZWxpbmVTaGlmdDonYmFzZWxpbmUtc2hpZnQnLGNsaXBQYXRoOidjbGlwLXBhdGgnLGNsaXBSdWxlOidjbGlwLXJ1bGUnLGNvbG9ySW50ZXJwb2xhdGlvbjonY29sb3ItaW50ZXJwb2xhdGlvbicsY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVyczonY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJyxjb2xvclJlbmRlcmluZzonY29sb3ItcmVuZGVyaW5nJyxkb21pbmFudEJhc2VsaW5lOidkb21pbmFudC1iYXNlbGluZScsZW5hYmxlQmFja2dyb3VuZDonZW5hYmxlLWJhY2tncm91bmQnLGZpbGxPcGFjaXR5OidmaWxsLW9wYWNpdHknLGZpbGxSdWxlOidmaWxsLXJ1bGUnLGZsb29kQ29sb3I6J2Zsb29kLWNvbG9yJyxmbG9vZE9wYWNpdHk6J2Zsb29kLW9wYWNpdHknLGZvbnRGYW1pbHk6J2ZvbnQtZmFtaWx5Jyxmb250U2l6ZTonZm9udC1zaXplJyxmb250U2l6ZUFkanVzdDonZm9udC1zaXplLWFkanVzdCcsZm9udFN0cmV0Y2g6J2ZvbnQtc3RyZXRjaCcsZm9udFN0eWxlOidmb250LXN0eWxlJyxmb250VmFyaWFudDonZm9udC12YXJpYW50Jyxmb250V2VpZ2h0Oidmb250LXdlaWdodCcsZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWw6J2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnLGdseXBoT3JpZW50YXRpb25WZXJ0aWNhbDonZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnLGhvcml6QWR2WDonaG9yaXotYWR2LXgnLGhvcml6T3JpZ2luWDonaG9yaXotb3JpZ2luLXgnLGltYWdlUmVuZGVyaW5nOidpbWFnZS1yZW5kZXJpbmcnLGxldHRlclNwYWNpbmc6J2xldHRlci1zcGFjaW5nJyxsaWdodGluZ0NvbG9yOidsaWdodGluZy1jb2xvcicsbWFya2VyRW5kOidtYXJrZXItZW5kJyxtYXJrZXJNaWQ6J21hcmtlci1taWQnLG1hcmtlclN0YXJ0OidtYXJrZXItc3RhcnQnLHN0b3BDb2xvcjonc3RvcC1jb2xvcicsc3RvcE9wYWNpdHk6J3N0b3Atb3BhY2l0eScsc3RyaWtldGhyb3VnaFBvc2l0aW9uOidzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJyxzdHJpa2V0aHJvdWdoVGhpY2tuZXNzOidzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcycsc3Ryb2tlRGFzaEFycmF5OidzdHJva2UtZGFzaGFycmF5JyxzdHJva2VEYXNoT2Zmc2V0OidzdHJva2UtZGFzaG9mZnNldCcsc3Ryb2tlTGluZUNhcDonc3Ryb2tlLWxpbmVjYXAnLHN0cm9rZUxpbmVKb2luOidzdHJva2UtbGluZWpvaW4nLHN0cm9rZU1pdGVyTGltaXQ6J3N0cm9rZS1taXRlcmxpbWl0JyxzdHJva2VPcGFjaXR5OidzdHJva2Utb3BhY2l0eScsc3Ryb2tlV2lkdGg6J3N0cm9rZS13aWR0aCcsdGV4dEFuY2hvcjondGV4dC1hbmNob3InLHRleHREZWNvcmF0aW9uOid0ZXh0LWRlY29yYXRpb24nLHRleHRSZW5kZXJpbmc6J3RleHQtcmVuZGVyaW5nJyx1bmRlcmxpbmVQb3NpdGlvbjondW5kZXJsaW5lLXBvc2l0aW9uJyx1bmRlcmxpbmVUaGlja25lc3M6J3VuZGVybGluZS10aGlja25lc3MnLHZlcnRBZHZZOid2ZXJ0LWFkdi15Jyx2ZXJ0T3JpZ2luWTondmVydC1vcmlnaW4teScsd29yZFNwYWNpbmc6J3dvcmQtc3BhY2luZycsd3JpdGluZ01vZGU6J3dyaXRpbmctbW9kZSd9LF9hdHRhY2hTVkc6ZnVuY3Rpb24oYSxiKXt2YXIgYz0oYS5uYW1lc3BhY2VVUkk9PXRoaXMuc3ZnTlM/YTpudWxsKTt2YXIgYT0oYz9udWxsOmEpO2lmKCQoYXx8YykuaGFzQ2xhc3ModGhpcy5tYXJrZXJDbGFzc05hbWUpKXtyZXR1cm59aWYodHlwZW9mIGI9PSdzdHJpbmcnKXtiPXtsb2FkVVJMOmJ9fWVsc2UgaWYodHlwZW9mIGI9PSdmdW5jdGlvbicpe2I9e29uTG9hZDpifX0kKGF8fGMpLmFkZENsYXNzKHRoaXMubWFya2VyQ2xhc3NOYW1lKTt0cnl7aWYoIWMpe2M9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHRoaXMuc3ZnTlMsJ3N2ZycpO2Muc2V0QXR0cmlidXRlKCd2ZXJzaW9uJywnMS4xJyk7Yy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJyxhLmNsaWVudFdpZHRoKTtjLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JyxhLmNsaWVudEhlaWdodCk7YS5hcHBlbmRDaGlsZChjKX10aGlzLl9hZnRlckxvYWQoYSxjLGJ8fHt9KX1jYXRjaChlKXtpZigkLmJyb3dzZXIubXNpZSl7aWYoIWEuaWQpe2EuaWQ9J3N2ZycrKHRoaXMuX3V1aWQrKyl9dGhpcy5fc2V0dGluZ3NbYS5pZF09YjthLmlubmVySFRNTD0nPGVtYmVkIHR5cGU9XCJpbWFnZS9zdmcreG1sXCIgd2lkdGg9XCIxMDAlXCIgJysnaGVpZ2h0PVwiMTAwJVwiIHNyYz1cIicrKGIuaW5pdFBhdGh8fCcnKSsnYmxhbmsuc3ZnXCIvPid9ZWxzZXthLmlubmVySFRNTD0nPHAgY2xhc3M9XCJzdmdfZXJyb3JcIj4nK3RoaXMubG9jYWwubm90U3VwcG9ydGVkVGV4dCsnPC9wPid9fX0sX3JlZ2lzdGVyU1ZHOmZ1bmN0aW9uKCl7Zm9yKHZhciBpPTA7aTxkb2N1bWVudC5lbWJlZHMubGVuZ3RoO2krKyl7dmFyIGE9ZG9jdW1lbnQuZW1iZWRzW2ldLnBhcmVudE5vZGU7aWYoISQoYSkuaGFzQ2xhc3MoJC5zdmcubWFya2VyQ2xhc3NOYW1lKXx8JC5kYXRhKGEscCkpe2NvbnRpbnVlfXZhciBiPW51bGw7dHJ5e2I9ZG9jdW1lbnQuZW1iZWRzW2ldLmdldFNWR0RvY3VtZW50KCl9Y2F0Y2goZSl7c2V0VGltZW91dCgkLnN2Zy5fcmVnaXN0ZXJTVkcsMjUwKTtyZXR1cm59Yj0oYj9iLmRvY3VtZW50RWxlbWVudDpudWxsKTtpZihiKXskLnN2Zy5fYWZ0ZXJMb2FkKGEsYil9fX0sX2FmdGVyTG9hZDpmdW5jdGlvbihhLGIsYyl7dmFyIGM9Y3x8dGhpcy5fc2V0dGluZ3NbYS5pZF07dGhpcy5fc2V0dGluZ3NbYT9hLmlkOicnXT1udWxsO3ZhciBkPW5ldyB0aGlzLl93cmFwcGVyQ2xhc3MoYixhKTskLmRhdGEoYXx8YixwLGQpO3RyeXtpZihjLmxvYWRVUkwpe2QubG9hZChjLmxvYWRVUkwsYyl9aWYoYy5zZXR0aW5ncyl7ZC5jb25maWd1cmUoYy5zZXR0aW5ncyl9aWYoYy5vbkxvYWQmJiFjLmxvYWRVUkwpe2Mub25Mb2FkLmFwcGx5KGF8fGIsW2RdKX19Y2F0Y2goZSl7YWxlcnQoZSl9fSxfZ2V0U1ZHOmZ1bmN0aW9uKGEpe2E9KHR5cGVvZiBhPT0nc3RyaW5nJz8kKGEpWzBdOihhLmpxdWVyeT9hWzBdOmEpKTtyZXR1cm4gJC5kYXRhKGEscCl9LF9kZXN0cm95U1ZHOmZ1bmN0aW9uKGEpe3ZhciBiPSQoYSk7aWYoIWIuaGFzQ2xhc3ModGhpcy5tYXJrZXJDbGFzc05hbWUpKXtyZXR1cm59Yi5yZW1vdmVDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSk7aWYoYS5uYW1lc3BhY2VVUkkhPXRoaXMuc3ZnTlMpe2IuZW1wdHkoKX0kLnJlbW92ZURhdGEoYSxwKX0sYWRkRXh0ZW5zaW9uOmZ1bmN0aW9uKGEsYil7dGhpcy5fZXh0ZW5zaW9ucy5wdXNoKFthLGJdKX19KTtmdW5jdGlvbiBTVkdXcmFwcGVyKGEsYil7dGhpcy5fc3ZnPWE7dGhpcy5fY29udGFpbmVyPWI7Zm9yKHZhciBpPTA7aTwkLnN2Zy5fZXh0ZW5zaW9ucy5sZW5ndGg7aSsrKXt2YXIgYz0kLnN2Zy5fZXh0ZW5zaW9uc1tpXTt0aGlzW2NbMF1dPW5ldyBjWzFdKHRoaXMpfX0kLmV4dGVuZChTVkdXcmFwcGVyLnByb3RvdHlwZSx7X3dpZHRoOmZ1bmN0aW9uKCl7cmV0dXJuKHRoaXMuX2NvbnRhaW5lcj90aGlzLl9jb250YWluZXIuY2xpZW50V2lkdGg6dGhpcy5fc3ZnLndpZHRoKX0sX2hlaWdodDpmdW5jdGlvbigpe3JldHVybih0aGlzLl9jb250YWluZXI/dGhpcy5fY29udGFpbmVyLmNsaWVudEhlaWdodDp0aGlzLl9zdmcuaGVpZ2h0KX0scm9vdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zdmd9LGNvbmZpZ3VyZTpmdW5jdGlvbihhLGIpe2lmKGIpe2Zvcih2YXIgaT10aGlzLl9zdmcuYXR0cmlidXRlcy5sZW5ndGgtMTtpPj0wO2ktLSl7dmFyIGM9dGhpcy5fc3ZnLmF0dHJpYnV0ZXMuaXRlbShpKTtpZighKGMubm9kZU5hbWU9PSdvbmxvYWQnfHxjLm5vZGVOYW1lPT0ndmVyc2lvbid8fGMubm9kZU5hbWUuc3Vic3RyaW5nKDAsNSk9PSd4bWxucycpKXt0aGlzLl9zdmcuYXR0cmlidXRlcy5yZW1vdmVOYW1lZEl0ZW0oYy5ub2RlTmFtZSl9fX1mb3IodmFyIGQgaW4gYSl7dGhpcy5fc3ZnLnNldEF0dHJpYnV0ZShkLGFbZF0pfXJldHVybiB0aGlzfSxnZXRFbGVtZW50QnlJZDpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5fc3ZnLm93bmVyRG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYSl9LGNoYW5nZTpmdW5jdGlvbihhLGIpe2lmKGEpe2Zvcih2YXIgYyBpbiBiKXtpZihiW2NdPT1udWxsKXthLnJlbW92ZUF0dHJpYnV0ZShjKX1lbHNle2Euc2V0QXR0cmlidXRlKGMsYltjXSl9fX1yZXR1cm4gdGhpc30sX2FyZ3M6ZnVuY3Rpb24oYixjLGQpe2Muc3BsaWNlKDAsMCwncGFyZW50Jyk7Yy5zcGxpY2UoYy5sZW5ndGgsMCwnc2V0dGluZ3MnKTt2YXIgZT17fTt2YXIgZj0wO2lmKGJbMF0hPW51bGwmJmJbMF0uanF1ZXJ5KXtiWzBdPWJbMF1bMF19aWYoYlswXSE9bnVsbCYmISh0eXBlb2YgYlswXT09J29iamVjdCcmJmJbMF0ubm9kZU5hbWUpKXtlWydwYXJlbnQnXT1udWxsO2Y9MX1mb3IodmFyIGk9MDtpPGIubGVuZ3RoO2krKyl7ZVtjW2krZl1dPWJbaV19aWYoZCl7JC5lYWNoKGQsZnVuY3Rpb24oaSxhKXtpZih0eXBlb2YgZVthXT09J29iamVjdCcpe2Uuc2V0dGluZ3M9ZVthXTtlW2FdPW51bGx9fSl9cmV0dXJuIGV9LHRpdGxlOmZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzLl9hcmdzKGFyZ3VtZW50cyxbJ3RleHQnXSk7dmFyIGU9dGhpcy5fbWFrZU5vZGUoZC5wYXJlbnQsJ3RpdGxlJyxkLnNldHRpbmdzfHx7fSk7ZS5hcHBlbmRDaGlsZCh0aGlzLl9zdmcub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShkLnRleHQpKTtyZXR1cm4gZX0sZGVzY3JpYmU6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMuX2FyZ3MoYXJndW1lbnRzLFsndGV4dCddKTt2YXIgZT10aGlzLl9tYWtlTm9kZShkLnBhcmVudCwnZGVzYycsZC5zZXR0aW5nc3x8e30pO2UuYXBwZW5kQ2hpbGQodGhpcy5fc3ZnLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZC50ZXh0KSk7cmV0dXJuIGV9LGRlZnM6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMuX2FyZ3MoYXJndW1lbnRzLFsnaWQnXSxbJ2lkJ10pO3JldHVybiB0aGlzLl9tYWtlTm9kZShkLnBhcmVudCwnZGVmcycsJC5leHRlbmQoKGQuaWQ/e2lkOmQuaWR9Ont9KSxkLnNldHRpbmdzfHx7fSkpfSxzeW1ib2w6ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyl7dmFyIGg9dGhpcy5fYXJncyhhcmd1bWVudHMsWydpZCcsJ3gxJywneTEnLCd3aWR0aCcsJ2hlaWdodCddKTtyZXR1cm4gdGhpcy5fbWFrZU5vZGUoaC5wYXJlbnQsJ3N5bWJvbCcsJC5leHRlbmQoe2lkOmguaWQsdmlld0JveDpoLngxKycgJytoLnkxKycgJytoLndpZHRoKycgJytoLmhlaWdodH0saC5zZXR0aW5nc3x8e30pKX0sbWFya2VyOmZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsaCl7dmFyIGk9dGhpcy5fYXJncyhhcmd1bWVudHMsWydpZCcsJ3JlZlgnLCdyZWZZJywnbVdpZHRoJywnbUhlaWdodCcsJ29yaWVudCddLFsnb3JpZW50J10pO3JldHVybiB0aGlzLl9tYWtlTm9kZShpLnBhcmVudCwnbWFya2VyJywkLmV4dGVuZCh7aWQ6aS5pZCxyZWZYOmkucmVmWCxyZWZZOmkucmVmWSxtYXJrZXJXaWR0aDppLm1XaWR0aCxtYXJrZXJIZWlnaHQ6aS5tSGVpZ2h0LG9yaWVudDppLm9yaWVudHx8J2F1dG8nfSxpLnNldHRpbmdzfHx7fSkpfSxzdHlsZTpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcy5fYXJncyhhcmd1bWVudHMsWydzdHlsZXMnXSk7dmFyIGU9dGhpcy5fbWFrZU5vZGUoZC5wYXJlbnQsJ3N0eWxlJywkLmV4dGVuZCh7dHlwZTondGV4dC9jc3MnfSxkLnNldHRpbmdzfHx7fSkpO2UuYXBwZW5kQ2hpbGQodGhpcy5fc3ZnLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZC5zdHlsZXMpKTtpZigkLmJyb3dzZXIub3BlcmEpeyQoJ2hlYWQnKS5hcHBlbmQoJzxzdHlsZSB0eXBlPVwidGV4dC9jc3NcIj4nK2Quc3R5bGVzKyc8L3N0eWxlPicpfXJldHVybiBlfSxzY3JpcHQ6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9dGhpcy5fYXJncyhhcmd1bWVudHMsWydzY3JpcHQnLCd0eXBlJ10sWyd0eXBlJ10pO3ZhciBmPXRoaXMuX21ha2VOb2RlKGUucGFyZW50LCdzY3JpcHQnLCQuZXh0ZW5kKHt0eXBlOmUudHlwZXx8J3RleHQvamF2YXNjcmlwdCd9LGUuc2V0dGluZ3N8fHt9KSk7Zi5hcHBlbmRDaGlsZCh0aGlzLl9zdmcub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLl9lc2NhcGVYTUwoZS5zY3JpcHQpKSk7aWYoISQuYnJvd3Nlci5tb3ppbGxhKXskLmdsb2JhbEV2YWwoZS5zY3JpcHQpfXJldHVybiBmfSxsaW5lYXJHcmFkaWVudDpmdW5jdGlvbihhLGIsYyxkLGUsZixnLGgpe3ZhciBpPXRoaXMuX2FyZ3MoYXJndW1lbnRzLFsnaWQnLCdzdG9wcycsJ3gxJywneTEnLCd4MicsJ3kyJ10sWyd4MSddKTt2YXIgaj0kLmV4dGVuZCh7aWQ6aS5pZH0sKGkueDEhPW51bGw/e3gxOmkueDEseTE6aS55MSx4MjppLngyLHkyOmkueTJ9Ont9KSk7cmV0dXJuIHRoaXMuX2dyYWRpZW50KGkucGFyZW50LCdsaW5lYXJHcmFkaWVudCcsJC5leHRlbmQoaixpLnNldHRpbmdzfHx7fSksaS5zdG9wcyl9LHJhZGlhbEdyYWRpZW50OmZ1bmN0aW9uKGEsYixjLGQsZSxyLGYsZyxoKXt2YXIgaT10aGlzLl9hcmdzKGFyZ3VtZW50cyxbJ2lkJywnc3RvcHMnLCdjeCcsJ2N5JywncicsJ2Z4JywnZnknXSxbJ2N4J10pO3ZhciBqPSQuZXh0ZW5kKHtpZDppLmlkfSwoaS5jeCE9bnVsbD97Y3g6aS5jeCxjeTppLmN5LHI6aS5yLGZ4OmkuZngsZnk6aS5meX06e30pKTtyZXR1cm4gdGhpcy5fZ3JhZGllbnQoaS5wYXJlbnQsJ3JhZGlhbEdyYWRpZW50JywkLmV4dGVuZChqLGkuc2V0dGluZ3N8fHt9KSxpLnN0b3BzKX0sX2dyYWRpZW50OmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPXRoaXMuX21ha2VOb2RlKGEsYixjKTtmb3IodmFyIGk9MDtpPGQubGVuZ3RoO2krKyl7dmFyIGY9ZFtpXTt0aGlzLl9tYWtlTm9kZShlLCdzdG9wJywkLmV4dGVuZCh7b2Zmc2V0OmZbMF0sc3RvcENvbG9yOmZbMV19LChmWzJdIT1udWxsP3tzdG9wT3BhY2l0eTpmWzJdfTp7fSkpKX1yZXR1cm4gZX0scGF0dGVybjpmdW5jdGlvbihhLGIseCx5LGMsZCxlLGYsZyxoLGkpe3ZhciBqPXRoaXMuX2FyZ3MoYXJndW1lbnRzLFsnaWQnLCd4JywneScsJ3dpZHRoJywnaGVpZ2h0JywndngnLCd2eScsJ3Z3aWR0aCcsJ3ZoZWlnaHQnXSxbJ3Z4J10pO3ZhciBrPSQuZXh0ZW5kKHtpZDpqLmlkLHg6ai54LHk6ai55LHdpZHRoOmoud2lkdGgsaGVpZ2h0OmouaGVpZ2h0fSwoai52eCE9bnVsbD97dmlld0JveDpqLnZ4KycgJytqLnZ5KycgJytqLnZ3aWR0aCsnICcrai52aGVpZ2h0fTp7fSkpO3JldHVybiB0aGlzLl9tYWtlTm9kZShqLnBhcmVudCwncGF0dGVybicsJC5leHRlbmQoayxqLnNldHRpbmdzfHx7fSkpfSxtYXNrOmZ1bmN0aW9uKGEsYix4LHksYyxkLGUpe3ZhciBmPXRoaXMuX2FyZ3MoYXJndW1lbnRzLFsnaWQnLCd4JywneScsJ3dpZHRoJywnaGVpZ2h0J10pO3JldHVybiB0aGlzLl9tYWtlTm9kZShmLnBhcmVudCwnbWFzaycsJC5leHRlbmQoe2lkOmYuaWQseDpmLngseTpmLnksd2lkdGg6Zi53aWR0aCxoZWlnaHQ6Zi5oZWlnaHR9LGYuc2V0dGluZ3N8fHt9KSl9LGNyZWF0ZVBhdGg6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFNWR1BhdGgoKX0sY3JlYXRlVGV4dDpmdW5jdGlvbigpe3JldHVybiBuZXcgU1ZHVGV4dCgpfSxzdmc6ZnVuY3Rpb24oYSx4LHksYixjLGQsZSxmLGcsaCl7dmFyIGk9dGhpcy5fYXJncyhhcmd1bWVudHMsWyd4JywneScsJ3dpZHRoJywnaGVpZ2h0JywndngnLCd2eScsJ3Z3aWR0aCcsJ3ZoZWlnaHQnXSxbJ3Z4J10pO3ZhciBqPSQuZXh0ZW5kKHt4OmkueCx5OmkueSx3aWR0aDppLndpZHRoLGhlaWdodDppLmhlaWdodH0sKGkudnghPW51bGw/e3ZpZXdCb3g6aS52eCsnICcraS52eSsnICcraS52d2lkdGgrJyAnK2kudmhlaWdodH06e30pKTtyZXR1cm4gdGhpcy5fbWFrZU5vZGUoaS5wYXJlbnQsJ3N2ZycsJC5leHRlbmQoaixpLnNldHRpbmdzfHx7fSkpfSxncm91cDpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcy5fYXJncyhhcmd1bWVudHMsWydpZCddLFsnaWQnXSk7cmV0dXJuIHRoaXMuX21ha2VOb2RlKGQucGFyZW50LCdnJywkLmV4dGVuZCh7aWQ6ZC5pZH0sZC5zZXR0aW5nc3x8e30pKX0sdXNlOmZ1bmN0aW9uKGEseCx5LGIsYyxkLGUpe3ZhciBmPXRoaXMuX2FyZ3MoYXJndW1lbnRzLFsneCcsJ3knLCd3aWR0aCcsJ2hlaWdodCcsJ3JlZiddKTtpZih0eXBlb2YgZi54PT0nc3RyaW5nJyl7Zi5yZWY9Zi54O2Yuc2V0dGluZ3M9Zi55O2YueD1mLnk9Zi53aWR0aD1mLmhlaWdodD1udWxsfXZhciBnPXRoaXMuX21ha2VOb2RlKGYucGFyZW50LCd1c2UnLCQuZXh0ZW5kKHt4OmYueCx5OmYueSx3aWR0aDpmLndpZHRoLGhlaWdodDpmLmhlaWdodH0sZi5zZXR0aW5nc3x8e30pKTtnLnNldEF0dHJpYnV0ZU5TKCQuc3ZnLnhsaW5rTlMsJ2hyZWYnLGYucmVmKTtyZXR1cm4gZ30sbGluazpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcy5fYXJncyhhcmd1bWVudHMsWydyZWYnXSk7dmFyIGU9dGhpcy5fbWFrZU5vZGUoZC5wYXJlbnQsJ2EnLGQuc2V0dGluZ3MpO2Uuc2V0QXR0cmlidXRlTlMoJC5zdmcueGxpbmtOUywnaHJlZicsZC5yZWYpO3JldHVybiBlfSxpbWFnZTpmdW5jdGlvbihhLHgseSxiLGMsZCxlKXt2YXIgZj10aGlzLl9hcmdzKGFyZ3VtZW50cyxbJ3gnLCd5Jywnd2lkdGgnLCdoZWlnaHQnLCdyZWYnXSk7dmFyIGc9dGhpcy5fbWFrZU5vZGUoZi5wYXJlbnQsJ2ltYWdlJywkLmV4dGVuZCh7eDpmLngseTpmLnksd2lkdGg6Zi53aWR0aCxoZWlnaHQ6Zi5oZWlnaHR9LGYuc2V0dGluZ3N8fHt9KSk7Zy5zZXRBdHRyaWJ1dGVOUygkLnN2Zy54bGlua05TLCdocmVmJyxmLnJlZik7cmV0dXJuIGd9LHBhdGg6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMuX2FyZ3MoYXJndW1lbnRzLFsncGF0aCddKTtyZXR1cm4gdGhpcy5fbWFrZU5vZGUoZC5wYXJlbnQsJ3BhdGgnLCQuZXh0ZW5kKHtkOihkLnBhdGgucGF0aD9kLnBhdGgucGF0aCgpOmQucGF0aCl9LGQuc2V0dGluZ3N8fHt9KSl9LHJlY3Q6ZnVuY3Rpb24oYSx4LHksYixjLGQsZSxmKXt2YXIgZz10aGlzLl9hcmdzKGFyZ3VtZW50cyxbJ3gnLCd5Jywnd2lkdGgnLCdoZWlnaHQnLCdyeCcsJ3J5J10sWydyeCddKTtyZXR1cm4gdGhpcy5fbWFrZU5vZGUoZy5wYXJlbnQsJ3JlY3QnLCQuZXh0ZW5kKHt4OmcueCx5OmcueSx3aWR0aDpnLndpZHRoLGhlaWdodDpnLmhlaWdodH0sKGcucng/e3J4Omcucngscnk6Zy5yeX06e30pLGcuc2V0dGluZ3N8fHt9KSl9LGNpcmNsZTpmdW5jdGlvbihhLGIsYyxyLGQpe3ZhciBlPXRoaXMuX2FyZ3MoYXJndW1lbnRzLFsnY3gnLCdjeScsJ3InXSk7cmV0dXJuIHRoaXMuX21ha2VOb2RlKGUucGFyZW50LCdjaXJjbGUnLCQuZXh0ZW5kKHtjeDplLmN4LGN5OmUuY3kscjplLnJ9LGUuc2V0dGluZ3N8fHt9KSl9LGVsbGlwc2U6ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3ZhciBnPXRoaXMuX2FyZ3MoYXJndW1lbnRzLFsnY3gnLCdjeScsJ3J4JywncnknXSk7cmV0dXJuIHRoaXMuX21ha2VOb2RlKGcucGFyZW50LCdlbGxpcHNlJywkLmV4dGVuZCh7Y3g6Zy5jeCxjeTpnLmN5LHJ4Omcucngscnk6Zy5yeX0sZy5zZXR0aW5nc3x8e30pKX0sbGluZTpmdW5jdGlvbihhLGIsYyxkLGUsZil7dmFyIGc9dGhpcy5fYXJncyhhcmd1bWVudHMsWyd4MScsJ3kxJywneDInLCd5MiddKTtyZXR1cm4gdGhpcy5fbWFrZU5vZGUoZy5wYXJlbnQsJ2xpbmUnLCQuZXh0ZW5kKHt4MTpnLngxLHkxOmcueTEseDI6Zy54Mix5MjpnLnkyfSxnLnNldHRpbmdzfHx7fSkpfSxwb2x5bGluZTpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcy5fYXJncyhhcmd1bWVudHMsWydwb2ludHMnXSk7cmV0dXJuIHRoaXMuX3BvbHkoZC5wYXJlbnQsJ3BvbHlsaW5lJyxkLnBvaW50cyxkLnNldHRpbmdzKX0scG9seWdvbjpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcy5fYXJncyhhcmd1bWVudHMsWydwb2ludHMnXSk7cmV0dXJuIHRoaXMuX3BvbHkoZC5wYXJlbnQsJ3BvbHlnb24nLGQucG9pbnRzLGQuc2V0dGluZ3MpfSxfcG9seTpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT0nJztmb3IodmFyIGk9MDtpPGMubGVuZ3RoO2krKyl7ZSs9Y1tpXS5qb2luKCkrJyAnfXJldHVybiB0aGlzLl9tYWtlTm9kZShhLGIsJC5leHRlbmQoe3BvaW50czokLnRyaW0oZSl9LGR8fHt9KSl9LHRleHQ6ZnVuY3Rpb24oYSx4LHksYixjKXt2YXIgZD10aGlzLl9hcmdzKGFyZ3VtZW50cyxbJ3gnLCd5JywndmFsdWUnXSk7aWYodHlwZW9mIGQueD09J3N0cmluZycmJmFyZ3VtZW50cy5sZW5ndGg8NCl7ZC52YWx1ZT1kLng7ZC5zZXR0aW5ncz1kLnk7ZC54PWQueT1udWxsfXJldHVybiB0aGlzLl90ZXh0KGQucGFyZW50LCd0ZXh0JyxkLnZhbHVlLCQuZXh0ZW5kKHt4OihkLngmJmlzQXJyYXkoZC54KT9kLnguam9pbignICcpOmQueCkseTooZC55JiZpc0FycmF5KGQueSk/ZC55LmpvaW4oJyAnKTpkLnkpfSxkLnNldHRpbmdzfHx7fSkpfSx0ZXh0cGF0aDpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT10aGlzLl9hcmdzKGFyZ3VtZW50cyxbJ3BhdGgnLCd2YWx1ZSddKTt2YXIgZj10aGlzLl90ZXh0KGUucGFyZW50LCd0ZXh0UGF0aCcsZS52YWx1ZSxlLnNldHRpbmdzfHx7fSk7Zi5zZXRBdHRyaWJ1dGVOUygkLnN2Zy54bGlua05TLCdocmVmJyxlLnBhdGgpO3JldHVybiBmfSxfdGV4dDpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT10aGlzLl9tYWtlTm9kZShhLGIsZCk7aWYodHlwZW9mIGM9PSdzdHJpbmcnKXtlLmFwcGVuZENoaWxkKGUub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjKSl9ZWxzZXtmb3IodmFyIGk9MDtpPGMuX3BhcnRzLmxlbmd0aDtpKyspe3ZhciBmPWMuX3BhcnRzW2ldO2lmKGZbMF09PSd0c3Bhbicpe3ZhciBnPXRoaXMuX21ha2VOb2RlKGUsZlswXSxmWzJdKTtnLmFwcGVuZENoaWxkKGUub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShmWzFdKSk7ZS5hcHBlbmRDaGlsZChnKX1lbHNlIGlmKGZbMF09PSd0cmVmJyl7dmFyIGc9dGhpcy5fbWFrZU5vZGUoZSxmWzBdLGZbMl0pO2cuc2V0QXR0cmlidXRlTlMoJC5zdmcueGxpbmtOUywnaHJlZicsZlsxXSk7ZS5hcHBlbmRDaGlsZChnKX1lbHNlIGlmKGZbMF09PSd0ZXh0cGF0aCcpe3ZhciBoPSQuZXh0ZW5kKHt9LGZbMl0pO2guaHJlZj1udWxsO3ZhciBnPXRoaXMuX21ha2VOb2RlKGUsZlswXSxoKTtnLnNldEF0dHJpYnV0ZU5TKCQuc3ZnLnhsaW5rTlMsJ2hyZWYnLGZbMl0uaHJlZik7Zy5hcHBlbmRDaGlsZChlLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZlsxXSkpO2UuYXBwZW5kQ2hpbGQoZyl9ZWxzZXtlLmFwcGVuZENoaWxkKGUub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShmWzFdKSl9fX1yZXR1cm4gZX0sb3RoZXI6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMuX2FyZ3MoYXJndW1lbnRzLFsnbmFtZSddKTtyZXR1cm4gdGhpcy5fbWFrZU5vZGUoZC5wYXJlbnQsZC5uYW1lLGQuc2V0dGluZ3N8fHt9KX0sX21ha2VOb2RlOmZ1bmN0aW9uKGEsYixjKXthPWF8fHRoaXMuX3N2Zzt2YXIgZD10aGlzLl9zdmcub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJC5zdmcuc3ZnTlMsYik7Zm9yKHZhciBiIGluIGMpe3ZhciBlPWNbYl07aWYoZSE9bnVsbCYmZSE9bnVsbCYmKHR5cGVvZiBlIT0nc3RyaW5nJ3x8ZSE9JycpKXtkLnNldEF0dHJpYnV0ZSgkLnN2Zy5fYXR0ck5hbWVzW2JdfHxiLGUpfX1hLmFwcGVuZENoaWxkKGQpO3JldHVybiBkfSxhZGQ6ZnVuY3Rpb24oYixjKXt2YXIgZD10aGlzLl9hcmdzKChhcmd1bWVudHMubGVuZ3RoPT0xP1tudWxsLGJdOmFyZ3VtZW50cyksWydub2RlJ10pO3ZhciBmPXRoaXM7ZC5wYXJlbnQ9ZC5wYXJlbnR8fHRoaXMuX3N2Zzt0cnl7aWYoJC5zdmcuX3JlbmVzaXMpe3Rocm93J0ZvcmNlIHRyYXZlcnNhbCc7fWQucGFyZW50LmFwcGVuZENoaWxkKGQubm9kZS5jbG9uZU5vZGUodHJ1ZSkpfWNhdGNoKGUpe2Qubm9kZT0oZC5ub2RlLmpxdWVyeT9kLm5vZGU6JChkLm5vZGUpKTtkLm5vZGUuZWFjaChmdW5jdGlvbigpe3ZhciBhPWYuX2Nsb25lQXNTVkcodGhpcyk7aWYoYSl7ZC5wYXJlbnQuYXBwZW5kQ2hpbGQoYSl9fSl9cmV0dXJuIHRoaXN9LF9jbG9uZUFzU1ZHOmZ1bmN0aW9uKGEpe3ZhciBiPW51bGw7aWYoYS5ub2RlVHlwZT09MSl7Yj10aGlzLl9zdmcub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJC5zdmcuc3ZnTlMsdGhpcy5fY2hlY2tOYW1lKGEubm9kZU5hbWUpKTtmb3IodmFyIGk9MDtpPGEuYXR0cmlidXRlcy5sZW5ndGg7aSsrKXt2YXIgYz1hLmF0dHJpYnV0ZXMuaXRlbShpKTtpZihjLm5vZGVOYW1lIT0neG1sbnMnJiZjLm5vZGVWYWx1ZSl7aWYoYy5wcmVmaXg9PSd4bGluaycpe2Iuc2V0QXR0cmlidXRlTlMoJC5zdmcueGxpbmtOUyxjLmxvY2FsTmFtZSxjLm5vZGVWYWx1ZSl9ZWxzZXtiLnNldEF0dHJpYnV0ZSh0aGlzLl9jaGVja05hbWUoYy5ub2RlTmFtZSksYy5ub2RlVmFsdWUpfX19Zm9yKHZhciBpPTA7aTxhLmNoaWxkTm9kZXMubGVuZ3RoO2krKyl7dmFyIGQ9dGhpcy5fY2xvbmVBc1NWRyhhLmNoaWxkTm9kZXNbaV0pO2lmKGQpe2IuYXBwZW5kQ2hpbGQoZCl9fX1lbHNlIGlmKGEubm9kZVR5cGU9PTMpe2lmKCQudHJpbShhLm5vZGVWYWx1ZSkpe2I9dGhpcy5fc3ZnLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYS5ub2RlVmFsdWUpfX1lbHNlIGlmKGEubm9kZVR5cGU9PTQpe2lmKCQudHJpbShhLm5vZGVWYWx1ZSkpe3RyeXtiPXRoaXMuX3N2Zy5vd25lckRvY3VtZW50LmNyZWF0ZUNEQVRBU2VjdGlvbihhLm5vZGVWYWx1ZSl9Y2F0Y2goZSl7Yj10aGlzLl9zdmcub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShhLm5vZGVWYWx1ZS5yZXBsYWNlKC8mL2csJyZhbXA7JykucmVwbGFjZSgvPC9nLCcmbHQ7JykucmVwbGFjZSgvPi9nLCcmZ3Q7JykpfX19cmV0dXJuIGJ9LF9jaGVja05hbWU6ZnVuY3Rpb24oYSl7YT0oYS5zdWJzdHJpbmcoMCwxKT49J0EnJiZhLnN1YnN0cmluZygwLDEpPD0nWic/YS50b0xvd2VyQ2FzZSgpOmEpO3JldHVybihhLnN1YnN0cmluZygwLDQpPT0nc3ZnOic/YS5zdWJzdHJpbmcoNCk6YSl9LGxvYWQ6ZnVuY3Rpb24oaCxqKXtqPSh0eXBlb2Ygaj09J2Jvb2xlYW4nP3thZGRUbzpqfToodHlwZW9mIGo9PSdmdW5jdGlvbic/e29uTG9hZDpqfTpqfHx7fSkpO2lmKCFqLmFkZFRvKXt0aGlzLmNsZWFyKGZhbHNlKX12YXIgaz1bdGhpcy5fc3ZnLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSx0aGlzLl9zdmcuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKV07dmFyIGw9dGhpczt2YXIgbT1mdW5jdGlvbihhKXthPSQuc3ZnLmxvY2FsLmVycm9yTG9hZGluZ1RleHQrJzogJythO2lmKGoub25Mb2FkKXtqLm9uTG9hZC5hcHBseShsLl9jb250YWluZXJ8fGwuX3N2ZyxbbCxhXSl9ZWxzZXtsLnRleHQobnVsbCwxMCwyMCxhKX19O3ZhciBuPWZ1bmN0aW9uKGEpe3ZhciBiPW5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MRE9NJyk7Yi52YWxpZGF0ZU9uUGFyc2U9ZmFsc2U7Yi5yZXNvbHZlRXh0ZXJuYWxzPWZhbHNlO2IuYXN5bmM9ZmFsc2U7Yi5sb2FkWE1MKGEpO2lmKGIucGFyc2VFcnJvci5lcnJvckNvZGUhPTApe20oYi5wYXJzZUVycm9yLnJlYXNvbik7cmV0dXJuIG51bGx9cmV0dXJuIGJ9O3ZhciBvPWZ1bmN0aW9uKGEpe2lmKCFhKXtyZXR1cm59aWYoYS5kb2N1bWVudEVsZW1lbnQubm9kZU5hbWUhPSdzdmcnKXt2YXIgYj1hLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdwYXJzZXJlcnJvcicpO3ZhciBjPShiLmxlbmd0aD9iWzBdLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdkaXYnKTpbXSk7bSghYi5sZW5ndGg/Jz8/Pyc6KGMubGVuZ3RoP2NbMF06YlswXSkuZmlyc3RDaGlsZC5ub2RlVmFsdWUpO3JldHVybn12YXIgZD17fTtmb3IodmFyIGk9MDtpPGEuZG9jdW1lbnRFbGVtZW50LmF0dHJpYnV0ZXMubGVuZ3RoO2krKyl7dmFyIGY9YS5kb2N1bWVudEVsZW1lbnQuYXR0cmlidXRlcy5pdGVtKGkpO2lmKCEoZi5ub2RlTmFtZT09J3ZlcnNpb24nfHxmLm5vZGVOYW1lLnN1YnN0cmluZygwLDUpPT0neG1sbnMnKSl7ZFtmLm5vZGVOYW1lXT1mLm5vZGVWYWx1ZX19bC5jb25maWd1cmUoZCx0cnVlKTt2YXIgZz1hLmRvY3VtZW50RWxlbWVudC5jaGlsZE5vZGVzO2Zvcih2YXIgaT0wO2k8Zy5sZW5ndGg7aSsrKXt0cnl7aWYoJC5zdmcuX3JlbmVzaXMpe3Rocm93J0ZvcmNlIHRyYXZlcnNhbCc7fWwuX3N2Zy5hcHBlbmRDaGlsZChnW2ldLmNsb25lTm9kZSh0cnVlKSk7aWYoZ1tpXS5ub2RlTmFtZT09J3NjcmlwdCcpeyQuZ2xvYmFsRXZhbChnW2ldLnRleHRDb250ZW50KX19Y2F0Y2goZSl7bC5hZGQobnVsbCxnW2ldKX19aWYoIWouY2hhbmdlU2l6ZSl7bC5jb25maWd1cmUoe3dpZHRoOmtbMF0saGVpZ2h0OmtbMV19KX1pZihqLm9uTG9hZCl7ai5vbkxvYWQuYXBwbHkobC5fY29udGFpbmVyfHxsLl9zdmcsW2xdKX19O2lmKGgubWF0Y2goJzxzdmcnKSl7bygkLmJyb3dzZXIubXNpZT9uKGgpOm5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoaCwndGV4dC94bWwnKSl9ZWxzZXskLmFqYXgoe3VybDpoLGRhdGFUeXBlOigkLmJyb3dzZXIubXNpZT8ndGV4dCc6J3htbCcpLHN1Y2Nlc3M6ZnVuY3Rpb24oYSl7bygkLmJyb3dzZXIubXNpZT9uKGEpOmEpfSxlcnJvcjpmdW5jdGlvbihhLGIsYyl7bShiKyhjPycgJytjLm1lc3NhZ2U6JycpKX19KX1yZXR1cm4gdGhpc30scmVtb3ZlOmZ1bmN0aW9uKGEpe2E9KGEuanF1ZXJ5P2FbMF06YSk7YS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpO3JldHVybiB0aGlzfSxjbGVhcjpmdW5jdGlvbihhKXtpZihhKXt0aGlzLmNvbmZpZ3VyZSh7fSx0cnVlKX13aGlsZSh0aGlzLl9zdmcuZmlyc3RDaGlsZCl7dGhpcy5fc3ZnLnJlbW92ZUNoaWxkKHRoaXMuX3N2Zy5maXJzdENoaWxkKX1yZXR1cm4gdGhpc30sdG9TVkc6ZnVuY3Rpb24oYSl7YT1hfHx0aGlzLl9zdmc7cmV0dXJuKHR5cGVvZiBYTUxTZXJpYWxpemVyPT0ndW5kZWZpbmVkJz90aGlzLl90b1NWRyhhKTpuZXcgWE1MU2VyaWFsaXplcigpLnNlcmlhbGl6ZVRvU3RyaW5nKGEpKX0sX3RvU1ZHOmZ1bmN0aW9uKGEpe3ZhciBiPScnO2lmKCFhKXtyZXR1cm4gYn1pZihhLm5vZGVUeXBlPT0zKXtiPWEubm9kZVZhbHVlfWVsc2UgaWYoYS5ub2RlVHlwZT09NCl7Yj0nPCFbQ0RBVEFbJythLm5vZGVWYWx1ZSsnXV0+J31lbHNle2I9JzwnK2Eubm9kZU5hbWU7aWYoYS5hdHRyaWJ1dGVzKXtmb3IodmFyIGk9MDtpPGEuYXR0cmlidXRlcy5sZW5ndGg7aSsrKXt2YXIgYz1hLmF0dHJpYnV0ZXMuaXRlbShpKTtpZighKCQudHJpbShjLm5vZGVWYWx1ZSk9PScnfHxjLm5vZGVWYWx1ZS5tYXRjaCgvXlxcW29iamVjdC8pfHxjLm5vZGVWYWx1ZS5tYXRjaCgvXmZ1bmN0aW9uLykpKXtiKz0nICcrKGMubmFtZXNwYWNlVVJJPT0kLnN2Zy54bGlua05TPyd4bGluazonOicnKStjLm5vZGVOYW1lKyc9XCInK2Mubm9kZVZhbHVlKydcIid9fX1pZihhLmZpcnN0Q2hpbGQpe2IrPSc+Jzt2YXIgZD1hLmZpcnN0Q2hpbGQ7d2hpbGUoZCl7Yis9dGhpcy5fdG9TVkcoZCk7ZD1kLm5leHRTaWJsaW5nfWIrPSc8LycrYS5ub2RlTmFtZSsnPid9ZWxzZXtiKz0nLz4nfX1yZXR1cm4gYn0sX2VzY2FwZVhNTDpmdW5jdGlvbihhKXthPWEucmVwbGFjZSgvJi9nLCcmYW1wOycpO2E9YS5yZXBsYWNlKC88L2csJyZsdDsnKTthPWEucmVwbGFjZSgvPi9nLCcmZ3Q7Jyk7cmV0dXJuIGF9fSk7ZnVuY3Rpb24gU1ZHUGF0aCgpe3RoaXMuX3BhdGg9Jyd9JC5leHRlbmQoU1ZHUGF0aC5wcm90b3R5cGUse3Jlc2V0OmZ1bmN0aW9uKCl7dGhpcy5fcGF0aD0nJztyZXR1cm4gdGhpc30sbW92ZTpmdW5jdGlvbih4LHksYSl7YT0oaXNBcnJheSh4KT95OmEpO3JldHVybiB0aGlzLl9jb29yZHMoKGE/J20nOidNJykseCx5KX0sbGluZTpmdW5jdGlvbih4LHksYSl7YT0oaXNBcnJheSh4KT95OmEpO3JldHVybiB0aGlzLl9jb29yZHMoKGE/J2wnOidMJykseCx5KX0saG9yaXo6ZnVuY3Rpb24oeCxhKXt0aGlzLl9wYXRoKz0oYT8naCc6J0gnKSsoaXNBcnJheSh4KT94LmpvaW4oJyAnKTp4KTtyZXR1cm4gdGhpc30sdmVydDpmdW5jdGlvbih5LGEpe3RoaXMuX3BhdGgrPShhPyd2JzonVicpKyhpc0FycmF5KHkpP3kuam9pbignICcpOnkpO3JldHVybiB0aGlzfSxjdXJ2ZUM6ZnVuY3Rpb24oYSxiLGMsZCx4LHksZSl7ZT0oaXNBcnJheShhKT9iOmUpO3JldHVybiB0aGlzLl9jb29yZHMoKGU/J2MnOidDJyksYSxiLGMsZCx4LHkpfSxzbW9vdGhDOmZ1bmN0aW9uKGEsYix4LHksYyl7Yz0oaXNBcnJheShhKT9iOmMpO3JldHVybiB0aGlzLl9jb29yZHMoKGM/J3MnOidTJyksYSxiLHgseSl9LGN1cnZlUTpmdW5jdGlvbihhLGIseCx5LGMpe2M9KGlzQXJyYXkoYSk/YjpjKTtyZXR1cm4gdGhpcy5fY29vcmRzKChjPydxJzonUScpLGEsYix4LHkpfSxzbW9vdGhROmZ1bmN0aW9uKHgseSxhKXthPShpc0FycmF5KHgpP3k6YSk7cmV0dXJuIHRoaXMuX2Nvb3JkcygoYT8ndCc6J1QnKSx4LHkpfSxfY29vcmRzOmZ1bmN0aW9uKGEsYixjLGQsZSxmLGcpe2lmKGlzQXJyYXkoYikpe2Zvcih2YXIgaT0wO2k8Yi5sZW5ndGg7aSsrKXt2YXIgaD1iW2ldO3RoaXMuX3BhdGgrPShpPT0wP2E6JyAnKStoWzBdKycsJytoWzFdKyhoLmxlbmd0aDw0PycnOicgJytoWzJdKycsJytoWzNdKyhoLmxlbmd0aDw2PycnOicgJytoWzRdKycsJytoWzVdKSl9fWVsc2V7dGhpcy5fcGF0aCs9YStiKycsJytjKyhkPT1udWxsPycnOicgJytkKycsJytlKyhmPT1udWxsPycnOicgJytmKycsJytnKSl9cmV0dXJuIHRoaXN9LGFyYzpmdW5jdGlvbihhLGIsYyxkLGUseCx5LGYpe2Y9KGlzQXJyYXkoYSk/YjpmKTt0aGlzLl9wYXRoKz0oZj8nYSc6J0EnKTtpZihpc0FycmF5KGEpKXtmb3IodmFyIGk9MDtpPGEubGVuZ3RoO2krKyl7dmFyIGc9YVtpXTt0aGlzLl9wYXRoKz0oaT09MD8nJzonICcpK2dbMF0rJywnK2dbMV0rJyAnK2dbMl0rJyAnKyhnWzNdPycxJzonMCcpKycsJysoZ1s0XT8nMSc6JzAnKSsnICcrZ1s1XSsnLCcrZ1s2XX19ZWxzZXt0aGlzLl9wYXRoKz1hKycsJytiKycgJytjKycgJysoZD8nMSc6JzAnKSsnLCcrKGU/JzEnOicwJykrJyAnK3grJywnK3l9cmV0dXJuIHRoaXN9LGNsb3NlOmZ1bmN0aW9uKCl7dGhpcy5fcGF0aCs9J3onO3JldHVybiB0aGlzfSxwYXRoOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3BhdGh9fSk7U1ZHUGF0aC5wcm90b3R5cGUubW92ZVRvPVNWR1BhdGgucHJvdG90eXBlLm1vdmU7U1ZHUGF0aC5wcm90b3R5cGUubGluZVRvPVNWR1BhdGgucHJvdG90eXBlLmxpbmU7U1ZHUGF0aC5wcm90b3R5cGUuaG9yaXpUbz1TVkdQYXRoLnByb3RvdHlwZS5ob3JpejtTVkdQYXRoLnByb3RvdHlwZS52ZXJ0VG89U1ZHUGF0aC5wcm90b3R5cGUudmVydDtTVkdQYXRoLnByb3RvdHlwZS5jdXJ2ZUNUbz1TVkdQYXRoLnByb3RvdHlwZS5jdXJ2ZUM7U1ZHUGF0aC5wcm90b3R5cGUuc21vb3RoQ1RvPVNWR1BhdGgucHJvdG90eXBlLnNtb290aEM7U1ZHUGF0aC5wcm90b3R5cGUuY3VydmVRVG89U1ZHUGF0aC5wcm90b3R5cGUuY3VydmVRO1NWR1BhdGgucHJvdG90eXBlLnNtb290aFFUbz1TVkdQYXRoLnByb3RvdHlwZS5zbW9vdGhRO1NWR1BhdGgucHJvdG90eXBlLmFyY1RvPVNWR1BhdGgucHJvdG90eXBlLmFyYztmdW5jdGlvbiBTVkdUZXh0KCl7dGhpcy5fcGFydHM9W119JC5leHRlbmQoU1ZHVGV4dC5wcm90b3R5cGUse3Jlc2V0OmZ1bmN0aW9uKCl7dGhpcy5fcGFydHM9W107cmV0dXJuIHRoaXN9LHN0cmluZzpmdW5jdGlvbihhKXt0aGlzLl9wYXJ0c1t0aGlzLl9wYXJ0cy5sZW5ndGhdPVsndGV4dCcsYV07cmV0dXJuIHRoaXN9LHNwYW46ZnVuY3Rpb24oYSxiKXt0aGlzLl9wYXJ0c1t0aGlzLl9wYXJ0cy5sZW5ndGhdPVsndHNwYW4nLGEsYl07cmV0dXJuIHRoaXN9LHJlZjpmdW5jdGlvbihhLGIpe3RoaXMuX3BhcnRzW3RoaXMuX3BhcnRzLmxlbmd0aF09Wyd0cmVmJyxhLGJdO3JldHVybiB0aGlzfSxwYXRoOmZ1bmN0aW9uKGEsYixjKXt0aGlzLl9wYXJ0c1t0aGlzLl9wYXJ0cy5sZW5ndGhdPVsndGV4dHBhdGgnLGIsJC5leHRlbmQoe2hyZWY6YX0sY3x8e30pXTtyZXR1cm4gdGhpc319KTskLmZuLnN2Zz1mdW5jdGlvbihhKXt2YXIgYj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSk7aWYodHlwZW9mIGE9PSdzdHJpbmcnJiZhPT0nZ2V0Jyl7cmV0dXJuICQuc3ZnWydfJythKydTVkcnXS5hcHBseSgkLnN2ZyxbdGhpc1swXV0uY29uY2F0KGIpKX1yZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7aWYodHlwZW9mIGE9PSdzdHJpbmcnKXskLnN2Z1snXycrYSsnU1ZHJ10uYXBwbHkoJC5zdmcsW3RoaXNdLmNvbmNhdChiKSl9ZWxzZXskLnN2Zy5fYXR0YWNoU1ZHKHRoaXMsYXx8e30pfX0pfTtmdW5jdGlvbiBpc0FycmF5KGEpe3JldHVybihhJiZhLmNvbnN0cnVjdG9yPT1BcnJheSl9JC5zdmc9bmV3IFNWR01hbmFnZXIoKX0pKGpRdWVyeSk7IiwiLyogaHR0cDovL2tlaXRoLXdvb2QubmFtZS9zdmcuaHRtbFxyXG4gICBTVkcvalF1ZXJ5IERPTSBjb21wYXRpYmlsaXR5IGZvciBqUXVlcnkgdjEuNC4zLlxyXG4gICBXcml0dGVuIGJ5IEtlaXRoIFdvb2QgKGtid29vZHthdH1paW5ldC5jb20uYXUpIEFwcmlsIDIwMDkuXHJcbiAgIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIEdQTCAoaHR0cDovL2Rldi5qcXVlcnkuY29tL2Jyb3dzZXIvdHJ1bmsvanF1ZXJ5L0dQTC1MSUNFTlNFLnR4dCkgYW5kIFxyXG4gICBNSVQgKGh0dHA6Ly9kZXYuanF1ZXJ5LmNvbS9icm93c2VyL3RydW5rL2pxdWVyeS9NSVQtTElDRU5TRS50eHQpIGxpY2Vuc2VzLiBcclxuICAgUGxlYXNlIGF0dHJpYnV0ZSB0aGUgYXV0aG9yIGlmIHlvdSB1c2UgaXQuICovXHJcbihmdW5jdGlvbigkKXskLmZuLmFkZENsYXNzPWZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbihkKXtkPWR8fCcnO3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtpZihpc1NWR0VsZW0odGhpcykpe3ZhciBjPXRoaXM7JC5lYWNoKGQuc3BsaXQoL1xccysvKSxmdW5jdGlvbihpLGEpe3ZhciBiPShjLmNsYXNzTmFtZT9jLmNsYXNzTmFtZS5iYXNlVmFsOmMuZ2V0QXR0cmlidXRlKCdjbGFzcycpKTtpZigkLmluQXJyYXkoYSxiLnNwbGl0KC9cXHMrLykpPT0tMSl7Yis9KGI/JyAnOicnKSthOyhjLmNsYXNzTmFtZT9jLmNsYXNzTmFtZS5iYXNlVmFsPWI6Yy5zZXRBdHRyaWJ1dGUoJ2NsYXNzJyxiKSl9fSl9ZWxzZXtlLmFwcGx5KCQodGhpcyksW2RdKX19KX19KCQuZm4uYWRkQ2xhc3MpOyQuZm4ucmVtb3ZlQ2xhc3M9ZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKGQpe2Q9ZHx8Jyc7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe2lmKGlzU1ZHRWxlbSh0aGlzKSl7dmFyIGM9dGhpczskLmVhY2goZC5zcGxpdCgvXFxzKy8pLGZ1bmN0aW9uKGksYSl7dmFyIGI9KGMuY2xhc3NOYW1lP2MuY2xhc3NOYW1lLmJhc2VWYWw6Yy5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykpO2I9JC5ncmVwKGIuc3BsaXQoL1xccysvKSxmdW5jdGlvbihuLGkpe3JldHVybiBuIT1hfSkuam9pbignICcpOyhjLmNsYXNzTmFtZT9jLmNsYXNzTmFtZS5iYXNlVmFsPWI6Yy5zZXRBdHRyaWJ1dGUoJ2NsYXNzJyxiKSl9KX1lbHNle2UuYXBwbHkoJCh0aGlzKSxbZF0pfX0pfX0oJC5mbi5yZW1vdmVDbGFzcyk7JC5mbi50b2dnbGVDbGFzcz1mdW5jdGlvbihjKXtyZXR1cm4gZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7aWYoaXNTVkdFbGVtKHRoaXMpKXtpZih0eXBlb2YgYiE9PSdib29sZWFuJyl7Yj0hJCh0aGlzKS5oYXNDbGFzcyhhKX0kKHRoaXMpWyhiPydhZGQnOidyZW1vdmUnKSsnQ2xhc3MnXShhKX1lbHNle2MuYXBwbHkoJCh0aGlzKSxbYSxiXSl9fSl9fSgkLmZuLnRvZ2dsZUNsYXNzKTskLmZuLmhhc0NsYXNzPWZ1bmN0aW9uKGQpe3JldHVybiBmdW5jdGlvbihiKXtiPWJ8fCcnO3ZhciBjPWZhbHNlO3RoaXMuZWFjaChmdW5jdGlvbigpe2lmKGlzU1ZHRWxlbSh0aGlzKSl7dmFyIGE9KHRoaXMuY2xhc3NOYW1lP3RoaXMuY2xhc3NOYW1lLmJhc2VWYWw6dGhpcy5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykpLnNwbGl0KC9cXHMrLyk7Yz0oJC5pbkFycmF5KGIsYSk+LTEpfWVsc2V7Yz0oZC5hcHBseSgkKHRoaXMpLFtiXSkpfXJldHVybiFjfSk7cmV0dXJuIGN9fSgkLmZuLmhhc0NsYXNzKTskLmZuLmF0dHI9ZnVuY3Rpb24oaCl7cmV0dXJuIGZ1bmN0aW9uKGIsYyxkKXtpZih0eXBlb2YgYj09PSdzdHJpbmcnJiZjPT09dW5kZWZpbmVkKXt2YXIgZT1oLmFwcGx5KHRoaXMsW2IsYyxkXSk7aWYoZSYmZS5iYXNlVmFsJiZlLmJhc2VWYWwubnVtYmVyT2ZJdGVtcyE9bnVsbCl7Yz0nJztlPWUuYmFzZVZhbDtmb3IodmFyIGk9MDtpPGUubnVtYmVyT2ZJdGVtcztpKyspe3ZhciBmPWUuZ2V0SXRlbShpKTtzd2l0Y2goZi50eXBlKXtjYXNlIDE6Yys9JyBtYXRyaXgoJytmLm1hdHJpeC5hKycsJytmLm1hdHJpeC5iKycsJytmLm1hdHJpeC5jKycsJytmLm1hdHJpeC5kKycsJytmLm1hdHJpeC5lKycsJytmLm1hdHJpeC5mKycpJzticmVhaztjYXNlIDI6Yys9JyB0cmFuc2xhdGUoJytmLm1hdHJpeC5lKycsJytmLm1hdHJpeC5mKycpJzticmVhaztjYXNlIDM6Yys9JyBzY2FsZSgnK2YubWF0cml4LmErJywnK2YubWF0cml4LmQrJyknO2JyZWFrO2Nhc2UgNDpjKz0nIHJvdGF0ZSgnK2YuYW5nbGUrJyknO2JyZWFrO2Nhc2UgNTpjKz0nIHNrZXdYKCcrZi5hbmdsZSsnKSc7YnJlYWs7Y2FzZSA2OmMrPScgc2tld1koJytmLmFuZ2xlKycpJzticmVha319ZT1jLnN1YnN0cmluZygxKX1yZXR1cm4oZSYmZS5iYXNlVmFsP2UuYmFzZVZhbC52YWx1ZUFzU3RyaW5nOmUpfXZhciBnPWI7aWYodHlwZW9mIGI9PT0nc3RyaW5nJyl7Zz17fTtnW2JdPWN9cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe2lmKGlzU1ZHRWxlbSh0aGlzKSl7Zm9yKHZhciBuIGluIGcpe3ZhciBhPSgkLmlzRnVuY3Rpb24oZ1tuXSk/Z1tuXSgpOmdbbl0pOyhkP3RoaXMuc3R5bGVbbl09YTp0aGlzLnNldEF0dHJpYnV0ZShuLGEpKX19ZWxzZXtoLmFwcGx5KCQodGhpcyksW2IsYyxkXSl9fSl9fSgkLmZuLmF0dHIpOyQuZm4ucmVtb3ZlQXR0cj1mdW5jdGlvbihiKXtyZXR1cm4gZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe2lmKGlzU1ZHRWxlbSh0aGlzKSl7KHRoaXNbYV0mJnRoaXNbYV0uYmFzZVZhbD90aGlzW2FdLmJhc2VWYWwudmFsdWU9Jyc6dGhpcy5zZXRBdHRyaWJ1dGUoYSwnJykpfWVsc2V7Yi5hcHBseSgkKHRoaXMpLFthXSl9fSl9fSgkLmZuLnJlbW92ZUF0dHIpO2Z1bmN0aW9uIGFueVNWRyhhKXtmb3IodmFyIGk9MDtpPGEubGVuZ3RoO2krKyl7aWYoYVtpXS5ub2RlVHlwZT09MSYmYVtpXS5uYW1lc3BhY2VVUkk9PSQuc3ZnLnN2Z05TKXtyZXR1cm4gdHJ1ZX19cmV0dXJuIGZhbHNlfSQuZXhwci5yZWxhdGl2ZVsnKyddPWZ1bmN0aW9uKGQpe3JldHVybiBmdW5jdGlvbihhLGIsYyl7ZChhLGIsY3x8YW55U1ZHKGEpKX19KCQuZXhwci5yZWxhdGl2ZVsnKyddKTskLmV4cHIucmVsYXRpdmVbJz4nXT1mdW5jdGlvbihkKXtyZXR1cm4gZnVuY3Rpb24oYSxiLGMpe2QoYSxiLGN8fGFueVNWRyhhKSl9fSgkLmV4cHIucmVsYXRpdmVbJz4nXSk7JC5leHByLnJlbGF0aXZlWycnXT1mdW5jdGlvbihkKXtyZXR1cm4gZnVuY3Rpb24oYSxiLGMpe2QoYSxiLGN8fGFueVNWRyhhKSl9fSgkLmV4cHIucmVsYXRpdmVbJyddKTskLmV4cHIucmVsYXRpdmVbJ34nXT1mdW5jdGlvbihkKXtyZXR1cm4gZnVuY3Rpb24oYSxiLGMpe2QoYSxiLGN8fGFueVNWRyhhKSl9fSgkLmV4cHIucmVsYXRpdmVbJ34nXSk7JC5leHByLmZpbmQuSUQ9ZnVuY3Rpb24oZCl7cmV0dXJuIGZ1bmN0aW9uKGEsYixjKXtyZXR1cm4oaXNTVkdFbGVtKGIpP1tiLm93bmVyRG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYVsxXSldOmQoYSxiLGMpKX19KCQuZXhwci5maW5kLklEKTt2YXIgaj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtqLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoJycpKTtpZihqLmdldEVsZW1lbnRzQnlUYWdOYW1lKCcqJykubGVuZ3RoPjApeyQuZXhwci5maW5kLlRBRz1mdW5jdGlvbihhLGIpe3ZhciBjPWIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoYVsxXSk7aWYoYVsxXT09PScqJyl7dmFyIGQ9W107Zm9yKHZhciBpPTA7Y1tpXXx8Yy5pdGVtKGkpO2krKyl7aWYoKGNbaV18fGMuaXRlbShpKSkubm9kZVR5cGU9PT0xKXtkLnB1c2goY1tpXXx8Yy5pdGVtKGkpKX19Yz1kfXJldHVybiBjfX0kLmV4cHIucHJlRmlsdGVyLkNMQVNTPWZ1bmN0aW9uKGEsYixjLGQsZixnKXthPScgJythWzFdLnJlcGxhY2UoL1xcXFwvZywnJykrJyAnO2lmKGcpe3JldHVybiBhfWZvcih2YXIgaT0wLGVsZW09e307ZWxlbSE9bnVsbDtpKyspe2VsZW09YltpXTtpZighZWxlbSl7dHJ5e2VsZW09Yi5pdGVtKGkpfWNhdGNoKGUpe319aWYoZWxlbSl7dmFyIGg9KCFpc1NWR0VsZW0oZWxlbSk/ZWxlbS5jbGFzc05hbWU6KGVsZW0uY2xhc3NOYW1lP2VsZW0uY2xhc3NOYW1lLmJhc2VWYWw6JycpfHxlbGVtLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSk7aWYoZl4oaCYmKCcgJytoKycgJykuaW5kZXhPZihhKT4tMSkpe2lmKCFjKWQucHVzaChlbGVtKX1lbHNlIGlmKGMpe2JbaV09ZmFsc2V9fX1yZXR1cm4gZmFsc2V9OyQuZXhwci5maWx0ZXIuQ0xBU1M9ZnVuY3Rpb24oYSxiKXt2YXIgYz0oIWlzU1ZHRWxlbShhKT9hLmNsYXNzTmFtZTooYS5jbGFzc05hbWU/YS5jbGFzc05hbWUuYmFzZVZhbDphLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSkpO3JldHVybignICcrYysnICcpLmluZGV4T2YoYik+LTF9OyQuZXhwci5maWx0ZXIuQVRUUj1mdW5jdGlvbihnKXtyZXR1cm4gZnVuY3Rpb24oYyxkKXt2YXIgZT1udWxsO2lmKGlzU1ZHRWxlbShjKSl7ZT1kWzFdOyQuZXhwci5hdHRySGFuZGxlW2VdPWZ1bmN0aW9uKGEpe3ZhciBiPWEuZ2V0QXR0cmlidXRlKGUpO3JldHVybiBiJiZiLmJhc2VWYWx8fGJ9fXZhciBmPWcoYyxkKTtpZihlKXskLmV4cHIuYXR0ckhhbmRsZVtlXT1udWxsfXJldHVybiBmfX0oJC5leHByLmZpbHRlci5BVFRSKTtmdW5jdGlvbiBpc1NWR0VsZW0oYSl7cmV0dXJuKGEubm9kZVR5cGU9PTEmJmEubmFtZXNwYWNlVVJJPT0kLnN2Zy5zdmdOUyl9fSkoalF1ZXJ5KTsiLCIoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlKHdpbmRvdykge1xyXG4gICAgICAgIHdpbmRvdyA9IHdpbmRvdyB8fCBldmFsKFwicmVxdWlyZSgnanNcIitcImRvbScpXCIpLmpzZG9tKCkuY3JlYXRlV2luZG93KCk7XHJcblxyXG4gICAgICAgIC8vIGFzc3VtZSB3aW5kb3cgaXMgYSBqc2RvbSBpbnN0YW5jZS4uLlxyXG4gICAgICAgIC8vIGpzZG9tIGluY2x1ZGVzIGFuIGluY29tcGxldGUgdmVyc2lvbiBvZiBYTUxIdHRwUmVxdWVzdFxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5YTUxIdHRwUmVxdWVzdCA9IGV2YWwoXCJyZXF1aXJlKCd4bWxcIitcImh0dHByZXF1ZXN0JylcIikuWE1MSHR0cFJlcXVlc3Q7XHJcbiAgICAgICAgICAgIC8vIHRyaWNrIGpRdWVyeSBpbnRvIHRoaW5raW5nIENPUlMgaXMgc3VwcG9ydGVkIChzaG91bGQgYmUgaW4gbm9kZS1YTUxIdHRwUmVxdWVzdClcclxuICAgICAgICAgICAgd2luZG93LlhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHt9XHJcblxyXG4gICAgICAgIHZhciBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbixcclxuICAgICAgICAgICAgbmF2aWdhdG9yID0gd2luZG93Lm5hdmlnYXRvcixcclxuICAgICAgICAgICAgWE1MSHR0cFJlcXVlc3QgPSB3aW5kb3cuWE1MSHR0cFJlcXVlc3Q7XHJcblxyXG4vKiFcclxuICogalF1ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2MS43LjFcclxuICogaHR0cDovL2pxdWVyeS5jb20vXHJcbiAqXHJcbiAqIENvcHlyaWdodCAyMDExLCBKb2huIFJlc2lnXHJcbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBvciBHUEwgVmVyc2lvbiAyIGxpY2Vuc2VzLlxyXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXHJcbiAqXHJcbiAqIEluY2x1ZGVzIFNpenpsZS5qc1xyXG4gKiBodHRwOi8vc2l6emxlanMuY29tL1xyXG4gKiBDb3B5cmlnaHQgMjAxMSwgVGhlIERvam8gRm91bmRhdGlvblxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlULCBCU0QsIGFuZCBHUEwgTGljZW5zZXMuXHJcbiAqXHJcbiAqIERhdGU6IE1vbiBOb3YgMjEgMjE6MTE6MDMgMjAxMSAtMDUwMFxyXG4gKi9cclxuKGZ1bmN0aW9uKCB3aW5kb3csIHVuZGVmaW5lZCApIHtcclxuXHJcbi8vIFVzZSB0aGUgY29ycmVjdCBkb2N1bWVudCBhY2NvcmRpbmdseSB3aXRoIHdpbmRvdyBhcmd1bWVudCAoc2FuZGJveClcclxuICAgIHZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCxcclxuICAgICAgICBuYXZpZ2F0b3IgPSB3aW5kb3cubmF2aWdhdG9yLFxyXG4gICAgICAgIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xyXG4gICAgdmFyIGpRdWVyeSA9IChmdW5jdGlvbigpIHtcclxuXHJcbi8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XHJcbiAgICAgICAgdmFyIGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBqUXVlcnkuZm4uaW5pdCggc2VsZWN0b3IsIGNvbnRleHQsIHJvb3RqUXVlcnkgKTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXHJcbiAgICAgICAgICAgIF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxyXG5cclxuICAgICAgICAvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxyXG4gICAgICAgICAgICBfJCA9IHdpbmRvdy4kLFxyXG5cclxuICAgICAgICAvLyBBIGNlbnRyYWwgcmVmZXJlbmNlIHRvIHRoZSByb290IGpRdWVyeShkb2N1bWVudClcclxuICAgICAgICAgICAgcm9vdGpRdWVyeSxcclxuXHJcbiAgICAgICAgLy8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3Mgb3IgSUQgc3RyaW5nc1xyXG4gICAgICAgIC8vIFByaW9yaXRpemUgI2lkIG92ZXIgPHRhZz4gdG8gYXZvaWQgWFNTIHZpYSBsb2NhdGlvbi5oYXNoICgjOTUyMSlcclxuICAgICAgICAgICAgcXVpY2tFeHByID0gL14oPzpbXiM8XSooPFtcXHdcXFddKz4pW14+XSokfCMoW1xcd1xcLV0qKSQpLyxcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgYSBzdHJpbmcgaGFzIGEgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyIGluIGl0XHJcbiAgICAgICAgICAgIHJub3R3aGl0ZSA9IC9cXFMvLFxyXG5cclxuICAgICAgICAvLyBVc2VkIGZvciB0cmltbWluZyB3aGl0ZXNwYWNlXHJcbiAgICAgICAgICAgIHRyaW1MZWZ0ID0gL15cXHMrLyxcclxuICAgICAgICAgICAgdHJpbVJpZ2h0ID0gL1xccyskLyxcclxuXHJcbiAgICAgICAgLy8gTWF0Y2ggYSBzdGFuZGFsb25lIHRhZ1xyXG4gICAgICAgICAgICByc2luZ2xlVGFnID0gL148KFxcdyspXFxzKlxcLz8+KD86PFxcL1xcMT4pPyQvLFxyXG5cclxuICAgICAgICAvLyBKU09OIFJlZ0V4cFxyXG4gICAgICAgICAgICBydmFsaWRjaGFycyA9IC9eW1xcXSw6e31cXHNdKiQvLFxyXG4gICAgICAgICAgICBydmFsaWRlc2NhcGUgPSAvXFxcXCg/OltcIlxcXFxcXC9iZm5ydF18dVswLTlhLWZBLUZdezR9KS9nLFxyXG4gICAgICAgICAgICBydmFsaWR0b2tlbnMgPSAvXCJbXlwiXFxcXFxcblxccl0qXCJ8dHJ1ZXxmYWxzZXxudWxsfC0/XFxkKyg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/L2csXHJcbiAgICAgICAgICAgIHJ2YWxpZGJyYWNlcyA9IC8oPzpefDp8LCkoPzpcXHMqXFxbKSsvZyxcclxuXHJcbiAgICAgICAgLy8gVXNlcmFnZW50IFJlZ0V4cFxyXG4gICAgICAgICAgICByd2Via2l0ID0gLyh3ZWJraXQpWyBcXC9dKFtcXHcuXSspLyxcclxuICAgICAgICAgICAgcm9wZXJhID0gLyhvcGVyYSkoPzouKnZlcnNpb24pP1sgXFwvXShbXFx3Ll0rKS8sXHJcbiAgICAgICAgICAgIHJtc2llID0gLyhtc2llKSAoW1xcdy5dKykvLFxyXG4gICAgICAgICAgICBybW96aWxsYSA9IC8obW96aWxsYSkoPzouKj8gcnY6KFtcXHcuXSspKT8vLFxyXG5cclxuICAgICAgICAvLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcclxuICAgICAgICAgICAgcmRhc2hBbHBoYSA9IC8tKFthLXpdfFswLTldKS9pZyxcclxuICAgICAgICAgICAgcm1zUHJlZml4ID0gL14tbXMtLyxcclxuXHJcbiAgICAgICAgLy8gVXNlZCBieSBqUXVlcnkuY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxyXG4gICAgICAgICAgICBmY2FtZWxDYXNlID0gZnVuY3Rpb24oIGFsbCwgbGV0dGVyICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICggbGV0dGVyICsgXCJcIiApLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIEtlZXAgYSBVc2VyQWdlbnQgc3RyaW5nIGZvciB1c2Ugd2l0aCBqUXVlcnkuYnJvd3NlclxyXG4gICAgICAgICAgICB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50LFxyXG5cclxuICAgICAgICAvLyBGb3IgbWF0Y2hpbmcgdGhlIGVuZ2luZSBhbmQgdmVyc2lvbiBvZiB0aGUgYnJvd3NlclxyXG4gICAgICAgICAgICBicm93c2VyTWF0Y2gsXHJcblxyXG4gICAgICAgIC8vIFRoZSBkZWZlcnJlZCB1c2VkIG9uIERPTSByZWFkeVxyXG4gICAgICAgICAgICByZWFkeUxpc3QsXHJcblxyXG4gICAgICAgIC8vIFRoZSByZWFkeSBldmVudCBoYW5kbGVyXHJcbiAgICAgICAgICAgIERPTUNvbnRlbnRMb2FkZWQsXHJcblxyXG4gICAgICAgIC8vIFNhdmUgYSByZWZlcmVuY2UgdG8gc29tZSBjb3JlIG1ldGhvZHNcclxuICAgICAgICAgICAgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFxyXG4gICAgICAgICAgICBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxyXG4gICAgICAgICAgICBwdXNoID0gQXJyYXkucHJvdG90eXBlLnB1c2gsXHJcbiAgICAgICAgICAgIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLFxyXG4gICAgICAgICAgICB0cmltID0gU3RyaW5nLnByb3RvdHlwZS50cmltLFxyXG4gICAgICAgICAgICBpbmRleE9mID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YsXHJcblxyXG4gICAgICAgIC8vIFtbQ2xhc3NdXSAtPiB0eXBlIHBhaXJzXHJcbiAgICAgICAgICAgIGNsYXNzMnR5cGUgPSB7fTtcclxuXHJcbiAgICAgICAgalF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcclxuICAgICAgICAgICAgY29uc3RydWN0b3I6IGpRdWVyeSxcclxuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByb290alF1ZXJ5ICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoLCBlbGVtLCByZXQsIGRvYztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgJChcIlwiKSwgJChudWxsKSwgb3IgJCh1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICBpZiAoICFzZWxlY3RvciApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgJChET01FbGVtZW50KVxyXG4gICAgICAgICAgICAgICAgaWYgKCBzZWxlY3Rvci5ub2RlVHlwZSApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQgPSB0aGlzWzBdID0gc2VsZWN0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRoZSBib2R5IGVsZW1lbnQgb25seSBleGlzdHMgb25jZSwgb3B0aW1pemUgZmluZGluZyBpdFxyXG4gICAgICAgICAgICAgICAgaWYgKCBzZWxlY3RvciA9PT0gXCJib2R5XCIgJiYgIWNvbnRleHQgJiYgZG9jdW1lbnQuYm9keSApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQgPSBkb2N1bWVudDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzWzBdID0gZG9jdW1lbnQuYm9keTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBIVE1MIHN0cmluZ3NcclxuICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFyZSB3ZSBkZWFsaW5nIHdpdGggSFRNTCBzdHJpbmcgb3IgYW4gSUQ/XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzZWxlY3Rvci5jaGFyQXQoMCkgPT09IFwiPFwiICYmIHNlbGVjdG9yLmNoYXJBdCggc2VsZWN0b3IubGVuZ3RoIC0gMSApID09PSBcIj5cIiAmJiBzZWxlY3Rvci5sZW5ndGggPj0gMyApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gcXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBWZXJpZnkgYSBtYXRjaCwgYW5kIHRoYXQgbm8gY29udGV4dCB3YXMgc3BlY2lmaWVkIGZvciAjaWRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIG1hdGNoICYmIChtYXRjaFsxXSB8fCAhY29udGV4dCkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXRjaFsxXSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFswXSA6IGNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2MgPSAoIGNvbnRleHQgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IGRvY3VtZW50ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBzaW5nbGUgc3RyaW5nIGlzIHBhc3NlZCBpbiBhbmQgaXQncyBhIHNpbmdsZSB0YWdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgZG8gYSBjcmVhdGVFbGVtZW50IGFuZCBza2lwIHRoZSByZXN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQgPSByc2luZ2xlVGFnLmV4ZWMoIHNlbGVjdG9yICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCByZXQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9IFsgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggcmV0WzFdICkgXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmZuLmF0dHIuY2FsbCggc2VsZWN0b3IsIGNvbnRleHQsIHRydWUgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgPSBbIGRvYy5jcmVhdGVFbGVtZW50KCByZXRbMV0gKSBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IGpRdWVyeS5idWlsZEZyYWdtZW50KCBbIG1hdGNoWzFdIF0sIFsgZG9jIF0gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9ICggcmV0LmNhY2hlYWJsZSA/IGpRdWVyeS5jbG9uZShyZXQuZnJhZ21lbnQpIDogcmV0LmZyYWdtZW50ICkuY2hpbGROb2RlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5Lm1lcmdlKCB0aGlzLCBzZWxlY3RvciApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhBTkRMRTogJChcIiNpZFwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtYXRjaFsyXSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHBhcmVudE5vZGUgdG8gY2F0Y2ggd2hlbiBCbGFja2JlcnJ5IDQuNiByZXR1cm5zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdGhlIGRvY3VtZW50ICM2OTYzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGVsZW0gJiYgZWxlbS5wYXJlbnROb2RlICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSBJRSBhbmQgT3BlcmEgcmV0dXJuIGl0ZW1zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnkgbmFtZSBpbnN0ZWFkIG9mIElEXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtLmlkICE9PSBtYXRjaFsyXSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvb3RqUXVlcnkuZmluZCggc2VsZWN0b3IgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UgaW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1swXSA9IGVsZW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gZG9jdW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSEFORExFOiAkKGV4cHIsICQoLi4uKSlcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICggY29udGV4dCB8fCByb290alF1ZXJ5ICkuZmluZCggc2VsZWN0b3IgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhBTkRMRTogJChleHByLCBjb250ZXh0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggc2VsZWN0b3IgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm9vdGpRdWVyeS5yZWFkeSggc2VsZWN0b3IgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHNlbGVjdG9yLnNlbGVjdG9yICE9PSB1bmRlZmluZWQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yLnNlbGVjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IHNlbGVjdG9yLmNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5tYWtlQXJyYXkoIHNlbGVjdG9yLCB0aGlzICk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvLyBTdGFydCB3aXRoIGFuIGVtcHR5IHNlbGVjdG9yXHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiBcIlwiLFxyXG5cclxuICAgICAgICAgICAgLy8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxyXG4gICAgICAgICAgICBqcXVlcnk6IFwiMS43LjFcIixcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxyXG4gICAgICAgICAgICBsZW5ndGg6IDAsXHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIGNvbnRhaW5lZCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldFxyXG4gICAgICAgICAgICBzaXplOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMsIDAgKTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1JcclxuICAgICAgICAgICAgLy8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiggbnVtICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bSA9PSBudWxsID9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIGEgJ2NsZWFuJyBhcnJheVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9BcnJheSgpIDpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIGp1c3QgdGhlIG9iamVjdFxyXG4gICAgICAgICAgICAgICAgICAgICggbnVtIDwgMCA/IHRoaXNbIHRoaXMubGVuZ3RoICsgbnVtIF0gOiB0aGlzWyBudW0gXSApO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLy8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xyXG4gICAgICAgICAgICAvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcclxuICAgICAgICAgICAgcHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMsIG5hbWUsIHNlbGVjdG9yICkge1xyXG4gICAgICAgICAgICAgICAgLy8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcclxuICAgICAgICAgICAgICAgIHZhciByZXQgPSB0aGlzLmNvbnN0cnVjdG9yKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBqUXVlcnkuaXNBcnJheSggZWxlbXMgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICBwdXNoLmFwcGx5KCByZXQsIGVsZW1zICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkubWVyZ2UoIHJldCwgZWxlbXMgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxyXG4gICAgICAgICAgICAgICAgcmV0LnByZXZPYmplY3QgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldC5jb250ZXh0ID0gdGhpcy5jb250ZXh0O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggbmFtZSA9PT0gXCJmaW5kXCIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0LnNlbGVjdG9yID0gdGhpcy5zZWxlY3RvciArICggdGhpcy5zZWxlY3RvciA/IFwiIFwiIDogXCJcIiApICsgc2VsZWN0b3I7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBuYW1lICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldC5zZWxlY3RvciA9IHRoaXMuc2VsZWN0b3IgKyBcIi5cIiArIG5hbWUgKyBcIihcIiArIHNlbGVjdG9yICsgXCIpXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxyXG4gICAgICAgICAgICAvLyAoWW91IGNhbiBzZWVkIHRoZSBhcmd1bWVudHMgd2l0aCBhbiBhcnJheSBvZiBhcmdzLCBidXQgdGhpcyBpc1xyXG4gICAgICAgICAgICAvLyBvbmx5IHVzZWQgaW50ZXJuYWxseS4pXHJcbiAgICAgICAgICAgIGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjaywgYXJncyApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZWFjaCggdGhpcywgY2FsbGJhY2ssIGFyZ3MgKTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHJlYWR5OiBmdW5jdGlvbiggZm4gKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBdHRhY2ggdGhlIGxpc3RlbmVyc1xyXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmJpbmRSZWFkeSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgY2FsbGJhY2tcclxuICAgICAgICAgICAgICAgIHJlYWR5TGlzdC5hZGQoIGZuICk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBlcTogZnVuY3Rpb24oIGkgKSB7XHJcbiAgICAgICAgICAgICAgICBpID0gK2k7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaSA9PT0gLTEgP1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2xpY2UoIGkgKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zbGljZSggaSwgaSArIDEgKTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGZpcnN0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVxKCAwICk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBsYXN0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVxKCAtMSApO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgc2xpY2U6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKCBzbGljZS5hcHBseSggdGhpcywgYXJndW1lbnRzICksXHJcbiAgICAgICAgICAgICAgICAgICAgXCJzbGljZVwiLCBzbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbihcIixcIikgKTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIG1hcDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBlbmQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKG51bGwpO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLy8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxyXG4gICAgICAgICAgICAvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cclxuICAgICAgICAgICAgcHVzaDogcHVzaCxcclxuICAgICAgICAgICAgc29ydDogW10uc29ydCxcclxuICAgICAgICAgICAgc3BsaWNlOiBbXS5zcGxpY2VcclxuICAgICAgICB9O1xyXG5cclxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxyXG4gICAgICAgIGpRdWVyeS5mbi5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcclxuXHJcbiAgICAgICAgalF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gYXJndW1lbnRzWzBdIHx8IHt9LFxyXG4gICAgICAgICAgICAgICAgaSA9IDEsXHJcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgZGVlcCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgLy8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxyXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xyXG4gICAgICAgICAgICAgICAgZGVlcCA9IHRhcmdldDtcclxuICAgICAgICAgICAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1sxXSB8fCB7fTtcclxuICAgICAgICAgICAgICAgIC8vIHNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcclxuICAgICAgICAgICAgICAgIGkgPSAyO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcclxuICAgICAgICAgICAgaWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFqUXVlcnkuaXNGdW5jdGlvbih0YXJnZXQpICkge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0ge307XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxyXG4gICAgICAgICAgICBpZiAoIGxlbmd0aCA9PT0gaSApIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAtLWk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgLy8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgaWYgKCAob3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdKSAhPSBudWxsICkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3RcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYyA9IHRhcmdldFsgbmFtZSBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRhcmdldCA9PT0gY29weSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBkZWVwICYmIGNvcHkgJiYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdChjb3B5KSB8fCAoY29weUlzQXJyYXkgPSBqUXVlcnkuaXNBcnJheShjb3B5KSkgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY29weUlzQXJyYXkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weUlzQXJyYXkgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNBcnJheShzcmMpID8gc3JjIDogW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdChzcmMpID8gc3JjIDoge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGRlZXAsIGNsb25lLCBjb3B5ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgalF1ZXJ5LmV4dGVuZCh7XHJcbiAgICAgICAgICAgIG5vQ29uZmxpY3Q6IGZ1bmN0aW9uKCBkZWVwICkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCB3aW5kb3cuJCA9PT0galF1ZXJ5ICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy4kID0gXyQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHtcclxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5O1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLy8gSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cclxuICAgICAgICAgICAgaXNSZWFkeTogZmFsc2UsXHJcblxyXG4gICAgICAgICAgICAvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXHJcbiAgICAgICAgICAgIC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXHJcbiAgICAgICAgICAgIHJlYWR5V2FpdDogMSxcclxuXHJcbiAgICAgICAgICAgIC8vIEhvbGQgKG9yIHJlbGVhc2UpIHRoZSByZWFkeSBldmVudFxyXG4gICAgICAgICAgICBob2xkUmVhZHk6IGZ1bmN0aW9uKCBob2xkICkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCBob2xkICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5yZWFkeVdhaXQrKztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnJlYWR5KCB0cnVlICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XHJcbiAgICAgICAgICAgIHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcclxuICAgICAgICAgICAgICAgIC8vIEVpdGhlciBhIHJlbGVhc2VkIGhvbGQgb3IgYW4gRE9NcmVhZHkvbG9hZCBldmVudCBhbmQgbm90IHlldCByZWFkeVxyXG4gICAgICAgICAgICAgICAgaWYgKCAod2FpdCA9PT0gdHJ1ZSAmJiAhLS1qUXVlcnkucmVhZHlXYWl0KSB8fCAod2FpdCAhPT0gdHJ1ZSAmJiAhalF1ZXJ5LmlzUmVhZHkpICkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBib2R5IGV4aXN0cywgYXQgbGVhc3QsIGluIGNhc2UgSUUgZ2V0cyBhIGxpdHRsZSBvdmVyemVhbG91cyAodGlja2V0ICM1NDQzKS5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoICFkb2N1bWVudC5ib2R5ICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5LCAxICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuaXNSZWFkeSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBmdW5jdGlvbnMgYm91bmQsIHRvIGV4ZWN1dGVcclxuICAgICAgICAgICAgICAgICAgICByZWFkeUxpc3QuZmlyZVdpdGgoIGRvY3VtZW50LCBbIGpRdWVyeSBdICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyaWdnZXIgYW55IGJvdW5kIHJlYWR5IGV2ZW50c1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggalF1ZXJ5LmZuLnRyaWdnZXIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeSggZG9jdW1lbnQgKS50cmlnZ2VyKCBcInJlYWR5XCIgKS5vZmYoIFwicmVhZHlcIiApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGJpbmRSZWFkeTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIHJlYWR5TGlzdCApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmVhZHlMaXN0ID0galF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWQgYWZ0ZXIgdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBicm93c2VyIGV2ZW50IGhhcyBhbHJlYWR5IG9jY3VycmVkLlxyXG4gICAgICAgICAgICAgICAgaWYgKCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IHJlYWR5XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSwgMSApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIE1vemlsbGEsIE9wZXJhIGFuZCB3ZWJraXQgbmlnaHRsaWVzIGN1cnJlbnRseSBzdXBwb3J0IHRoaXMgZXZlbnRcclxuICAgICAgICAgICAgICAgIGlmICggZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXHJcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIERPTUNvbnRlbnRMb2FkZWQsIGZhbHNlICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBqUXVlcnkucmVhZHksIGZhbHNlICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIElFIGV2ZW50IG1vZGVsIGlzIHVzZWRcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGRvY3VtZW50LmF0dGFjaEV2ZW50ICkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGVuc3VyZSBmaXJpbmcgYmVmb3JlIG9ubG9hZCxcclxuICAgICAgICAgICAgICAgICAgICAvLyBtYXliZSBsYXRlIGJ1dCBzYWZlIGFsc28gZm9yIGlmcmFtZXNcclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5hdHRhY2hFdmVudCggXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiwgRE9NQ29udGVudExvYWRlZCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xyXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5hdHRhY2hFdmVudCggXCJvbmxvYWRcIiwgalF1ZXJ5LnJlYWR5ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIElFIGFuZCBub3QgYSBmcmFtZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVhbGx5IGNoZWNrIHRvIHNlZSBpZiB0aGUgZG9jdW1lbnQgaXMgcmVhZHlcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdG9wbGV2ZWwgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wbGV2ZWwgPSB3aW5kb3cuZnJhbWVFbGVtZW50ID09IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChlKSB7fVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCAmJiB0b3BsZXZlbCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9TY3JvbGxDaGVjaygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8vIFNlZSB0ZXN0L3VuaXQvY29yZS5qcyBmb3IgZGV0YWlscyBjb25jZXJuaW5nIGlzRnVuY3Rpb24uXHJcbiAgICAgICAgICAgIC8vIFNpbmNlIHZlcnNpb24gMS4zLCBET00gbWV0aG9kcyBhbmQgZnVuY3Rpb25zIGxpa2UgYWxlcnRcclxuICAgICAgICAgICAgLy8gYXJlbid0IHN1cHBvcnRlZC4gVGhleSByZXR1cm4gZmFsc2Ugb24gSUUgKCMyOTY4KS5cclxuICAgICAgICAgICAgaXNGdW5jdGlvbjogZnVuY3Rpb24oIG9iaiApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkudHlwZShvYmopID09PSBcImZ1bmN0aW9uXCI7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBpc0FycmF5OiBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKCBvYmogKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LnR5cGUob2JqKSA9PT0gXCJhcnJheVwiO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLy8gQSBjcnVkZSB3YXkgb2YgZGV0ZXJtaW5pbmcgaWYgYW4gb2JqZWN0IGlzIGEgd2luZG93XHJcbiAgICAgICAgICAgIGlzV2luZG93OiBmdW5jdGlvbiggb2JqICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmIFwic2V0SW50ZXJ2YWxcIiBpbiBvYmo7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBpc051bWVyaWM6IGZ1bmN0aW9uKCBvYmogKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gIWlzTmFOKCBwYXJzZUZsb2F0KG9iaikgKSAmJiBpc0Zpbml0ZSggb2JqICk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICB0eXBlOiBmdW5jdGlvbiggb2JqICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iaiA9PSBudWxsID9cclxuICAgICAgICAgICAgICAgICAgICBTdHJpbmcoIG9iaiApIDpcclxuICAgICAgICAgICAgICAgIGNsYXNzMnR5cGVbIHRvU3RyaW5nLmNhbGwob2JqKSBdIHx8IFwib2JqZWN0XCI7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xyXG4gICAgICAgICAgICAgICAgLy8gTXVzdCBiZSBhbiBPYmplY3QuXHJcbiAgICAgICAgICAgICAgICAvLyBCZWNhdXNlIG9mIElFLCB3ZSBhbHNvIGhhdmUgdG8gY2hlY2sgdGhlIHByZXNlbmNlIG9mIHRoZSBjb25zdHJ1Y3RvciBwcm9wZXJ0eS5cclxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IERPTSBub2RlcyBhbmQgd2luZG93IG9iamVjdHMgZG9uJ3QgcGFzcyB0aHJvdWdoLCBhcyB3ZWxsXHJcbiAgICAgICAgICAgICAgICBpZiAoICFvYmogfHwgalF1ZXJ5LnR5cGUob2JqKSAhPT0gXCJvYmplY3RcIiB8fCBvYmoubm9kZVR5cGUgfHwgalF1ZXJ5LmlzV2luZG93KCBvYmogKSApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBOb3Qgb3duIGNvbnN0cnVjdG9yIHByb3BlcnR5IG11c3QgYmUgT2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBvYmouY29uc3RydWN0b3IgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgIWhhc093bi5jYWxsKG9iaiwgXCJjb25zdHJ1Y3RvclwiKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhaGFzT3duLmNhbGwob2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgXCJpc1Byb3RvdHlwZU9mXCIpICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoIGUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSUU4LDkgV2lsbCB0aHJvdyBleGNlcHRpb25zIG9uIGNlcnRhaW4gaG9zdCBvYmplY3RzICM5ODk3XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIE93biBwcm9wZXJ0aWVzIGFyZSBlbnVtZXJhdGVkIGZpcnN0bHksIHNvIHRvIHNwZWVkIHVwLFxyXG4gICAgICAgICAgICAgICAgLy8gaWYgbGFzdCBvbmUgaXMgb3duLCB0aGVuIGFsbCBwcm9wZXJ0aWVzIGFyZSBvd24uXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGtleTtcclxuICAgICAgICAgICAgICAgIGZvciAoIGtleSBpbiBvYmogKSB7fVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCB8fCBoYXNPd24uY2FsbCggb2JqLCBrZXkgKTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgbmFtZSBpbiBvYmogKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciggbXNnICk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBwYXJzZUpTT046IGZ1bmN0aW9uKCBkYXRhICkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiB8fCAhZGF0YSApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgbGVhZGluZy90cmFpbGluZyB3aGl0ZXNwYWNlIGlzIHJlbW92ZWQgKElFIGNhbid0IGhhbmRsZSBpdClcclxuICAgICAgICAgICAgICAgIGRhdGEgPSBqUXVlcnkudHJpbSggZGF0YSApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gcGFyc2UgdXNpbmcgdGhlIG5hdGl2ZSBKU09OIHBhcnNlciBmaXJzdFxyXG4gICAgICAgICAgICAgICAgaWYgKCB3aW5kb3cuSlNPTiAmJiB3aW5kb3cuSlNPTi5wYXJzZSApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LkpTT04ucGFyc2UoIGRhdGEgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGluY29taW5nIGRhdGEgaXMgYWN0dWFsIEpTT05cclxuICAgICAgICAgICAgICAgIC8vIExvZ2ljIGJvcnJvd2VkIGZyb20gaHR0cDovL2pzb24ub3JnL2pzb24yLmpzXHJcbiAgICAgICAgICAgICAgICBpZiAoIHJ2YWxpZGNoYXJzLnRlc3QoIGRhdGEucmVwbGFjZSggcnZhbGlkZXNjYXBlLCBcIkBcIiApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCBydmFsaWR0b2tlbnMsIFwiXVwiIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoIHJ2YWxpZGJyYWNlcywgXCJcIikpICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCBuZXcgRnVuY3Rpb24oIFwicmV0dXJuIFwiICsgZGF0YSApICkoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXJyb3IoIFwiSW52YWxpZCBKU09OOiBcIiArIGRhdGEgKTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcclxuICAgICAgICAgICAgcGFyc2VYTUw6IGZ1bmN0aW9uKCBkYXRhICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHhtbCwgdG1wO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHdpbmRvdy5ET01QYXJzZXIgKSB7IC8vIFN0YW5kYXJkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IG5ldyBET01QYXJzZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeG1sID0gdG1wLnBhcnNlRnJvbVN0cmluZyggZGF0YSAsIFwidGV4dC94bWxcIiApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIElFXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhtbCA9IG5ldyBBY3RpdmVYT2JqZWN0KCBcIk1pY3Jvc29mdC5YTUxET01cIiApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4bWwuYXN5bmMgPSBcImZhbHNlXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhtbC5sb2FkWE1MKCBkYXRhICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCggZSApIHtcclxuICAgICAgICAgICAgICAgICAgICB4bWwgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoICF4bWwgfHwgIXhtbC5kb2N1bWVudEVsZW1lbnQgfHwgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInBhcnNlcmVycm9yXCIgKS5sZW5ndGggKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmVycm9yKCBcIkludmFsaWQgWE1MOiBcIiArIGRhdGEgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB4bWw7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBub29wOiBmdW5jdGlvbigpIHt9LFxyXG5cclxuICAgICAgICAgICAgLy8gRXZhbHVhdGVzIGEgc2NyaXB0IGluIGEgZ2xvYmFsIGNvbnRleHRcclxuICAgICAgICAgICAgLy8gV29ya2Fyb3VuZHMgYmFzZWQgb24gZmluZGluZ3MgYnkgSmltIERyaXNjb2xsXHJcbiAgICAgICAgICAgIC8vIGh0dHA6Ly93ZWJsb2dzLmphdmEubmV0L2Jsb2cvZHJpc2NvbGwvYXJjaGl2ZS8yMDA5LzA5LzA4L2V2YWwtamF2YXNjcmlwdC1nbG9iYWwtY29udGV4dFxyXG4gICAgICAgICAgICBnbG9iYWxFdmFsOiBmdW5jdGlvbiggZGF0YSApIHtcclxuICAgICAgICAgICAgICAgIGlmICggZGF0YSAmJiBybm90d2hpdGUudGVzdCggZGF0YSApICkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHVzZSBleGVjU2NyaXB0IG9uIEludGVybmV0IEV4cGxvcmVyXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgdXNlIGFuIGFub255bW91cyBmdW5jdGlvbiBzbyB0aGF0IGNvbnRleHQgaXMgd2luZG93XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmF0aGVyIHRoYW4galF1ZXJ5IGluIEZpcmVmb3hcclxuICAgICAgICAgICAgICAgICAgICAoIHdpbmRvdy5leGVjU2NyaXB0IHx8IGZ1bmN0aW9uKCBkYXRhICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3dbIFwiZXZhbFwiIF0uY2FsbCggd2luZG93LCBkYXRhICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSApKCBkYXRhICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXHJcbiAgICAgICAgICAgIC8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3MilcclxuICAgICAgICAgICAgY2FtZWxDYXNlOiBmdW5jdGlvbiggc3RyaW5nICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBub2RlTmFtZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09IG5hbWUudG9VcHBlckNhc2UoKTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8vIGFyZ3MgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcclxuICAgICAgICAgICAgZWFjaDogZnVuY3Rpb24oIG9iamVjdCwgY2FsbGJhY2ssIGFyZ3MgKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSwgaSA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICBpc09iaiA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGpRdWVyeS5pc0Z1bmN0aW9uKCBvYmplY3QgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGFyZ3MgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpc09iaiApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggbmFtZSBpbiBvYmplY3QgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNhbGxiYWNrLmFwcGx5KCBvYmplY3RbIG5hbWUgXSwgYXJncyApID09PSBmYWxzZSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IGxlbmd0aDsgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNhbGxiYWNrLmFwcGx5KCBvYmplY3RbIGkrKyBdLCBhcmdzICkgPT09IGZhbHNlICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBBIHNwZWNpYWwsIGZhc3QsIGNhc2UgZm9yIHRoZSBtb3N0IGNvbW1vbiB1c2Ugb2YgZWFjaFxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGlzT2JqICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBuYW1lIGluIG9iamVjdCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY2FsbGJhY2suY2FsbCggb2JqZWN0WyBuYW1lIF0sIG5hbWUsIG9iamVjdFsgbmFtZSBdICkgPT09IGZhbHNlICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbGVuZ3RoOyApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY2FsbGJhY2suY2FsbCggb2JqZWN0WyBpIF0sIGksIG9iamVjdFsgaSsrIF0gKSA9PT0gZmFsc2UgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8vIFVzZSBuYXRpdmUgU3RyaW5nLnRyaW0gZnVuY3Rpb24gd2hlcmV2ZXIgcG9zc2libGVcclxuICAgICAgICAgICAgdHJpbTogdHJpbSA/XHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiggdGV4dCApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGV4dCA9PSBudWxsID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJcIiA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyaW0uY2FsbCggdGV4dCApO1xyXG4gICAgICAgICAgICAgICAgfSA6XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHVzZSBvdXIgb3duIHRyaW1taW5nIGZ1bmN0aW9uYWxpdHlcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCB0ZXh0ICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0ID09IG51bGwgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlwiIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dC50b1N0cmluZygpLnJlcGxhY2UoIHRyaW1MZWZ0LCBcIlwiICkucmVwbGFjZSggdHJpbVJpZ2h0LCBcIlwiICk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLy8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxyXG4gICAgICAgICAgICBtYWtlQXJyYXk6IGZ1bmN0aW9uKCBhcnJheSwgcmVzdWx0cyApIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggYXJyYXkgIT0gbnVsbCApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgd2luZG93LCBzdHJpbmdzIChhbmQgZnVuY3Rpb25zKSBhbHNvIGhhdmUgJ2xlbmd0aCdcclxuICAgICAgICAgICAgICAgICAgICAvLyBUd2Vha2VkIGxvZ2ljIHNsaWdodGx5IHRvIGhhbmRsZSBCbGFja2JlcnJ5IDQuNyBSZWdFeHAgaXNzdWVzICM2OTMwXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBqUXVlcnkudHlwZSggYXJyYXkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBhcnJheS5sZW5ndGggPT0gbnVsbCB8fCB0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGUgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlID09PSBcInJlZ2V4cFwiIHx8IGpRdWVyeS5pc1dpbmRvdyggYXJyYXkgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHVzaC5jYWxsKCByZXQsIGFycmF5ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lm1lcmdlKCByZXQsIGFycmF5ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBpbkFycmF5OiBmdW5jdGlvbiggZWxlbSwgYXJyYXksIGkgKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVuO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggYXJyYXkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpbmRleE9mICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXhPZi5jYWxsKCBhcnJheSwgZWxlbSwgaSApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGVuID0gYXJyYXkubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGkgPSBpID8gaSA8IDAgPyBNYXRoLm1heCggMCwgbGVuICsgaSApIDogaSA6IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIGFjY2Vzc2luZyBpbiBzcGFyc2UgYXJyYXlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaSBpbiBhcnJheSAmJiBhcnJheVsgaSBdID09PSBlbGVtICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgbWVyZ2U6IGZ1bmN0aW9uKCBmaXJzdCwgc2Vjb25kICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGkgPSBmaXJzdC5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgaiA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCB0eXBlb2Ygc2Vjb25kLmxlbmd0aCA9PT0gXCJudW1iZXJcIiApIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgbCA9IHNlY29uZC5sZW5ndGg7IGogPCBsOyBqKysgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaiBdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICggc2Vjb25kW2pdICE9PSB1bmRlZmluZWQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaisrIF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZpcnN0Lmxlbmd0aCA9IGk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0O1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgZ3JlcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgaW52ICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IFtdLCByZXRWYWw7XHJcbiAgICAgICAgICAgICAgICBpbnYgPSAhIWludjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXHJcbiAgICAgICAgICAgICAgICAvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsZW5ndGggPSBlbGVtcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKyApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXRWYWwgPSAhIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpbnYgIT09IHJldFZhbCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goIGVsZW1zWyBpIF0gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxyXG4gICAgICAgICAgICBtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSwga2V5LCByZXQgPSBbXSxcclxuICAgICAgICAgICAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBlbGVtcy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAvLyBqcXVlcnkgb2JqZWN0cyBhcmUgdHJlYXRlZCBhcyBhcnJheXNcclxuICAgICAgICAgICAgICAgICAgICBpc0FycmF5ID0gZWxlbXMgaW5zdGFuY2VvZiBqUXVlcnkgfHwgbGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiAoICggbGVuZ3RoID4gMCAmJiBlbGVtc1sgMCBdICYmIGVsZW1zWyBsZW5ndGggLTEgXSApIHx8IGxlbmd0aCA9PT0gMCB8fCBqUXVlcnkuaXNBcnJheSggZWxlbXMgKSApIDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXJcclxuICAgICAgICAgICAgICAgIGlmICggaXNBcnJheSApIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHZhbHVlICE9IG51bGwgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXRbIHJldC5sZW5ndGggXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCBrZXkgaW4gZWxlbXMgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBrZXkgXSwga2V5LCBhcmcgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdmFsdWUgIT0gbnVsbCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldFsgcmV0Lmxlbmd0aCBdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldC5jb25jYXQuYXBwbHkoIFtdLCByZXQgKTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xyXG4gICAgICAgICAgICBndWlkOiAxLFxyXG5cclxuICAgICAgICAgICAgLy8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XHJcbiAgICAgICAgICAgIC8vIGFyZ3VtZW50cy5cclxuICAgICAgICAgICAgcHJveHk6IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcclxuICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRtcCA9IGZuWyBjb250ZXh0IF07XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IGZuO1xyXG4gICAgICAgICAgICAgICAgICAgIGZuID0gdG1wO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxyXG4gICAgICAgICAgICAgICAgaWYgKCAhalF1ZXJ5LmlzRnVuY3Rpb24oIGZuICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTaW11bGF0ZWQgYmluZFxyXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKSxcclxuICAgICAgICAgICAgICAgICAgICBwcm94eSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQsIGFyZ3MuY29uY2F0KCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcclxuICAgICAgICAgICAgICAgIHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBwcm94eS5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3h5O1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLy8gTXV0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyB0byBhIGNvbGxlY3Rpb25cclxuICAgICAgICAgICAgLy8gVGhlIHZhbHVlL3MgY2FuIG9wdGlvbmFsbHkgYmUgZXhlY3V0ZWQgaWYgaXQncyBhIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgIGFjY2VzczogZnVuY3Rpb24oIGVsZW1zLCBrZXksIHZhbHVlLCBleGVjLCBmbiwgcGFzcyApIHtcclxuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBlbGVtcy5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU2V0dGluZyBtYW55IGF0dHJpYnV0ZXNcclxuICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgayBpbiBrZXkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5hY2Nlc3MoIGVsZW1zLCBrLCBrZXlba10sIGV4ZWMsIGZuLCB2YWx1ZSApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU2V0dGluZyBvbmUgYXR0cmlidXRlXHJcbiAgICAgICAgICAgICAgICBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW9uYWxseSwgZnVuY3Rpb24gdmFsdWVzIGdldCBleGVjdXRlZCBpZiBleGVjIGlzIHRydWVcclxuICAgICAgICAgICAgICAgICAgICBleGVjID0gIXBhc3MgJiYgZXhlYyAmJiBqUXVlcnkuaXNGdW5jdGlvbih2YWx1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbiggZWxlbXNbaV0sIGtleSwgZXhlYyA/IHZhbHVlLmNhbGwoIGVsZW1zW2ldLCBpLCBmbiggZWxlbXNbaV0sIGtleSApICkgOiB2YWx1ZSwgcGFzcyApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1zO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEdldHRpbmcgYW4gYXR0cmlidXRlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVuZ3RoID8gZm4oIGVsZW1zWzBdLCBrZXkgKSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIG5vdzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKCBuZXcgRGF0ZSgpICkuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLy8gVXNlIG9mIGpRdWVyeS5icm93c2VyIGlzIGZyb3duZWQgdXBvbi5cclxuICAgICAgICAgICAgLy8gTW9yZSBkZXRhaWxzOiBodHRwOi8vZG9jcy5qcXVlcnkuY29tL1V0aWxpdGllcy9qUXVlcnkuYnJvd3NlclxyXG4gICAgICAgICAgICB1YU1hdGNoOiBmdW5jdGlvbiggdWEgKSB7XHJcbiAgICAgICAgICAgICAgICB1YSA9IHVhLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gcndlYmtpdC5leGVjKCB1YSApIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgcm9wZXJhLmV4ZWMoIHVhICkgfHxcclxuICAgICAgICAgICAgICAgICAgICBybXNpZS5leGVjKCB1YSApIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgdWEuaW5kZXhPZihcImNvbXBhdGlibGVcIikgPCAwICYmIHJtb3ppbGxhLmV4ZWMoIHVhICkgfHxcclxuICAgICAgICAgICAgICAgICAgICBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBicm93c2VyOiBtYXRjaFsxXSB8fCBcIlwiLCB2ZXJzaW9uOiBtYXRjaFsyXSB8fCBcIjBcIiB9O1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgc3ViOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGpRdWVyeVN1Yiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBqUXVlcnlTdWIuZm4uaW5pdCggc2VsZWN0b3IsIGNvbnRleHQgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGpRdWVyeS5leHRlbmQoIHRydWUsIGpRdWVyeVN1YiwgdGhpcyApO1xyXG4gICAgICAgICAgICAgICAgalF1ZXJ5U3ViLnN1cGVyY2xhc3MgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgalF1ZXJ5U3ViLmZuID0galF1ZXJ5U3ViLnByb3RvdHlwZSA9IHRoaXMoKTtcclxuICAgICAgICAgICAgICAgIGpRdWVyeVN1Yi5mbi5jb25zdHJ1Y3RvciA9IGpRdWVyeVN1YjtcclxuICAgICAgICAgICAgICAgIGpRdWVyeVN1Yi5zdWIgPSB0aGlzLnN1YjtcclxuICAgICAgICAgICAgICAgIGpRdWVyeVN1Yi5mbi5pbml0ID0gZnVuY3Rpb24gaW5pdCggc2VsZWN0b3IsIGNvbnRleHQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjb250ZXh0ICYmIGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgJiYgIShjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5U3ViKSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IGpRdWVyeVN1YiggY29udGV4dCApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5mbi5pbml0LmNhbGwoIHRoaXMsIHNlbGVjdG9yLCBjb250ZXh0LCByb290alF1ZXJ5U3ViICk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgalF1ZXJ5U3ViLmZuLmluaXQucHJvdG90eXBlID0galF1ZXJ5U3ViLmZuO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJvb3RqUXVlcnlTdWIgPSBqUXVlcnlTdWIoZG9jdW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeVN1YjtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGJyb3dzZXI6IHt9XHJcbiAgICAgICAgfSk7XHJcblxyXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcclxuICAgICAgICBqUXVlcnkuZWFjaChcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3RcIi5zcGxpdChcIiBcIiksIGZ1bmN0aW9uKGksIG5hbWUpIHtcclxuICAgICAgICAgICAgY2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGJyb3dzZXJNYXRjaCA9IGpRdWVyeS51YU1hdGNoKCB1c2VyQWdlbnQgKTtcclxuICAgICAgICBpZiAoIGJyb3dzZXJNYXRjaC5icm93c2VyICkge1xyXG4gICAgICAgICAgICBqUXVlcnkuYnJvd3NlclsgYnJvd3Nlck1hdGNoLmJyb3dzZXIgXSA9IHRydWU7XHJcbiAgICAgICAgICAgIGpRdWVyeS5icm93c2VyLnZlcnNpb24gPSBicm93c2VyTWF0Y2gudmVyc2lvbjtcclxuICAgICAgICB9XHJcblxyXG4vLyBEZXByZWNhdGVkLCB1c2UgalF1ZXJ5LmJyb3dzZXIud2Via2l0IGluc3RlYWRcclxuICAgICAgICBpZiAoIGpRdWVyeS5icm93c2VyLndlYmtpdCApIHtcclxuICAgICAgICAgICAgalF1ZXJ5LmJyb3dzZXIuc2FmYXJpID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4vLyBJRSBkb2Vzbid0IG1hdGNoIG5vbi1icmVha2luZyBzcGFjZXMgd2l0aCBcXHNcclxuICAgICAgICBpZiAoIHJub3R3aGl0ZS50ZXN0KCBcIlxceEEwXCIgKSApIHtcclxuICAgICAgICAgICAgdHJpbUxlZnQgPSAvXltcXHNcXHhBMF0rLztcclxuICAgICAgICAgICAgdHJpbVJpZ2h0ID0gL1tcXHNcXHhBMF0rJC87XHJcbiAgICAgICAgfVxyXG5cclxuLy8gQWxsIGpRdWVyeSBvYmplY3RzIHNob3VsZCBwb2ludCBiYWNrIHRvIHRoZXNlXHJcbiAgICAgICAgcm9vdGpRdWVyeSA9IGpRdWVyeShkb2N1bWVudCk7XHJcblxyXG4vLyBDbGVhbnVwIGZ1bmN0aW9ucyBmb3IgdGhlIGRvY3VtZW50IHJlYWR5IG1ldGhvZFxyXG4gICAgICAgIGlmICggZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciApIHtcclxuICAgICAgICAgICAgRE9NQ29udGVudExvYWRlZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIERPTUNvbnRlbnRMb2FkZWQsIGZhbHNlICk7XHJcbiAgICAgICAgICAgICAgICBqUXVlcnkucmVhZHkoKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICggZG9jdW1lbnQuYXR0YWNoRXZlbnQgKSB7XHJcbiAgICAgICAgICAgIERPTUNvbnRlbnRMb2FkZWQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBib2R5IGV4aXN0cywgYXQgbGVhc3QsIGluIGNhc2UgSUUgZ2V0cyBhIGxpdHRsZSBvdmVyemVhbG91cyAodGlja2V0ICM1NDQzKS5cclxuICAgICAgICAgICAgICAgIGlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRldGFjaEV2ZW50KCBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiLCBET01Db250ZW50TG9hZGVkICk7XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnJlYWR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuLy8gVGhlIERPTSByZWFkeSBjaGVjayBmb3IgSW50ZXJuZXQgRXhwbG9yZXJcclxuICAgICAgICBmdW5jdGlvbiBkb1Njcm9sbENoZWNrKCkge1xyXG4gICAgICAgICAgICBpZiAoIGpRdWVyeS5pc1JlYWR5ICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgSUUgaXMgdXNlZCwgdXNlIHRoZSB0cmljayBieSBEaWVnbyBQZXJpbmlcclxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9qYXZhc2NyaXB0Lm53Ym94LmNvbS9JRUNvbnRlbnRMb2FkZWQvXHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwoXCJsZWZ0XCIpO1xyXG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoIGRvU2Nyb2xsQ2hlY2ssIDEgKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gYW5kIGV4ZWN1dGUgYW55IHdhaXRpbmcgZnVuY3Rpb25zXHJcbiAgICAgICAgICAgIGpRdWVyeS5yZWFkeSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGpRdWVyeTtcclxuXHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbi8vIFN0cmluZyB0byBPYmplY3QgZmxhZ3MgZm9ybWF0IGNhY2hlXHJcbiAgICB2YXIgZmxhZ3NDYWNoZSA9IHt9O1xyXG5cclxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIGZsYWdzIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzIGFuZCBzdG9yZSBpbiBjYWNoZVxyXG4gICAgZnVuY3Rpb24gY3JlYXRlRmxhZ3MoIGZsYWdzICkge1xyXG4gICAgICAgIHZhciBvYmplY3QgPSBmbGFnc0NhY2hlWyBmbGFncyBdID0ge30sXHJcbiAgICAgICAgICAgIGksIGxlbmd0aDtcclxuICAgICAgICBmbGFncyA9IGZsYWdzLnNwbGl0KCAvXFxzKy8gKTtcclxuICAgICAgICBmb3IgKCBpID0gMCwgbGVuZ3RoID0gZmxhZ3MubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKysgKSB7XHJcbiAgICAgICAgICAgIG9iamVjdFsgZmxhZ3NbaV0gXSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvYmplY3Q7XHJcbiAgICB9XHJcblxyXG4gICAgLypcclxuICAgICAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxyXG4gICAgICpcclxuICAgICAqXHRmbGFnczpcdGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIGZsYWdzIHRoYXQgd2lsbCBjaGFuZ2UgaG93XHJcbiAgICAgKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXNcclxuICAgICAqXHJcbiAgICAgKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxyXG4gICAgICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxyXG4gICAgICpcclxuICAgICAqIFBvc3NpYmxlIGZsYWdzOlxyXG4gICAgICpcclxuICAgICAqXHRvbmNlOlx0XHRcdHdpbGwgZW5zdXJlIHRoZSBjYWxsYmFjayBsaXN0IGNhbiBvbmx5IGJlIGZpcmVkIG9uY2UgKGxpa2UgYSBEZWZlcnJlZClcclxuICAgICAqXHJcbiAgICAgKlx0bWVtb3J5Olx0XHRcdHdpbGwga2VlcCB0cmFjayBvZiBwcmV2aW91cyB2YWx1ZXMgYW5kIHdpbGwgY2FsbCBhbnkgY2FsbGJhY2sgYWRkZWRcclxuICAgICAqXHRcdFx0XHRcdGFmdGVyIHRoZSBsaXN0IGhhcyBiZWVuIGZpcmVkIHJpZ2h0IGF3YXkgd2l0aCB0aGUgbGF0ZXN0IFwibWVtb3JpemVkXCJcclxuICAgICAqXHRcdFx0XHRcdHZhbHVlcyAobGlrZSBhIERlZmVycmVkKVxyXG4gICAgICpcclxuICAgICAqXHR1bmlxdWU6XHRcdFx0d2lsbCBlbnN1cmUgYSBjYWxsYmFjayBjYW4gb25seSBiZSBhZGRlZCBvbmNlIChubyBkdXBsaWNhdGUgaW4gdGhlIGxpc3QpXHJcbiAgICAgKlxyXG4gICAgICpcdHN0b3BPbkZhbHNlOlx0aW50ZXJydXB0IGNhbGxpbmdzIHdoZW4gYSBjYWxsYmFjayByZXR1cm5zIGZhbHNlXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBqUXVlcnkuQ2FsbGJhY2tzID0gZnVuY3Rpb24oIGZsYWdzICkge1xyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IGZsYWdzIGZyb20gU3RyaW5nLWZvcm1hdHRlZCB0byBPYmplY3QtZm9ybWF0dGVkXHJcbiAgICAgICAgLy8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxyXG4gICAgICAgIGZsYWdzID0gZmxhZ3MgPyAoIGZsYWdzQ2FjaGVbIGZsYWdzIF0gfHwgY3JlYXRlRmxhZ3MoIGZsYWdzICkgKSA6IHt9O1xyXG5cclxuICAgICAgICB2YXIgLy8gQWN0dWFsIGNhbGxiYWNrIGxpc3RcclxuICAgICAgICAgICAgbGlzdCA9IFtdLFxyXG4gICAgICAgIC8vIFN0YWNrIG9mIGZpcmUgY2FsbHMgZm9yIHJlcGVhdGFibGUgbGlzdHNcclxuICAgICAgICAgICAgc3RhY2sgPSBbXSxcclxuICAgICAgICAvLyBMYXN0IGZpcmUgdmFsdWUgKGZvciBub24tZm9yZ2V0dGFibGUgbGlzdHMpXHJcbiAgICAgICAgICAgIG1lbW9yeSxcclxuICAgICAgICAvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXHJcbiAgICAgICAgICAgIGZpcmluZyxcclxuICAgICAgICAvLyBGaXJzdCBjYWxsYmFjayB0byBmaXJlICh1c2VkIGludGVybmFsbHkgYnkgYWRkIGFuZCBmaXJlV2l0aClcclxuICAgICAgICAgICAgZmlyaW5nU3RhcnQsXHJcbiAgICAgICAgLy8gRW5kIG9mIHRoZSBsb29wIHdoZW4gZmlyaW5nXHJcbiAgICAgICAgICAgIGZpcmluZ0xlbmd0aCxcclxuICAgICAgICAvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSByZW1vdmUgaWYgbmVlZGVkKVxyXG4gICAgICAgICAgICBmaXJpbmdJbmRleCxcclxuICAgICAgICAvLyBBZGQgb25lIG9yIHNldmVyYWwgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XHJcbiAgICAgICAgICAgIGFkZCA9IGZ1bmN0aW9uKCBhcmdzICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGksXHJcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgIGVsZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZSxcclxuICAgICAgICAgICAgICAgICAgICBhY3R1YWw7XHJcbiAgICAgICAgICAgICAgICBmb3IgKCBpID0gMCwgbGVuZ3RoID0gYXJncy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKyApIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtID0gYXJnc1sgaSBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBqUXVlcnkudHlwZSggZWxlbSApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggdHlwZSA9PT0gXCJhcnJheVwiICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZCggZWxlbSApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHR5cGUgPT09IFwiZnVuY3Rpb25cIiApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGlmIG5vdCBpbiB1bmlxdWUgbW9kZSBhbmQgY2FsbGJhY2sgaXMgbm90IGluXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIWZsYWdzLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGVsZW0gKSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QucHVzaCggZWxlbSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIC8vIEZpcmUgY2FsbGJhY2tzXHJcbiAgICAgICAgICAgIGZpcmUgPSBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcclxuICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgbWVtb3J5ID0gIWZsYWdzLm1lbW9yeSB8fCBbIGNvbnRleHQsIGFyZ3MgXTtcclxuICAgICAgICAgICAgICAgIGZpcmluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBmaXJpbmdJbmRleCA9IGZpcmluZ1N0YXJ0IHx8IDA7XHJcbiAgICAgICAgICAgICAgICBmaXJpbmdTdGFydCA9IDA7XHJcbiAgICAgICAgICAgICAgICBmaXJpbmdMZW5ndGggPSBsaXN0Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGZvciAoIDsgbGlzdCAmJiBmaXJpbmdJbmRleCA8IGZpcmluZ0xlbmd0aDsgZmlyaW5nSW5kZXgrKyApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGxpc3RbIGZpcmluZ0luZGV4IF0uYXBwbHkoIGNvbnRleHQsIGFyZ3MgKSA9PT0gZmFsc2UgJiYgZmxhZ3Muc3RvcE9uRmFsc2UgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbW9yeSA9IHRydWU7IC8vIE1hcmsgYXMgaGFsdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZpcmluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCBsaXN0ICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggIWZsYWdzLm9uY2UgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc3RhY2sgJiYgc3RhY2subGVuZ3RoICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVtb3J5ID0gc3RhY2suc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZmlyZVdpdGgoIG1lbW9yeVsgMCBdLCBtZW1vcnlbIDEgXSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggbWVtb3J5ID09PSB0cnVlICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmRpc2FibGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIC8vIEFjdHVhbCBDYWxsYmFja3Mgb2JqZWN0XHJcbiAgICAgICAgICAgIHNlbGYgPSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XHJcbiAgICAgICAgICAgICAgICBhZGQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggbGlzdCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGQoIGFyZ3VtZW50cyApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyB3ZSBuZWVkIHRvIGFkZCB0aGUgY2FsbGJhY2tzIHRvIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjdXJyZW50IGZpcmluZyBiYXRjaD9cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBmaXJpbmcgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJpbmdMZW5ndGggPSBsaXN0Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdpdGggbWVtb3J5LCBpZiB3ZSdyZSBub3QgZmlyaW5nIHRoZW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHNob3VsZCBjYWxsIHJpZ2h0IGF3YXksIHVubGVzcyBwcmV2aW91c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmlyaW5nIHdhcyBoYWx0ZWQgKHN0b3BPbkZhbHNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBtZW1vcnkgJiYgbWVtb3J5ICE9PSB0cnVlICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyaW5nU3RhcnQgPSBsZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJlKCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XHJcbiAgICAgICAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggbGlzdCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdJbmRleCA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdMZW5ndGggPSBhcmdzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggOyBhcmdJbmRleCA8IGFyZ0xlbmd0aCA7IGFyZ0luZGV4KysgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggYXJnc1sgYXJnSW5kZXggXSA9PT0gbGlzdFsgaSBdICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgZmlyaW5nSW5kZXggYW5kIGZpcmluZ0xlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGZpcmluZyApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaSA8PSBmaXJpbmdMZW5ndGggKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyaW5nTGVuZ3RoLS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpIDw9IGZpcmluZ0luZGV4ICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJpbmdJbmRleC0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdC5zcGxpY2UoIGktLSwgMSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIHNvbWUgdW5pY2l0eSBwcm9wZXJ0eSB0aGVuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIG9ubHkgbmVlZCB0byBkbyB0aGlzIG9uY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBmbGFncy51bmlxdWUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvLyBDb250cm9sIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3RcclxuICAgICAgICAgICAgICAgIGhhczogZnVuY3Rpb24oIGZuICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggbGlzdCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBmbiA9PT0gbGlzdFsgaSBdICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XHJcbiAgICAgICAgICAgICAgICBlbXB0eTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8vIEhhdmUgdGhlIGxpc3QgZG8gbm90aGluZyBhbnltb3JlXHJcbiAgICAgICAgICAgICAgICBkaXNhYmxlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ID0gc3RhY2sgPSBtZW1vcnkgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLy8gSXMgaXQgZGlzYWJsZWQ/XHJcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFsaXN0O1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8vIExvY2sgdGhlIGxpc3QgaW4gaXRzIGN1cnJlbnQgc3RhdGVcclxuICAgICAgICAgICAgICAgIGxvY2s6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggIW1lbW9yeSB8fCBtZW1vcnkgPT09IHRydWUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZGlzYWJsZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvLyBJcyBpdCBsb2NrZWQ/XHJcbiAgICAgICAgICAgICAgICBsb2NrZWQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhc3RhY2s7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLy8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xyXG4gICAgICAgICAgICAgICAgZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggc3RhY2sgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZmlyaW5nICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhZmxhZ3Mub25jZSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKCBbIGNvbnRleHQsIGFyZ3MgXSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCAhKCBmbGFncy5vbmNlICYmIG1lbW9yeSApICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyZSggY29udGV4dCwgYXJncyApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXHJcbiAgICAgICAgICAgICAgICBmaXJlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmZpcmVXaXRoKCB0aGlzLCBhcmd1bWVudHMgKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvLyBUbyBrbm93IGlmIHRoZSBjYWxsYmFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2VcclxuICAgICAgICAgICAgICAgIGZpcmVkOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISFtZW1vcnk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgfTtcclxuXHJcblxyXG5cclxuXHJcbiAgICB2YXIgLy8gU3RhdGljIHJlZmVyZW5jZSB0byBzbGljZVxyXG4gICAgICAgIHNsaWNlRGVmZXJyZWQgPSBbXS5zbGljZTtcclxuXHJcbiAgICBqUXVlcnkuZXh0ZW5kKHtcclxuXHJcbiAgICAgICAgRGVmZXJyZWQ6IGZ1bmN0aW9uKCBmdW5jICkge1xyXG4gICAgICAgICAgICB2YXIgZG9uZUxpc3QgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcclxuICAgICAgICAgICAgICAgIGZhaWxMaXN0ID0galF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXHJcbiAgICAgICAgICAgICAgICBwcm9ncmVzc0xpc3QgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksXHJcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IFwicGVuZGluZ1wiLFxyXG4gICAgICAgICAgICAgICAgbGlzdHMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZTogZG9uZUxpc3QsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0OiBmYWlsTGlzdCxcclxuICAgICAgICAgICAgICAgICAgICBub3RpZnk6IHByb2dyZXNzTGlzdFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHByb21pc2UgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9uZTogZG9uZUxpc3QuYWRkLFxyXG4gICAgICAgICAgICAgICAgICAgIGZhaWw6IGZhaWxMaXN0LmFkZCxcclxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzczogcHJvZ3Jlc3NMaXN0LmFkZCxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVwcmVjYXRlZFxyXG4gICAgICAgICAgICAgICAgICAgIGlzUmVzb2x2ZWQ6IGRvbmVMaXN0LmZpcmVkLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzUmVqZWN0ZWQ6IGZhaWxMaXN0LmZpcmVkLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGVuOiBmdW5jdGlvbiggZG9uZUNhbGxiYWNrcywgZmFpbENhbGxiYWNrcywgcHJvZ3Jlc3NDYWxsYmFja3MgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLmRvbmUoIGRvbmVDYWxsYmFja3MgKS5mYWlsKCBmYWlsQ2FsbGJhY2tzICkucHJvZ3Jlc3MoIHByb2dyZXNzQ2FsbGJhY2tzICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgYWx3YXlzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQuZG9uZS5hcHBseSggZGVmZXJyZWQsIGFyZ3VtZW50cyApLmZhaWwuYXBwbHkoIGRlZmVycmVkLCBhcmd1bWVudHMgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBwaXBlOiBmdW5jdGlvbiggZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkuRGVmZXJyZWQoZnVuY3Rpb24oIG5ld0RlZmVyICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmVhY2goIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lOiBbIGZuRG9uZSwgXCJyZXNvbHZlXCIgXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsOiBbIGZuRmFpbCwgXCJyZWplY3RcIiBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzOiBbIGZuUHJvZ3Jlc3MsIFwibm90aWZ5XCIgXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oIGhhbmRsZXIsIGRhdGEgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gZGF0YVsgMCBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24gPSBkYXRhWyAxIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGZuICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkWyBoYW5kbGVyIF0oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5lZCA9IGZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcmV0dXJuZWQgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHJldHVybmVkLnByb21pc2UgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5lZC5wcm9taXNlKCkudGhlbiggbmV3RGVmZXIucmVzb2x2ZSwgbmV3RGVmZXIucmVqZWN0LCBuZXdEZWZlci5ub3RpZnkgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RGVmZXJbIGFjdGlvbiArIFwiV2l0aFwiIF0oIHRoaXMgPT09IGRlZmVycmVkID8gbmV3RGVmZXIgOiB0aGlzLCBbIHJldHVybmVkIF0gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWRbIGhhbmRsZXIgXSggbmV3RGVmZXJbIGFjdGlvbiBdICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLnByb21pc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCBhIHByb21pc2UgZm9yIHRoaXMgZGVmZXJyZWRcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBvYmogPT0gbnVsbCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IHByb21pc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIga2V5IGluIHByb21pc2UgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqWyBrZXkgXSA9IHByb21pc2VbIGtleSBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGRlZmVycmVkID0gcHJvbWlzZS5wcm9taXNlKHt9KSxcclxuICAgICAgICAgICAgICAgIGtleTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIGtleSBpbiBsaXN0cyApIHtcclxuICAgICAgICAgICAgICAgIGRlZmVycmVkWyBrZXkgXSA9IGxpc3RzWyBrZXkgXS5maXJlO1xyXG4gICAgICAgICAgICAgICAgZGVmZXJyZWRbIGtleSArIFwiV2l0aFwiIF0gPSBsaXN0c1sga2V5IF0uZmlyZVdpdGg7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEhhbmRsZSBzdGF0ZVxyXG4gICAgICAgICAgICBkZWZlcnJlZC5kb25lKCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHN0YXRlID0gXCJyZXNvbHZlZFwiO1xyXG4gICAgICAgICAgICB9LCBmYWlsTGlzdC5kaXNhYmxlLCBwcm9ncmVzc0xpc3QubG9jayApLmZhaWwoIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgc3RhdGUgPSBcInJlamVjdGVkXCI7XHJcbiAgICAgICAgICAgIH0sIGRvbmVMaXN0LmRpc2FibGUsIHByb2dyZXNzTGlzdC5sb2NrICk7XHJcblxyXG4gICAgICAgICAgICAvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XHJcbiAgICAgICAgICAgIGlmICggZnVuYyApIHtcclxuICAgICAgICAgICAgICAgIGZ1bmMuY2FsbCggZGVmZXJyZWQsIGRlZmVycmVkICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFsbCBkb25lIVxyXG4gICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gRGVmZXJyZWQgaGVscGVyXHJcbiAgICAgICAgd2hlbjogZnVuY3Rpb24oIGZpcnN0UGFyYW0gKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gc2xpY2VEZWZlcnJlZC5jYWxsKCBhcmd1bWVudHMsIDAgKSxcclxuICAgICAgICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICBwVmFsdWVzID0gbmV3IEFycmF5KCBsZW5ndGggKSxcclxuICAgICAgICAgICAgICAgIGNvdW50ID0gbGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgcENvdW50ID0gbGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQgPSBsZW5ndGggPD0gMSAmJiBmaXJzdFBhcmFtICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBmaXJzdFBhcmFtLnByb21pc2UgKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RQYXJhbSA6XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LkRlZmVycmVkKCksXHJcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gZGVmZXJyZWQucHJvbWlzZSgpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiByZXNvbHZlRnVuYyggaSApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJnc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZURlZmVycmVkLmNhbGwoIGFyZ3VtZW50cywgMCApIDogdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhKCAtLWNvdW50ICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmVXaXRoKCBkZWZlcnJlZCwgYXJncyApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gcHJvZ3Jlc3NGdW5jKCBpICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcclxuICAgICAgICAgICAgICAgICAgICBwVmFsdWVzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlRGVmZXJyZWQuY2FsbCggYXJndW1lbnRzLCAwICkgOiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5ub3RpZnlXaXRoKCBwcm9taXNlLCBwVmFsdWVzICk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICggbGVuZ3RoID4gMSApIHtcclxuICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggYXJnc1sgaSBdICYmIGFyZ3NbIGkgXS5wcm9taXNlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBhcmdzWyBpIF0ucHJvbWlzZSApICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzWyBpIF0ucHJvbWlzZSgpLnRoZW4oIHJlc29sdmVGdW5jKGkpLCBkZWZlcnJlZC5yZWplY3QsIHByb2dyZXNzRnVuYyhpKSApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC0tY291bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCAhY291bnQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGRlZmVycmVkLCBhcmdzICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGRlZmVycmVkICE9PSBmaXJzdFBhcmFtICkge1xyXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGRlZmVycmVkLCBsZW5ndGggPyBbIGZpcnN0UGFyYW0gXSA6IFtdICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG5cclxuXHJcblxyXG4gICAgalF1ZXJ5LnN1cHBvcnQgPSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIHZhciBzdXBwb3J0LFxyXG4gICAgICAgICAgICBhbGwsXHJcbiAgICAgICAgICAgIGEsXHJcbiAgICAgICAgICAgIHNlbGVjdCxcclxuICAgICAgICAgICAgb3B0LFxyXG4gICAgICAgICAgICBpbnB1dCxcclxuICAgICAgICAgICAgbWFyZ2luRGl2LFxyXG4gICAgICAgICAgICBmcmFnbWVudCxcclxuICAgICAgICAgICAgdGRzLFxyXG4gICAgICAgICAgICBldmVudHMsXHJcbiAgICAgICAgICAgIGV2ZW50TmFtZSxcclxuICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgaXNTdXBwb3J0ZWQsXHJcbiAgICAgICAgICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSxcclxuICAgICAgICAgICAgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xyXG5cclxuICAgICAgICAvLyBQcmVsaW1pbmFyeSB0ZXN0c1xyXG4gICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJjbGFzc05hbWVcIiwgXCJ0XCIpO1xyXG4gICAgICAgIGRpdi5pbm5lckhUTUwgPSBcIiAgIDxsaW5rLz48dGFibGU+PC90YWJsZT48YSBocmVmPScvYScgc3R5bGU9J3RvcDoxcHg7ZmxvYXQ6bGVmdDtvcGFjaXR5Oi41NTsnPmE8L2E+PGlucHV0IHR5cGU9J2NoZWNrYm94Jy8+XCI7XHJcblxyXG4gICAgICAgIGFsbCA9IGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCIqXCIgKTtcclxuICAgICAgICBhID0gZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcImFcIiApWyAwIF07XHJcblxyXG4gICAgICAgIC8vIENhbid0IGdldCBiYXNpYyB0ZXN0IHN1cHBvcnRcclxuICAgICAgICBpZiAoICFhbGwgfHwgIWFsbC5sZW5ndGggfHwgIWEgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7fTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZpcnN0IGJhdGNoIG9mIHN1cHBvcnRzIHRlc3RzXHJcbiAgICAgICAgc2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzZWxlY3RcIiApO1xyXG4gICAgICAgIG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKSApO1xyXG4gICAgICAgIGlucHV0ID0gZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcImlucHV0XCIgKVsgMCBdO1xyXG5cclxuICAgICAgICBzdXBwb3J0ID0ge1xyXG4gICAgICAgICAgICAvLyBJRSBzdHJpcHMgbGVhZGluZyB3aGl0ZXNwYWNlIHdoZW4gLmlubmVySFRNTCBpcyB1c2VkXHJcbiAgICAgICAgICAgIGxlYWRpbmdXaGl0ZXNwYWNlOiAoIGRpdi5maXJzdENoaWxkLm5vZGVUeXBlID09PSAzICksXHJcblxyXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0Ym9keSBlbGVtZW50cyBhcmVuJ3QgYXV0b21hdGljYWxseSBpbnNlcnRlZFxyXG4gICAgICAgICAgICAvLyBJRSB3aWxsIGluc2VydCB0aGVtIGludG8gZW1wdHkgdGFibGVzXHJcbiAgICAgICAgICAgIHRib2R5OiAhZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidGJvZHlcIikubGVuZ3RoLFxyXG5cclxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgbGluayBlbGVtZW50cyBnZXQgc2VyaWFsaXplZCBjb3JyZWN0bHkgYnkgaW5uZXJIVE1MXHJcbiAgICAgICAgICAgIC8vIFRoaXMgcmVxdWlyZXMgYSB3cmFwcGVyIGVsZW1lbnQgaW4gSUVcclxuICAgICAgICAgICAgaHRtbFNlcmlhbGl6ZTogISFkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJsaW5rXCIpLmxlbmd0aCxcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgc3R5bGUgaW5mb3JtYXRpb24gZnJvbSBnZXRBdHRyaWJ1dGVcclxuICAgICAgICAgICAgLy8gKElFIHVzZXMgLmNzc1RleHQgaW5zdGVhZClcclxuICAgICAgICAgICAgc3R5bGU6IC90b3AvLnRlc3QoIGEuZ2V0QXR0cmlidXRlKFwic3R5bGVcIikgKSxcclxuXHJcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IFVSTHMgYXJlbid0IG1hbmlwdWxhdGVkXHJcbiAgICAgICAgICAgIC8vIChJRSBub3JtYWxpemVzIGl0IGJ5IGRlZmF1bHQpXHJcbiAgICAgICAgICAgIGhyZWZOb3JtYWxpemVkOiAoIGEuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIvYVwiICksXHJcblxyXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBlbGVtZW50IG9wYWNpdHkgZXhpc3RzXHJcbiAgICAgICAgICAgIC8vIChJRSB1c2VzIGZpbHRlciBpbnN0ZWFkKVxyXG4gICAgICAgICAgICAvLyBVc2UgYSByZWdleCB0byB3b3JrIGFyb3VuZCBhIFdlYktpdCBpc3N1ZS4gU2VlICM1MTQ1XHJcbiAgICAgICAgICAgIG9wYWNpdHk6IC9eMC41NS8udGVzdCggYS5zdHlsZS5vcGFjaXR5ICksXHJcblxyXG4gICAgICAgICAgICAvLyBWZXJpZnkgc3R5bGUgZmxvYXQgZXhpc3RlbmNlXHJcbiAgICAgICAgICAgIC8vIChJRSB1c2VzIHN0eWxlRmxvYXQgaW5zdGVhZCBvZiBjc3NGbG9hdClcclxuICAgICAgICAgICAgY3NzRmxvYXQ6ICEhYS5zdHlsZS5jc3NGbG9hdCxcclxuXHJcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGlmIG5vIHZhbHVlIGlzIHNwZWNpZmllZCBmb3IgYSBjaGVja2JveFxyXG4gICAgICAgICAgICAvLyB0aGF0IGl0IGRlZmF1bHRzIHRvIFwib25cIi5cclxuICAgICAgICAgICAgLy8gKFdlYktpdCBkZWZhdWx0cyB0byBcIlwiIGluc3RlYWQpXHJcbiAgICAgICAgICAgIGNoZWNrT246ICggaW5wdXQudmFsdWUgPT09IFwib25cIiApLFxyXG5cclxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgYSBzZWxlY3RlZC1ieS1kZWZhdWx0IG9wdGlvbiBoYXMgYSB3b3JraW5nIHNlbGVjdGVkIHByb3BlcnR5LlxyXG4gICAgICAgICAgICAvLyAoV2ViS2l0IGRlZmF1bHRzIHRvIGZhbHNlIGluc3RlYWQgb2YgdHJ1ZSwgSUUgdG9vLCBpZiBpdCdzIGluIGFuIG9wdGdyb3VwKVxyXG4gICAgICAgICAgICBvcHRTZWxlY3RlZDogb3B0LnNlbGVjdGVkLFxyXG5cclxuICAgICAgICAgICAgLy8gVGVzdCBzZXRBdHRyaWJ1dGUgb24gY2FtZWxDYXNlIGNsYXNzLiBJZiBpdCB3b3Jrcywgd2UgbmVlZCBhdHRyRml4ZXMgd2hlbiBkb2luZyBnZXQvc2V0QXR0cmlidXRlIChpZTYvNylcclxuICAgICAgICAgICAgZ2V0U2V0QXR0cmlidXRlOiBkaXYuY2xhc3NOYW1lICE9PSBcInRcIixcclxuXHJcbiAgICAgICAgICAgIC8vIFRlc3RzIGZvciBlbmN0eXBlIHN1cHBvcnQgb24gYSBmb3JtKCM2NzQzKVxyXG4gICAgICAgICAgICBlbmN0eXBlOiAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmb3JtXCIpLmVuY3R5cGUsXHJcblxyXG4gICAgICAgICAgICAvLyBNYWtlcyBzdXJlIGNsb25pbmcgYW4gaHRtbDUgZWxlbWVudCBkb2VzIG5vdCBjYXVzZSBwcm9ibGVtc1xyXG4gICAgICAgICAgICAvLyBXaGVyZSBvdXRlckhUTUwgaXMgdW5kZWZpbmVkLCB0aGlzIHN0aWxsIHdvcmtzXHJcbiAgICAgICAgICAgIGh0bWw1Q2xvbmU6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJuYXZcIikuY2xvbmVOb2RlKCB0cnVlICkub3V0ZXJIVE1MICE9PSBcIjw6bmF2PjwvOm5hdj5cIixcclxuXHJcbiAgICAgICAgICAgIC8vIFdpbGwgYmUgZGVmaW5lZCBsYXRlclxyXG4gICAgICAgICAgICBzdWJtaXRCdWJibGVzOiB0cnVlLFxyXG4gICAgICAgICAgICBjaGFuZ2VCdWJibGVzOiB0cnVlLFxyXG4gICAgICAgICAgICBmb2N1c2luQnViYmxlczogZmFsc2UsXHJcbiAgICAgICAgICAgIGRlbGV0ZUV4cGFuZG86IHRydWUsXHJcbiAgICAgICAgICAgIG5vQ2xvbmVFdmVudDogdHJ1ZSxcclxuICAgICAgICAgICAgaW5saW5lQmxvY2tOZWVkc0xheW91dDogZmFsc2UsXHJcbiAgICAgICAgICAgIHNocmlua1dyYXBCbG9ja3M6IGZhbHNlLFxyXG4gICAgICAgICAgICByZWxpYWJsZU1hcmdpblJpZ2h0OiB0cnVlXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIGNoZWNrZWQgc3RhdHVzIGlzIHByb3Blcmx5IGNsb25lZFxyXG4gICAgICAgIGlucHV0LmNoZWNrZWQgPSB0cnVlO1xyXG4gICAgICAgIHN1cHBvcnQubm9DbG9uZUNoZWNrZWQgPSBpbnB1dC5jbG9uZU5vZGUoIHRydWUgKS5jaGVja2VkO1xyXG5cclxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgb3B0aW9ucyBpbnNpZGUgZGlzYWJsZWQgc2VsZWN0cyBhcmVuJ3QgbWFya2VkIGFzIGRpc2FibGVkXHJcbiAgICAgICAgLy8gKFdlYktpdCBtYXJrcyB0aGVtIGFzIGRpc2FibGVkKVxyXG4gICAgICAgIHNlbGVjdC5kaXNhYmxlZCA9IHRydWU7XHJcbiAgICAgICAgc3VwcG9ydC5vcHREaXNhYmxlZCA9ICFvcHQuZGlzYWJsZWQ7XHJcblxyXG4gICAgICAgIC8vIFRlc3QgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZGVsZXRlIGFuIGV4cGFuZG8gZnJvbSBhbiBlbGVtZW50XHJcbiAgICAgICAgLy8gRmFpbHMgaW4gSW50ZXJuZXQgRXhwbG9yZXJcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBkZWxldGUgZGl2LnRlc3Q7XHJcbiAgICAgICAgfSBjYXRjaCggZSApIHtcclxuICAgICAgICAgICAgc3VwcG9ydC5kZWxldGVFeHBhbmRvID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoICFkaXYuYWRkRXZlbnRMaXN0ZW5lciAmJiBkaXYuYXR0YWNoRXZlbnQgJiYgZGl2LmZpcmVFdmVudCApIHtcclxuICAgICAgICAgICAgZGl2LmF0dGFjaEV2ZW50KCBcIm9uY2xpY2tcIiwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDbG9uaW5nIGEgbm9kZSBzaG91bGRuJ3QgY29weSBvdmVyIGFueVxyXG4gICAgICAgICAgICAgICAgLy8gYm91bmQgZXZlbnQgaGFuZGxlcnMgKElFIGRvZXMgdGhpcylcclxuICAgICAgICAgICAgICAgIHN1cHBvcnQubm9DbG9uZUV2ZW50ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBkaXYuY2xvbmVOb2RlKCB0cnVlICkuZmlyZUV2ZW50KCBcIm9uY2xpY2tcIiApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgYSByYWRpbyBtYWludGFpbnMgaXRzIHZhbHVlXHJcbiAgICAgICAgLy8gYWZ0ZXIgYmVpbmcgYXBwZW5kZWQgdG8gdGhlIERPTVxyXG4gICAgICAgIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xyXG4gICAgICAgIGlucHV0LnZhbHVlID0gXCJ0XCI7XHJcbiAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcInJhZGlvXCIpO1xyXG4gICAgICAgIHN1cHBvcnQucmFkaW9WYWx1ZSA9IGlucHV0LnZhbHVlID09PSBcInRcIjtcclxuXHJcbiAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIik7XHJcbiAgICAgICAgZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApO1xyXG4gICAgICAgIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xyXG4gICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKCBkaXYubGFzdENoaWxkICk7XHJcblxyXG4gICAgICAgIC8vIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xyXG4gICAgICAgIHN1cHBvcnQuY2hlY2tDbG9uZSA9IGZyYWdtZW50LmNsb25lTm9kZSggdHJ1ZSApLmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5jaGVja2VkO1xyXG5cclxuICAgICAgICAvLyBDaGVjayBpZiBhIGRpc2Nvbm5lY3RlZCBjaGVja2JveCB3aWxsIHJldGFpbiBpdHMgY2hlY2tlZFxyXG4gICAgICAgIC8vIHZhbHVlIG9mIHRydWUgYWZ0ZXIgYXBwZW5kZWQgdG8gdGhlIERPTSAoSUU2LzcpXHJcbiAgICAgICAgc3VwcG9ydC5hcHBlbmRDaGVja2VkID0gaW5wdXQuY2hlY2tlZDtcclxuXHJcbiAgICAgICAgZnJhZ21lbnQucmVtb3ZlQ2hpbGQoIGlucHV0ICk7XHJcbiAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRpdiApO1xyXG5cclxuICAgICAgICBkaXYuaW5uZXJIVE1MID0gXCJcIjtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgZGl2IHdpdGggZXhwbGljaXQgd2lkdGggYW5kIG5vIG1hcmdpbi1yaWdodCBpbmNvcnJlY3RseVxyXG4gICAgICAgIC8vIGdldHMgY29tcHV0ZWQgbWFyZ2luLXJpZ2h0IGJhc2VkIG9uIHdpZHRoIG9mIGNvbnRhaW5lci4gRm9yIG1vcmVcclxuICAgICAgICAvLyBpbmZvIHNlZSBidWcgIzMzMzNcclxuICAgICAgICAvLyBGYWlscyBpbiBXZWJLaXQgYmVmb3JlIEZlYiAyMDExIG5pZ2h0bGllc1xyXG4gICAgICAgIC8vIFdlYktpdCBCdWcgMTMzNDMgLSBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgd3JvbmcgdmFsdWUgZm9yIG1hcmdpbi1yaWdodFxyXG4gICAgICAgIGlmICggd2luZG93LmdldENvbXB1dGVkU3R5bGUgKSB7XHJcbiAgICAgICAgICAgIG1hcmdpbkRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcclxuICAgICAgICAgICAgbWFyZ2luRGl2LnN0eWxlLndpZHRoID0gXCIwXCI7XHJcbiAgICAgICAgICAgIG1hcmdpbkRpdi5zdHlsZS5tYXJnaW5SaWdodCA9IFwiMFwiO1xyXG4gICAgICAgICAgICBkaXYuc3R5bGUud2lkdGggPSBcIjJweFwiO1xyXG4gICAgICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoIG1hcmdpbkRpdiApO1xyXG4gICAgICAgICAgICBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luUmlnaHQgPVxyXG4gICAgICAgICAgICAgICAgKCBwYXJzZUludCggKCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggbWFyZ2luRGl2LCBudWxsICkgfHwgeyBtYXJnaW5SaWdodDogMCB9ICkubWFyZ2luUmlnaHQsIDEwICkgfHwgMCApID09PSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGVjaG5pcXVlIGZyb20gSnVyaXkgWmF5dHNldlxyXG4gICAgICAgIC8vIGh0dHA6Ly9wZXJmZWN0aW9ua2lsbHMuY29tL2RldGVjdGluZy1ldmVudC1zdXBwb3J0LXdpdGhvdXQtYnJvd3Nlci1zbmlmZmluZy9cclxuICAgICAgICAvLyBXZSBvbmx5IGNhcmUgYWJvdXQgdGhlIGNhc2Ugd2hlcmUgbm9uLXN0YW5kYXJkIGV2ZW50IHN5c3RlbXNcclxuICAgICAgICAvLyBhcmUgdXNlZCwgbmFtZWx5IGluIElFLiBTaG9ydC1jaXJjdWl0aW5nIGhlcmUgaGVscHMgdXMgdG9cclxuICAgICAgICAvLyBhdm9pZCBhbiBldmFsIGNhbGwgKGluIHNldEF0dHJpYnV0ZSkgd2hpY2ggY2FuIGNhdXNlIENTUFxyXG4gICAgICAgIC8vIHRvIGdvIGhheXdpcmUuIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vU2VjdXJpdHkvQ1NQXHJcbiAgICAgICAgaWYgKCBkaXYuYXR0YWNoRXZlbnQgKSB7XHJcbiAgICAgICAgICAgIGZvciggaSBpbiB7XHJcbiAgICAgICAgICAgICAgICBzdWJtaXQ6IDEsXHJcbiAgICAgICAgICAgICAgICBjaGFuZ2U6IDEsXHJcbiAgICAgICAgICAgICAgICBmb2N1c2luOiAxXHJcbiAgICAgICAgICAgIH0pIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50TmFtZSA9IFwib25cIiArIGk7XHJcbiAgICAgICAgICAgICAgICBpc1N1cHBvcnRlZCA9ICggZXZlbnROYW1lIGluIGRpdiApO1xyXG4gICAgICAgICAgICAgICAgaWYgKCAhaXNTdXBwb3J0ZWQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGl2LnNldEF0dHJpYnV0ZSggZXZlbnROYW1lLCBcInJldHVybjtcIiApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlzU3VwcG9ydGVkID0gKCB0eXBlb2YgZGl2WyBldmVudE5hbWUgXSA9PT0gXCJmdW5jdGlvblwiICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzdXBwb3J0WyBpICsgXCJCdWJibGVzXCIgXSA9IGlzU3VwcG9ydGVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmcmFnbWVudC5yZW1vdmVDaGlsZCggZGl2ICk7XHJcblxyXG4gICAgICAgIC8vIE51bGwgZWxlbWVudHMgdG8gYXZvaWQgbGVha3MgaW4gSUVcclxuICAgICAgICBmcmFnbWVudCA9IHNlbGVjdCA9IG9wdCA9IG1hcmdpbkRpdiA9IGRpdiA9IGlucHV0ID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gUnVuIHRlc3RzIHRoYXQgbmVlZCBhIGJvZHkgYXQgZG9jIHJlYWR5XHJcbiAgICAgICAgalF1ZXJ5KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyLCBvdXRlciwgaW5uZXIsIHRhYmxlLCB0ZCwgb2Zmc2V0U3VwcG9ydCxcclxuICAgICAgICAgICAgICAgIGNvbk1hcmdpblRvcCwgcHRsbSwgdmIsIHN0eWxlLCBodG1sLFxyXG4gICAgICAgICAgICAgICAgYm9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYm9keVwiKVswXTtcclxuXHJcbiAgICAgICAgICAgIGlmICggIWJvZHkgKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gZm9yIGZyYW1lc2V0IGRvY3MgdGhhdCBkb24ndCBoYXZlIGEgYm9keVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25NYXJnaW5Ub3AgPSAxO1xyXG4gICAgICAgICAgICBwdGxtID0gXCJwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7d2lkdGg6MXB4O2hlaWdodDoxcHg7bWFyZ2luOjA7XCI7XHJcbiAgICAgICAgICAgIHZiID0gXCJ2aXNpYmlsaXR5OmhpZGRlbjtib3JkZXI6MDtcIjtcclxuICAgICAgICAgICAgc3R5bGUgPSBcInN0eWxlPSdcIiArIHB0bG0gKyBcImJvcmRlcjo1cHggc29saWQgIzAwMDtwYWRkaW5nOjA7J1wiO1xyXG4gICAgICAgICAgICBodG1sID0gXCI8ZGl2IFwiICsgc3R5bGUgKyBcIj48ZGl2PjwvZGl2PjwvZGl2PlwiICtcclxuICAgICAgICAgICAgICAgIFwiPHRhYmxlIFwiICsgc3R5bGUgKyBcIiBjZWxscGFkZGluZz0nMCcgY2VsbHNwYWNpbmc9JzAnPlwiICtcclxuICAgICAgICAgICAgICAgIFwiPHRyPjx0ZD48L3RkPjwvdHI+PC90YWJsZT5cIjtcclxuXHJcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gdmIgKyBcIndpZHRoOjA7aGVpZ2h0OjA7cG9zaXRpb246c3RhdGljO3RvcDowO21hcmdpbi10b3A6XCIgKyBjb25NYXJnaW5Ub3AgKyBcInB4XCI7XHJcbiAgICAgICAgICAgIGJvZHkuaW5zZXJ0QmVmb3JlKCBjb250YWluZXIsIGJvZHkuZmlyc3RDaGlsZCApO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29uc3RydWN0IHRoZSB0ZXN0IGVsZW1lbnRcclxuICAgICAgICAgICAgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKCBkaXYgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRhYmxlIGNlbGxzIHN0aWxsIGhhdmUgb2Zmc2V0V2lkdGgvSGVpZ2h0IHdoZW4gdGhleSBhcmUgc2V0XHJcbiAgICAgICAgICAgIC8vIHRvIGRpc3BsYXk6bm9uZSBhbmQgdGhlcmUgYXJlIHN0aWxsIG90aGVyIHZpc2libGUgdGFibGUgY2VsbHMgaW4gYVxyXG4gICAgICAgICAgICAvLyB0YWJsZSByb3c7IGlmIHNvLCBvZmZzZXRXaWR0aC9IZWlnaHQgYXJlIG5vdCByZWxpYWJsZSBmb3IgdXNlIHdoZW5cclxuICAgICAgICAgICAgLy8gZGV0ZXJtaW5pbmcgaWYgYW4gZWxlbWVudCBoYXMgYmVlbiBoaWRkZW4gZGlyZWN0bHkgdXNpbmdcclxuICAgICAgICAgICAgLy8gZGlzcGxheTpub25lIChpdCBpcyBzdGlsbCBzYWZlIHRvIHVzZSBvZmZzZXRzIGlmIGEgcGFyZW50IGVsZW1lbnQgaXNcclxuICAgICAgICAgICAgLy8gaGlkZGVuOyBkb24gc2FmZXR5IGdvZ2dsZXMgYW5kIHNlZSBidWcgIzQ1MTIgZm9yIG1vcmUgaW5mb3JtYXRpb24pLlxyXG4gICAgICAgICAgICAvLyAob25seSBJRSA4IGZhaWxzIHRoaXMgdGVzdClcclxuICAgICAgICAgICAgZGl2LmlubmVySFRNTCA9IFwiPHRhYmxlPjx0cj48dGQgc3R5bGU9J3BhZGRpbmc6MDtib3JkZXI6MDtkaXNwbGF5Om5vbmUnPjwvdGQ+PHRkPnQ8L3RkPjwvdHI+PC90YWJsZT5cIjtcclxuICAgICAgICAgICAgdGRzID0gZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInRkXCIgKTtcclxuICAgICAgICAgICAgaXNTdXBwb3J0ZWQgPSAoIHRkc1sgMCBdLm9mZnNldEhlaWdodCA9PT0gMCApO1xyXG5cclxuICAgICAgICAgICAgdGRzWyAwIF0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XHJcbiAgICAgICAgICAgIHRkc1sgMSBdLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGVtcHR5IHRhYmxlIGNlbGxzIHN0aWxsIGhhdmUgb2Zmc2V0V2lkdGgvSGVpZ2h0XHJcbiAgICAgICAgICAgIC8vIChJRSA8PSA4IGZhaWwgdGhpcyB0ZXN0KVxyXG4gICAgICAgICAgICBzdXBwb3J0LnJlbGlhYmxlSGlkZGVuT2Zmc2V0cyA9IGlzU3VwcG9ydGVkICYmICggdGRzWyAwIF0ub2Zmc2V0SGVpZ2h0ID09PSAwICk7XHJcblxyXG4gICAgICAgICAgICAvLyBGaWd1cmUgb3V0IGlmIHRoZSBXM0MgYm94IG1vZGVsIHdvcmtzIGFzIGV4cGVjdGVkXHJcbiAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSBcIlwiO1xyXG4gICAgICAgICAgICBkaXYuc3R5bGUud2lkdGggPSBkaXYuc3R5bGUucGFkZGluZ0xlZnQgPSBcIjFweFwiO1xyXG4gICAgICAgICAgICBqUXVlcnkuYm94TW9kZWwgPSBzdXBwb3J0LmJveE1vZGVsID0gZGl2Lm9mZnNldFdpZHRoID09PSAyO1xyXG5cclxuICAgICAgICAgICAgaWYgKCB0eXBlb2YgZGl2LnN0eWxlLnpvb20gIT09IFwidW5kZWZpbmVkXCIgKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBuYXRpdmVseSBibG9jay1sZXZlbCBlbGVtZW50cyBhY3QgbGlrZSBpbmxpbmUtYmxvY2tcclxuICAgICAgICAgICAgICAgIC8vIGVsZW1lbnRzIHdoZW4gc2V0dGluZyB0aGVpciBkaXNwbGF5IHRvICdpbmxpbmUnIGFuZCBnaXZpbmdcclxuICAgICAgICAgICAgICAgIC8vIHRoZW0gbGF5b3V0XHJcbiAgICAgICAgICAgICAgICAvLyAoSUUgPCA4IGRvZXMgdGhpcylcclxuICAgICAgICAgICAgICAgIGRpdi5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmVcIjtcclxuICAgICAgICAgICAgICAgIGRpdi5zdHlsZS56b29tID0gMTtcclxuICAgICAgICAgICAgICAgIHN1cHBvcnQuaW5saW5lQmxvY2tOZWVkc0xheW91dCA9ICggZGl2Lm9mZnNldFdpZHRoID09PSAyICk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgZWxlbWVudHMgd2l0aCBsYXlvdXQgc2hyaW5rLXdyYXAgdGhlaXIgY2hpbGRyZW5cclxuICAgICAgICAgICAgICAgIC8vIChJRSA2IGRvZXMgdGhpcylcclxuICAgICAgICAgICAgICAgIGRpdi5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSBcIjxkaXYgc3R5bGU9J3dpZHRoOjRweDsnPjwvZGl2PlwiO1xyXG4gICAgICAgICAgICAgICAgc3VwcG9ydC5zaHJpbmtXcmFwQmxvY2tzID0gKCBkaXYub2Zmc2V0V2lkdGggIT09IDIgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZGl2LnN0eWxlLmNzc1RleHQgPSBwdGxtICsgdmI7XHJcbiAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSBodG1sO1xyXG5cclxuICAgICAgICAgICAgb3V0ZXIgPSBkaXYuZmlyc3RDaGlsZDtcclxuICAgICAgICAgICAgaW5uZXIgPSBvdXRlci5maXJzdENoaWxkO1xyXG4gICAgICAgICAgICB0ZCA9IG91dGVyLm5leHRTaWJsaW5nLmZpcnN0Q2hpbGQuZmlyc3RDaGlsZDtcclxuXHJcbiAgICAgICAgICAgIG9mZnNldFN1cHBvcnQgPSB7XHJcbiAgICAgICAgICAgICAgICBkb2VzTm90QWRkQm9yZGVyOiAoIGlubmVyLm9mZnNldFRvcCAhPT0gNSApLFxyXG4gICAgICAgICAgICAgICAgZG9lc0FkZEJvcmRlckZvclRhYmxlQW5kQ2VsbHM6ICggdGQub2Zmc2V0VG9wID09PSA1IClcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGlubmVyLnN0eWxlLnBvc2l0aW9uID0gXCJmaXhlZFwiO1xyXG4gICAgICAgICAgICBpbm5lci5zdHlsZS50b3AgPSBcIjIwcHhcIjtcclxuXHJcbiAgICAgICAgICAgIC8vIHNhZmFyaSBzdWJ0cmFjdHMgcGFyZW50IGJvcmRlciB3aWR0aCBoZXJlIHdoaWNoIGlzIDVweFxyXG4gICAgICAgICAgICBvZmZzZXRTdXBwb3J0LmZpeGVkUG9zaXRpb24gPSAoIGlubmVyLm9mZnNldFRvcCA9PT0gMjAgfHwgaW5uZXIub2Zmc2V0VG9wID09PSAxNSApO1xyXG4gICAgICAgICAgICBpbm5lci5zdHlsZS5wb3NpdGlvbiA9IGlubmVyLnN0eWxlLnRvcCA9IFwiXCI7XHJcblxyXG4gICAgICAgICAgICBvdXRlci5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XHJcbiAgICAgICAgICAgIG91dGVyLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xyXG5cclxuICAgICAgICAgICAgb2Zmc2V0U3VwcG9ydC5zdWJ0cmFjdHNCb3JkZXJGb3JPdmVyZmxvd05vdFZpc2libGUgPSAoIGlubmVyLm9mZnNldFRvcCA9PT0gLTUgKTtcclxuICAgICAgICAgICAgb2Zmc2V0U3VwcG9ydC5kb2VzTm90SW5jbHVkZU1hcmdpbkluQm9keU9mZnNldCA9ICggYm9keS5vZmZzZXRUb3AgIT09IGNvbk1hcmdpblRvcCApO1xyXG5cclxuICAgICAgICAgICAgYm9keS5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XHJcbiAgICAgICAgICAgIGRpdiAgPSBjb250YWluZXIgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgalF1ZXJ5LmV4dGVuZCggc3VwcG9ydCwgb2Zmc2V0U3VwcG9ydCApO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gc3VwcG9ydDtcclxuICAgIH0pKCk7XHJcblxyXG5cclxuXHJcblxyXG4gICAgdmFyIHJicmFjZSA9IC9eKD86XFx7LipcXH18XFxbLipcXF0pJC8sXHJcbiAgICAgICAgcm11bHRpRGFzaCA9IC8oW0EtWl0pL2c7XHJcblxyXG4gICAgalF1ZXJ5LmV4dGVuZCh7XHJcbiAgICAgICAgY2FjaGU6IHt9LFxyXG5cclxuICAgICAgICAvLyBQbGVhc2UgdXNlIHdpdGggY2F1dGlvblxyXG4gICAgICAgIHV1aWQ6IDAsXHJcblxyXG4gICAgICAgIC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxyXG4gICAgICAgIC8vIE5vbi1kaWdpdHMgcmVtb3ZlZCB0byBtYXRjaCByaW5saW5lalF1ZXJ5XHJcbiAgICAgICAgZXhwYW5kbzogXCJqUXVlcnlcIiArICggalF1ZXJ5LmZuLmpxdWVyeSArIE1hdGgucmFuZG9tKCkgKS5yZXBsYWNlKCAvXFxEL2csIFwiXCIgKSxcclxuXHJcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBlbGVtZW50cyB0aHJvdyB1bmNhdGNoYWJsZSBleGNlcHRpb25zIGlmIHlvdVxyXG4gICAgICAgIC8vIGF0dGVtcHQgdG8gYWRkIGV4cGFuZG8gcHJvcGVydGllcyB0byB0aGVtLlxyXG4gICAgICAgIG5vRGF0YToge1xyXG4gICAgICAgICAgICBcImVtYmVkXCI6IHRydWUsXHJcbiAgICAgICAgICAgIC8vIEJhbiBhbGwgb2JqZWN0cyBleGNlcHQgZm9yIEZsYXNoICh3aGljaCBoYW5kbGUgZXhwYW5kb3MpXHJcbiAgICAgICAgICAgIFwib2JqZWN0XCI6IFwiY2xzaWQ6RDI3Q0RCNkUtQUU2RC0xMWNmLTk2QjgtNDQ0NTUzNTQwMDAwXCIsXHJcbiAgICAgICAgICAgIFwiYXBwbGV0XCI6IHRydWVcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcclxuICAgICAgICAgICAgZWxlbSA9IGVsZW0ubm9kZVR5cGUgPyBqUXVlcnkuY2FjaGVbIGVsZW1balF1ZXJ5LmV4cGFuZG9dIF0gOiBlbGVtWyBqUXVlcnkuZXhwYW5kbyBdO1xyXG4gICAgICAgICAgICByZXR1cm4gISFlbGVtICYmICFpc0VtcHR5RGF0YU9iamVjdCggZWxlbSApO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGRhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhLCBwdnQgLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XHJcbiAgICAgICAgICAgIGlmICggIWpRdWVyeS5hY2NlcHREYXRhKCBlbGVtICkgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBwcml2YXRlQ2FjaGUsIHRoaXNDYWNoZSwgcmV0LFxyXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxLZXkgPSBqUXVlcnkuZXhwYW5kbyxcclxuICAgICAgICAgICAgICAgIGdldEJ5TmFtZSA9IHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiLFxyXG5cclxuICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byBoYW5kbGUgRE9NIG5vZGVzIGFuZCBKUyBvYmplY3RzIGRpZmZlcmVudGx5IGJlY2F1c2UgSUU2LTdcclxuICAgICAgICAgICAgLy8gY2FuJ3QgR0Mgb2JqZWN0IHJlZmVyZW5jZXMgcHJvcGVybHkgYWNyb3NzIHRoZSBET00tSlMgYm91bmRhcnlcclxuICAgICAgICAgICAgICAgIGlzTm9kZSA9IGVsZW0ubm9kZVR5cGUsXHJcblxyXG4gICAgICAgICAgICAvLyBPbmx5IERPTSBub2RlcyBuZWVkIHRoZSBnbG9iYWwgalF1ZXJ5IGNhY2hlOyBKUyBvYmplY3QgZGF0YSBpc1xyXG4gICAgICAgICAgICAvLyBhdHRhY2hlZCBkaXJlY3RseSB0byB0aGUgb2JqZWN0IHNvIEdDIGNhbiBvY2N1ciBhdXRvbWF0aWNhbGx5XHJcbiAgICAgICAgICAgICAgICBjYWNoZSA9IGlzTm9kZSA/IGpRdWVyeS5jYWNoZSA6IGVsZW0sXHJcblxyXG4gICAgICAgICAgICAvLyBPbmx5IGRlZmluaW5nIGFuIElEIGZvciBKUyBvYmplY3RzIGlmIGl0cyBjYWNoZSBhbHJlYWR5IGV4aXN0cyBhbGxvd3NcclxuICAgICAgICAgICAgLy8gdGhlIGNvZGUgdG8gc2hvcnRjdXQgb24gdGhlIHNhbWUgcGF0aCBhcyBhIERPTSBub2RlIHdpdGggbm8gY2FjaGVcclxuICAgICAgICAgICAgICAgIGlkID0gaXNOb2RlID8gZWxlbVsgaW50ZXJuYWxLZXkgXSA6IGVsZW1bIGludGVybmFsS2V5IF0gJiYgaW50ZXJuYWxLZXksXHJcbiAgICAgICAgICAgICAgICBpc0V2ZW50cyA9IG5hbWUgPT09IFwiZXZlbnRzXCI7XHJcblxyXG4gICAgICAgICAgICAvLyBBdm9pZCBkb2luZyBhbnkgbW9yZSB3b3JrIHRoYW4gd2UgbmVlZCB0byB3aGVuIHRyeWluZyB0byBnZXQgZGF0YSBvbiBhblxyXG4gICAgICAgICAgICAvLyBvYmplY3QgdGhhdCBoYXMgbm8gZGF0YSBhdCBhbGxcclxuICAgICAgICAgICAgaWYgKCAoIWlkIHx8ICFjYWNoZVtpZF0gfHwgKCFpc0V2ZW50cyAmJiAhcHZ0ICYmICFjYWNoZVtpZF0uZGF0YSkpICYmIGdldEJ5TmFtZSAmJiBkYXRhID09PSB1bmRlZmluZWQgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggIWlkICkge1xyXG4gICAgICAgICAgICAgICAgLy8gT25seSBET00gbm9kZXMgbmVlZCBhIG5ldyB1bmlxdWUgSUQgZm9yIGVhY2ggZWxlbWVudCBzaW5jZSB0aGVpciBkYXRhXHJcbiAgICAgICAgICAgICAgICAvLyBlbmRzIHVwIGluIHRoZSBnbG9iYWwgY2FjaGVcclxuICAgICAgICAgICAgICAgIGlmICggaXNOb2RlICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1bIGludGVybmFsS2V5IF0gPSBpZCA9ICsralF1ZXJ5LnV1aWQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkID0gaW50ZXJuYWxLZXk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggIWNhY2hlWyBpZCBdICkge1xyXG4gICAgICAgICAgICAgICAgY2FjaGVbIGlkIF0gPSB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBdm9pZHMgZXhwb3NpbmcgalF1ZXJ5IG1ldGFkYXRhIG9uIHBsYWluIEpTIG9iamVjdHMgd2hlbiB0aGUgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAvLyBpcyBzZXJpYWxpemVkIHVzaW5nIEpTT04uc3RyaW5naWZ5XHJcbiAgICAgICAgICAgICAgICBpZiAoICFpc05vZGUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVbIGlkIF0udG9KU09OID0galF1ZXJ5Lm5vb3A7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFuIG9iamVjdCBjYW4gYmUgcGFzc2VkIHRvIGpRdWVyeS5kYXRhIGluc3RlYWQgb2YgYSBrZXkvdmFsdWUgcGFpcjsgdGhpcyBnZXRzXHJcbiAgICAgICAgICAgIC8vIHNoYWxsb3cgY29waWVkIG92ZXIgb250byB0aGUgZXhpc3RpbmcgY2FjaGVcclxuICAgICAgICAgICAgaWYgKCB0eXBlb2YgbmFtZSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiICkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCBwdnQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVbIGlkIF0gPSBqUXVlcnkuZXh0ZW5kKCBjYWNoZVsgaWQgXSwgbmFtZSApO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWNoZVsgaWQgXS5kYXRhID0galF1ZXJ5LmV4dGVuZCggY2FjaGVbIGlkIF0uZGF0YSwgbmFtZSApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwcml2YXRlQ2FjaGUgPSB0aGlzQ2FjaGUgPSBjYWNoZVsgaWQgXTtcclxuXHJcbiAgICAgICAgICAgIC8vIGpRdWVyeSBkYXRhKCkgaXMgc3RvcmVkIGluIGEgc2VwYXJhdGUgb2JqZWN0IGluc2lkZSB0aGUgb2JqZWN0J3MgaW50ZXJuYWwgZGF0YVxyXG4gICAgICAgICAgICAvLyBjYWNoZSBpbiBvcmRlciB0byBhdm9pZCBrZXkgY29sbGlzaW9ucyBiZXR3ZWVuIGludGVybmFsIGRhdGEgYW5kIHVzZXItZGVmaW5lZFxyXG4gICAgICAgICAgICAvLyBkYXRhLlxyXG4gICAgICAgICAgICBpZiAoICFwdnQgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoICF0aGlzQ2FjaGUuZGF0YSApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzQ2FjaGUuZGF0YSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXNDYWNoZSA9IHRoaXNDYWNoZS5kYXRhO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcclxuICAgICAgICAgICAgICAgIHRoaXNDYWNoZVsgalF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApIF0gPSBkYXRhO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBVc2VycyBzaG91bGQgbm90IGF0dGVtcHQgdG8gaW5zcGVjdCB0aGUgaW50ZXJuYWwgZXZlbnRzIG9iamVjdCB1c2luZyBqUXVlcnkuZGF0YSxcclxuICAgICAgICAgICAgLy8gaXQgaXMgdW5kb2N1bWVudGVkIGFuZCBzdWJqZWN0IHRvIGNoYW5nZS4gQnV0IGRvZXMgYW55b25lIGxpc3Rlbj8gTm8uXHJcbiAgICAgICAgICAgIGlmICggaXNFdmVudHMgJiYgIXRoaXNDYWNoZVsgbmFtZSBdICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByaXZhdGVDYWNoZS5ldmVudHM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBib3RoIGNvbnZlcnRlZC10by1jYW1lbCBhbmQgbm9uLWNvbnZlcnRlZCBkYXRhIHByb3BlcnR5IG5hbWVzXHJcbiAgICAgICAgICAgIC8vIElmIGEgZGF0YSBwcm9wZXJ0eSB3YXMgc3BlY2lmaWVkXHJcbiAgICAgICAgICAgIGlmICggZ2V0QnlOYW1lICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZpcnN0IFRyeSB0byBmaW5kIGFzLWlzIHByb3BlcnR5IGRhdGFcclxuICAgICAgICAgICAgICAgIHJldCA9IHRoaXNDYWNoZVsgbmFtZSBdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRlc3QgZm9yIG51bGx8dW5kZWZpbmVkIHByb3BlcnR5IGRhdGFcclxuICAgICAgICAgICAgICAgIGlmICggcmV0ID09IG51bGwgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byBmaW5kIHRoZSBjYW1lbENhc2VkIHByb3BlcnR5XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gdGhpc0NhY2hlWyBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICkgXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldCA9IHRoaXNDYWNoZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICByZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgcHZ0IC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xyXG4gICAgICAgICAgICBpZiAoICFqUXVlcnkuYWNjZXB0RGF0YSggZWxlbSApICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgdGhpc0NhY2hlLCBpLCBsLFxyXG5cclxuICAgICAgICAgICAgLy8gUmVmZXJlbmNlIHRvIGludGVybmFsIGRhdGEgY2FjaGUga2V5XHJcbiAgICAgICAgICAgICAgICBpbnRlcm5hbEtleSA9IGpRdWVyeS5leHBhbmRvLFxyXG5cclxuICAgICAgICAgICAgICAgIGlzTm9kZSA9IGVsZW0ubm9kZVR5cGUsXHJcblxyXG4gICAgICAgICAgICAvLyBTZWUgalF1ZXJ5LmRhdGEgZm9yIG1vcmUgaW5mb3JtYXRpb25cclxuICAgICAgICAgICAgICAgIGNhY2hlID0gaXNOb2RlID8galF1ZXJ5LmNhY2hlIDogZWxlbSxcclxuXHJcbiAgICAgICAgICAgIC8vIFNlZSBqUXVlcnkuZGF0YSBmb3IgbW9yZSBpbmZvcm1hdGlvblxyXG4gICAgICAgICAgICAgICAgaWQgPSBpc05vZGUgPyBlbGVtWyBpbnRlcm5hbEtleSBdIDogaW50ZXJuYWxLZXk7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IG5vIGNhY2hlIGVudHJ5IGZvciB0aGlzIG9iamVjdCwgdGhlcmUgaXMgbm9cclxuICAgICAgICAgICAgLy8gcHVycG9zZSBpbiBjb250aW51aW5nXHJcbiAgICAgICAgICAgIGlmICggIWNhY2hlWyBpZCBdICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIG5hbWUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpc0NhY2hlID0gcHZ0ID8gY2FjaGVbIGlkIF0gOiBjYWNoZVsgaWQgXS5kYXRhO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggdGhpc0NhY2hlICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0IGFycmF5IG9yIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgbmFtZXMgZm9yIGRhdGEga2V5c1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggIWpRdWVyeS5pc0FycmF5KCBuYW1lICkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnkgdGhlIHN0cmluZyBhcyBhIGtleSBiZWZvcmUgYW55IG1hbmlwdWxhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG5hbWUgaW4gdGhpc0NhY2hlICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IFsgbmFtZSBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwbGl0IHRoZSBjYW1lbCBjYXNlZCB2ZXJzaW9uIGJ5IHNwYWNlcyB1bmxlc3MgYSBrZXkgd2l0aCB0aGUgc3BhY2VzIGV4aXN0c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbmFtZSBpbiB0aGlzQ2FjaGUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IFsgbmFtZSBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS5zcGxpdCggXCIgXCIgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IDAsIGwgPSBuYW1lLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXNDYWNoZVsgbmFtZVtpXSBdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gZGF0YSBsZWZ0IGluIHRoZSBjYWNoZSwgd2Ugd2FudCB0byBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBsZXQgdGhlIGNhY2hlIG9iamVjdCBpdHNlbGYgZ2V0IGRlc3Ryb3llZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggISggcHZ0ID8gaXNFbXB0eURhdGFPYmplY3QgOiBqUXVlcnkuaXNFbXB0eU9iamVjdCApKCB0aGlzQ2FjaGUgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU2VlIGpRdWVyeS5kYXRhIGZvciBtb3JlIGluZm9ybWF0aW9uXHJcbiAgICAgICAgICAgIGlmICggIXB2dCApIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVsgaWQgXS5kYXRhO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIERvbid0IGRlc3Ryb3kgdGhlIHBhcmVudCBjYWNoZSB1bmxlc3MgdGhlIGludGVybmFsIGRhdGEgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAvLyBoYWQgYmVlbiB0aGUgb25seSB0aGluZyBsZWZ0IGluIGl0XHJcbiAgICAgICAgICAgICAgICBpZiAoICFpc0VtcHR5RGF0YU9iamVjdChjYWNoZVsgaWQgXSkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBCcm93c2VycyB0aGF0IGZhaWwgZXhwYW5kbyBkZWxldGlvbiBhbHNvIHJlZnVzZSB0byBkZWxldGUgZXhwYW5kb3Mgb25cclxuICAgICAgICAgICAgLy8gdGhlIHdpbmRvdywgYnV0IGl0IHdpbGwgYWxsb3cgaXQgb24gYWxsIG90aGVyIEpTIG9iamVjdHM7IG90aGVyIGJyb3dzZXJzXHJcbiAgICAgICAgICAgIC8vIGRvbid0IGNhcmVcclxuICAgICAgICAgICAgLy8gRW5zdXJlIHRoYXQgYGNhY2hlYCBpcyBub3QgYSB3aW5kb3cgb2JqZWN0ICMxMDA4MFxyXG4gICAgICAgICAgICBpZiAoIGpRdWVyeS5zdXBwb3J0LmRlbGV0ZUV4cGFuZG8gfHwgIWNhY2hlLnNldEludGVydmFsICkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGNhY2hlWyBpZCBdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2FjaGVbIGlkIF0gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBXZSBkZXN0cm95ZWQgdGhlIGNhY2hlIGFuZCBuZWVkIHRvIGVsaW1pbmF0ZSB0aGUgZXhwYW5kbyBvbiB0aGUgbm9kZSB0byBhdm9pZFxyXG4gICAgICAgICAgICAvLyBmYWxzZSBsb29rdXBzIGluIHRoZSBjYWNoZSBmb3IgZW50cmllcyB0aGF0IG5vIGxvbmdlciBleGlzdFxyXG4gICAgICAgICAgICBpZiAoIGlzTm9kZSApIHtcclxuICAgICAgICAgICAgICAgIC8vIElFIGRvZXMgbm90IGFsbG93IHVzIHRvIGRlbGV0ZSBleHBhbmRvIHByb3BlcnRpZXMgZnJvbSBub2RlcyxcclxuICAgICAgICAgICAgICAgIC8vIG5vciBkb2VzIGl0IGhhdmUgYSByZW1vdmVBdHRyaWJ1dGUgZnVuY3Rpb24gb24gRG9jdW1lbnQgbm9kZXM7XHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBtdXN0IGhhbmRsZSBhbGwgb2YgdGhlc2UgY2FzZXNcclxuICAgICAgICAgICAgICAgIGlmICggalF1ZXJ5LnN1cHBvcnQuZGVsZXRlRXhwYW5kbyApIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZWxlbVsgaW50ZXJuYWxLZXkgXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGVsZW0ucmVtb3ZlQXR0cmlidXRlICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBpbnRlcm5hbEtleSApO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtWyBpbnRlcm5hbEtleSBdID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cclxuICAgICAgICBfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZGF0YSggZWxlbSwgbmFtZSwgZGF0YSwgdHJ1ZSApO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIEEgbWV0aG9kIGZvciBkZXRlcm1pbmluZyBpZiBhIERPTSBub2RlIGNhbiBoYW5kbGUgdGhlIGRhdGEgZXhwYW5kb1xyXG4gICAgICAgIGFjY2VwdERhdGE6IGZ1bmN0aW9uKCBlbGVtICkge1xyXG4gICAgICAgICAgICBpZiAoIGVsZW0ubm9kZU5hbWUgKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBqUXVlcnkubm9EYXRhWyBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIG1hdGNoICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhKG1hdGNoID09PSB0cnVlIHx8IGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NpZFwiKSAhPT0gbWF0Y2gpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcclxuICAgICAgICBkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcclxuICAgICAgICAgICAgdmFyIHBhcnRzLCBhdHRyLCBuYW1lLFxyXG4gICAgICAgICAgICAgICAgZGF0YSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiBrZXkgPT09IFwidW5kZWZpbmVkXCIgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMubGVuZ3RoICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBqUXVlcnkuZGF0YSggdGhpc1swXSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXNbMF0ubm9kZVR5cGUgPT09IDEgJiYgIWpRdWVyeS5fZGF0YSggdGhpc1swXSwgXCJwYXJzZWRBdHRyc1wiICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIgPSB0aGlzWzBdLmF0dHJpYnV0ZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGF0dHIubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGF0dHJbaV0ubmFtZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG5hbWUuaW5kZXhPZiggXCJkYXRhLVwiICkgPT09IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUuc3Vic3RyaW5nKDUpICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFBdHRyKCB0aGlzWzBdLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuX2RhdGEoIHRoaXNbMF0sIFwicGFyc2VkQXR0cnNcIiwgdHJ1ZSApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5kYXRhKCB0aGlzLCBrZXkgKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwYXJ0cyA9IGtleS5zcGxpdChcIi5cIik7XHJcbiAgICAgICAgICAgIHBhcnRzWzFdID0gcGFydHNbMV0gPyBcIi5cIiArIHBhcnRzWzFdIDogXCJcIjtcclxuXHJcbiAgICAgICAgICAgIGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLnRyaWdnZXJIYW5kbGVyKFwiZ2V0RGF0YVwiICsgcGFydHNbMV0gKyBcIiFcIiwgW3BhcnRzWzBdXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGZldGNoIGFueSBpbnRlcm5hbGx5IHN0b3JlZCBkYXRhIGZpcnN0XHJcbiAgICAgICAgICAgICAgICBpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiB0aGlzLmxlbmd0aCApIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhID0galF1ZXJ5LmRhdGEoIHRoaXNbMF0sIGtleSApO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhQXR0ciggdGhpc1swXSwga2V5LCBkYXRhICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBwYXJ0c1sxXSA/XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhKCBwYXJ0c1swXSApIDpcclxuICAgICAgICAgICAgICAgICAgICBkYXRhO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IFsgcGFydHNbMF0sIHZhbHVlIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYudHJpZ2dlckhhbmRsZXIoIFwic2V0RGF0YVwiICsgcGFydHNbMV0gKyBcIiFcIiwgYXJncyApO1xyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5kYXRhKCB0aGlzLCBrZXksIHZhbHVlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VySGFuZGxlciggXCJjaGFuZ2VEYXRhXCIgKyBwYXJ0c1sxXSArIFwiIVwiLCBhcmdzICk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBqUXVlcnkucmVtb3ZlRGF0YSggdGhpcywga2V5ICk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGZ1bmN0aW9uIGRhdGFBdHRyKCBlbGVtLCBrZXksIGRhdGEgKSB7XHJcbiAgICAgICAgLy8gSWYgbm90aGluZyB3YXMgZm91bmQgaW50ZXJuYWxseSwgdHJ5IHRvIGZldGNoIGFueVxyXG4gICAgICAgIC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxyXG4gICAgICAgIGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgbmFtZSA9IFwiZGF0YS1cIiArIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcIi0kMVwiICkudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGRhdGEgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEgPT09IFwidHJ1ZVwiID8gdHJ1ZSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPT09IFwiZmFsc2VcIiA/IGZhbHNlIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPT09IFwibnVsbFwiID8gbnVsbCA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmlzTnVtZXJpYyggZGF0YSApID8gcGFyc2VGbG9hdCggZGF0YSApIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmJyYWNlLnRlc3QoIGRhdGEgKSA/IGpRdWVyeS5wYXJzZUpTT04oIGRhdGEgKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCggZSApIHt9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXHJcbiAgICAgICAgICAgICAgICBqUXVlcnkuZGF0YSggZWxlbSwga2V5LCBkYXRhICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9XHJcblxyXG4vLyBjaGVja3MgYSBjYWNoZSBvYmplY3QgZm9yIGVtcHRpbmVzc1xyXG4gICAgZnVuY3Rpb24gaXNFbXB0eURhdGFPYmplY3QoIG9iaiApIHtcclxuICAgICAgICBmb3IgKCB2YXIgbmFtZSBpbiBvYmogKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBpZiB0aGUgcHVibGljIGRhdGEgb2JqZWN0IGlzIGVtcHR5LCB0aGUgcHJpdmF0ZSBpcyBzdGlsbCBlbXB0eVxyXG4gICAgICAgICAgICBpZiAoIG5hbWUgPT09IFwiZGF0YVwiICYmIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBvYmpbbmFtZV0gKSApIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICggbmFtZSAhPT0gXCJ0b0pTT05cIiApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlUXVldWVNYXJrRGVmZXIoIGVsZW0sIHR5cGUsIHNyYyApIHtcclxuICAgICAgICB2YXIgZGVmZXJEYXRhS2V5ID0gdHlwZSArIFwiZGVmZXJcIixcclxuICAgICAgICAgICAgcXVldWVEYXRhS2V5ID0gdHlwZSArIFwicXVldWVcIixcclxuICAgICAgICAgICAgbWFya0RhdGFLZXkgPSB0eXBlICsgXCJtYXJrXCIsXHJcbiAgICAgICAgICAgIGRlZmVyID0galF1ZXJ5Ll9kYXRhKCBlbGVtLCBkZWZlckRhdGFLZXkgKTtcclxuICAgICAgICBpZiAoIGRlZmVyICYmXHJcbiAgICAgICAgICAgICggc3JjID09PSBcInF1ZXVlXCIgfHwgIWpRdWVyeS5fZGF0YShlbGVtLCBxdWV1ZURhdGFLZXkpICkgJiZcclxuICAgICAgICAgICAgKCBzcmMgPT09IFwibWFya1wiIHx8ICFqUXVlcnkuX2RhdGEoZWxlbSwgbWFya0RhdGFLZXkpICkgKSB7XHJcbiAgICAgICAgICAgIC8vIEdpdmUgcm9vbSBmb3IgaGFyZC1jb2RlZCBjYWxsYmFja3MgdG8gZmlyZSBmaXJzdFxyXG4gICAgICAgICAgICAvLyBhbmQgZXZlbnR1YWxseSBtYXJrL3F1ZXVlIHNvbWV0aGluZyBlbHNlIG9uIHRoZSBlbGVtZW50XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCAhalF1ZXJ5Ll9kYXRhKCBlbGVtLCBxdWV1ZURhdGFLZXkgKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICFqUXVlcnkuX2RhdGEoIGVsZW0sIG1hcmtEYXRhS2V5ICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnJlbW92ZURhdGEoIGVsZW0sIGRlZmVyRGF0YUtleSwgdHJ1ZSApO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmVyLmZpcmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgMCApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBqUXVlcnkuZXh0ZW5kKHtcclxuXHJcbiAgICAgICAgX21hcms6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xyXG4gICAgICAgICAgICBpZiAoIGVsZW0gKSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlID0gKCB0eXBlIHx8IFwiZnhcIiApICsgXCJtYXJrXCI7XHJcbiAgICAgICAgICAgICAgICBqUXVlcnkuX2RhdGEoIGVsZW0sIHR5cGUsIChqUXVlcnkuX2RhdGEoIGVsZW0sIHR5cGUgKSB8fCAwKSArIDEgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF91bm1hcms6IGZ1bmN0aW9uKCBmb3JjZSwgZWxlbSwgdHlwZSApIHtcclxuICAgICAgICAgICAgaWYgKCBmb3JjZSAhPT0gdHJ1ZSApIHtcclxuICAgICAgICAgICAgICAgIHR5cGUgPSBlbGVtO1xyXG4gICAgICAgICAgICAgICAgZWxlbSA9IGZvcmNlO1xyXG4gICAgICAgICAgICAgICAgZm9yY2UgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIGVsZW0gKSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlID0gdHlwZSB8fCBcImZ4XCI7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gdHlwZSArIFwibWFya1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ID0gZm9yY2UgPyAwIDogKCAoalF1ZXJ5Ll9kYXRhKCBlbGVtLCBrZXkgKSB8fCAxKSAtIDEgKTtcclxuICAgICAgICAgICAgICAgIGlmICggY291bnQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Ll9kYXRhKCBlbGVtLCBrZXksIGNvdW50ICk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVEYXRhKCBlbGVtLCBrZXksIHRydWUgKTtcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVRdWV1ZU1hcmtEZWZlciggZWxlbSwgdHlwZSwgXCJtYXJrXCIgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSwgZGF0YSApIHtcclxuICAgICAgICAgICAgdmFyIHE7XHJcbiAgICAgICAgICAgIGlmICggZWxlbSApIHtcclxuICAgICAgICAgICAgICAgIHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XHJcbiAgICAgICAgICAgICAgICBxID0galF1ZXJ5Ll9kYXRhKCBlbGVtLCB0eXBlICk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3BlZWQgdXAgZGVxdWV1ZSBieSBnZXR0aW5nIG91dCBxdWlja2x5IGlmIHRoaXMgaXMganVzdCBhIGxvb2t1cFxyXG4gICAgICAgICAgICAgICAgaWYgKCBkYXRhICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggIXEgfHwgalF1ZXJ5LmlzQXJyYXkoZGF0YSkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHEgPSBqUXVlcnkuX2RhdGEoIGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoZGF0YSkgKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBxLnB1c2goIGRhdGEgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcSB8fCBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xyXG4gICAgICAgICAgICB0eXBlID0gdHlwZSB8fCBcImZ4XCI7XHJcblxyXG4gICAgICAgICAgICB2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIGVsZW0sIHR5cGUgKSxcclxuICAgICAgICAgICAgICAgIGZuID0gcXVldWUuc2hpZnQoKSxcclxuICAgICAgICAgICAgICAgIGhvb2tzID0ge307XHJcblxyXG4gICAgICAgICAgICAvLyBJZiB0aGUgZnggcXVldWUgaXMgZGVxdWV1ZWQsIGFsd2F5cyByZW1vdmUgdGhlIHByb2dyZXNzIHNlbnRpbmVsXHJcbiAgICAgICAgICAgIGlmICggZm4gPT09IFwiaW5wcm9ncmVzc1wiICkge1xyXG4gICAgICAgICAgICAgICAgZm4gPSBxdWV1ZS5zaGlmdCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIGZuICkge1xyXG4gICAgICAgICAgICAgICAgLy8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xyXG4gICAgICAgICAgICAgICAgLy8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxyXG4gICAgICAgICAgICAgICAgaWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVldWUudW5zaGlmdCggXCJpbnByb2dyZXNzXCIgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBqUXVlcnkuX2RhdGEoIGVsZW0sIHR5cGUgKyBcIi5ydW5cIiwgaG9va3MgKTtcclxuICAgICAgICAgICAgICAgIGZuLmNhbGwoIGVsZW0sIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5kZXF1ZXVlKCBlbGVtLCB0eXBlICk7XHJcbiAgICAgICAgICAgICAgICB9LCBob29rcyApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoICFxdWV1ZS5sZW5ndGggKSB7XHJcbiAgICAgICAgICAgICAgICBqUXVlcnkucmVtb3ZlRGF0YSggZWxlbSwgdHlwZSArIFwicXVldWUgXCIgKyB0eXBlICsgXCIucnVuXCIsIHRydWUgKTtcclxuICAgICAgICAgICAgICAgIGhhbmRsZVF1ZXVlTWFya0RlZmVyKCBlbGVtLCB0eXBlLCBcInF1ZXVlXCIgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xyXG4gICAgICAgIHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcclxuICAgICAgICAgICAgaWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSB0eXBlO1xyXG4gICAgICAgICAgICAgICAgdHlwZSA9IFwiZnhcIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBkYXRhID09PSB1bmRlZmluZWQgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWzBdLCB0eXBlICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgZGF0YSApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggdHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWzBdICE9PSBcImlucHJvZ3Jlc3NcIiApIHtcclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlcXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXHJcbiAgICAgICAgLy8gaHR0cDovL2JsaW5kc2lnbmFscy5jb20vaW5kZXgucGhwLzIwMDkvMDcvanF1ZXJ5LWRlbGF5L1xyXG4gICAgICAgIGRlbGF5OiBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcclxuICAgICAgICAgICAgdGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcclxuICAgICAgICAgICAgdHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVldWUoIHR5cGUsIGZ1bmN0aW9uKCBuZXh0LCBob29rcyApIHtcclxuICAgICAgICAgICAgICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dCggbmV4dCwgdGltZSApO1xyXG4gICAgICAgICAgICAgICAgaG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCggdGltZW91dCApO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxyXG4gICAgICAgIC8vIGFyZSBlbXB0aWVkIChmeCBpcyB0aGUgdHlwZSBieSBkZWZhdWx0KVxyXG4gICAgICAgIHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmplY3QgKSB7XHJcbiAgICAgICAgICAgIGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XHJcbiAgICAgICAgICAgICAgICBvYmplY3QgPSB0eXBlO1xyXG4gICAgICAgICAgICAgICAgdHlwZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0eXBlID0gdHlwZSB8fCBcImZ4XCI7XHJcbiAgICAgICAgICAgIHZhciBkZWZlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxyXG4gICAgICAgICAgICAgICAgZWxlbWVudHMgPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgaSA9IGVsZW1lbnRzLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIGNvdW50ID0gMSxcclxuICAgICAgICAgICAgICAgIGRlZmVyRGF0YUtleSA9IHR5cGUgKyBcImRlZmVyXCIsXHJcbiAgICAgICAgICAgICAgICBxdWV1ZURhdGFLZXkgPSB0eXBlICsgXCJxdWV1ZVwiLFxyXG4gICAgICAgICAgICAgICAgbWFya0RhdGFLZXkgPSB0eXBlICsgXCJtYXJrXCIsXHJcbiAgICAgICAgICAgICAgICB0bXA7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlc29sdmUoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoICEoIC0tY291bnQgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZlci5yZXNvbHZlV2l0aCggZWxlbWVudHMsIFsgZWxlbWVudHMgXSApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdoaWxlKCBpLS0gKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKCB0bXAgPSBqUXVlcnkuZGF0YSggZWxlbWVudHNbIGkgXSwgZGVmZXJEYXRhS2V5LCB1bmRlZmluZWQsIHRydWUgKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoIGpRdWVyeS5kYXRhKCBlbGVtZW50c1sgaSBdLCBxdWV1ZURhdGFLZXksIHVuZGVmaW5lZCwgdHJ1ZSApIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5kYXRhKCBlbGVtZW50c1sgaSBdLCBtYXJrRGF0YUtleSwgdW5kZWZpbmVkLCB0cnVlICkgKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZGF0YSggZWxlbWVudHNbIGkgXSwgZGVmZXJEYXRhS2V5LCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgdHJ1ZSApICkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIHRtcC5hZGQoIHJlc29sdmUgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBkZWZlci5wcm9taXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG5cclxuXHJcblxyXG4gICAgdmFyIHJjbGFzcyA9IC9bXFxuXFx0XFxyXS9nLFxyXG4gICAgICAgIHJzcGFjZSA9IC9cXHMrLyxcclxuICAgICAgICBycmV0dXJuID0gL1xcci9nLFxyXG4gICAgICAgIHJ0eXBlID0gL14oPzpidXR0b258aW5wdXQpJC9pLFxyXG4gICAgICAgIHJmb2N1c2FibGUgPSAvXig/OmJ1dHRvbnxpbnB1dHxvYmplY3R8c2VsZWN0fHRleHRhcmVhKSQvaSxcclxuICAgICAgICByY2xpY2thYmxlID0gL15hKD86cmVhKT8kL2ksXHJcbiAgICAgICAgcmJvb2xlYW4gPSAvXig/OmF1dG9mb2N1c3xhdXRvcGxheXxhc3luY3xjaGVja2VkfGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkfHNlbGVjdGVkKSQvaSxcclxuICAgICAgICBnZXRTZXRBdHRyaWJ1dGUgPSBqUXVlcnkuc3VwcG9ydC5nZXRTZXRBdHRyaWJ1dGUsXHJcbiAgICAgICAgbm9kZUhvb2ssIGJvb2xIb29rLCBmaXhTcGVjaWZpZWQ7XHJcblxyXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XHJcbiAgICAgICAgYXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xyXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmFjY2VzcyggdGhpcywgbmFtZSwgdmFsdWUsIHRydWUsIGpRdWVyeS5hdHRyICk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBqUXVlcnkucmVtb3ZlQXR0ciggdGhpcywgbmFtZSApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBwcm9wOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuYWNjZXNzKCB0aGlzLCBuYW1lLCB2YWx1ZSwgdHJ1ZSwgalF1ZXJ5LnByb3AgKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICByZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcclxuICAgICAgICAgICAgbmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIC8vIHRyeS9jYXRjaCBoYW5kbGVzIGNhc2VzIHdoZXJlIElFIGJhbGtzIChzdWNoIGFzIHJlbW92aW5nIGEgcHJvcGVydHkgb24gd2luZG93KVxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzWyBuYW1lIF0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXNbIG5hbWUgXTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2goIGUgKSB7fVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xyXG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lcywgaSwgbCwgZWxlbSxcclxuICAgICAgICAgICAgICAgIHNldENsYXNzLCBjLCBjbDtcclxuXHJcbiAgICAgICAgICAgIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBqICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKHRoaXMsIGosIHRoaXMuY2xhc3NOYW1lKSApO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICkge1xyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lcyA9IHZhbHVlLnNwbGl0KCByc3BhY2UgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW0gPSB0aGlzWyBpIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhZWxlbS5jbGFzc05hbWUgJiYgY2xhc3NOYW1lcy5sZW5ndGggPT09IDEgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmNsYXNzTmFtZSA9IHZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldENsYXNzID0gXCIgXCIgKyBlbGVtLmNsYXNzTmFtZSArIFwiIFwiO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGMgPSAwLCBjbCA9IGNsYXNzTmFtZXMubGVuZ3RoOyBjIDwgY2w7IGMrKyApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICF+c2V0Q2xhc3MuaW5kZXhPZiggXCIgXCIgKyBjbGFzc05hbWVzWyBjIF0gKyBcIiBcIiApICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRDbGFzcyArPSBjbGFzc05hbWVzWyBjIF0gKyBcIiBcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmNsYXNzTmFtZSA9IGpRdWVyeS50cmltKCBzZXRDbGFzcyApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICByZW1vdmVDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xyXG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lcywgaSwgbCwgZWxlbSwgY2xhc3NOYW1lLCBjLCBjbDtcclxuXHJcbiAgICAgICAgICAgIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBqICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSggdGhpcyApLnJlbW92ZUNsYXNzKCB2YWx1ZS5jYWxsKHRoaXMsIGosIHRoaXMuY2xhc3NOYW1lKSApO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZXMgPSAoIHZhbHVlIHx8IFwiXCIgKS5zcGxpdCggcnNwYWNlICk7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtID0gdGhpc1sgaSBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgZWxlbS5jbGFzc05hbWUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdmFsdWUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWUgPSAoXCIgXCIgKyBlbGVtLmNsYXNzTmFtZSArIFwiIFwiKS5yZXBsYWNlKCByY2xhc3MsIFwiIFwiICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBjID0gMCwgY2wgPSBjbGFzc05hbWVzLmxlbmd0aDsgYyA8IGNsOyBjKysgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lID0gY2xhc3NOYW1lLnJlcGxhY2UoXCIgXCIgKyBjbGFzc05hbWVzWyBjIF0gKyBcIiBcIiwgXCIgXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5jbGFzc05hbWUgPSBqUXVlcnkudHJpbSggY2xhc3NOYW1lICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5jbGFzc05hbWUgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcclxuICAgICAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWUsXHJcbiAgICAgICAgICAgICAgICBpc0Jvb2wgPSB0eXBlb2Ygc3RhdGVWYWwgPT09IFwiYm9vbGVhblwiO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KCB0aGlzICkudG9nZ2xlQ2xhc3MoIHZhbHVlLmNhbGwodGhpcywgaSwgdGhpcy5jbGFzc05hbWUsIHN0YXRlVmFsKSwgc3RhdGVWYWwgKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCB0eXBlID09PSBcInN0cmluZ1wiICkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZVZhbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lcyA9IHZhbHVlLnNwbGl0KCByc3BhY2UgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCAoY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0pICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBlYWNoIGNsYXNzTmFtZSBnaXZlbiwgc3BhY2Ugc2VwZXJhdGVkIGxpc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBpc0Jvb2wgPyBzdGF0ZSA6ICFzZWxmLmhhc0NsYXNzKCBjbGFzc05hbWUgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZlsgc3RhdGUgPyBcImFkZENsYXNzXCIgOiBcInJlbW92ZUNsYXNzXCIgXSggY2xhc3NOYW1lICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHR5cGUgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGlzLmNsYXNzTmFtZSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmUgY2xhc3NOYW1lIGlmIHNldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuX2RhdGEoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCB0aGlzLmNsYXNzTmFtZSApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdG9nZ2xlIHdob2xlIGNsYXNzTmFtZVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID8gXCJcIiA6IGpRdWVyeS5fZGF0YSggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xyXG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gXCIgXCIgKyBzZWxlY3RvciArIFwiIFwiLFxyXG4gICAgICAgICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICAgICAgICBsID0gdGhpcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoIDsgaSA8IGw7IGkrKyApIHtcclxuICAgICAgICAgICAgICAgIGlmICggdGhpc1tpXS5ub2RlVHlwZSA9PT0gMSAmJiAoXCIgXCIgKyB0aGlzW2ldLmNsYXNzTmFtZSArIFwiIFwiKS5yZXBsYWNlKHJjbGFzcywgXCIgXCIpLmluZGV4T2YoIGNsYXNzTmFtZSApID4gLTEgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcclxuICAgICAgICAgICAgdmFyIGhvb2tzLCByZXQsIGlzRnVuY3Rpb24sXHJcbiAgICAgICAgICAgICAgICBlbGVtID0gdGhpc1swXTtcclxuXHJcbiAgICAgICAgICAgIGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIGVsZW0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9va3MgPSBqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdIHx8IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBcInZhbHVlXCIgKSkgIT09IHVuZGVmaW5lZCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldCA9IGVsZW0udmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIG1vc3QgY29tbW9uIHN0cmluZyBjYXNlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXQucmVwbGFjZShycmV0dXJuLCBcIlwiKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgPT0gbnVsbCA/IFwiXCIgOiByZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSBqUXVlcnkodGhpcyksIHZhbDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICggaXNGdW5jdGlvbiApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBzZWxmLnZhbCgpICk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcclxuICAgICAgICAgICAgICAgIGlmICggdmFsID09IG51bGwgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsICs9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBqUXVlcnkuaXNBcnJheSggdmFsICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsID0galF1ZXJ5Lm1hcCh2YWwsIGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBob29rcyA9IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xyXG4gICAgICAgICAgICAgICAgaWYgKCAhaG9va3MgfHwgIShcInNldFwiIGluIGhvb2tzKSB8fCBob29rcy5zZXQoIHRoaXMsIHZhbCwgXCJ2YWx1ZVwiICkgPT09IHVuZGVmaW5lZCApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBqUXVlcnkuZXh0ZW5kKHtcclxuICAgICAgICB2YWxIb29rczoge1xyXG4gICAgICAgICAgICBvcHRpb246IHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXR0cmlidXRlcy52YWx1ZSBpcyB1bmRlZmluZWQgaW4gQmxhY2tiZXJyeSA0LjcgYnV0XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlcyAudmFsdWUuIFNlZSAjNjkzMlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBlbGVtLmF0dHJpYnV0ZXMudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICF2YWwgfHwgdmFsLnNwZWNpZmllZCA/IGVsZW0udmFsdWUgOiBlbGVtLnRleHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNlbGVjdDoge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiggZWxlbSApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUsIGksIG1heCwgb3B0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGhpbmcgd2FzIHNlbGVjdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpbmRleCA8IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgIGkgPSBvbmUgPyBpbmRleCA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gb25lID8gaW5kZXggKyAxIDogb3B0aW9ucy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbWF4OyBpKysgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBvcHRpb24uc2VsZWN0ZWQgJiYgKGpRdWVyeS5zdXBwb3J0Lm9wdERpc2FibGVkID8gIW9wdGlvbi5kaXNhYmxlZCA6IG9wdGlvbi5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA9PT0gbnVsbCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICghb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHwgIWpRdWVyeS5ub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIiApKSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggb25lICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goIHZhbHVlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeGVzIEJ1ZyAjMjU1MSAtLSBzZWxlY3QudmFsKCkgYnJva2VuIGluIElFIGFmdGVyIGZvcm0ucmVzZXQoKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggb25lICYmICF2YWx1ZXMubGVuZ3RoICYmIG9wdGlvbnMubGVuZ3RoICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5KCBvcHRpb25zWyBpbmRleCBdICkudmFsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSggdmFsdWUgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KGVsZW0pLmZpbmQoXCJvcHRpb25cIikuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkodGhpcykudmFsKCksIHZhbHVlcyApID49IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggIXZhbHVlcy5sZW5ndGggKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2VsZWN0ZWRJbmRleCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYXR0ckZuOiB7XHJcbiAgICAgICAgICAgIHZhbDogdHJ1ZSxcclxuICAgICAgICAgICAgY3NzOiB0cnVlLFxyXG4gICAgICAgICAgICBodG1sOiB0cnVlLFxyXG4gICAgICAgICAgICB0ZXh0OiB0cnVlLFxyXG4gICAgICAgICAgICBkYXRhOiB0cnVlLFxyXG4gICAgICAgICAgICB3aWR0aDogdHJ1ZSxcclxuICAgICAgICAgICAgaGVpZ2h0OiB0cnVlLFxyXG4gICAgICAgICAgICBvZmZzZXQ6IHRydWVcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBhdHRyOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUsIHBhc3MgKSB7XHJcbiAgICAgICAgICAgIHZhciByZXQsIGhvb2tzLCBub3R4bWwsXHJcbiAgICAgICAgICAgICAgICBuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XHJcblxyXG4gICAgICAgICAgICAvLyBkb24ndCBnZXQvc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXHJcbiAgICAgICAgICAgIGlmICggIWVsZW0gfHwgblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggcGFzcyAmJiBuYW1lIGluIGpRdWVyeS5hdHRyRm4gKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5KCBlbGVtIClbIG5hbWUgXSggdmFsdWUgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcclxuICAgICAgICAgICAgaWYgKCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgPT09IFwidW5kZWZpbmVkXCIgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG5vdHhtbCA9IG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFsbCBhdHRyaWJ1dGVzIGFyZSBsb3dlcmNhc2VcclxuICAgICAgICAgICAgLy8gR3JhYiBuZWNlc3NhcnkgaG9vayBpZiBvbmUgaXMgZGVmaW5lZFxyXG4gICAgICAgICAgICBpZiAoIG5vdHhtbCApIHtcclxuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICBob29rcyA9IGpRdWVyeS5hdHRySG9va3NbIG5hbWUgXSB8fCAoIHJib29sZWFuLnRlc3QoIG5hbWUgKSA/IGJvb2xIb29rIDogbm9kZUhvb2sgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggdmFsdWUgPT09IG51bGwgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJiBub3R4bWwgJiYgKHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSkgIT09IHVuZGVmaW5lZCApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIFwiXCIgKyB2YWx1ZSApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgbm90eG1sICYmIChyZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSkgIT09IG51bGwgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZXQgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0ID09PSBudWxsID9cclxuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQgOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcclxuICAgICAgICAgICAgdmFyIHByb3BOYW1lLCBhdHRyTmFtZXMsIG5hbWUsIGwsXHJcbiAgICAgICAgICAgICAgICBpID0gMDtcclxuXHJcbiAgICAgICAgICAgIGlmICggdmFsdWUgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcclxuICAgICAgICAgICAgICAgIGF0dHJOYW1lcyA9IHZhbHVlLnRvTG93ZXJDYXNlKCkuc3BsaXQoIHJzcGFjZSApO1xyXG4gICAgICAgICAgICAgICAgbCA9IGF0dHJOYW1lcy5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbDsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBhdHRyTmFtZXNbIGkgXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBuYW1lICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wTmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlZSAjOTY5OSBmb3IgZXhwbGFuYXRpb24gb2YgdGhpcyBhcHByb2FjaCAoc2V0dGluZyBmaXJzdCwgdGhlbiByZW1vdmFsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuYXR0ciggZWxlbSwgbmFtZSwgXCJcIiApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZSggZ2V0U2V0QXR0cmlidXRlID8gbmFtZSA6IHByb3BOYW1lICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSB0byBmYWxzZSBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcmJvb2xlYW4udGVzdCggbmFtZSApICYmIHByb3BOYW1lIGluIGVsZW0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtWyBwcm9wTmFtZSBdID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBhdHRySG9va3M6IHtcclxuICAgICAgICAgICAgdHlwZToge1xyXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2FuJ3QgYWxsb3cgdGhlIHR5cGUgcHJvcGVydHkgdG8gYmUgY2hhbmdlZCAoc2luY2UgaXQgY2F1c2VzIHByb2JsZW1zIGluIElFKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggcnR5cGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmIGVsZW0ucGFyZW50Tm9kZSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmVycm9yKCBcInR5cGUgcHJvcGVydHkgY2FuJ3QgYmUgY2hhbmdlZFwiICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggIWpRdWVyeS5zdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFwicmFkaW9cIiAmJiBqUXVlcnkubm9kZU5hbWUoZWxlbSwgXCJpbnB1dFwiKSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0dGluZyB0aGUgdHlwZSBvbiBhIHJhZGlvIGJ1dHRvbiBhZnRlciB0aGUgdmFsdWUgcmVzZXRzIHRoZSB2YWx1ZSBpbiBJRTYtOVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCB2YWx1ZSB0byBpdCdzIGRlZmF1bHQgaW4gY2FzZSB0eXBlIGlzIHNldCBhZnRlciB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGZvciBlbGVtZW50IGNyZWF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBlbGVtLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIHZhbHVlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdmFsICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS52YWx1ZSA9IHZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyBVc2UgdGhlIHZhbHVlIHByb3BlcnR5IGZvciBiYWNrIGNvbXBhdFxyXG4gICAgICAgICAgICAvLyBVc2UgdGhlIG5vZGVIb29rIGZvciBidXR0b24gZWxlbWVudHMgaW4gSUU2LzcgKCMxOTU0KVxyXG4gICAgICAgICAgICB2YWx1ZToge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIG5vZGVIb29rICYmIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJidXR0b25cIiApICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZUhvb2suZ2V0KCBlbGVtLCBuYW1lICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lIGluIGVsZW0gP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnZhbHVlIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbDtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIG5vZGVIb29rICYmIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJidXR0b25cIiApICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZUhvb2suc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBEb2VzIG5vdCByZXR1cm4gc28gdGhhdCBzZXRBdHRyaWJ1dGUgaXMgYWxzbyB1c2VkXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbS52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcHJvcEZpeDoge1xyXG4gICAgICAgICAgICB0YWJpbmRleDogXCJ0YWJJbmRleFwiLFxyXG4gICAgICAgICAgICByZWFkb25seTogXCJyZWFkT25seVwiLFxyXG4gICAgICAgICAgICBcImZvclwiOiBcImh0bWxGb3JcIixcclxuICAgICAgICAgICAgXCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiLFxyXG4gICAgICAgICAgICBtYXhsZW5ndGg6IFwibWF4TGVuZ3RoXCIsXHJcbiAgICAgICAgICAgIGNlbGxzcGFjaW5nOiBcImNlbGxTcGFjaW5nXCIsXHJcbiAgICAgICAgICAgIGNlbGxwYWRkaW5nOiBcImNlbGxQYWRkaW5nXCIsXHJcbiAgICAgICAgICAgIHJvd3NwYW46IFwicm93U3BhblwiLFxyXG4gICAgICAgICAgICBjb2xzcGFuOiBcImNvbFNwYW5cIixcclxuICAgICAgICAgICAgdXNlbWFwOiBcInVzZU1hcFwiLFxyXG4gICAgICAgICAgICBmcmFtZWJvcmRlcjogXCJmcmFtZUJvcmRlclwiLFxyXG4gICAgICAgICAgICBjb250ZW50ZWRpdGFibGU6IFwiY29udGVudEVkaXRhYmxlXCJcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XHJcbiAgICAgICAgICAgIHZhciByZXQsIGhvb2tzLCBub3R4bWwsXHJcbiAgICAgICAgICAgICAgICBuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XHJcblxyXG4gICAgICAgICAgICAvLyBkb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXHJcbiAgICAgICAgICAgIGlmICggIWVsZW0gfHwgblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG5vdHhtbCA9IG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggbm90eG1sICkge1xyXG4gICAgICAgICAgICAgICAgLy8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xyXG4gICAgICAgICAgICAgICAgbmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcclxuICAgICAgICAgICAgICAgIGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSkgIT09IHVuZGVmaW5lZCApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICggZWxlbVsgbmFtZSBdID0gdmFsdWUgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApKSAhPT0gbnVsbCApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1bIG5hbWUgXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHByb3BIb29rczoge1xyXG4gICAgICAgICAgICB0YWJJbmRleDoge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiggZWxlbSApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBlbGVtLnRhYkluZGV4IGRvZXNuJ3QgYWx3YXlzIHJldHVybiB0aGUgY29ycmVjdCB2YWx1ZSB3aGVuIGl0IGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL2ZsdWlkcHJvamVjdC5vcmcvYmxvZy8yMDA4LzAxLzA5L2dldHRpbmctc2V0dGluZy1hbmQtcmVtb3ZpbmctdGFiaW5kZXgtdmFsdWVzLXdpdGgtamF2YXNjcmlwdC9cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlTm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcInRhYmluZGV4XCIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXR0cmlidXRlTm9kZSAmJiBhdHRyaWJ1dGVOb2RlLnNwZWNpZmllZCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KCBhdHRyaWJ1dGVOb2RlLnZhbHVlLCAxMCApIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHwgcmNsaWNrYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgJiYgZWxlbS5ocmVmID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4vLyBBZGQgdGhlIHRhYkluZGV4IHByb3BIb29rIHRvIGF0dHJIb29rcyBmb3IgYmFjay1jb21wYXQgKGRpZmZlcmVudCBjYXNlIGlzIGludGVudGlvbmFsKVxyXG4gICAgalF1ZXJ5LmF0dHJIb29rcy50YWJpbmRleCA9IGpRdWVyeS5wcm9wSG9va3MudGFiSW5kZXg7XHJcblxyXG4vLyBIb29rIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcclxuICAgIGJvb2xIb29rID0ge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XHJcbiAgICAgICAgICAgIC8vIEFsaWduIGJvb2xlYW4gYXR0cmlidXRlcyB3aXRoIGNvcnJlc3BvbmRpbmcgcHJvcGVydGllc1xyXG4gICAgICAgICAgICAvLyBGYWxsIGJhY2sgdG8gYXR0cmlidXRlIHByZXNlbmNlIHdoZXJlIHNvbWUgYm9vbGVhbnMgYXJlIG5vdCBzdXBwb3J0ZWRcclxuICAgICAgICAgICAgdmFyIGF0dHJOb2RlLFxyXG4gICAgICAgICAgICAgICAgcHJvcGVydHkgPSBqUXVlcnkucHJvcCggZWxlbSwgbmFtZSApO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvcGVydHkgPT09IHRydWUgfHwgdHlwZW9mIHByb3BlcnR5ICE9PSBcImJvb2xlYW5cIiAmJiAoIGF0dHJOb2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpICkgJiYgYXR0ck5vZGUubm9kZVZhbHVlICE9PSBmYWxzZSA/XHJcbiAgICAgICAgICAgICAgICBuYW1lLnRvTG93ZXJDYXNlKCkgOlxyXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9wTmFtZTtcclxuICAgICAgICAgICAgaWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXHJcbiAgICAgICAgICAgICAgICBqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gdmFsdWUgaXMgdHJ1ZSBzaW5jZSB3ZSBrbm93IGF0IHRoaXMgcG9pbnQgaXQncyB0eXBlIGJvb2xlYW4gYW5kIG5vdCBmYWxzZVxyXG4gICAgICAgICAgICAgICAgLy8gU2V0IGJvb2xlYW4gYXR0cmlidXRlcyB0byB0aGUgc2FtZSBuYW1lIGFuZCBzZXQgdGhlIERPTSBwcm9wZXJ0eVxyXG4gICAgICAgICAgICAgICAgcHJvcE5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoIHByb3BOYW1lIGluIGVsZW0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSBzZXQgdGhlIElETCBzcGVjaWZpY2FsbHkgaWYgaXQgYWxyZWFkeSBleGlzdHMgb24gdGhlIGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICBlbGVtWyBwcm9wTmFtZSBdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbi8vIElFNi83IGRvIG5vdCBzdXBwb3J0IGdldHRpbmcvc2V0dGluZyBzb21lIGF0dHJpYnV0ZXMgd2l0aCBnZXQvc2V0QXR0cmlidXRlXHJcbiAgICBpZiAoICFnZXRTZXRBdHRyaWJ1dGUgKSB7XHJcblxyXG4gICAgICAgIGZpeFNwZWNpZmllZCA9IHtcclxuICAgICAgICAgICAgbmFtZTogdHJ1ZSxcclxuICAgICAgICAgICAgaWQ6IHRydWVcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBVc2UgdGhpcyBmb3IgYW55IGF0dHJpYnV0ZSBpbiBJRTYvN1xyXG4gICAgICAgIC8vIFRoaXMgZml4ZXMgYWxtb3N0IGV2ZXJ5IElFNi83IGlzc3VlXHJcbiAgICAgICAgbm9kZUhvb2sgPSBqUXVlcnkudmFsSG9va3MuYnV0dG9uID0ge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJldDtcclxuICAgICAgICAgICAgICAgIHJldCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldCAmJiAoIGZpeFNwZWNpZmllZFsgbmFtZSBdID8gcmV0Lm5vZGVWYWx1ZSAhPT0gXCJcIiA6IHJldC5zcGVjaWZpZWQgKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0Lm5vZGVWYWx1ZSA6XHJcbiAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcclxuICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgZXhpc3Rpbmcgb3IgY3JlYXRlIGEgbmV3IGF0dHJpYnV0ZSBub2RlXHJcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICk7XHJcbiAgICAgICAgICAgICAgICBpZiAoICFyZXQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gZG9jdW1lbnQuY3JlYXRlQXR0cmlidXRlKCBuYW1lICk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGVOb2RlKCByZXQgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiAoIHJldC5ub2RlVmFsdWUgPSB2YWx1ZSArIFwiXCIgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIEFwcGx5IHRoZSBub2RlSG9vayB0byB0YWJpbmRleFxyXG4gICAgICAgIGpRdWVyeS5hdHRySG9va3MudGFiaW5kZXguc2V0ID0gbm9kZUhvb2suc2V0O1xyXG5cclxuICAgICAgICAvLyBTZXQgd2lkdGggYW5kIGhlaWdodCB0byBhdXRvIGluc3RlYWQgb2YgMCBvbiBlbXB0eSBzdHJpbmcoIEJ1ZyAjODE1MCApXHJcbiAgICAgICAgLy8gVGhpcyBpcyBmb3IgcmVtb3ZhbHNcclxuICAgICAgICBqUXVlcnkuZWFjaChbIFwid2lkdGhcIiwgXCJoZWlnaHRcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcclxuICAgICAgICAgICAgalF1ZXJ5LmF0dHJIb29rc1sgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggalF1ZXJ5LmF0dHJIb29rc1sgbmFtZSBdLCB7XHJcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHZhbHVlID09PSBcIlwiICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgXCJhdXRvXCIgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIFNldCBjb250ZW50ZWRpdGFibGUgdG8gZmFsc2Ugb24gcmVtb3ZhbHMoIzEwNDI5KVxyXG4gICAgICAgIC8vIFNldHRpbmcgdG8gZW1wdHkgc3RyaW5nIHRocm93cyBhbiBlcnJvciBhcyBhbiBpbnZhbGlkIHZhbHVlXHJcbiAgICAgICAgalF1ZXJ5LmF0dHJIb29rcy5jb250ZW50ZWRpdGFibGUgPSB7XHJcbiAgICAgICAgICAgIGdldDogbm9kZUhvb2suZ2V0LFxyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcclxuICAgICAgICAgICAgICAgIGlmICggdmFsdWUgPT09IFwiXCIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBcImZhbHNlXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBub2RlSG9vay5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuXHJcbi8vIFNvbWUgYXR0cmlidXRlcyByZXF1aXJlIGEgc3BlY2lhbCBjYWxsIG9uIElFXHJcbiAgICBpZiAoICFqUXVlcnkuc3VwcG9ydC5ocmVmTm9ybWFsaXplZCApIHtcclxuICAgICAgICBqUXVlcnkuZWFjaChbIFwiaHJlZlwiLCBcInNyY1wiLCBcIndpZHRoXCIsIFwiaGVpZ2h0XCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XHJcbiAgICAgICAgICAgIGpRdWVyeS5hdHRySG9va3NbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGpRdWVyeS5hdHRySG9va3NbIG5hbWUgXSwge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiggZWxlbSApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUsIDIgKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0ID09PSBudWxsID8gdW5kZWZpbmVkIDogcmV0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoICFqUXVlcnkuc3VwcG9ydC5zdHlsZSApIHtcclxuICAgICAgICBqUXVlcnkuYXR0ckhvb2tzLnN0eWxlID0ge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xyXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIHVuZGVmaW5lZCBpbiB0aGUgY2FzZSBvZiBlbXB0eSBzdHJpbmdcclxuICAgICAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSB0byBsb3dlcmNhc2Ugc2luY2UgSUUgdXBwZXJjYXNlcyBjc3MgcHJvcGVydHkgbmFtZXNcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLnN0eWxlLmNzc1RleHQudG9Mb3dlckNhc2UoKSB8fCB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICggZWxlbS5zdHlsZS5jc3NUZXh0ID0gXCJcIiArIHZhbHVlICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuLy8gU2FmYXJpIG1pcy1yZXBvcnRzIHRoZSBkZWZhdWx0IHNlbGVjdGVkIHByb3BlcnR5IG9mIGFuIG9wdGlvblxyXG4vLyBBY2Nlc3NpbmcgdGhlIHBhcmVudCdzIHNlbGVjdGVkSW5kZXggcHJvcGVydHkgZml4ZXMgaXRcclxuICAgIGlmICggIWpRdWVyeS5zdXBwb3J0Lm9wdFNlbGVjdGVkICkge1xyXG4gICAgICAgIGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQgPSBqUXVlcnkuZXh0ZW5kKCBqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggcGFyZW50ICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5zZWxlY3RlZEluZGV4O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBpdCBhbHNvIHdvcmtzIHdpdGggb3B0Z3JvdXBzLCBzZWUgIzU3MDFcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHBhcmVudC5wYXJlbnROb2RlICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4vLyBJRTYvNyBjYWxsIGVuY3R5cGUgZW5jb2RpbmdcclxuICAgIGlmICggIWpRdWVyeS5zdXBwb3J0LmVuY3R5cGUgKSB7XHJcbiAgICAgICAgalF1ZXJ5LnByb3BGaXguZW5jdHlwZSA9IFwiZW5jb2RpbmdcIjtcclxuICAgIH1cclxuXHJcbi8vIFJhZGlvcyBhbmQgY2hlY2tib3hlcyBnZXR0ZXIvc2V0dGVyXHJcbiAgICBpZiAoICFqUXVlcnkuc3VwcG9ydC5jaGVja09uICkge1xyXG4gICAgICAgIGpRdWVyeS5lYWNoKFsgXCJyYWRpb1wiLCBcImNoZWNrYm94XCIgXSwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0ge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiggZWxlbSApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgaW4gV2Via2l0IFwiXCIgaXMgcmV0dXJuZWQgaW5zdGVhZCBvZiBcIm9uXCIgaWYgYSB2YWx1ZSBpc24ndCBzcGVjaWZpZWRcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSA9PT0gbnVsbCA/IFwib25cIiA6IGVsZW0udmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBqUXVlcnkuZWFjaChbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0galF1ZXJ5LmV4dGVuZCggalF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0sIHtcclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWx1ZSApICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoIGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkoZWxlbSkudmFsKCksIHZhbHVlICkgPj0gMCApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcblxyXG5cclxuXHJcbiAgICB2YXIgcmZvcm1FbGVtcyA9IC9eKD86dGV4dGFyZWF8aW5wdXR8c2VsZWN0KSQvaSxcclxuICAgICAgICBydHlwZW5hbWVzcGFjZSA9IC9eKFteXFwuXSopPyg/OlxcLiguKykpPyQvLFxyXG4gICAgICAgIHJob3ZlckhhY2sgPSAvXFxiaG92ZXIoXFwuXFxTKyk/XFxiLyxcclxuICAgICAgICBya2V5RXZlbnQgPSAvXmtleS8sXHJcbiAgICAgICAgcm1vdXNlRXZlbnQgPSAvXig/Om1vdXNlfGNvbnRleHRtZW51KXxjbGljay8sXHJcbiAgICAgICAgcmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC8sXHJcbiAgICAgICAgcnF1aWNrSXMgPSAvXihcXHcqKSg/OiMoW1xcd1xcLV0rKSk/KD86XFwuKFtcXHdcXC1dKykpPyQvLFxyXG4gICAgICAgIHF1aWNrUGFyc2UgPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XHJcbiAgICAgICAgICAgIHZhciBxdWljayA9IHJxdWlja0lzLmV4ZWMoIHNlbGVjdG9yICk7XHJcbiAgICAgICAgICAgIGlmICggcXVpY2sgKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAgIDAgIDEgICAgMiAgIDNcclxuICAgICAgICAgICAgICAgIC8vIFsgXywgdGFnLCBpZCwgY2xhc3MgXVxyXG4gICAgICAgICAgICAgICAgcXVpY2tbMV0gPSAoIHF1aWNrWzFdIHx8IFwiXCIgKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgcXVpY2tbM10gPSBxdWlja1szXSAmJiBuZXcgUmVnRXhwKCBcIig/Ol58XFxcXHMpXCIgKyBxdWlja1szXSArIFwiKD86XFxcXHN8JClcIiApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBxdWljaztcclxuICAgICAgICB9LFxyXG4gICAgICAgIHF1aWNrSXMgPSBmdW5jdGlvbiggZWxlbSwgbSApIHtcclxuICAgICAgICAgICAgdmFyIGF0dHJzID0gZWxlbS5hdHRyaWJ1dGVzIHx8IHt9O1xyXG4gICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgKCFtWzFdIHx8IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbVsxXSkgJiZcclxuICAgICAgICAgICAgICAgICghbVsyXSB8fCAoYXR0cnMuaWQgfHwge30pLnZhbHVlID09PSBtWzJdKSAmJlxyXG4gICAgICAgICAgICAgICAgKCFtWzNdIHx8IG1bM10udGVzdCggKGF0dHJzWyBcImNsYXNzXCIgXSB8fCB7fSkudmFsdWUgKSlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhvdmVySGFjayA9IGZ1bmN0aW9uKCBldmVudHMgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZXZlbnQuc3BlY2lhbC5ob3ZlciA/IGV2ZW50cyA6IGV2ZW50cy5yZXBsYWNlKCByaG92ZXJIYWNrLCBcIm1vdXNlZW50ZXIkMSBtb3VzZWxlYXZlJDFcIiApO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgLypcclxuICAgICAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cclxuICAgICAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXHJcbiAgICAgKi9cclxuICAgIGpRdWVyeS5ldmVudCA9IHtcclxuXHJcbiAgICAgICAgYWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGVsZW1EYXRhLCBldmVudEhhbmRsZSwgZXZlbnRzLFxyXG4gICAgICAgICAgICAgICAgdCwgdG5zLCB0eXBlLCBuYW1lc3BhY2VzLCBoYW5kbGVPYmosXHJcbiAgICAgICAgICAgICAgICBoYW5kbGVPYmpJbiwgcXVpY2ssIGhhbmRsZXJzLCBzcGVjaWFsO1xyXG5cclxuICAgICAgICAgICAgLy8gRG9uJ3QgYXR0YWNoIGV2ZW50cyB0byBub0RhdGEgb3IgdGV4dC9jb21tZW50IG5vZGVzIChhbGxvdyBwbGFpbiBvYmplY3RzIHRobylcclxuICAgICAgICAgICAgaWYgKCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggfHwgIXR5cGVzIHx8ICFoYW5kbGVyIHx8ICEoZWxlbURhdGEgPSBqUXVlcnkuX2RhdGEoIGVsZW0gKSkgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxyXG4gICAgICAgICAgICBpZiAoIGhhbmRsZXIuaGFuZGxlciApIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZU9iakluID0gaGFuZGxlcjtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcclxuICAgICAgICAgICAgaWYgKCAhaGFuZGxlci5ndWlkICkge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdFxyXG4gICAgICAgICAgICBldmVudHMgPSBlbGVtRGF0YS5ldmVudHM7XHJcbiAgICAgICAgICAgIGlmICggIWV2ZW50cyApIHtcclxuICAgICAgICAgICAgICAgIGVsZW1EYXRhLmV2ZW50cyA9IGV2ZW50cyA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlO1xyXG4gICAgICAgICAgICBpZiAoICFldmVudEhhbmRsZSApIHtcclxuICAgICAgICAgICAgICAgIGVsZW1EYXRhLmhhbmRsZSA9IGV2ZW50SGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcclxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIgJiYgKCFlIHx8IGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSkgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuZGlzcGF0Y2guYXBwbHkoIGV2ZW50SGFuZGxlLmVsZW0sIGFyZ3VtZW50cyApIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8vIEFkZCBlbGVtIGFzIGEgcHJvcGVydHkgb2YgdGhlIGhhbmRsZSBmbiB0byBwcmV2ZW50IGEgbWVtb3J5IGxlYWsgd2l0aCBJRSBub24tbmF0aXZlIGV2ZW50c1xyXG4gICAgICAgICAgICAgICAgZXZlbnRIYW5kbGUuZWxlbSA9IGVsZW07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2VcclxuICAgICAgICAgICAgLy8galF1ZXJ5KC4uLikuYmluZChcIm1vdXNlb3ZlciBtb3VzZW91dFwiLCBmbik7XHJcbiAgICAgICAgICAgIHR5cGVzID0galF1ZXJ5LnRyaW0oIGhvdmVySGFjayh0eXBlcykgKS5zcGxpdCggXCIgXCIgKTtcclxuICAgICAgICAgICAgZm9yICggdCA9IDA7IHQgPCB0eXBlcy5sZW5ndGg7IHQrKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0bnMgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1t0XSApIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgdHlwZSA9IHRuc1sxXTtcclxuICAgICAgICAgICAgICAgIG5hbWVzcGFjZXMgPSAoIHRuc1syXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxyXG4gICAgICAgICAgICAgICAgc3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXHJcbiAgICAgICAgICAgICAgICB0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxyXG4gICAgICAgICAgICAgICAgc3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcclxuICAgICAgICAgICAgICAgIGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ1R5cGU6IHRuc1sxXSxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgZ3VpZDogaGFuZGxlci5ndWlkLFxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcclxuICAgICAgICAgICAgICAgICAgICBxdWljazogcXVpY2tQYXJzZSggc2VsZWN0b3IgKSxcclxuICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbihcIi5cIilcclxuICAgICAgICAgICAgICAgIH0sIGhhbmRsZU9iakluICk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3RcclxuICAgICAgICAgICAgICAgIGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF07XHJcbiAgICAgICAgICAgICAgICBpZiAoICFoYW5kbGVycyApIHtcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIvYXR0YWNoRXZlbnQgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggIXNwZWNpYWwuc2V0dXAgfHwgc3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmluZCB0aGUgZ2xvYmFsIGV2ZW50IGhhbmRsZXIgdG8gdGhlIGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlLCBmYWxzZSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggZWxlbS5hdHRhY2hFdmVudCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uYXR0YWNoRXZlbnQoIFwib25cIiArIHR5cGUsIGV2ZW50SGFuZGxlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBzcGVjaWFsLmFkZCApIHtcclxuICAgICAgICAgICAgICAgICAgICBzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcclxuICAgICAgICAgICAgICAgIGlmICggc2VsZWN0b3IgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXHJcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBOdWxsaWZ5IGVsZW0gdG8gcHJldmVudCBtZW1vcnkgbGVha3MgaW4gSUVcclxuICAgICAgICAgICAgZWxlbSA9IG51bGw7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2xvYmFsOiB7fSxcclxuXHJcbiAgICAgICAgLy8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XHJcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcyApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBlbGVtRGF0YSA9IGpRdWVyeS5oYXNEYXRhKCBlbGVtICkgJiYgalF1ZXJ5Ll9kYXRhKCBlbGVtICksXHJcbiAgICAgICAgICAgICAgICB0LCB0bnMsIHR5cGUsIG9yaWdUeXBlLCBuYW1lc3BhY2VzLCBvcmlnQ291bnQsXHJcbiAgICAgICAgICAgICAgICBqLCBldmVudHMsIHNwZWNpYWwsIGhhbmRsZSwgZXZlbnRUeXBlLCBoYW5kbGVPYmo7XHJcblxyXG4gICAgICAgICAgICBpZiAoICFlbGVtRGF0YSB8fCAhKGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cykgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcclxuICAgICAgICAgICAgdHlwZXMgPSBqUXVlcnkudHJpbSggaG92ZXJIYWNrKCB0eXBlcyB8fCBcIlwiICkgKS5zcGxpdChcIiBcIik7XHJcbiAgICAgICAgICAgIGZvciAoIHQgPSAwOyB0IDwgdHlwZXMubGVuZ3RoOyB0KysgKSB7XHJcbiAgICAgICAgICAgICAgICB0bnMgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1t0XSApIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgdHlwZSA9IG9yaWdUeXBlID0gdG5zWzFdO1xyXG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlcyA9IHRuc1syXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVbmJpbmQgYWxsIGV2ZW50cyAob24gdGhpcyBuYW1lc3BhY2UsIGlmIHByb3ZpZGVkKSBmb3IgdGhlIGVsZW1lbnRcclxuICAgICAgICAgICAgICAgIGlmICggIXR5cGUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICggdHlwZSBpbiBldmVudHMgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKyB0eXBlc1sgdCBdLCBoYW5kbGVyLCBzZWxlY3RvciwgdHJ1ZSApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcclxuICAgICAgICAgICAgICAgIHR5cGUgPSAoIHNlbGVjdG9yPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xyXG4gICAgICAgICAgICAgICAgZXZlbnRUeXBlID0gZXZlbnRzWyB0eXBlIF0gfHwgW107XHJcbiAgICAgICAgICAgICAgICBvcmlnQ291bnQgPSBldmVudFR5cGUubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlcyA9IG5hbWVzcGFjZXMgPyBuZXcgUmVnRXhwKFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLnNwbGl0KFwiLlwiKS5zb3J0KCkuam9pbihcIlxcXFwuKD86LipcXFxcLik/XCIpICsgXCIoXFxcXC58JClcIikgOiBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcclxuICAgICAgICAgICAgICAgIGZvciAoIGogPSAwOyBqIDwgZXZlbnRUeXBlLmxlbmd0aDsgaisrICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iaiA9IGV2ZW50VHlwZVsgaiBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICggIW5hbWVzcGFjZXMgfHwgbmFtZXNwYWNlcy50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoICFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50VHlwZS5zcGxpY2UoIGotLSwgMSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBoYW5kbGVPYmouc2VsZWN0b3IgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFR5cGUuZGVsZWdhdGVDb3VudC0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc3BlY2lhbC5yZW1vdmUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGVjaWFsLnJlbW92ZS5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XHJcbiAgICAgICAgICAgICAgICAvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcclxuICAgICAgICAgICAgICAgIGlmICggZXZlbnRUeXBlLmxlbmd0aCA9PT0gMCAmJiBvcmlnQ291bnQgIT09IGV2ZW50VHlwZS5sZW5ndGggKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fCBzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMgKSA9PT0gZmFsc2UgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZXZlbnRzWyB0eXBlIF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXHJcbiAgICAgICAgICAgIGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGV2ZW50cyApICkge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlID0gZWxlbURhdGEuaGFuZGxlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCBoYW5kbGUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlLmVsZW0gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZURhdGEgYWxzbyBjaGVja3MgZm9yIGVtcHRpbmVzcyBhbmQgY2xlYXJzIHRoZSBleHBhbmRvIGlmIGVtcHR5XHJcbiAgICAgICAgICAgICAgICAvLyBzbyB1c2UgaXQgaW5zdGVhZCBvZiBkZWxldGVcclxuICAgICAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVEYXRhKCBlbGVtLCBbIFwiZXZlbnRzXCIsIFwiaGFuZGxlXCIgXSwgdHJ1ZSApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gRXZlbnRzIHRoYXQgYXJlIHNhZmUgdG8gc2hvcnQtY2lyY3VpdCBpZiBubyBoYW5kbGVycyBhcmUgYXR0YWNoZWQuXHJcbiAgICAgICAgLy8gTmF0aXZlIERPTSBldmVudHMgc2hvdWxkIG5vdCBiZSBhZGRlZCwgdGhleSBtYXkgaGF2ZSBpbmxpbmUgaGFuZGxlcnMuXHJcbiAgICAgICAgY3VzdG9tRXZlbnQ6IHtcclxuICAgICAgICAgICAgXCJnZXREYXRhXCI6IHRydWUsXHJcbiAgICAgICAgICAgIFwic2V0RGF0YVwiOiB0cnVlLFxyXG4gICAgICAgICAgICBcImNoYW5nZURhdGFcIjogdHJ1ZVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xyXG4gICAgICAgICAgICAvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xyXG4gICAgICAgICAgICBpZiAoIGVsZW0gJiYgKGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCkgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEV2ZW50IG9iamVjdCBvciBldmVudCB0eXBlXHJcbiAgICAgICAgICAgIHZhciB0eXBlID0gZXZlbnQudHlwZSB8fCBldmVudCxcclxuICAgICAgICAgICAgICAgIG5hbWVzcGFjZXMgPSBbXSxcclxuICAgICAgICAgICAgICAgIGNhY2hlLCBleGNsdXNpdmUsIGksIGN1ciwgb2xkLCBvbnR5cGUsIHNwZWNpYWwsIGhhbmRsZSwgZXZlbnRQYXRoLCBidWJibGVUeXBlO1xyXG5cclxuICAgICAgICAgICAgLy8gZm9jdXMvYmx1ciBtb3JwaHMgdG8gZm9jdXNpbi9vdXQ7IGVuc3VyZSB3ZSdyZSBub3QgZmlyaW5nIHRoZW0gcmlnaHQgbm93XHJcbiAgICAgICAgICAgIGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCB0eXBlLmluZGV4T2YoIFwiIVwiICkgPj0gMCApIHtcclxuICAgICAgICAgICAgICAgIC8vIEV4Y2x1c2l2ZSBldmVudHMgdHJpZ2dlciBvbmx5IGZvciB0aGUgZXhhY3QgZXZlbnQgKG5vIG5hbWVzcGFjZXMpXHJcbiAgICAgICAgICAgICAgICB0eXBlID0gdHlwZS5zbGljZSgwLCAtMSk7XHJcbiAgICAgICAgICAgICAgICBleGNsdXNpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIHR5cGUuaW5kZXhPZiggXCIuXCIgKSA+PSAwICkge1xyXG4gICAgICAgICAgICAgICAgLy8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxyXG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoXCIuXCIpO1xyXG4gICAgICAgICAgICAgICAgdHlwZSA9IG5hbWVzcGFjZXMuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgIG5hbWVzcGFjZXMuc29ydCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoICghZWxlbSB8fCBqUXVlcnkuZXZlbnQuY3VzdG9tRXZlbnRbIHR5cGUgXSkgJiYgIWpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSApIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vIGpRdWVyeSBoYW5kbGVycyBmb3IgdGhpcyBldmVudCB0eXBlLCBhbmQgaXQgY2FuJ3QgaGF2ZSBpbmxpbmUgaGFuZGxlcnNcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIEV2ZW50LCBPYmplY3QsIG9yIGp1c3QgYW4gZXZlbnQgdHlwZSBzdHJpbmdcclxuICAgICAgICAgICAgZXZlbnQgPSB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgP1xyXG4gICAgICAgICAgICAgICAgLy8galF1ZXJ5LkV2ZW50IG9iamVjdFxyXG4gICAgICAgICAgICAgICAgZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gPyBldmVudCA6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT2JqZWN0IGxpdGVyYWxcclxuICAgICAgICAgICAgICAgICAgICBuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCBldmVudCApIDpcclxuICAgICAgICAgICAgICAgIC8vIEp1c3QgdGhlIGV2ZW50IHR5cGUgKHN0cmluZylcclxuICAgICAgICAgICAgICAgIG5ldyBqUXVlcnkuRXZlbnQoIHR5cGUgKTtcclxuXHJcbiAgICAgICAgICAgIGV2ZW50LnR5cGUgPSB0eXBlO1xyXG4gICAgICAgICAgICBldmVudC5pc1RyaWdnZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICBldmVudC5leGNsdXNpdmUgPSBleGNsdXNpdmU7XHJcbiAgICAgICAgICAgIGV2ZW50Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKTtcclxuICAgICAgICAgICAgZXZlbnQubmFtZXNwYWNlX3JlID0gZXZlbnQubmFtZXNwYWNlPyBuZXcgUmVnRXhwKFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oXCJcXFxcLig/Oi4qXFxcXC4pP1wiKSArIFwiKFxcXFwufCQpXCIpIDogbnVsbDtcclxuICAgICAgICAgICAgb250eXBlID0gdHlwZS5pbmRleE9mKCBcIjpcIiApIDwgMCA/IFwib25cIiArIHR5cGUgOiBcIlwiO1xyXG5cclxuICAgICAgICAgICAgLy8gSGFuZGxlIGEgZ2xvYmFsIHRyaWdnZXJcclxuICAgICAgICAgICAgaWYgKCAhZWxlbSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBTdG9wIHRhdW50aW5nIHRoZSBkYXRhIGNhY2hlOyByZW1vdmUgZ2xvYmFsIGV2ZW50cyBhbmQgYWx3YXlzIGF0dGFjaCB0byBkb2N1bWVudFxyXG4gICAgICAgICAgICAgICAgY2FjaGUgPSBqUXVlcnkuY2FjaGU7XHJcbiAgICAgICAgICAgICAgICBmb3IgKCBpIGluIGNhY2hlICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggY2FjaGVbIGkgXS5ldmVudHMgJiYgY2FjaGVbIGkgXS5ldmVudHNbIHR5cGUgXSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoIGV2ZW50LCBkYXRhLCBjYWNoZVsgaSBdLmhhbmRsZS5lbGVtLCB0cnVlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDbGVhbiB1cCB0aGUgZXZlbnQgaW4gY2FzZSBpdCBpcyBiZWluZyByZXVzZWRcclxuICAgICAgICAgICAgZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBpZiAoICFldmVudC50YXJnZXQgKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQgPSBlbGVtO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDbG9uZSBhbnkgaW5jb21pbmcgZGF0YSBhbmQgcHJlcGVuZCB0aGUgZXZlbnQsIGNyZWF0aW5nIHRoZSBoYW5kbGVyIGFyZyBsaXN0XHJcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhICE9IG51bGwgPyBqUXVlcnkubWFrZUFycmF5KCBkYXRhICkgOiBbXTtcclxuICAgICAgICAgICAgZGF0YS51bnNoaWZ0KCBldmVudCApO1xyXG5cclxuICAgICAgICAgICAgLy8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xyXG4gICAgICAgICAgICBzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcclxuICAgICAgICAgICAgaWYgKCBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcclxuICAgICAgICAgICAgLy8gQnViYmxlIHVwIHRvIGRvY3VtZW50LCB0aGVuIHRvIHdpbmRvdzsgd2F0Y2ggZm9yIGEgZ2xvYmFsIG93bmVyRG9jdW1lbnQgdmFyICgjOTcyNClcclxuICAgICAgICAgICAgZXZlbnRQYXRoID0gW1sgZWxlbSwgc3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlIF1dO1xyXG4gICAgICAgICAgICBpZiAoICFvbmx5SGFuZGxlcnMgJiYgIXNwZWNpYWwubm9CdWJibGUgJiYgIWpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGJ1YmJsZVR5cGUgPSBzcGVjaWFsLmRlbGVnYXRlVHlwZSB8fCB0eXBlO1xyXG4gICAgICAgICAgICAgICAgY3VyID0gcmZvY3VzTW9ycGgudGVzdCggYnViYmxlVHlwZSArIHR5cGUgKSA/IGVsZW0gOiBlbGVtLnBhcmVudE5vZGU7XHJcbiAgICAgICAgICAgICAgICBvbGQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgZm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50UGF0aC5wdXNoKFsgY3VyLCBidWJibGVUeXBlIF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIG9sZCA9IGN1cjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGFkZCB3aW5kb3cgaWYgd2UgZ290IHRvIGRvY3VtZW50IChlLmcuLCBub3QgcGxhaW4gb2JqIG9yIGRldGFjaGVkIERPTSlcclxuICAgICAgICAgICAgICAgIGlmICggb2xkICYmIG9sZCA9PT0gZWxlbS5vd25lckRvY3VtZW50ICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50UGF0aC5wdXNoKFsgb2xkLmRlZmF1bHRWaWV3IHx8IG9sZC5wYXJlbnRXaW5kb3cgfHwgd2luZG93LCBidWJibGVUeXBlIF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXHJcbiAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgZXZlbnRQYXRoLmxlbmd0aCAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKTsgaSsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGN1ciA9IGV2ZW50UGF0aFtpXVswXTtcclxuICAgICAgICAgICAgICAgIGV2ZW50LnR5cGUgPSBldmVudFBhdGhbaV1bMV07XHJcblxyXG4gICAgICAgICAgICAgICAgaGFuZGxlID0gKCBqUXVlcnkuX2RhdGEoIGN1ciwgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSAmJiBqUXVlcnkuX2RhdGEoIGN1ciwgXCJoYW5kbGVcIiApO1xyXG4gICAgICAgICAgICAgICAgaWYgKCBoYW5kbGUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIGlzIGEgYmFyZSBKUyBmdW5jdGlvbiBhbmQgbm90IGEgalF1ZXJ5IGhhbmRsZXJcclxuICAgICAgICAgICAgICAgIGhhbmRsZSA9IG9udHlwZSAmJiBjdXJbIG9udHlwZSBdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCBoYW5kbGUgJiYgalF1ZXJ5LmFjY2VwdERhdGEoIGN1ciApICYmIGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICkgPT09IGZhbHNlICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZXZlbnQudHlwZSA9IHR5cGU7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XHJcbiAgICAgICAgICAgIGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCAoIXNwZWNpYWwuX2RlZmF1bHQgfHwgc3BlY2lhbC5fZGVmYXVsdC5hcHBseSggZWxlbS5vd25lckRvY3VtZW50LCBkYXRhICkgPT09IGZhbHNlKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICEodHlwZSA9PT0gXCJjbGlja1wiICYmIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJhXCIgKSkgJiYgalF1ZXJ5LmFjY2VwdERhdGEoIGVsZW0gKSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbid0IHVzZSBhbiAuaXNGdW5jdGlvbigpIGNoZWNrIGhlcmUgYmVjYXVzZSBJRTYvNyBmYWlscyB0aGF0IHRlc3QuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKCM2MTcwKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElFPDkgZGllcyBvbiBmb2N1cy9ibHVyIHRvIGhpZGRlbiBlbGVtZW50ICgjMTQ4NilcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIG9udHlwZSAmJiBlbGVtWyB0eXBlIF0gJiYgKCh0eXBlICE9PSBcImZvY3VzXCIgJiYgdHlwZSAhPT0gXCJibHVyXCIpIHx8IGV2ZW50LnRhcmdldC5vZmZzZXRXaWR0aCAhPT0gMCkgJiYgIWpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbGQgPSBlbGVtWyBvbnR5cGUgXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggb2xkICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbVsgb250eXBlIF0gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHlwZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbVsgdHlwZSBdKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG9sZCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1bIG9udHlwZSBdID0gb2xkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnQucmVzdWx0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGRpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBNYWtlIGEgd3JpdGFibGUgalF1ZXJ5LkV2ZW50IGZyb20gdGhlIG5hdGl2ZSBldmVudCBvYmplY3RcclxuICAgICAgICAgICAgZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KCBldmVudCB8fCB3aW5kb3cuZXZlbnQgKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBoYW5kbGVycyA9ICggKGpRdWVyeS5fZGF0YSggdGhpcywgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSB8fCBbXSksXHJcbiAgICAgICAgICAgICAgICBkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcclxuICAgICAgICAgICAgICAgIGFyZ3MgPSBbXS5zbGljZS5jYWxsKCBhcmd1bWVudHMsIDAgKSxcclxuICAgICAgICAgICAgICAgIHJ1bl9hbGwgPSAhZXZlbnQuZXhjbHVzaXZlICYmICFldmVudC5uYW1lc3BhY2UsXHJcbiAgICAgICAgICAgICAgICBoYW5kbGVyUXVldWUgPSBbXSxcclxuICAgICAgICAgICAgICAgIGksIGosIGN1ciwganFjdXIsIHJldCwgc2VsTWF0Y2gsIG1hdGNoZWQsIG1hdGNoZXMsIGhhbmRsZU9iaiwgc2VsLCByZWxhdGVkO1xyXG5cclxuICAgICAgICAgICAgLy8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcclxuICAgICAgICAgICAgYXJnc1swXSA9IGV2ZW50O1xyXG4gICAgICAgICAgICBldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgaGFuZGxlcnMgdGhhdCBzaG91bGQgcnVuIGlmIHRoZXJlIGFyZSBkZWxlZ2F0ZWQgZXZlbnRzXHJcbiAgICAgICAgICAgIC8vIEF2b2lkIGRpc2FibGVkIGVsZW1lbnRzIGluIElFICgjNjkxMSkgYW5kIG5vbi1sZWZ0LWNsaWNrIGJ1YmJsaW5nIGluIEZpcmVmb3ggKCMzODYxKVxyXG4gICAgICAgICAgICBpZiAoIGRlbGVnYXRlQ291bnQgJiYgIWV2ZW50LnRhcmdldC5kaXNhYmxlZCAmJiAhKGV2ZW50LmJ1dHRvbiAmJiBldmVudC50eXBlID09PSBcImNsaWNrXCIpICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFByZWdlbmVyYXRlIGEgc2luZ2xlIGpRdWVyeSBvYmplY3QgZm9yIHJldXNlIHdpdGggLmlzKClcclxuICAgICAgICAgICAgICAgIGpxY3VyID0galF1ZXJ5KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAganFjdXIuY29udGV4dCA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIGN1ciA9IGV2ZW50LnRhcmdldDsgY3VyICE9IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsTWF0Y2ggPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAganFjdXJbMF0gPSBjdXI7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBpIF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbCA9IGhhbmRsZU9iai5zZWxlY3RvcjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc2VsTWF0Y2hbIHNlbCBdID09PSB1bmRlZmluZWQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxNYXRjaFsgc2VsIF0gPSAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlT2JqLnF1aWNrID8gcXVpY2tJcyggY3VyLCBoYW5kbGVPYmoucXVpY2sgKSA6IGpxY3VyLmlzKCBzZWwgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHNlbE1hdGNoWyBzZWwgXSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaCggaGFuZGxlT2JqICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXRjaGVzLmxlbmd0aCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlclF1ZXVlLnB1c2goeyBlbGVtOiBjdXIsIG1hdGNoZXM6IG1hdGNoZXMgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXHJcbiAgICAgICAgICAgIGlmICggaGFuZGxlcnMubGVuZ3RoID4gZGVsZWdhdGVDb3VudCApIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXJRdWV1ZS5wdXNoKHsgZWxlbTogdGhpcywgbWF0Y2hlczogaGFuZGxlcnMuc2xpY2UoIGRlbGVnYXRlQ291bnQgKSB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcclxuICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBoYW5kbGVyUXVldWUubGVuZ3RoICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpOyBpKysgKSB7XHJcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gaGFuZGxlclF1ZXVlWyBpIF07XHJcbiAgICAgICAgICAgICAgICBldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIGogPSAwOyBqIDwgbWF0Y2hlZC5tYXRjaGVzLmxlbmd0aCAmJiAhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKTsgaisrICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iaiA9IG1hdGNoZWQubWF0Y2hlc1sgaiBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUcmlnZ2VyZWQgZXZlbnQgbXVzdCBlaXRoZXIgMSkgYmUgbm9uLWV4Y2x1c2l2ZSBhbmQgaGF2ZSBubyBuYW1lc3BhY2UsIG9yXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gMikgaGF2ZSBuYW1lc3BhY2UocykgYSBzdWJzZXQgb3IgZXF1YWwgdG8gdGhvc2UgaW4gdGhlIGJvdW5kIGV2ZW50IChib3RoIGNhbiBoYXZlIG5vIG5hbWVzcGFjZSkuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBydW5fYWxsIHx8ICghZXZlbnQubmFtZXNwYWNlICYmICFoYW5kbGVPYmoubmFtZXNwYWNlKSB8fCBldmVudC5uYW1lc3BhY2VfcmUgJiYgZXZlbnQubmFtZXNwYWNlX3JlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gKCAoalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9KS5oYW5kbGUgfHwgaGFuZGxlT2JqLmhhbmRsZXIgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5yZXN1bHQgPSByZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHJldCA9PT0gZmFsc2UgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50LnJlc3VsdDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBJbmNsdWRlcyBzb21lIGV2ZW50IHByb3BzIHNoYXJlZCBieSBLZXlFdmVudCBhbmQgTW91c2VFdmVudFxyXG4gICAgICAgIC8vICoqKiBhdHRyQ2hhbmdlIGF0dHJOYW1lIHJlbGF0ZWROb2RlIHNyY0VsZW1lbnQgIGFyZSBub3Qgbm9ybWFsaXplZCwgbm9uLVczQywgZGVwcmVjYXRlZCwgd2lsbCBiZSByZW1vdmVkIGluIDEuOCAqKipcclxuICAgICAgICBwcm9wczogXCJhdHRyQ2hhbmdlIGF0dHJOYW1lIHJlbGF0ZWROb2RlIHNyY0VsZW1lbnQgYWx0S2V5IGJ1YmJsZXMgY2FuY2VsYWJsZSBjdHJsS2V5IGN1cnJlbnRUYXJnZXQgZXZlbnRQaGFzZSBtZXRhS2V5IHJlbGF0ZWRUYXJnZXQgc2hpZnRLZXkgdGFyZ2V0IHRpbWVTdGFtcCB2aWV3IHdoaWNoXCIuc3BsaXQoXCIgXCIpLFxyXG5cclxuICAgICAgICBmaXhIb29rczoge30sXHJcblxyXG4gICAgICAgIGtleUhvb2tzOiB7XHJcbiAgICAgICAgICAgIHByb3BzOiBcImNoYXIgY2hhckNvZGUga2V5IGtleUNvZGVcIi5zcGxpdChcIiBcIiksXHJcbiAgICAgICAgICAgIGZpbHRlcjogZnVuY3Rpb24oIGV2ZW50LCBvcmlnaW5hbCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcclxuICAgICAgICAgICAgICAgIGlmICggZXZlbnQud2hpY2ggPT0gbnVsbCApIHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudC53aGljaCA9IG9yaWdpbmFsLmNoYXJDb2RlICE9IG51bGwgPyBvcmlnaW5hbC5jaGFyQ29kZSA6IG9yaWdpbmFsLmtleUNvZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgbW91c2VIb29rczoge1xyXG4gICAgICAgICAgICBwcm9wczogXCJidXR0b24gYnV0dG9ucyBjbGllbnRYIGNsaWVudFkgZnJvbUVsZW1lbnQgb2Zmc2V0WCBvZmZzZXRZIHBhZ2VYIHBhZ2VZIHNjcmVlblggc2NyZWVuWSB0b0VsZW1lbnRcIi5zcGxpdChcIiBcIiksXHJcbiAgICAgICAgICAgIGZpbHRlcjogZnVuY3Rpb24oIGV2ZW50LCBvcmlnaW5hbCApIHtcclxuICAgICAgICAgICAgICAgIHZhciBldmVudERvYywgZG9jLCBib2R5LFxyXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbiA9IG9yaWdpbmFsLmJ1dHRvbixcclxuICAgICAgICAgICAgICAgICAgICBmcm9tRWxlbWVudCA9IG9yaWdpbmFsLmZyb21FbGVtZW50O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwYWdlWC9ZIGlmIG1pc3NpbmcgYW5kIGNsaWVudFgvWSBhdmFpbGFibGVcclxuICAgICAgICAgICAgICAgIGlmICggZXZlbnQucGFnZVggPT0gbnVsbCAmJiBvcmlnaW5hbC5jbGllbnRYICE9IG51bGwgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnREb2MgPSBldmVudC50YXJnZXQub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudDtcclxuICAgICAgICAgICAgICAgICAgICBkb2MgPSBldmVudERvYy5kb2N1bWVudEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IGV2ZW50RG9jLmJvZHk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnBhZ2VYID0gb3JpZ2luYWwuY2xpZW50WCArICggZG9jICYmIGRvYy5zY3JvbGxMZWZ0IHx8IGJvZHkgJiYgYm9keS5zY3JvbGxMZWZ0IHx8IDAgKSAtICggZG9jICYmIGRvYy5jbGllbnRMZWZ0IHx8IGJvZHkgJiYgYm9keS5jbGllbnRMZWZ0IHx8IDAgKTtcclxuICAgICAgICAgICAgICAgICAgICBldmVudC5wYWdlWSA9IG9yaWdpbmFsLmNsaWVudFkgKyAoIGRvYyAmJiBkb2Muc2Nyb2xsVG9wICB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsVG9wICB8fCAwICkgLSAoIGRvYyAmJiBkb2MuY2xpZW50VG9wICB8fCBib2R5ICYmIGJvZHkuY2xpZW50VG9wICB8fCAwICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIHJlbGF0ZWRUYXJnZXQsIGlmIG5lY2Vzc2FyeVxyXG4gICAgICAgICAgICAgICAgaWYgKCAhZXZlbnQucmVsYXRlZFRhcmdldCAmJiBmcm9tRWxlbWVudCApIHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudC5yZWxhdGVkVGFyZ2V0ID0gZnJvbUVsZW1lbnQgPT09IGV2ZW50LnRhcmdldCA/IG9yaWdpbmFsLnRvRWxlbWVudCA6IGZyb21FbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcclxuICAgICAgICAgICAgICAgIC8vIE5vdGU6IGJ1dHRvbiBpcyBub3Qgbm9ybWFsaXplZCwgc28gZG9uJ3QgdXNlIGl0XHJcbiAgICAgICAgICAgICAgICBpZiAoICFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCApIHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudC53aGljaCA9ICggYnV0dG9uICYgMSA/IDEgOiAoIGJ1dHRvbiAmIDIgPyAzIDogKCBidXR0b24gJiA0ID8gMiA6IDAgKSApICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZml4OiBmdW5jdGlvbiggZXZlbnQgKSB7XHJcbiAgICAgICAgICAgIGlmICggZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIHdyaXRhYmxlIGNvcHkgb2YgdGhlIGV2ZW50IG9iamVjdCBhbmQgbm9ybWFsaXplIHNvbWUgcHJvcGVydGllc1xyXG4gICAgICAgICAgICB2YXIgaSwgcHJvcCxcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQgPSBldmVudCxcclxuICAgICAgICAgICAgICAgIGZpeEhvb2sgPSBqUXVlcnkuZXZlbnQuZml4SG9va3NbIGV2ZW50LnR5cGUgXSB8fCB7fSxcclxuICAgICAgICAgICAgICAgIGNvcHkgPSBmaXhIb29rLnByb3BzID8gdGhpcy5wcm9wcy5jb25jYXQoIGZpeEhvb2sucHJvcHMgKSA6IHRoaXMucHJvcHM7XHJcblxyXG4gICAgICAgICAgICBldmVudCA9IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xyXG5cclxuICAgICAgICAgICAgZm9yICggaSA9IGNvcHkubGVuZ3RoOyBpOyApIHtcclxuICAgICAgICAgICAgICAgIHByb3AgPSBjb3B5WyAtLWkgXTtcclxuICAgICAgICAgICAgICAgIGV2ZW50WyBwcm9wIF0gPSBvcmlnaW5hbEV2ZW50WyBwcm9wIF07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZpeCB0YXJnZXQgcHJvcGVydHksIGlmIG5lY2Vzc2FyeSAoIzE5MjUsIElFIDYvNy84ICYgU2FmYXJpMilcclxuICAgICAgICAgICAgaWYgKCAhZXZlbnQudGFyZ2V0ICkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0ID0gb3JpZ2luYWxFdmVudC5zcmNFbGVtZW50IHx8IGRvY3VtZW50O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAoIzUwNCwgU2FmYXJpKVxyXG4gICAgICAgICAgICBpZiAoIGV2ZW50LnRhcmdldC5ub2RlVHlwZSA9PT0gMyApIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldCA9IGV2ZW50LnRhcmdldC5wYXJlbnROb2RlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBGb3IgbW91c2Uva2V5IGV2ZW50czsgYWRkIG1ldGFLZXkgaWYgaXQncyBub3QgdGhlcmUgKCMzMzY4LCBJRTYvNy84KVxyXG4gICAgICAgICAgICBpZiAoIGV2ZW50Lm1ldGFLZXkgPT09IHVuZGVmaW5lZCApIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50Lm1ldGFLZXkgPSBldmVudC5jdHJsS2V5O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZml4SG9vay5maWx0ZXI/IGZpeEhvb2suZmlsdGVyKCBldmVudCwgb3JpZ2luYWxFdmVudCApIDogZXZlbnQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc3BlY2lhbDoge1xyXG4gICAgICAgICAgICByZWFkeToge1xyXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSByZWFkeSBldmVudCBpcyBzZXR1cFxyXG4gICAgICAgICAgICAgICAgc2V0dXA6IGpRdWVyeS5iaW5kUmVhZHlcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGxvYWQ6IHtcclxuICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcclxuICAgICAgICAgICAgICAgIG5vQnViYmxlOiB0cnVlXHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBmb2N1czoge1xyXG4gICAgICAgICAgICAgICAgZGVsZWdhdGVUeXBlOiBcImZvY3VzaW5cIlxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBibHVyOiB7XHJcbiAgICAgICAgICAgICAgICBkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNvdXRcIlxyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgYmVmb3JldW5sb2FkOiB7XHJcbiAgICAgICAgICAgICAgICBzZXR1cDogZnVuY3Rpb24oIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlICkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgd2FudCB0byBkbyB0aGlzIHNwZWNpYWwgY2FzZSBvbiB3aW5kb3dzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBqUXVlcnkuaXNXaW5kb3coIHRoaXMgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbmJlZm9yZXVubG9hZCA9IGV2ZW50SGFuZGxlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgdGVhcmRvd246IGZ1bmN0aW9uKCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMub25iZWZvcmV1bmxvYWQgPT09IGV2ZW50SGFuZGxlICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uYmVmb3JldW5sb2FkID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50LCBidWJibGUgKSB7XHJcbiAgICAgICAgICAgIC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZS5cclxuICAgICAgICAgICAgLy8gRmFrZSBvcmlnaW5hbEV2ZW50IHRvIGF2b2lkIGRvbm9yJ3Mgc3RvcFByb3BhZ2F0aW9uLCBidXQgaWYgdGhlXHJcbiAgICAgICAgICAgIC8vIHNpbXVsYXRlZCBldmVudCBwcmV2ZW50cyBkZWZhdWx0IHRoZW4gd2UgZG8gdGhlIHNhbWUgb24gdGhlIGRvbm9yLlxyXG4gICAgICAgICAgICB2YXIgZSA9IGpRdWVyeS5leHRlbmQoXHJcbiAgICAgICAgICAgICAgICBuZXcgalF1ZXJ5LkV2ZW50KCksXHJcbiAgICAgICAgICAgICAgICBldmVudCxcclxuICAgICAgICAgICAgICAgIHsgdHlwZTogdHlwZSxcclxuICAgICAgICAgICAgICAgICAgICBpc1NpbXVsYXRlZDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiB7fVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBpZiAoIGJ1YmJsZSApIHtcclxuICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuZGlzcGF0Y2guY2FsbCggZWxlbSwgZSApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICggZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuLy8gU29tZSBwbHVnaW5zIGFyZSB1c2luZywgYnV0IGl0J3MgdW5kb2N1bWVudGVkL2RlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZC5cclxuLy8gVGhlIDEuNyBzcGVjaWFsIGV2ZW50IGludGVyZmFjZSBzaG91bGQgcHJvdmlkZSBhbGwgdGhlIGhvb2tzIG5lZWRlZCBub3cuXHJcbiAgICBqUXVlcnkuZXZlbnQuaGFuZGxlID0galF1ZXJ5LmV2ZW50LmRpc3BhdGNoO1xyXG5cclxuICAgIGpRdWVyeS5yZW1vdmVFdmVudCA9IGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIgP1xyXG4gICAgICAgIGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XHJcbiAgICAgICAgICAgIGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xyXG4gICAgICAgICAgICAgICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUsIGZhbHNlICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IDpcclxuICAgICAgICBmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xyXG4gICAgICAgICAgICBpZiAoIGVsZW0uZGV0YWNoRXZlbnQgKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtLmRldGFjaEV2ZW50KCBcIm9uXCIgKyB0eXBlLCBoYW5kbGUgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgalF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XHJcbiAgICAgICAgLy8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXHJcbiAgICAgICAgaWYgKCAhKHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQpICkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IGpRdWVyeS5FdmVudCggc3JjLCBwcm9wcyApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRXZlbnQgb2JqZWN0XHJcbiAgICAgICAgaWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcclxuICAgICAgICAgICAgdGhpcy50eXBlID0gc3JjLnR5cGU7XHJcblxyXG4gICAgICAgICAgICAvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxyXG4gICAgICAgICAgICAvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cclxuICAgICAgICAgICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSAoIHNyYy5kZWZhdWx0UHJldmVudGVkIHx8IHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgfHxcclxuICAgICAgICAgICAgc3JjLmdldFByZXZlbnREZWZhdWx0ICYmIHNyYy5nZXRQcmV2ZW50RGVmYXVsdCgpICkgPyByZXR1cm5UcnVlIDogcmV0dXJuRmFsc2U7XHJcblxyXG4gICAgICAgICAgICAvLyBFdmVudCB0eXBlXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy50eXBlID0gc3JjO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3RcclxuICAgICAgICBpZiAoIHByb3BzICkge1xyXG4gICAgICAgICAgICBqUXVlcnkuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcclxuICAgICAgICB0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IGpRdWVyeS5ub3coKTtcclxuXHJcbiAgICAgICAgLy8gTWFyayBpdCBhcyBmaXhlZFxyXG4gICAgICAgIHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZXR1cm5UcnVlKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXHJcbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxyXG4gICAgalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcclxuICAgICAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xyXG4gICAgICAgICAgICBpZiAoICFlICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBpZiBwcmV2ZW50RGVmYXVsdCBleGlzdHMgcnVuIGl0IG9uIHRoZSBvcmlnaW5hbCBldmVudFxyXG4gICAgICAgICAgICBpZiAoIGUucHJldmVudERlZmF1bHQgKSB7XHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHNldCB0aGUgcmV0dXJuVmFsdWUgcHJvcGVydHkgb2YgdGhlIG9yaWdpbmFsIGV2ZW50IHRvIGZhbHNlIChJRSlcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XHJcblxyXG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcclxuICAgICAgICAgICAgaWYgKCAhZSApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpZiBzdG9wUHJvcGFnYXRpb24gZXhpc3RzIHJ1biBpdCBvbiB0aGUgb3JpZ2luYWwgZXZlbnRcclxuICAgICAgICAgICAgaWYgKCBlLnN0b3BQcm9wYWdhdGlvbiApIHtcclxuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHNldCB0aGUgY2FuY2VsQnViYmxlIHByb3BlcnR5IG9mIHRoZSBvcmlnaW5hbCBldmVudCB0byB0cnVlIChJRSlcclxuICAgICAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxyXG4gICAgICAgIGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcclxuICAgICAgICBpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2VcclxuICAgIH07XHJcblxyXG4vLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3NcclxuICAgIGpRdWVyeS5lYWNoKHtcclxuICAgICAgICBtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxyXG4gICAgICAgIG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIlxyXG4gICAgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcclxuICAgICAgICBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgb3JpZyBdID0ge1xyXG4gICAgICAgICAgICBkZWxlZ2F0ZVR5cGU6IGZpeCxcclxuICAgICAgICAgICAgYmluZFR5cGU6IGZpeCxcclxuXHJcbiAgICAgICAgICAgIGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqLFxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gaGFuZGxlT2JqLnNlbGVjdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIHJldDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGb3IgbW91c2VudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXHJcbiAgICAgICAgICAgICAgICAvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xyXG4gICAgICAgICAgICAgICAgaWYgKCAhcmVsYXRlZCB8fCAocmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApKSApIHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcclxuICAgICAgICAgICAgICAgICAgICBldmVudC50eXBlID0gZml4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxuXHJcbi8vIElFIHN1Ym1pdCBkZWxlZ2F0aW9uXHJcbiAgICBpZiAoICFqUXVlcnkuc3VwcG9ydC5zdWJtaXRCdWJibGVzICkge1xyXG5cclxuICAgICAgICBqUXVlcnkuZXZlbnQuc3BlY2lhbC5zdWJtaXQgPSB7XHJcbiAgICAgICAgICAgIHNldHVwOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIC8vIE9ubHkgbmVlZCB0aGlzIGZvciBkZWxlZ2F0ZWQgZm9ybSBzdWJtaXQgZXZlbnRzXHJcbiAgICAgICAgICAgICAgICBpZiAoIGpRdWVyeS5ub2RlTmFtZSggdGhpcywgXCJmb3JtXCIgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTGF6eS1hZGQgYSBzdWJtaXQgaGFuZGxlciB3aGVuIGEgZGVzY2VuZGFudCBmb3JtIG1heSBwb3RlbnRpYWxseSBiZSBzdWJtaXR0ZWRcclxuICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIFwiY2xpY2suX3N1Ym1pdCBrZXlwcmVzcy5fc3VibWl0XCIsIGZ1bmN0aW9uKCBlICkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vZGUgbmFtZSBjaGVjayBhdm9pZHMgYSBWTUwtcmVsYXRlZCBjcmFzaCBpbiBJRSAoIzk4MDcpXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW0gPSBlLnRhcmdldCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybSA9IGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgfHwgalF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcImJ1dHRvblwiICkgPyBlbGVtLmZvcm0gOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBmb3JtICYmICFmb3JtLl9zdWJtaXRfYXR0YWNoZWQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5hZGQoIGZvcm0sIFwic3VibWl0Ll9zdWJtaXRcIiwgZnVuY3Rpb24oIGV2ZW50ICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgZm9ybSB3YXMgc3VibWl0dGVkIGJ5IHRoZSB1c2VyLCBidWJibGUgdGhlIGV2ZW50IHVwIHRoZSB0cmVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMucGFyZW50Tm9kZSAmJiAhZXZlbnQuaXNUcmlnZ2VyICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5zaW11bGF0ZSggXCJzdWJtaXRcIiwgdGhpcy5wYXJlbnROb2RlLCBldmVudCwgdHJ1ZSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybS5fc3VibWl0X2F0dGFjaGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIC8vIHJldHVybiB1bmRlZmluZWQgc2luY2Ugd2UgZG9uJ3QgbmVlZCBhbiBldmVudCBsaXN0ZW5lclxyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgdGVhcmRvd246IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgLy8gT25seSBuZWVkIHRoaXMgZm9yIGRlbGVnYXRlZCBmb3JtIHN1Ym1pdCBldmVudHNcclxuICAgICAgICAgICAgICAgIGlmICggalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCBcImZvcm1cIiApICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZGVsZWdhdGVkIGhhbmRsZXJzOyBjbGVhbkRhdGEgZXZlbnR1YWxseSByZWFwcyBzdWJtaXQgaGFuZGxlcnMgYXR0YWNoZWQgYWJvdmVcclxuICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIFwiLl9zdWJtaXRcIiApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbi8vIElFIGNoYW5nZSBkZWxlZ2F0aW9uIGFuZCBjaGVja2JveC9yYWRpbyBmaXhcclxuICAgIGlmICggIWpRdWVyeS5zdXBwb3J0LmNoYW5nZUJ1YmJsZXMgKSB7XHJcblxyXG4gICAgICAgIGpRdWVyeS5ldmVudC5zcGVjaWFsLmNoYW5nZSA9IHtcclxuXHJcbiAgICAgICAgICAgIHNldHVwOiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHJmb3JtRWxlbXMudGVzdCggdGhpcy5ub2RlTmFtZSApICkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElFIGRvZXNuJ3QgZmlyZSBjaGFuZ2Ugb24gYSBjaGVjay9yYWRpbyB1bnRpbCBibHVyOyB0cmlnZ2VyIGl0IG9uIGNsaWNrXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWZ0ZXIgYSBwcm9wZXJ0eWNoYW5nZS4gRWF0IHRoZSBibHVyLWNoYW5nZSBpbiBzcGVjaWFsLmNoYW5nZS5oYW5kbGUuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBzdGlsbCBmaXJlcyBvbmNoYW5nZSBhIHNlY29uZCB0aW1lIGZvciBjaGVjay9yYWRpbyBhZnRlciBibHVyLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggdGhpcy50eXBlID09PSBcImNoZWNrYm94XCIgfHwgdGhpcy50eXBlID09PSBcInJhZGlvXCIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIFwicHJvcGVydHljaGFuZ2UuX2NoYW5nZVwiLCBmdW5jdGlvbiggZXZlbnQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGV2ZW50Lm9yaWdpbmFsRXZlbnQucHJvcGVydHlOYW1lID09PSBcImNoZWNrZWRcIiApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9qdXN0X2NoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgXCJjbGljay5fY2hhbmdlXCIsIGZ1bmN0aW9uKCBldmVudCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdGhpcy5fanVzdF9jaGFuZ2VkICYmICFldmVudC5pc1RyaWdnZXIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fanVzdF9jaGFuZ2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBcImNoYW5nZVwiLCB0aGlzLCBldmVudCwgdHJ1ZSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gRGVsZWdhdGVkIGV2ZW50OyBsYXp5LWFkZCBhIGNoYW5nZSBoYW5kbGVyIG9uIGRlc2NlbmRhbnQgaW5wdXRzXHJcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCBcImJlZm9yZWFjdGl2YXRlLl9jaGFuZ2VcIiwgZnVuY3Rpb24oIGUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW0gPSBlLnRhcmdldDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCByZm9ybUVsZW1zLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSAmJiAhZWxlbS5fY2hhbmdlX2F0dGFjaGVkICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuYWRkKCBlbGVtLCBcImNoYW5nZS5fY2hhbmdlXCIsIGZ1bmN0aW9uKCBldmVudCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdGhpcy5wYXJlbnROb2RlICYmICFldmVudC5pc1NpbXVsYXRlZCAmJiAhZXZlbnQuaXNUcmlnZ2VyICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5zaW11bGF0ZSggXCJjaGFuZ2VcIiwgdGhpcy5wYXJlbnROb2RlLCBldmVudCwgdHJ1ZSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5fY2hhbmdlX2F0dGFjaGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVsZW0gPSBldmVudC50YXJnZXQ7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3dhbGxvdyBuYXRpdmUgY2hhbmdlIGV2ZW50cyBmcm9tIGNoZWNrYm94L3JhZGlvLCB3ZSBhbHJlYWR5IHRyaWdnZXJlZCB0aGVtIGFib3ZlXHJcbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMgIT09IGVsZW0gfHwgZXZlbnQuaXNTaW11bGF0ZWQgfHwgZXZlbnQuaXNUcmlnZ2VyIHx8IChlbGVtLnR5cGUgIT09IFwicmFkaW9cIiAmJiBlbGVtLnR5cGUgIT09IFwiY2hlY2tib3hcIikgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50LmhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHRlYXJkb3duOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIFwiLl9jaGFuZ2VcIiApO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiByZm9ybUVsZW1zLnRlc3QoIHRoaXMubm9kZU5hbWUgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4vLyBDcmVhdGUgXCJidWJibGluZ1wiIGZvY3VzIGFuZCBibHVyIGV2ZW50c1xyXG4gICAgaWYgKCAhalF1ZXJ5LnN1cHBvcnQuZm9jdXNpbkJ1YmJsZXMgKSB7XHJcbiAgICAgICAgalF1ZXJ5LmVhY2goeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xyXG5cclxuICAgICAgICAgICAgLy8gQXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIHdoaWxlIHNvbWVvbmUgd2FudHMgZm9jdXNpbi9mb2N1c291dFxyXG4gICAgICAgICAgICB2YXIgYXR0YWNoZXMgPSAwLFxyXG4gICAgICAgICAgICAgICAgaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApLCB0cnVlICk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xyXG4gICAgICAgICAgICAgICAgc2V0dXA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggYXR0YWNoZXMrKyA9PT0gMCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB0ZWFyZG93bjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAtLWF0dGFjaGVzID09PSAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xyXG5cclxuICAgICAgICBvbjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIC8qSU5URVJOQUwqLyBvbmUgKSB7XHJcbiAgICAgICAgICAgIHZhciBvcmlnRm4sIHR5cGU7XHJcblxyXG4gICAgICAgICAgICAvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcclxuICAgICAgICAgICAgaWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAoIHR5cGVzLU9iamVjdCwgc2VsZWN0b3IsIGRhdGEgKVxyXG4gICAgICAgICAgICAgICAgaWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBzZWxlY3RvcjtcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbiggdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAoIHR5cGVzLCBmbiApXHJcbiAgICAgICAgICAgICAgICBmbiA9IHNlbGVjdG9yO1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBmbiA9PSBudWxsICkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcclxuICAgICAgICAgICAgICAgICAgICBmbiA9IGRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gKCB0eXBlcywgZGF0YSwgZm4gKVxyXG4gICAgICAgICAgICAgICAgICAgIGZuID0gZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gc2VsZWN0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCBmbiA9PT0gZmFsc2UgKSB7XHJcbiAgICAgICAgICAgICAgICBmbiA9IHJldHVybkZhbHNlO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCAhZm4gKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBvbmUgPT09IDEgKSB7XHJcbiAgICAgICAgICAgICAgICBvcmlnRm4gPSBmbjtcclxuICAgICAgICAgICAgICAgIGZuID0gZnVuY3Rpb24oIGV2ZW50ICkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxyXG4gICAgICAgICAgICAgICAgZm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8ICggb3JpZ0ZuLmd1aWQgPSBqUXVlcnkuZ3VpZCsrICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25lOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub24uY2FsbCggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgMSApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcclxuICAgICAgICAgICAgaWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XHJcbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xyXG4gICAgICAgICAgICAgICAgalF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZihcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVPYmoubmFtZXNwYWNlPyBoYW5kbGVPYmoudHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6IGhhbmRsZU9iai50eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iai5zZWxlY3RvcixcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVPYmouaGFuZGxlclxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xyXG4gICAgICAgICAgICAgICAgLy8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcclxuICAgICAgICAgICAgICAgIGZvciAoIHZhciB0eXBlIGluIHR5cGVzICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2ZmKCB0eXBlLCBzZWxlY3RvciwgdHlwZXNbIHR5cGUgXSApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCBzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAoIHR5cGVzIFssIGZuXSApXHJcbiAgICAgICAgICAgICAgICBmbiA9IHNlbGVjdG9yO1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCBmbiA9PT0gZmFsc2UgKSB7XHJcbiAgICAgICAgICAgICAgICBmbiA9IHJldHVybkZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yICk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2ZmKCB0eXBlcywgbnVsbCwgZm4gKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBsaXZlOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xyXG4gICAgICAgICAgICBqUXVlcnkoIHRoaXMuY29udGV4dCApLm9uKCB0eXBlcywgdGhpcy5zZWxlY3RvciwgZGF0YSwgZm4gKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkaWU6IGZ1bmN0aW9uKCB0eXBlcywgZm4gKSB7XHJcbiAgICAgICAgICAgIGpRdWVyeSggdGhpcy5jb250ZXh0ICkub2ZmKCB0eXBlcywgdGhpcy5zZWxlY3RvciB8fCBcIioqXCIsIGZuICk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbiApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkge1xyXG4gICAgICAgICAgICAvLyAoIG5hbWVzcGFjZSApIG9yICggc2VsZWN0b3IsIHR5cGVzIFssIGZuXSApXHJcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09IDE/IHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOiB0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yLCBmbiApO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XHJcbiAgICAgICAgICAgIGlmICggdGhpc1swXSApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpc1swXSwgdHJ1ZSApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdG9nZ2xlOiBmdW5jdGlvbiggZm4gKSB7XHJcbiAgICAgICAgICAgIC8vIFNhdmUgcmVmZXJlbmNlIHRvIGFyZ3VtZW50cyBmb3IgYWNjZXNzIGluIGNsb3N1cmVcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXHJcbiAgICAgICAgICAgICAgICBndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrLFxyXG4gICAgICAgICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICAgICAgICB0b2dnbGVyID0gZnVuY3Rpb24oIGV2ZW50ICkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpZ3VyZSBvdXQgd2hpY2ggZnVuY3Rpb24gdG8gZXhlY3V0ZVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXN0VG9nZ2xlID0gKCBqUXVlcnkuX2RhdGEoIHRoaXMsIFwibGFzdFRvZ2dsZVwiICsgZm4uZ3VpZCApIHx8IDAgKSAlIGk7XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Ll9kYXRhKCB0aGlzLCBcImxhc3RUb2dnbGVcIiArIGZuLmd1aWQsIGxhc3RUb2dnbGUgKyAxICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGNsaWNrcyBzdG9wXHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGV4ZWN1dGUgdGhlIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3NbIGxhc3RUb2dnbGUgXS5hcHBseSggdGhpcywgYXJndW1lbnRzICkgfHwgZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy8gbGluayBhbGwgdGhlIGZ1bmN0aW9ucywgc28gYW55IG9mIHRoZW0gY2FuIHVuYmluZCB0aGlzIGNsaWNrIGhhbmRsZXJcclxuICAgICAgICAgICAgdG9nZ2xlci5ndWlkID0gZ3VpZDtcclxuICAgICAgICAgICAgd2hpbGUgKCBpIDwgYXJncy5sZW5ndGggKSB7XHJcbiAgICAgICAgICAgICAgICBhcmdzWyBpKysgXS5ndWlkID0gZ3VpZDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xpY2soIHRvZ2dsZXIgKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBob3ZlcjogZnVuY3Rpb24oIGZuT3ZlciwgZm5PdXQgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGpRdWVyeS5lYWNoKCAoXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgbG9hZCByZXNpemUgc2Nyb2xsIHVubG9hZCBjbGljayBkYmxjbGljayBcIiArXHJcbiAgICBcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcclxuICAgIFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBlcnJvciBjb250ZXh0bWVudVwiKS5zcGxpdChcIiBcIiksIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xyXG5cclxuICAgICAgICAvLyBIYW5kbGUgZXZlbnQgYmluZGluZ1xyXG4gICAgICAgIGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIGRhdGEsIGZuICkge1xyXG4gICAgICAgICAgICBpZiAoIGZuID09IG51bGwgKSB7XHJcbiAgICAgICAgICAgICAgICBmbiA9IGRhdGE7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID9cclxuICAgICAgICAgICAgICAgIHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxyXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCBuYW1lICk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYgKCBqUXVlcnkuYXR0ckZuICkge1xyXG4gICAgICAgICAgICBqUXVlcnkuYXR0ckZuWyBuYW1lIF0gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBya2V5RXZlbnQudGVzdCggbmFtZSApICkge1xyXG4gICAgICAgICAgICBqUXVlcnkuZXZlbnQuZml4SG9va3NbIG5hbWUgXSA9IGpRdWVyeS5ldmVudC5rZXlIb29rcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggcm1vdXNlRXZlbnQudGVzdCggbmFtZSApICkge1xyXG4gICAgICAgICAgICBqUXVlcnkuZXZlbnQuZml4SG9va3NbIG5hbWUgXSA9IGpRdWVyeS5ldmVudC5tb3VzZUhvb2tzO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuXHJcblxyXG4gICAgLyohXHJcbiAgICAgKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZVxyXG4gICAgICogIENvcHlyaWdodCAyMDExLCBUaGUgRG9qbyBGb3VuZGF0aW9uXHJcbiAgICAgKiAgUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCwgQlNELCBhbmQgR1BMIExpY2Vuc2VzLlxyXG4gICAgICogIE1vcmUgaW5mb3JtYXRpb246IGh0dHA6Ly9zaXp6bGVqcy5jb20vXHJcbiAgICAgKi9cclxuICAgIChmdW5jdGlvbigpe1xyXG5cclxuICAgICAgICB2YXIgY2h1bmtlciA9IC8oKD86XFwoKD86XFwoW14oKV0rXFwpfFteKCldKykrXFwpfFxcWyg/OlxcW1teXFxbXFxdXSpcXF18WydcIl1bXidcIl0qWydcIl18W15cXFtcXF0nXCJdKykrXFxdfFxcXFwufFteID4rfiwoXFxbXFxcXF0rKSt8Wz4rfl0pKFxccyosXFxzKik/KCg/Oi58XFxyfFxcbikqKS9nLFxyXG4gICAgICAgICAgICBleHBhbmRvID0gXCJzaXpjYWNoZVwiICsgKE1hdGgucmFuZG9tKCkgKyAnJykucmVwbGFjZSgnLicsICcnKSxcclxuICAgICAgICAgICAgZG9uZSA9IDAsXHJcbiAgICAgICAgICAgIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyxcclxuICAgICAgICAgICAgaGFzRHVwbGljYXRlID0gZmFsc2UsXHJcbiAgICAgICAgICAgIGJhc2VIYXNEdXBsaWNhdGUgPSB0cnVlLFxyXG4gICAgICAgICAgICByQmFja3NsYXNoID0gL1xcXFwvZyxcclxuICAgICAgICAgICAgclJldHVybiA9IC9cXHJcXG4vZyxcclxuICAgICAgICAgICAgck5vbldvcmQgPSAvXFxXLztcclxuXHJcbi8vIEhlcmUgd2UgY2hlY2sgaWYgdGhlIEphdmFTY3JpcHQgZW5naW5lIGlzIHVzaW5nIHNvbWUgc29ydCBvZlxyXG4vLyBvcHRpbWl6YXRpb24gd2hlcmUgaXQgZG9lcyBub3QgYWx3YXlzIGNhbGwgb3VyIGNvbXBhcmlzaW9uXHJcbi8vIGZ1bmN0aW9uLiBJZiB0aGF0IGlzIHRoZSBjYXNlLCBkaXNjYXJkIHRoZSBoYXNEdXBsaWNhdGUgdmFsdWUuXHJcbi8vICAgVGh1cyBmYXIgdGhhdCBpbmNsdWRlcyBHb29nbGUgQ2hyb21lLlxyXG4gICAgICAgIFswLCAwXS5zb3J0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBiYXNlSGFzRHVwbGljYXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB2YXIgU2l6emxlID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xyXG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcclxuICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XHJcblxyXG4gICAgICAgICAgICB2YXIgb3JpZ0NvbnRleHQgPSBjb250ZXh0O1xyXG5cclxuICAgICAgICAgICAgaWYgKCBjb250ZXh0Lm5vZGVUeXBlICE9PSAxICYmIGNvbnRleHQubm9kZVR5cGUgIT09IDkgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggIXNlbGVjdG9yIHx8IHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgbSwgc2V0LCBjaGVja1NldCwgZXh0cmEsIHJldCwgY3VyLCBwb3AsIGksXHJcbiAgICAgICAgICAgICAgICBwcnVuZSA9IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0WE1MID0gU2l6emxlLmlzWE1MKCBjb250ZXh0ICksXHJcbiAgICAgICAgICAgICAgICBwYXJ0cyA9IFtdLFxyXG4gICAgICAgICAgICAgICAgc29GYXIgPSBzZWxlY3RvcjtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgY2h1bmtlciByZWdleHAgKHN0YXJ0IGZyb20gaGVhZClcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgY2h1bmtlci5leGVjKCBcIlwiICk7XHJcbiAgICAgICAgICAgICAgICBtID0gY2h1bmtlci5leGVjKCBzb0ZhciApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggbSApIHtcclxuICAgICAgICAgICAgICAgICAgICBzb0ZhciA9IG1bM107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goIG1bMV0gKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBtWzJdICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYSA9IG1bM107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSB3aGlsZSAoIG0gKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggcGFydHMubGVuZ3RoID4gMSAmJiBvcmlnUE9TLmV4ZWMoIHNlbGVjdG9yICkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBwYXJ0cy5sZW5ndGggPT09IDIgJiYgRXhwci5yZWxhdGl2ZVsgcGFydHNbMF0gXSApIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXQgPSBwb3NQcm9jZXNzKCBwYXJ0c1swXSArIHBhcnRzWzFdLCBjb250ZXh0LCBzZWVkICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXQgPSBFeHByLnJlbGF0aXZlWyBwYXJ0c1swXSBdID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgWyBjb250ZXh0IF0gOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBTaXp6bGUoIHBhcnRzLnNoaWZ0KCksIGNvbnRleHQgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCBwYXJ0cy5sZW5ndGggKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gcGFydHMuc2hpZnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggRXhwci5yZWxhdGl2ZVsgc2VsZWN0b3IgXSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yICs9IHBhcnRzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldCA9IHBvc1Byb2Nlc3MoIHNlbGVjdG9yLCBzZXQsIHNlZWQgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVGFrZSBhIHNob3J0Y3V0IGFuZCBzZXQgdGhlIGNvbnRleHQgaWYgdGhlIHJvb3Qgc2VsZWN0b3IgaXMgYW4gSURcclxuICAgICAgICAgICAgICAgIC8vIChidXQgbm90IGlmIGl0J2xsIGJlIGZhc3RlciBpZiB0aGUgaW5uZXIgc2VsZWN0b3IgaXMgYW4gSUQpXHJcbiAgICAgICAgICAgICAgICBpZiAoICFzZWVkICYmIHBhcnRzLmxlbmd0aCA+IDEgJiYgY29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiAhY29udGV4dFhNTCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIEV4cHIubWF0Y2guSUQudGVzdChwYXJ0c1swXSkgJiYgIUV4cHIubWF0Y2guSUQudGVzdChwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXSkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldCA9IFNpenpsZS5maW5kKCBwYXJ0cy5zaGlmdCgpLCBjb250ZXh0LCBjb250ZXh0WE1MICk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IHJldC5leHByID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgU2l6emxlLmZpbHRlciggcmV0LmV4cHIsIHJldC5zZXQgKVswXSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldC5zZXRbMF07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBjb250ZXh0ICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldCA9IHNlZWQgP1xyXG4gICAgICAgICAgICAgICAgICAgIHsgZXhwcjogcGFydHMucG9wKCksIHNldDogbWFrZUFycmF5KHNlZWQpIH0gOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBTaXp6bGUuZmluZCggcGFydHMucG9wKCksIHBhcnRzLmxlbmd0aCA9PT0gMSAmJiAocGFydHNbMF0gPT09IFwiflwiIHx8IHBhcnRzWzBdID09PSBcIitcIikgJiYgY29udGV4dC5wYXJlbnROb2RlID8gY29udGV4dC5wYXJlbnROb2RlIDogY29udGV4dCwgY29udGV4dFhNTCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBzZXQgPSByZXQuZXhwciA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFNpenpsZS5maWx0ZXIoIHJldC5leHByLCByZXQuc2V0ICkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXQuc2V0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHBhcnRzLmxlbmd0aCA+IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrU2V0ID0gbWFrZUFycmF5KCBzZXQgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJ1bmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICggcGFydHMubGVuZ3RoICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXIgPSBwYXJ0cy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9wID0gY3VyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhRXhwci5yZWxhdGl2ZVsgY3VyIF0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXIgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9wID0gcGFydHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcG9wID09IG51bGwgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3AgPSBjb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBFeHByLnJlbGF0aXZlWyBjdXIgXSggY2hlY2tTZXQsIHBvcCwgY29udGV4dFhNTCApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrU2V0ID0gcGFydHMgPSBbXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCAhY2hlY2tTZXQgKSB7XHJcbiAgICAgICAgICAgICAgICBjaGVja1NldCA9IHNldDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCAhY2hlY2tTZXQgKSB7XHJcbiAgICAgICAgICAgICAgICBTaXp6bGUuZXJyb3IoIGN1ciB8fCBzZWxlY3RvciApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIHRvU3RyaW5nLmNhbGwoY2hlY2tTZXQpID09PSBcIltvYmplY3QgQXJyYXldXCIgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoICFwcnVuZSApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2guYXBwbHkoIHJlc3VsdHMsIGNoZWNrU2V0ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggY29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID09PSAxICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyBjaGVja1NldFtpXSAhPSBudWxsOyBpKysgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY2hlY2tTZXRbaV0gJiYgKGNoZWNrU2V0W2ldID09PSB0cnVlIHx8IGNoZWNrU2V0W2ldLm5vZGVUeXBlID09PSAxICYmIFNpenpsZS5jb250YWlucyhjb250ZXh0LCBjaGVja1NldFtpXSkpICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKCBzZXRbaV0gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyBjaGVja1NldFtpXSAhPSBudWxsOyBpKysgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY2hlY2tTZXRbaV0gJiYgY2hlY2tTZXRbaV0ubm9kZVR5cGUgPT09IDEgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goIHNldFtpXSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1ha2VBcnJheSggY2hlY2tTZXQsIHJlc3VsdHMgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBleHRyYSApIHtcclxuICAgICAgICAgICAgICAgIFNpenpsZSggZXh0cmEsIG9yaWdDb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XHJcbiAgICAgICAgICAgICAgICBTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBTaXp6bGUudW5pcXVlU29ydCA9IGZ1bmN0aW9uKCByZXN1bHRzICkge1xyXG4gICAgICAgICAgICBpZiAoIHNvcnRPcmRlciApIHtcclxuICAgICAgICAgICAgICAgIGhhc0R1cGxpY2F0ZSA9IGJhc2VIYXNEdXBsaWNhdGU7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRzLnNvcnQoIHNvcnRPcmRlciApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggaGFzRHVwbGljYXRlICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMTsgaSA8IHJlc3VsdHMubGVuZ3RoOyBpKysgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcmVzdWx0c1tpXSA9PT0gcmVzdWx0c1sgaSAtIDEgXSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMuc3BsaWNlKCBpLS0sIDEgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgU2l6emxlLm1hdGNoZXMgPSBmdW5jdGlvbiggZXhwciwgc2V0ICkge1xyXG4gICAgICAgICAgICByZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBzZXQgKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBTaXp6bGUubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24oIG5vZGUsIGV4cHIgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTaXp6bGUoIGV4cHIsIG51bGwsIG51bGwsIFtub2RlXSApLmxlbmd0aCA+IDA7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgU2l6emxlLmZpbmQgPSBmdW5jdGlvbiggZXhwciwgY29udGV4dCwgaXNYTUwgKSB7XHJcbiAgICAgICAgICAgIHZhciBzZXQsIGksIGxlbiwgbWF0Y2gsIHR5cGUsIGxlZnQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoICFleHByICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKCBpID0gMCwgbGVuID0gRXhwci5vcmRlci5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcclxuICAgICAgICAgICAgICAgIHR5cGUgPSBFeHByLm9yZGVyW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggKG1hdGNoID0gRXhwci5sZWZ0TWF0Y2hbIHR5cGUgXS5leGVjKCBleHByICkpICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBtYXRjaFsxXTtcclxuICAgICAgICAgICAgICAgICAgICBtYXRjaC5zcGxpY2UoIDEsIDEgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBsZWZ0LnN1YnN0ciggbGVmdC5sZW5ndGggLSAxICkgIT09IFwiXFxcXFwiICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFsxXSA9IChtYXRjaFsxXSB8fCBcIlwiKS5yZXBsYWNlKCByQmFja3NsYXNoLCBcIlwiICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldCA9IEV4cHIuZmluZFsgdHlwZSBdKCBtYXRjaCwgY29udGV4dCwgaXNYTUwgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc2V0ICE9IG51bGwgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gZXhwci5yZXBsYWNlKCBFeHByLm1hdGNoWyB0eXBlIF0sIFwiXCIgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoICFzZXQgKSB7XHJcbiAgICAgICAgICAgICAgICBzZXQgPSB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiA/XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCIqXCIgKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgW107XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7IHNldDogc2V0LCBleHByOiBleHByIH07XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgU2l6emxlLmZpbHRlciA9IGZ1bmN0aW9uKCBleHByLCBzZXQsIGlucGxhY2UsIG5vdCApIHtcclxuICAgICAgICAgICAgdmFyIG1hdGNoLCBhbnlGb3VuZCxcclxuICAgICAgICAgICAgICAgIHR5cGUsIGZvdW5kLCBpdGVtLCBmaWx0ZXIsIGxlZnQsXHJcbiAgICAgICAgICAgICAgICBpLCBwYXNzLFxyXG4gICAgICAgICAgICAgICAgb2xkID0gZXhwcixcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtdLFxyXG4gICAgICAgICAgICAgICAgY3VyTG9vcCA9IHNldCxcclxuICAgICAgICAgICAgICAgIGlzWE1MRmlsdGVyID0gc2V0ICYmIHNldFswXSAmJiBTaXp6bGUuaXNYTUwoIHNldFswXSApO1xyXG5cclxuICAgICAgICAgICAgd2hpbGUgKCBleHByICYmIHNldC5sZW5ndGggKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKCB0eXBlIGluIEV4cHIuZmlsdGVyICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggKG1hdGNoID0gRXhwci5sZWZ0TWF0Y2hbIHR5cGUgXS5leGVjKCBleHByICkpICE9IG51bGwgJiYgbWF0Y2hbMl0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlciA9IEV4cHIuZmlsdGVyWyB0eXBlIF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBtYXRjaFsxXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFueUZvdW5kID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaC5zcGxpY2UoMSwxKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbGVmdC5zdWJzdHIoIGxlZnQubGVuZ3RoIC0gMSApID09PSBcIlxcXFxcIiApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGN1ckxvb3AgPT09IHJlc3VsdCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIEV4cHIucHJlRmlsdGVyWyB0eXBlIF0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IEV4cHIucHJlRmlsdGVyWyB0eXBlIF0oIG1hdGNoLCBjdXJMb29wLCBpbnBsYWNlLCByZXN1bHQsIG5vdCwgaXNYTUxGaWx0ZXIgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFtYXRjaCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbnlGb3VuZCA9IGZvdW5kID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBtYXRjaCA9PT0gdHJ1ZSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXRjaCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyAoaXRlbSA9IGN1ckxvb3BbaV0pICE9IG51bGw7IGkrKyApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGl0ZW0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gZmlsdGVyKCBpdGVtLCBtYXRjaCwgaSwgY3VyTG9vcCApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXNzID0gbm90IF4gZm91bmQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGlucGxhY2UgJiYgZm91bmQgIT0gbnVsbCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcGFzcyApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbnlGb3VuZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJMb29wW2ldID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBwYXNzICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goIGl0ZW0gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFueUZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBmb3VuZCAhPT0gdW5kZWZpbmVkICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhaW5wbGFjZSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJMb29wID0gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSBleHByLnJlcGxhY2UoIEV4cHIubWF0Y2hbIHR5cGUgXSwgXCJcIiApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIWFueUZvdW5kICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJbXByb3BlciBleHByZXNzaW9uXHJcbiAgICAgICAgICAgICAgICBpZiAoIGV4cHIgPT09IG9sZCApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGFueUZvdW5kID09IG51bGwgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFNpenpsZS5lcnJvciggZXhwciApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgb2xkID0gZXhwcjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGN1ckxvb3A7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgU2l6emxlLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnICk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmVpdmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XHJcbiAgICAgICAgICAgIHZhciBpLCBub2RlLFxyXG4gICAgICAgICAgICAgICAgbm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlLFxyXG4gICAgICAgICAgICAgICAgcmV0ID0gXCJcIjtcclxuXHJcbiAgICAgICAgICAgIGlmICggbm9kZVR5cGUgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5ICkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0ZXh0Q29udGVudCB8fCBpbm5lclRleHQgZm9yIGVsZW1lbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgZWxlbS50ZXh0Q29udGVudCA9PT0gJ3N0cmluZycgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLnRleHRDb250ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHR5cGVvZiBlbGVtLmlubmVyVGV4dCA9PT0gJ3N0cmluZycgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgSUUncyBjYXJyaWFnZSByZXR1cm5zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmlubmVyVGV4dC5yZXBsYWNlKCByUmV0dXJuLCAnJyApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYXZlcnNlIGl0J3MgY2hpbGRyZW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCArPSBnZXRUZXh0KCBlbGVtICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5ub2RlVmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcclxuICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyAobm9kZSA9IGVsZW1baV0pOyBpKysgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIG5vZGUubm9kZVR5cGUgIT09IDggKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldCArPSBnZXRUZXh0KCBub2RlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdmFyIEV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xyXG4gICAgICAgICAgICBvcmRlcjogWyBcIklEXCIsIFwiTkFNRVwiLCBcIlRBR1wiIF0sXHJcblxyXG4gICAgICAgICAgICBtYXRjaDoge1xyXG4gICAgICAgICAgICAgICAgSUQ6IC8jKCg/OltcXHdcXHUwMGMwLVxcdUZGRkZcXC1dfFxcXFwuKSspLyxcclxuICAgICAgICAgICAgICAgIENMQVNTOiAvXFwuKCg/OltcXHdcXHUwMGMwLVxcdUZGRkZcXC1dfFxcXFwuKSspLyxcclxuICAgICAgICAgICAgICAgIE5BTUU6IC9cXFtuYW1lPVsnXCJdKigoPzpbXFx3XFx1MDBjMC1cXHVGRkZGXFwtXXxcXFxcLikrKVsnXCJdKlxcXS8sXHJcbiAgICAgICAgICAgICAgICBBVFRSOiAvXFxbXFxzKigoPzpbXFx3XFx1MDBjMC1cXHVGRkZGXFwtXXxcXFxcLikrKVxccyooPzooXFxTPz0pXFxzKig/OihbJ1wiXSkoLio/KVxcM3woIz8oPzpbXFx3XFx1MDBjMC1cXHVGRkZGXFwtXXxcXFxcLikqKXwpfClcXHMqXFxdLyxcclxuICAgICAgICAgICAgICAgIFRBRzogL14oKD86W1xcd1xcdTAwYzAtXFx1RkZGRlxcKlxcLV18XFxcXC4pKykvLFxyXG4gICAgICAgICAgICAgICAgQ0hJTEQ6IC86KG9ubHl8bnRofGxhc3R8Zmlyc3QpLWNoaWxkKD86XFwoXFxzKihldmVufG9kZHwoPzpbK1xcLV0/XFxkK3woPzpbK1xcLV0/XFxkKik/blxccyooPzpbK1xcLV1cXHMqXFxkKyk/KSlcXHMqXFwpKT8vLFxyXG4gICAgICAgICAgICAgICAgUE9TOiAvOihudGh8ZXF8Z3R8bHR8Zmlyc3R8bGFzdHxldmVufG9kZCkoPzpcXCgoXFxkKilcXCkpPyg/PVteXFwtXXwkKS8sXHJcbiAgICAgICAgICAgICAgICBQU0VVRE86IC86KCg/OltcXHdcXHUwMGMwLVxcdUZGRkZcXC1dfFxcXFwuKSspKD86XFwoKFsnXCJdPykoKD86XFwoW15cXCldK1xcKXxbXlxcKFxcKV0qKSspXFwyXFwpKT8vXHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBsZWZ0TWF0Y2g6IHt9LFxyXG5cclxuICAgICAgICAgICAgYXR0ck1hcDoge1xyXG4gICAgICAgICAgICAgICAgXCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiLFxyXG4gICAgICAgICAgICAgICAgXCJmb3JcIjogXCJodG1sRm9yXCJcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGF0dHJIYW5kbGU6IHtcclxuICAgICAgICAgICAgICAgIGhyZWY6IGZ1bmN0aW9uKCBlbGVtICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJocmVmXCIgKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBmdW5jdGlvbiggZWxlbSApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICByZWxhdGl2ZToge1xyXG4gICAgICAgICAgICAgICAgXCIrXCI6IGZ1bmN0aW9uKGNoZWNrU2V0LCBwYXJ0KXtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNQYXJ0U3RyID0gdHlwZW9mIHBhcnQgPT09IFwic3RyaW5nXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVGFnID0gaXNQYXJ0U3RyICYmICFyTm9uV29yZC50ZXN0KCBwYXJ0ICksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUGFydFN0ck5vdFRhZyA9IGlzUGFydFN0ciAmJiAhaXNUYWc7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggaXNUYWcgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnQgPSBwYXJ0LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGVja1NldC5sZW5ndGgsIGVsZW07IGkgPCBsOyBpKysgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKGVsZW0gPSBjaGVja1NldFtpXSkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIChlbGVtID0gZWxlbS5wcmV2aW91c1NpYmxpbmcpICYmIGVsZW0ubm9kZVR5cGUgIT09IDEgKSB7fVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrU2V0W2ldID0gaXNQYXJ0U3RyTm90VGFnIHx8IGVsZW0gJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBwYXJ0ID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0gfHwgZmFsc2UgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSA9PT0gcGFydDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpc1BhcnRTdHJOb3RUYWcgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFNpenpsZS5maWx0ZXIoIHBhcnQsIGNoZWNrU2V0LCB0cnVlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBcIj5cIjogZnVuY3Rpb24oIGNoZWNrU2V0LCBwYXJ0ICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1BhcnRTdHIgPSB0eXBlb2YgcGFydCA9PT0gXCJzdHJpbmdcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGwgPSBjaGVja1NldC5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggaXNQYXJ0U3RyICYmICFyTm9uV29yZC50ZXN0KCBwYXJ0ICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnQgPSBwYXJ0LnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBsOyBpKysgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gY2hlY2tTZXRbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tTZXRbaV0gPSBwYXJlbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gcGFydCA/IHBhcmVudCA6IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IGw7IGkrKyApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0gPSBjaGVja1NldFtpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGVsZW0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tTZXRbaV0gPSBpc1BhcnRTdHIgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnBhcmVudE5vZGUgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0ucGFyZW50Tm9kZSA9PT0gcGFydDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpc1BhcnRTdHIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTaXp6bGUuZmlsdGVyKCBwYXJ0LCBjaGVja1NldCwgdHJ1ZSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBcIlwiOiBmdW5jdGlvbihjaGVja1NldCwgcGFydCwgaXNYTUwpe1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlQ2hlY2ssXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmVOYW1lID0gZG9uZSsrLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0ZuID0gZGlyQ2hlY2s7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIHBhcnQgPT09IFwic3RyaW5nXCIgJiYgIXJOb25Xb3JkLnRlc3QoIHBhcnQgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydCA9IHBhcnQudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUNoZWNrID0gcGFydDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tGbiA9IGRpck5vZGVDaGVjaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrRm4oIFwicGFyZW50Tm9kZVwiLCBwYXJ0LCBkb25lTmFtZSwgY2hlY2tTZXQsIG5vZGVDaGVjaywgaXNYTUwgKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgXCJ+XCI6IGZ1bmN0aW9uKCBjaGVja1NldCwgcGFydCwgaXNYTUwgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVDaGVjayxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZU5hbWUgPSBkb25lKyssXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRm4gPSBkaXJDaGVjaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgcGFydCA9PT0gXCJzdHJpbmdcIiAmJiAhck5vbldvcmQudGVzdCggcGFydCApICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0ID0gcGFydC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlQ2hlY2sgPSBwYXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0ZuID0gZGlyTm9kZUNoZWNrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tGbiggXCJwcmV2aW91c1NpYmxpbmdcIiwgcGFydCwgZG9uZU5hbWUsIGNoZWNrU2V0LCBub2RlQ2hlY2ssIGlzWE1MICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBmaW5kOiB7XHJcbiAgICAgICAgICAgICAgICBJRDogZnVuY3Rpb24oIG1hdGNoLCBjb250ZXh0LCBpc1hNTCApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmICFpc1hNTCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKG1hdGNoWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgcGFyZW50Tm9kZSB0byBjYXRjaCB3aGVuIEJsYWNrYmVycnkgNC42IHJldHVybnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm9kZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIGluIHRoZSBkb2N1bWVudCAjNjk2M1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbSAmJiBtLnBhcmVudE5vZGUgPyBbbV0gOiBbXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIE5BTUU6IGZ1bmN0aW9uKCBtYXRjaCwgY29udGV4dCApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5TmFtZSggbWF0Y2hbMV0gKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHJlc3VsdHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCByZXN1bHRzW2ldLmdldEF0dHJpYnV0ZShcIm5hbWVcIikgPT09IG1hdGNoWzFdICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKCByZXN1bHRzW2ldICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gbnVsbCA6IHJldDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIFRBRzogZnVuY3Rpb24oIG1hdGNoLCBjb250ZXh0ICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBtYXRjaFsxXSApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcHJlRmlsdGVyOiB7XHJcbiAgICAgICAgICAgICAgICBDTEFTUzogZnVuY3Rpb24oIG1hdGNoLCBjdXJMb29wLCBpbnBsYWNlLCByZXN1bHQsIG5vdCwgaXNYTUwgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBcIiBcIiArIG1hdGNoWzFdLnJlcGxhY2UoIHJCYWNrc2xhc2gsIFwiXCIgKSArIFwiIFwiO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGlzWE1MICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2g7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGVsZW07IChlbGVtID0gY3VyTG9vcFtpXSkgIT0gbnVsbDsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGVsZW0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG5vdCBeIChlbGVtLmNsYXNzTmFtZSAmJiAoXCIgXCIgKyBlbGVtLmNsYXNzTmFtZSArIFwiIFwiKS5yZXBsYWNlKC9bXFx0XFxuXFxyXS9nLCBcIiBcIikuaW5kZXhPZihtYXRjaCkgPj0gMCkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhaW5wbGFjZSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goIGVsZW0gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggaW5wbGFjZSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJMb29wW2ldID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgSUQ6IGZ1bmN0aW9uKCBtYXRjaCApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hbMV0ucmVwbGFjZSggckJhY2tzbGFzaCwgXCJcIiApO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBUQUc6IGZ1bmN0aW9uKCBtYXRjaCwgY3VyTG9vcCApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hbMV0ucmVwbGFjZSggckJhY2tzbGFzaCwgXCJcIiApLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIENISUxEOiBmdW5jdGlvbiggbWF0Y2ggKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXRjaFsxXSA9PT0gXCJudGhcIiApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhbWF0Y2hbMl0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzJdID0gbWF0Y2hbMl0ucmVwbGFjZSgvXlxcK3xcXHMqL2csICcnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBhcnNlIGVxdWF0aW9ucyBsaWtlICdldmVuJywgJ29kZCcsICc1JywgJzJuJywgJzNuKzInLCAnNG4tMScsICctbis2J1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVzdCA9IC8oLT8pKFxcZCopKD86bihbK1xcLV0/XFxkKikpPy8uZXhlYyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzJdID09PSBcImV2ZW5cIiAmJiBcIjJuXCIgfHwgbWF0Y2hbMl0gPT09IFwib2RkXCIgJiYgXCIybisxXCIgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICEvXFxELy50ZXN0KCBtYXRjaFsyXSApICYmIFwiMG4rXCIgKyBtYXRjaFsyXSB8fCBtYXRjaFsyXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIG51bWJlcnMgKGZpcnN0KW4rKGxhc3QpIGluY2x1ZGluZyBpZiB0aGV5IGFyZSBuZWdhdGl2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFsyXSA9ICh0ZXN0WzFdICsgKHRlc3RbMl0gfHwgMSkpIC0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbM10gPSB0ZXN0WzNdIC0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIG1hdGNoWzJdICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBNb3ZlIHRvIG5vcm1hbCBjYWNoaW5nIHN5c3RlbVxyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoWzBdID0gZG9uZSsrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2g7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIEFUVFI6IGZ1bmN0aW9uKCBtYXRjaCwgY3VyTG9vcCwgaW5wbGFjZSwgcmVzdWx0LCBub3QsIGlzWE1MICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gbWF0Y2hbMV0gPSBtYXRjaFsxXS5yZXBsYWNlKCByQmFja3NsYXNoLCBcIlwiICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggIWlzWE1MICYmIEV4cHIuYXR0ck1hcFtuYW1lXSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMV0gPSBFeHByLmF0dHJNYXBbbmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgaWYgYW4gdW4tcXVvdGVkIHZhbHVlIHdhcyB1c2VkXHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hbNF0gPSAoIG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCIgKS5yZXBsYWNlKCByQmFja3NsYXNoLCBcIlwiICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggbWF0Y2hbMl0gPT09IFwifj1cIiApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbNF0gPSBcIiBcIiArIG1hdGNoWzRdICsgXCIgXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2g7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIFBTRVVETzogZnVuY3Rpb24oIG1hdGNoLCBjdXJMb29wLCBpbnBsYWNlLCByZXN1bHQsIG5vdCApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIG1hdGNoWzFdID09PSBcIm5vdFwiICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBjb21wbGV4IGV4cHJlc3Npb24sIG9yIGEgc2ltcGxlIG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICggY2h1bmtlci5leGVjKG1hdGNoWzNdKSB8fCBcIlwiICkubGVuZ3RoID4gMSB8fCAvXlxcdy8udGVzdChtYXRjaFszXSkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFszXSA9IFNpenpsZShtYXRjaFszXSwgbnVsbCwgbnVsbCwgY3VyTG9vcCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IFNpenpsZS5maWx0ZXIobWF0Y2hbM10sIGN1ckxvb3AsIGlucGxhY2UsIHRydWUgXiBub3QpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIWlucGxhY2UgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2guYXBwbHkoIHJlc3VsdCwgcmV0ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIEV4cHIubWF0Y2guUE9TLnRlc3QoIG1hdGNoWzBdICkgfHwgRXhwci5tYXRjaC5DSElMRC50ZXN0KCBtYXRjaFswXSApICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaDtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgUE9TOiBmdW5jdGlvbiggbWF0Y2ggKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2gudW5zaGlmdCggdHJ1ZSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2g7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBmaWx0ZXJzOiB7XHJcbiAgICAgICAgICAgICAgICBlbmFibGVkOiBmdW5jdGlvbiggZWxlbSApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2UgJiYgZWxlbS50eXBlICE9PSBcImhpZGRlblwiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogZnVuY3Rpb24oIGVsZW0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIGNoZWNrZWQ6IGZ1bmN0aW9uKCBlbGVtICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmNoZWNrZWQgPT09IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHNlbGVjdGVkOiBmdW5jdGlvbiggZWxlbSApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggZWxlbS5wYXJlbnROb2RlICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIWVsZW0uZmlyc3RDaGlsZDtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgZW1wdHk6IGZ1bmN0aW9uKCBlbGVtICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhZWxlbS5maXJzdENoaWxkO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBoYXM6IGZ1bmN0aW9uKCBlbGVtLCBpLCBtYXRjaCApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISFTaXp6bGUoIG1hdGNoWzNdLCBlbGVtICkubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBoZWFkZXI6IGZ1bmN0aW9uKCBlbGVtICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoL2hcXGQvaSkudGVzdCggZWxlbS5ub2RlTmFtZSApO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApLCB0eXBlID0gZWxlbS50eXBlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElFNiBhbmQgNyB3aWxsIG1hcCBlbGVtLnR5cGUgdG8gJ3RleHQnIGZvciBuZXcgSFRNTDUgdHlwZXMgKHNlYXJjaCwgZXRjKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZSBnZXRBdHRyaWJ1dGUgaW5zdGVhZCB0byB0ZXN0IHRoaXMgY2FzZVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJiBcInRleHRcIiA9PT0gdHlwZSAmJiAoIGF0dHIgPT09IHR5cGUgfHwgYXR0ciA9PT0gbnVsbCApO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICByYWRpbzogZnVuY3Rpb24oIGVsZW0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICYmIFwicmFkaW9cIiA9PT0gZWxlbS50eXBlO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBjaGVja2JveDogZnVuY3Rpb24oIGVsZW0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICYmIFwiY2hlY2tib3hcIiA9PT0gZWxlbS50eXBlO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBmaWxlOiBmdW5jdGlvbiggZWxlbSApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiYgXCJmaWxlXCIgPT09IGVsZW0udHlwZTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgcGFzc3dvcmQ6IGZ1bmN0aW9uKCBlbGVtICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJiBcInBhc3N3b3JkXCIgPT09IGVsZW0udHlwZTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgc3VibWl0OiBmdW5jdGlvbiggZWxlbSApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiKSAmJiBcInN1Ym1pdFwiID09PSBlbGVtLnR5cGU7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIGltYWdlOiBmdW5jdGlvbiggZWxlbSApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiYgXCJpbWFnZVwiID09PSBlbGVtLnR5cGU7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHJlc2V0OiBmdW5jdGlvbiggZWxlbSApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiKSAmJiBcInJlc2V0XCIgPT09IGVsZW0udHlwZTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgYnV0dG9uOiBmdW5jdGlvbiggZWxlbSApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIFwiYnV0dG9uXCIgPT09IGVsZW0udHlwZSB8fCBuYW1lID09PSBcImJ1dHRvblwiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBpbnB1dDogZnVuY3Rpb24oIGVsZW0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgvaW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbi9pKS50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIGZvY3VzOiBmdW5jdGlvbiggZWxlbSApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbSA9PT0gZWxlbS5vd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldEZpbHRlcnM6IHtcclxuICAgICAgICAgICAgICAgIGZpcnN0OiBmdW5jdGlvbiggZWxlbSwgaSApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSA9PT0gMDtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgbGFzdDogZnVuY3Rpb24oIGVsZW0sIGksIG1hdGNoLCBhcnJheSApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSA9PT0gYXJyYXkubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgZXZlbjogZnVuY3Rpb24oIGVsZW0sIGkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgJSAyID09PSAwO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBvZGQ6IGZ1bmN0aW9uKCBlbGVtLCBpICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpICUgMiA9PT0gMTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgbHQ6IGZ1bmN0aW9uKCBlbGVtLCBpLCBtYXRjaCApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSA8IG1hdGNoWzNdIC0gMDtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgZ3Q6IGZ1bmN0aW9uKCBlbGVtLCBpLCBtYXRjaCApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSA+IG1hdGNoWzNdIC0gMDtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgbnRoOiBmdW5jdGlvbiggZWxlbSwgaSwgbWF0Y2ggKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoWzNdIC0gMCA9PT0gaTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgZXE6IGZ1bmN0aW9uKCBlbGVtLCBpLCBtYXRjaCApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hbM10gLSAwID09PSBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmaWx0ZXI6IHtcclxuICAgICAgICAgICAgICAgIFBTRVVETzogZnVuY3Rpb24oIGVsZW0sIG1hdGNoLCBpLCBhcnJheSApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IG1hdGNoWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXIgPSBFeHByLmZpbHRlcnNbIG5hbWUgXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBmaWx0ZXIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXIoIGVsZW0sIGksIG1hdGNoLCBhcnJheSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBuYW1lID09PSBcImNvbnRhaW5zXCIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZWxlbS50ZXh0Q29udGVudCB8fCBlbGVtLmlubmVyVGV4dCB8fCBnZXRUZXh0KFsgZWxlbSBdKSB8fCBcIlwiKS5pbmRleE9mKG1hdGNoWzNdKSA+PSAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBuYW1lID09PSBcIm5vdFwiICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm90ID0gbWF0Y2hbM107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDAsIGwgPSBub3QubGVuZ3RoOyBqIDwgbDsgaisrICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBub3Rbal0gPT09IGVsZW0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgU2l6emxlLmVycm9yKCBuYW1lICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBDSElMRDogZnVuY3Rpb24oIGVsZW0sIG1hdGNoICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmaXJzdCwgbGFzdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZU5hbWUsIHBhcmVudCwgY2FjaGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50LCBkaWZmLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gbWF0Y2hbMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBlbGVtO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKCB0eXBlICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwib25seVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZmlyc3RcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggKG5vZGUgPSBub2RlLnByZXZpb3VzU2libGluZykgKVx0IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0eXBlID09PSBcImZpcnN0XCIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGVsZW07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibGFzdFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCAobm9kZSA9IG5vZGUubmV4dFNpYmxpbmcpIClcdCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBub2RlLm5vZGVUeXBlID09PSAxICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm50aFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBtYXRjaFsyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3QgPSBtYXRjaFszXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGZpcnN0ID09PSAxICYmIGxhc3QgPT09IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZU5hbWUgPSBtYXRjaFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHBhcmVudCAmJiAocGFyZW50WyBleHBhbmRvIF0gIT09IGRvbmVOYW1lIHx8ICFlbGVtLm5vZGVJbmRleCkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBub2RlID0gcGFyZW50LmZpcnN0Q2hpbGQ7IG5vZGU7IG5vZGUgPSBub2RlLm5leHRTaWJsaW5nICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm5vZGVJbmRleCA9ICsrY291bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFsgZXhwYW5kbyBdID0gZG9uZU5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlmZiA9IGVsZW0ubm9kZUluZGV4IC0gbGFzdDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGZpcnN0ID09PSAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkaWZmID09PSAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICggZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBJRDogZnVuY3Rpb24oIGVsZW0sIG1hdGNoICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiaWRcIikgPT09IG1hdGNoO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBUQUc6IGZ1bmN0aW9uKCBlbGVtLCBtYXRjaCApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG1hdGNoID09PSBcIipcIiAmJiBlbGVtLm5vZGVUeXBlID09PSAxKSB8fCAhIWVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBtYXRjaDtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgQ0xBU1M6IGZ1bmN0aW9uKCBlbGVtLCBtYXRjaCApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFwiIFwiICsgKGVsZW0uY2xhc3NOYW1lIHx8IGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikpICsgXCIgXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaW5kZXhPZiggbWF0Y2ggKSA+IC0xO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBBVFRSOiBmdW5jdGlvbiggZWxlbSwgbWF0Y2ggKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBtYXRjaFsxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gU2l6emxlLmF0dHIgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU2l6emxlLmF0dHIoIGVsZW0sIG5hbWUgKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBFeHByLmF0dHJIYW5kbGVbIG5hbWUgXSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRXhwci5hdHRySGFuZGxlWyBuYW1lIF0oIGVsZW0gKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbVsgbmFtZSBdICE9IG51bGwgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtWyBuYW1lIF0gOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdCArIFwiXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBtYXRjaFsyXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2sgPSBtYXRjaFs0XTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PSBudWxsID9cclxuICAgICAgICAgICAgICAgICAgICB0eXBlID09PSBcIiE9XCIgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhdHlwZSAmJiBTaXp6bGUuYXR0ciA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCAhPSBudWxsIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPT09IFwiPVwiID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID09PSBjaGVjayA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9PT0gXCIqPVwiID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5pbmRleE9mKGNoZWNrKSA+PSAwIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9PT0gXCJ+PVwiID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiIFwiICsgdmFsdWUgKyBcIiBcIikuaW5kZXhPZihjaGVjaykgPj0gMCA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhY2hlY2sgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgJiYgcmVzdWx0ICE9PSBmYWxzZSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9PT0gXCIhPVwiID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSAhPT0gY2hlY2sgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID09PSBcIl49XCIgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5pbmRleE9mKGNoZWNrKSA9PT0gMCA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID09PSBcIiQ9XCIgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuc3Vic3RyKHZhbHVlLmxlbmd0aCAtIGNoZWNrLmxlbmd0aCkgPT09IGNoZWNrIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID09PSBcInw9XCIgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID09PSBjaGVjayB8fCB2YWx1ZS5zdWJzdHIoMCwgY2hlY2subGVuZ3RoICsgMSkgPT09IGNoZWNrICsgXCItXCIgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgUE9TOiBmdW5jdGlvbiggZWxlbSwgbWF0Y2gsIGksIGFycmF5ICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gbWF0Y2hbMl0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlciA9IEV4cHIuc2V0RmlsdGVyc1sgbmFtZSBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGZpbHRlciApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlciggZWxlbSwgaSwgbWF0Y2gsIGFycmF5ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdmFyIG9yaWdQT1MgPSBFeHByLm1hdGNoLlBPUyxcclxuICAgICAgICAgICAgZmVzY2FwZSA9IGZ1bmN0aW9uKGFsbCwgbnVtKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIlxcXFxcIiArIChudW0gLSAwICsgMSk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgIGZvciAoIHZhciB0eXBlIGluIEV4cHIubWF0Y2ggKSB7XHJcbiAgICAgICAgICAgIEV4cHIubWF0Y2hbIHR5cGUgXSA9IG5ldyBSZWdFeHAoIEV4cHIubWF0Y2hbIHR5cGUgXS5zb3VyY2UgKyAoLyg/IVteXFxbXSpcXF0pKD8hW15cXChdKlxcKSkvLnNvdXJjZSkgKTtcclxuICAgICAgICAgICAgRXhwci5sZWZ0TWF0Y2hbIHR5cGUgXSA9IG5ldyBSZWdFeHAoIC8oXig/Oi58XFxyfFxcbikqPykvLnNvdXJjZSArIEV4cHIubWF0Y2hbIHR5cGUgXS5zb3VyY2UucmVwbGFjZSgvXFxcXChcXGQrKS9nLCBmZXNjYXBlKSApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG1ha2VBcnJheSA9IGZ1bmN0aW9uKCBhcnJheSwgcmVzdWx0cyApIHtcclxuICAgICAgICAgICAgYXJyYXkgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJyYXksIDAgKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggcmVzdWx0cyApIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaC5hcHBseSggcmVzdWx0cywgYXJyYXkgKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYXJyYXk7XHJcbiAgICAgICAgfTtcclxuXHJcbi8vIFBlcmZvcm0gYSBzaW1wbGUgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRoZSBicm93c2VyIGlzIGNhcGFibGUgb2ZcclxuLy8gY29udmVydGluZyBhIE5vZGVMaXN0IHRvIGFuIGFycmF5IHVzaW5nIGJ1aWx0aW4gbWV0aG9kcy5cclxuLy8gQWxzbyB2ZXJpZmllcyB0aGF0IHRoZSByZXR1cm5lZCBhcnJheSBob2xkcyBET00gbm9kZXNcclxuLy8gKHdoaWNoIGlzIG5vdCB0aGUgY2FzZSBpbiB0aGUgQmxhY2tiZXJyeSBicm93c2VyKVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2hpbGROb2RlcywgMCApWzBdLm5vZGVUeXBlO1xyXG5cclxuLy8gUHJvdmlkZSBhIGZhbGxiYWNrIG1ldGhvZCBpZiBpdCBkb2VzIG5vdCB3b3JrXHJcbiAgICAgICAgfSBjYXRjaCggZSApIHtcclxuICAgICAgICAgICAgbWFrZUFycmF5ID0gZnVuY3Rpb24oIGFycmF5LCByZXN1bHRzICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHJldCA9IHJlc3VsdHMgfHwgW107XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCB0b1N0cmluZy5jYWxsKGFycmF5KSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiICkge1xyXG4gICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KCByZXQsIGFycmF5ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiBhcnJheS5sZW5ndGggPT09IFwibnVtYmVyXCIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goIGFycmF5W2ldICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggOyBhcnJheVtpXTsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goIGFycmF5W2ldICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzb3J0T3JkZXIsIHNpYmxpbmdDaGVjaztcclxuXHJcbiAgICAgICAgaWYgKCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29tcGFyZURvY3VtZW50UG9zaXRpb24gKSB7XHJcbiAgICAgICAgICAgIHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCBhID09PSBiICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc0R1cGxpY2F0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiB8fCAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiA/IC0xIDogMTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKSAmIDQgPyAtMSA6IDE7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIG5vZGVzIGFyZSBpZGVudGljYWwsIHdlIGNhbiBleGl0IGVhcmx5XHJcbiAgICAgICAgICAgICAgICBpZiAoIGEgPT09IGIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzRHVwbGljYXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gdXNpbmcgc291cmNlSW5kZXggKGluIElFKSBpZiBpdCdzIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBhLnNvdXJjZUluZGV4ICYmIGIuc291cmNlSW5kZXggKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuc291cmNlSW5kZXggLSBiLnNvdXJjZUluZGV4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBhbCwgYmwsXHJcbiAgICAgICAgICAgICAgICAgICAgYXAgPSBbXSxcclxuICAgICAgICAgICAgICAgICAgICBicCA9IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIGF1cCA9IGEucGFyZW50Tm9kZSxcclxuICAgICAgICAgICAgICAgICAgICBidXAgPSBiLnBhcmVudE5vZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgY3VyID0gYXVwO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MgKG9yIGlkZW50aWNhbCkgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcclxuICAgICAgICAgICAgICAgIGlmICggYXVwID09PSBidXAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmdDaGVjayggYSwgYiApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBubyBwYXJlbnRzIHdlcmUgZm91bmQgdGhlbiB0aGUgbm9kZXMgYXJlIGRpc2Nvbm5lY3RlZFxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggIWF1cCApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggIWJ1cCApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgdGhleSdyZSBzb21ld2hlcmUgZWxzZSBpbiB0aGUgdHJlZSBzbyB3ZSBuZWVkXHJcbiAgICAgICAgICAgICAgICAvLyB0byBidWlsZCB1cCBhIGZ1bGwgbGlzdCBvZiB0aGUgcGFyZW50Tm9kZXMgZm9yIGNvbXBhcmlzb25cclxuICAgICAgICAgICAgICAgIHdoaWxlICggY3VyICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFwLnVuc2hpZnQoIGN1ciApO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5wYXJlbnROb2RlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGN1ciA9IGJ1cDtcclxuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoIGN1ciApIHtcclxuICAgICAgICAgICAgICAgICAgICBicC51bnNoaWZ0KCBjdXIgKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXIgPSBjdXIucGFyZW50Tm9kZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBhbCA9IGFwLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGJsID0gYnAubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHdhbGtpbmcgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XHJcbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBhbCAmJiBpIDwgYmw7IGkrKyApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGFwW2ldICE9PSBicFtpXSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmdDaGVjayggYXBbaV0sIGJwW2ldICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFdlIGVuZGVkIHNvbWVwbGFjZSB1cCB0aGUgdHJlZSBzbyBkbyBhIHNpYmxpbmcgY2hlY2tcclxuICAgICAgICAgICAgICAgIHJldHVybiBpID09PSBhbCA/XHJcbiAgICAgICAgICAgICAgICAgICAgc2libGluZ0NoZWNrKCBhLCBicFtpXSwgLTEgKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgc2libGluZ0NoZWNrKCBhcFtpXSwgYiwgMSApO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgc2libGluZ0NoZWNrID0gZnVuY3Rpb24oIGEsIGIsIHJldCApIHtcclxuICAgICAgICAgICAgICAgIGlmICggYSA9PT0gYiApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBjdXIgPSBhLm5leHRTaWJsaW5nO1xyXG5cclxuICAgICAgICAgICAgICAgIHdoaWxlICggY3VyICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggY3VyID09PSBiICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBjdXIgPSBjdXIubmV4dFNpYmxpbmc7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZSBicm93c2VyIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZSB3aGVuXHJcbi8vIHF1ZXJ5aW5nIGJ5IGdldEVsZW1lbnRCeUlkIChhbmQgcHJvdmlkZSBhIHdvcmthcm91bmQpXHJcbiAgICAgICAgKGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIC8vIFdlJ3JlIGdvaW5nIHRvIGluamVjdCBhIGZha2UgaW5wdXQgZWxlbWVudCB3aXRoIGEgc3BlY2lmaWVkIG5hbWVcclxuICAgICAgICAgICAgdmFyIGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxyXG4gICAgICAgICAgICAgICAgaWQgPSBcInNjcmlwdFwiICsgKG5ldyBEYXRlKCkpLmdldFRpbWUoKSxcclxuICAgICAgICAgICAgICAgIHJvb3QgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcblxyXG4gICAgICAgICAgICBmb3JtLmlubmVySFRNTCA9IFwiPGEgbmFtZT0nXCIgKyBpZCArIFwiJy8+XCI7XHJcblxyXG4gICAgICAgICAgICAvLyBJbmplY3QgaXQgaW50byB0aGUgcm9vdCBlbGVtZW50LCBjaGVjayBpdHMgc3RhdHVzLCBhbmQgcmVtb3ZlIGl0IHF1aWNrbHlcclxuICAgICAgICAgICAgcm9vdC5pbnNlcnRCZWZvcmUoIGZvcm0sIHJvb3QuZmlyc3RDaGlsZCApO1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlIHdvcmthcm91bmQgaGFzIHRvIGRvIGFkZGl0aW9uYWwgY2hlY2tzIGFmdGVyIGEgZ2V0RWxlbWVudEJ5SWRcclxuICAgICAgICAgICAgLy8gV2hpY2ggc2xvd3MgdGhpbmdzIGRvd24gZm9yIG90aGVyIGJyb3dzZXJzIChoZW5jZSB0aGUgYnJhbmNoaW5nKVxyXG4gICAgICAgICAgICBpZiAoIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBpZCApICkge1xyXG4gICAgICAgICAgICAgICAgRXhwci5maW5kLklEID0gZnVuY3Rpb24oIG1hdGNoLCBjb250ZXh0LCBpc1hNTCApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmICFpc1hNTCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKG1hdGNoWzFdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0uaWQgPT09IG1hdGNoWzFdIHx8IHR5cGVvZiBtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiYgbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIikubm9kZVZhbHVlID09PSBtYXRjaFsxXSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW21dIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW107XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICBFeHByLmZpbHRlci5JRCA9IGZ1bmN0aW9uKCBlbGVtLCBtYXRjaCApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxICYmIG5vZGUgJiYgbm9kZS5ub2RlVmFsdWUgPT09IG1hdGNoO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcm9vdC5yZW1vdmVDaGlsZCggZm9ybSApO1xyXG5cclxuICAgICAgICAgICAgLy8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcclxuICAgICAgICAgICAgcm9vdCA9IGZvcm0gPSBudWxsO1xyXG4gICAgICAgIH0pKCk7XHJcblxyXG4gICAgICAgIChmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgdGhlIGJyb3dzZXIgcmV0dXJucyBvbmx5IGVsZW1lbnRzXHJcbiAgICAgICAgICAgIC8vIHdoZW4gZG9pbmcgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpXHJcblxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBmYWtlIGVsZW1lbnRcclxuICAgICAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgICAgIGRpdi5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlQ29tbWVudChcIlwiKSApO1xyXG5cclxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIG5vIGNvbW1lbnRzIGFyZSBmb3VuZFxyXG4gICAgICAgICAgICBpZiAoIGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoID4gMCApIHtcclxuICAgICAgICAgICAgICAgIEV4cHIuZmluZC5UQUcgPSBmdW5jdGlvbiggbWF0Y2gsIGNvbnRleHQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBtYXRjaFsxXSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgb3V0IHBvc3NpYmxlIGNvbW1lbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXRjaFsxXSA9PT0gXCIqXCIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXAgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgcmVzdWx0c1tpXTsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCByZXN1bHRzW2ldLm5vZGVUeXBlID09PSAxICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcC5wdXNoKCByZXN1bHRzW2ldICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSB0bXA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiBhbiBhdHRyaWJ1dGUgcmV0dXJucyBub3JtYWxpemVkIGhyZWYgYXR0cmlidXRlc1xyXG4gICAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gXCI8YSBocmVmPScjJz48L2E+XCI7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGRpdi5maXJzdENoaWxkICYmIHR5cGVvZiBkaXYuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiZcclxuICAgICAgICAgICAgICAgIGRpdi5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcImhyZWZcIikgIT09IFwiI1wiICkge1xyXG5cclxuICAgICAgICAgICAgICAgIEV4cHIuYXR0ckhhbmRsZS5ocmVmID0gZnVuY3Rpb24oIGVsZW0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcImhyZWZcIiwgMiApO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcclxuICAgICAgICAgICAgZGl2ID0gbnVsbDtcclxuICAgICAgICB9KSgpO1xyXG5cclxuICAgICAgICBpZiAoIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgKSB7XHJcbiAgICAgICAgICAgIChmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgdmFyIG9sZFNpenpsZSA9IFNpenpsZSxcclxuICAgICAgICAgICAgICAgICAgICBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIGlkID0gXCJfX3NpenpsZV9fXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgZGl2LmlubmVySFRNTCA9IFwiPHAgY2xhc3M9J1RFU1QnPjwvcD5cIjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgY2FuJ3QgaGFuZGxlIHVwcGVyY2FzZSBvciB1bmljb2RlIGNoYXJhY3RlcnMgd2hlblxyXG4gICAgICAgICAgICAgICAgLy8gaW4gcXVpcmtzIG1vZGUuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGRpdi5xdWVyeVNlbGVjdG9yQWxsICYmIGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiLlRFU1RcIikubGVuZ3RoID09PSAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBTaXp6bGUgPSBmdW5jdGlvbiggcXVlcnksIGNvbnRleHQsIGV4dHJhLCBzZWVkICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHVzZSBxdWVyeVNlbGVjdG9yQWxsIG9uIG5vbi1YTUwgZG9jdW1lbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gKElEIHNlbGVjdG9ycyBkb24ndCB3b3JrIGluIG5vbi1IVE1MIGRvY3VtZW50cylcclxuICAgICAgICAgICAgICAgICAgICBpZiAoICFzZWVkICYmICFTaXp6bGUuaXNYTUwoY29udGV4dCkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlZSBpZiB3ZSBmaW5kIGEgc2VsZWN0b3IgdG8gc3BlZWQgdXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gL14oXFx3KyQpfF5cXC4oW1xcd1xcLV0rJCl8XiMoW1xcd1xcLV0rJCkvLmV4ZWMoIHF1ZXJ5ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG1hdGNoICYmIChjb250ZXh0Lm5vZGVUeXBlID09PSAxIHx8IGNvbnRleHQubm9kZVR5cGUgPT09IDkpICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3BlZWQtdXA6IFNpenpsZShcIlRBR1wiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXRjaFsxXSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZUFycmF5KCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBxdWVyeSApLCBleHRyYSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTcGVlZC11cDogU2l6emxlKFwiLkNMQVNTXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBtYXRjaFsyXSAmJiBFeHByLmZpbmQuQ0xBU1MgJiYgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlQXJyYXkoIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggbWF0Y2hbMl0gKSwgZXh0cmEgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjb250ZXh0Lm5vZGVUeXBlID09PSA5ICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3BlZWQtdXA6IFNpenpsZShcImJvZHlcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBib2R5IGVsZW1lbnQgb25seSBleGlzdHMgb25jZSwgb3B0aW1pemUgZmluZGluZyBpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBxdWVyeSA9PT0gXCJib2R5XCIgJiYgY29udGV4dC5ib2R5ICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlQXJyYXkoIFsgY29udGV4dC5ib2R5IF0sIGV4dHJhICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNwZWVkLXVwOiBTaXp6bGUoXCIjSURcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIG1hdGNoICYmIG1hdGNoWzNdICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbM10gKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgcGFyZW50Tm9kZSB0byBjYXRjaCB3aGVuIEJsYWNrYmVycnkgNC42IHJldHVybnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdGhlIGRvY3VtZW50ICM2OTYzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtICYmIGVsZW0ucGFyZW50Tm9kZSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlIElFIGFuZCBPcGVyYSByZXR1cm4gaXRlbXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnkgbmFtZSBpbnN0ZWFkIG9mIElEXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZWxlbS5pZCA9PT0gbWF0Y2hbM10gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZUFycmF5KCBbIGVsZW0gXSwgZXh0cmEgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZUFycmF5KCBbXSwgZXh0cmEgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZUFycmF5KCBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpLCBleHRyYSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChxc2FFcnJvcikge31cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBxU0Egd29ya3Mgc3RyYW5nZWx5IG9uIEVsZW1lbnQtcm9vdGVkIHF1ZXJpZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbiB3b3JrIGFyb3VuZCB0aGlzIGJ5IHNwZWNpZnlpbmcgYW4gZXh0cmEgSUQgb24gdGhlIHJvb3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCB3b3JraW5nIHVwIGZyb20gdGhlcmUgKFRoYW5rcyB0byBBbmRyZXcgRHVwb250IGZvciB0aGUgdGVjaG5pcXVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUUgOCBkb2Vzbid0IHdvcmsgb24gb2JqZWN0IGVsZW1lbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGNvbnRleHQubm9kZVR5cGUgPT09IDEgJiYgY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9sZENvbnRleHQgPSBjb250ZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKCBcImlkXCIgKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuaWQgPSBvbGQgfHwgaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzUGFyZW50ID0gY29udGV4dC5wYXJlbnROb2RlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlSGllcmFyY2h5U2VsZWN0b3IgPSAvXlxccypbK35dLy50ZXN0KCBxdWVyeSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIW9sZCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNldEF0dHJpYnV0ZSggXCJpZFwiLCBuaWQgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmlkID0gbmlkLnJlcGxhY2UoIC8nL2csIFwiXFxcXCQmXCIgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcmVsYXRpdmVIaWVyYXJjaHlTZWxlY3RvciAmJiBoYXNQYXJlbnQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIXJlbGF0aXZlSGllcmFyY2h5U2VsZWN0b3IgfHwgaGFzUGFyZW50ICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZUFycmF5KCBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW2lkPSdcIiArIG5pZCArIFwiJ10gXCIgKyBxdWVyeSApLCBleHRyYSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoKHBzZXVkb0Vycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIW9sZCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkQ29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoIFwiaWRcIiApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9sZFNpenpsZShxdWVyeSwgY29udGV4dCwgZXh0cmEsIHNlZWQpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgcHJvcCBpbiBvbGRTaXp6bGUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgU2l6emxlWyBwcm9wIF0gPSBvbGRTaXp6bGVbIHByb3AgXTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxyXG4gICAgICAgICAgICAgICAgZGl2ID0gbnVsbDtcclxuICAgICAgICAgICAgfSkoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIChmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICB2YXIgaHRtbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcclxuICAgICAgICAgICAgICAgIG1hdGNoZXMgPSBodG1sLm1hdGNoZXNTZWxlY3RvciB8fCBodG1sLm1vek1hdGNoZXNTZWxlY3RvciB8fCBodG1sLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBodG1sLm1zTWF0Y2hlc1NlbGVjdG9yO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBtYXRjaGVzICkge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXHJcbiAgICAgICAgICAgICAgICAvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5IGZhaWxzIHRoaXMpXHJcbiAgICAgICAgICAgICAgICB2YXIgZGlzY29ubmVjdGVkTWF0Y2ggPSAhbWF0Y2hlcy5jYWxsKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksIFwiZGl2XCIgKSxcclxuICAgICAgICAgICAgICAgICAgICBwc2V1ZG9Xb3JrcyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcclxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzLmNhbGwoIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgXCJbdGVzdCE9JyddOnNpenpsZVwiICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCggcHNldWRvRXJyb3IgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHNldWRvV29ya3MgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIFNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggbm9kZSwgZXhwciApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBhdHRyaWJ1dGUgc2VsZWN0b3JzIGFyZSBxdW90ZWRcclxuICAgICAgICAgICAgICAgICAgICBleHByID0gZXhwci5yZXBsYWNlKC9cXD1cXHMqKFteJ1wiXFxdXSopXFxzKlxcXS9nLCBcIj0nJDEnXVwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhU2l6emxlLmlzWE1MKCBub2RlICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHBzZXVkb1dvcmtzIHx8ICFFeHByLm1hdGNoLlBTRVVETy50ZXN0KCBleHByICkgJiYgIS8hPS8udGVzdCggZXhwciApICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIG5vZGUsIGV4cHIgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcmV0IHx8ICFkaXNjb25uZWN0ZWRNYXRjaCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmcmFnbWVudCBpbiBJRSA5LCBzbyBjaGVjayBmb3IgdGhhdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmRvY3VtZW50ICYmIG5vZGUuZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChlKSB7fVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNpenpsZShleHByLCBudWxsLCBudWxsLCBbbm9kZV0pLmxlbmd0aCA+IDA7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkoKTtcclxuXHJcbiAgICAgICAgKGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG5cclxuICAgICAgICAgICAgZGl2LmlubmVySFRNTCA9IFwiPGRpdiBjbGFzcz0ndGVzdCBlJz48L2Rpdj48ZGl2IGNsYXNzPSd0ZXN0Jz48L2Rpdj5cIjtcclxuXHJcbiAgICAgICAgICAgIC8vIE9wZXJhIGNhbid0IGZpbmQgYSBzZWNvbmQgY2xhc3NuYW1lIChpbiA5LjYpXHJcbiAgICAgICAgICAgIC8vIEFsc28sIG1ha2Ugc3VyZSB0aGF0IGdldEVsZW1lbnRzQnlDbGFzc05hbWUgYWN0dWFsbHkgZXhpc3RzXHJcbiAgICAgICAgICAgIGlmICggIWRpdi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lIHx8IGRpdi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiZVwiKS5sZW5ndGggPT09IDAgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNhZmFyaSBjYWNoZXMgY2xhc3MgYXR0cmlidXRlcywgZG9lc24ndCBjYXRjaCBjaGFuZ2VzIChpbiAzLjIpXHJcbiAgICAgICAgICAgIGRpdi5sYXN0Q2hpbGQuY2xhc3NOYW1lID0gXCJlXCI7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGRpdi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiZVwiKS5sZW5ndGggPT09IDEgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIEV4cHIub3JkZXIuc3BsaWNlKDEsIDAsIFwiQ0xBU1NcIik7XHJcbiAgICAgICAgICAgIEV4cHIuZmluZC5DTEFTUyA9IGZ1bmN0aW9uKCBtYXRjaCwgY29udGV4dCwgaXNYTUwgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgIWlzWE1MICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUobWF0Y2hbMV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcclxuICAgICAgICAgICAgZGl2ID0gbnVsbDtcclxuICAgICAgICB9KSgpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBkaXJOb2RlQ2hlY2soIGRpciwgY3VyLCBkb25lTmFtZSwgY2hlY2tTZXQsIG5vZGVDaGVjaywgaXNYTUwgKSB7XHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGNoZWNrU2V0Lmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbGVtID0gY2hlY2tTZXRbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBlbGVtICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBlbGVtID0gZWxlbVtkaXJdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGVsZW0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZWxlbVsgZXhwYW5kbyBdID09PSBkb25lTmFtZSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gY2hlY2tTZXRbZWxlbS5zaXpzZXRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAhaXNYTUwgKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1bIGV4cGFuZG8gXSA9IGRvbmVOYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zaXpzZXQgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gY3VyICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBlbGVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0gPSBlbGVtW2Rpcl07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBjaGVja1NldFtpXSA9IG1hdGNoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBkaXJDaGVjayggZGlyLCBjdXIsIGRvbmVOYW1lLCBjaGVja1NldCwgbm9kZUNoZWNrLCBpc1hNTCApIHtcclxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gY2hlY2tTZXQubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVsZW0gPSBjaGVja1NldFtpXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGVsZW0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGVsZW0gPSBlbGVtW2Rpcl07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICggZWxlbSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtWyBleHBhbmRvIF0gPT09IGRvbmVOYW1lICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBjaGVja1NldFtlbGVtLnNpenNldF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhaXNYTUwgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbVsgZXhwYW5kbyBdID0gZG9uZU5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zaXpzZXQgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIGN1ciAhPT0gXCJzdHJpbmdcIiApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGVsZW0gPT09IGN1ciApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggU2l6emxlLmZpbHRlciggY3VyLCBbZWxlbV0gKS5sZW5ndGggPiAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gZWxlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSA9IGVsZW1bZGlyXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrU2V0W2ldID0gbWF0Y2g7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zICkge1xyXG4gICAgICAgICAgICBTaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbiggYSwgYiApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhICE9PSBiICYmIChhLmNvbnRhaW5zID8gYS5jb250YWlucyhiKSA6IHRydWUpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29tcGFyZURvY3VtZW50UG9zaXRpb24gKSB7XHJcbiAgICAgICAgICAgIFNpenpsZS5jb250YWlucyA9IGZ1bmN0aW9uKCBhLCBiICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICEhKGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYikgJiAxNik7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIFNpenpsZS5jb250YWlucyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgU2l6emxlLmlzWE1MID0gZnVuY3Rpb24oIGVsZW0gKSB7XHJcbiAgICAgICAgICAgIC8vIGRvY3VtZW50RWxlbWVudCBpcyB2ZXJpZmllZCBmb3IgY2FzZXMgd2hlcmUgaXQgZG9lc24ndCB5ZXQgZXhpc3RcclxuICAgICAgICAgICAgLy8gKHN1Y2ggYXMgbG9hZGluZyBpZnJhbWVzIGluIElFIC0gIzQ4MzMpXHJcbiAgICAgICAgICAgIHZhciBkb2N1bWVudEVsZW1lbnQgPSAoZWxlbSA/IGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtIDogMCkuZG9jdW1lbnRFbGVtZW50O1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50RWxlbWVudCA/IGRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gXCJIVE1MXCIgOiBmYWxzZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB2YXIgcG9zUHJvY2VzcyA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgc2VlZCApIHtcclxuICAgICAgICAgICAgdmFyIG1hdGNoLFxyXG4gICAgICAgICAgICAgICAgdG1wU2V0ID0gW10sXHJcbiAgICAgICAgICAgICAgICBsYXRlciA9IFwiXCIsXHJcbiAgICAgICAgICAgICAgICByb290ID0gY29udGV4dC5ub2RlVHlwZSA/IFtjb250ZXh0XSA6IGNvbnRleHQ7XHJcblxyXG4gICAgICAgICAgICAvLyBQb3NpdGlvbiBzZWxlY3RvcnMgbXVzdCBiZSBkb25lIGFmdGVyIHRoZSBmaWx0ZXJcclxuICAgICAgICAgICAgLy8gQW5kIHNvIG11c3QgOm5vdChwb3NpdGlvbmFsKSBzbyB3ZSBtb3ZlIGFsbCBQU0VVRE9zIHRvIHRoZSBlbmRcclxuICAgICAgICAgICAgd2hpbGUgKCAobWF0Y2ggPSBFeHByLm1hdGNoLlBTRVVETy5leGVjKCBzZWxlY3RvciApKSApIHtcclxuICAgICAgICAgICAgICAgIGxhdGVyICs9IG1hdGNoWzBdO1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKCBFeHByLm1hdGNoLlBTRVVETywgXCJcIiApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzZWxlY3RvciA9IEV4cHIucmVsYXRpdmVbc2VsZWN0b3JdID8gc2VsZWN0b3IgKyBcIipcIiA6IHNlbGVjdG9yO1xyXG5cclxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gcm9vdC5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XHJcbiAgICAgICAgICAgICAgICBTaXp6bGUoIHNlbGVjdG9yLCByb290W2ldLCB0bXBTZXQsIHNlZWQgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIFNpenpsZS5maWx0ZXIoIGxhdGVyLCB0bXBTZXQgKTtcclxuICAgICAgICB9O1xyXG5cclxuLy8gRVhQT1NFXHJcbi8vIE92ZXJyaWRlIHNpenpsZSBhdHRyaWJ1dGUgcmV0cmlldmFsXHJcbiAgICAgICAgU2l6emxlLmF0dHIgPSBqUXVlcnkuYXR0cjtcclxuICAgICAgICBTaXp6bGUuc2VsZWN0b3JzLmF0dHJNYXAgPSB7fTtcclxuICAgICAgICBqUXVlcnkuZmluZCA9IFNpenpsZTtcclxuICAgICAgICBqUXVlcnkuZXhwciA9IFNpenpsZS5zZWxlY3RvcnM7XHJcbiAgICAgICAgalF1ZXJ5LmV4cHJbXCI6XCJdID0galF1ZXJ5LmV4cHIuZmlsdGVycztcclxuICAgICAgICBqUXVlcnkudW5pcXVlID0gU2l6emxlLnVuaXF1ZVNvcnQ7XHJcbiAgICAgICAgalF1ZXJ5LnRleHQgPSBTaXp6bGUuZ2V0VGV4dDtcclxuICAgICAgICBqUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XHJcbiAgICAgICAgalF1ZXJ5LmNvbnRhaW5zID0gU2l6emxlLmNvbnRhaW5zO1xyXG5cclxuXHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICB2YXIgcnVudGlsID0gL1VudGlsJC8sXHJcbiAgICAgICAgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXZVbnRpbHxwcmV2QWxsKS8sXHJcbiAgICAvLyBOb3RlOiBUaGlzIFJlZ0V4cCBzaG91bGQgYmUgaW1wcm92ZWQsIG9yIGxpa2VseSBwdWxsZWQgZnJvbSBTaXp6bGVcclxuICAgICAgICBybXVsdGlzZWxlY3RvciA9IC8sLyxcclxuICAgICAgICBpc1NpbXBsZSA9IC9eLlteOiNcXFtcXC4sXSokLyxcclxuICAgICAgICBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZSxcclxuICAgICAgICBQT1MgPSBqUXVlcnkuZXhwci5tYXRjaC5QT1MsXHJcbiAgICAvLyBtZXRob2RzIGd1YXJhbnRlZWQgdG8gcHJvZHVjZSBhIHVuaXF1ZSBzZXQgd2hlbiBzdGFydGluZyBmcm9tIGEgdW5pcXVlIHNldFxyXG4gICAgICAgIGd1YXJhbnRlZWRVbmlxdWUgPSB7XHJcbiAgICAgICAgICAgIGNoaWxkcmVuOiB0cnVlLFxyXG4gICAgICAgICAgICBjb250ZW50czogdHJ1ZSxcclxuICAgICAgICAgICAgbmV4dDogdHJ1ZSxcclxuICAgICAgICAgICAgcHJldjogdHJ1ZVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XHJcbiAgICAgICAgZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgICAgICAgICBpLCBsO1xyXG5cclxuICAgICAgICAgICAgaWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5KCBzZWxlY3RvciApLmZpbHRlcihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gMCwgbCA9IHNlbGYubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcmV0ID0gdGhpcy5wdXNoU3RhY2soIFwiXCIsIFwiZmluZFwiLCBzZWxlY3RvciApLFxyXG4gICAgICAgICAgICAgICAgbGVuZ3RoLCBuLCByO1xyXG5cclxuICAgICAgICAgICAgZm9yICggaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcclxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHJldC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBqUXVlcnkuZmluZCggc2VsZWN0b3IsIHRoaXNbaV0sIHJldCApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggaSA+IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHJlc3VsdHMgYXJlIHVuaXF1ZVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIG4gPSBsZW5ndGg7IG4gPCByZXQubGVuZ3RoOyBuKysgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIHIgPSAwOyByIDwgbGVuZ3RoOyByKysgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHJldFtyXSA9PT0gcmV0W25dICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5zcGxpY2Uobi0tLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQgKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gdGFyZ2V0cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBqUXVlcnkuY29udGFpbnMoIHRoaXMsIHRhcmdldHNbaV0gKSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3codGhpcywgc2VsZWN0b3IsIGZhbHNlKSwgXCJub3RcIiwgc2VsZWN0b3IpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGZpbHRlcjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyh0aGlzLCBzZWxlY3RvciwgdHJ1ZSksIFwiZmlsdGVyXCIsIHNlbGVjdG9yICk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgaXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcclxuICAgICAgICAgICAgcmV0dXJuICEhc2VsZWN0b3IgJiYgKFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBQT1MudGVzdCggc2VsZWN0b3IgKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeSggc2VsZWN0b3IsIHRoaXMuY29udGV4dCApLmluZGV4KCB0aGlzWzBdICkgPj0gMCA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCB0aGlzICkubGVuZ3RoID4gMCA6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXIoIHNlbGVjdG9yICkubGVuZ3RoID4gMCApO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XHJcbiAgICAgICAgICAgIHZhciByZXQgPSBbXSwgaSwgbCwgY3VyID0gdGhpc1swXTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFycmF5IChkZXByZWNhdGVkIGFzIG9mIGpRdWVyeSAxLjcpXHJcbiAgICAgICAgICAgIGlmICggalF1ZXJ5LmlzQXJyYXkoIHNlbGVjdG9ycyApICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxldmVsID0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoIGN1ciAmJiBjdXIub3duZXJEb2N1bWVudCAmJiBjdXIgIT09IGNvbnRleHQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBzZWxlY3RvcnMubGVuZ3RoOyBpKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGpRdWVyeSggY3VyICkuaXMoIHNlbGVjdG9yc1sgaSBdICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaCh7IHNlbGVjdG9yOiBzZWxlY3RvcnNbIGkgXSwgZWxlbTogY3VyLCBsZXZlbDogbGV2ZWwgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5wYXJlbnROb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldmVsKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU3RyaW5nXHJcbiAgICAgICAgICAgIHZhciBwb3MgPSBQT1MudGVzdCggc2VsZWN0b3JzICkgfHwgdHlwZW9mIHNlbGVjdG9ycyAhPT0gXCJzdHJpbmdcIiA/XHJcbiAgICAgICAgICAgICAgICBqUXVlcnkoIHNlbGVjdG9ycywgY29udGV4dCB8fCB0aGlzLmNvbnRleHQgKSA6XHJcbiAgICAgICAgICAgICAgICAwO1xyXG5cclxuICAgICAgICAgICAgZm9yICggaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcclxuICAgICAgICAgICAgICAgIGN1ciA9IHRoaXNbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKCBjdXIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBwb3MgPyBwb3MuaW5kZXgoY3VyKSA+IC0xIDogalF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKGN1ciwgc2VsZWN0b3JzKSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goIGN1ciApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyID0gY3VyLnBhcmVudE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIWN1ciB8fCAhY3VyLm93bmVyRG9jdW1lbnQgfHwgY3VyID09PSBjb250ZXh0IHx8IGN1ci5ub2RlVHlwZSA9PT0gMTEgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0ID0gcmV0Lmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlKCByZXQgKSA6IHJldDtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0LCBcImNsb3Nlc3RcIiwgc2VsZWN0b3JzICk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHdpdGhpblxyXG4gICAgICAgIC8vIHRoZSBtYXRjaGVkIHNldCBvZiBlbGVtZW50c1xyXG4gICAgICAgIGluZGV4OiBmdW5jdGlvbiggZWxlbSApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIE5vIGFyZ3VtZW50LCByZXR1cm4gaW5kZXggaW4gcGFyZW50XHJcbiAgICAgICAgICAgIGlmICggIWVsZW0gKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKCB0aGlzWzBdICYmIHRoaXNbMF0ucGFyZW50Tm9kZSApID8gdGhpcy5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGluZGV4IGluIHNlbGVjdG9yXHJcbiAgICAgICAgICAgIGlmICggdHlwZW9mIGVsZW0gPT09IFwic3RyaW5nXCIgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LmluQXJyYXkoIHRoaXNbMF0sIGpRdWVyeSggZWxlbSApICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxyXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmluQXJyYXkoXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcclxuICAgICAgICAgICAgICAgIGVsZW0uanF1ZXJ5ID8gZWxlbVswXSA6IGVsZW0sIHRoaXMgKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBhZGQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcclxuICAgICAgICAgICAgdmFyIHNldCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiA/XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIDpcclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciAmJiBzZWxlY3Rvci5ub2RlVHlwZSA/IFsgc2VsZWN0b3IgXSA6IHNlbGVjdG9yICksXHJcbiAgICAgICAgICAgICAgICBhbGwgPSBqUXVlcnkubWVyZ2UoIHRoaXMuZ2V0KCksIHNldCApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKCBpc0Rpc2Nvbm5lY3RlZCggc2V0WzBdICkgfHwgaXNEaXNjb25uZWN0ZWQoIGFsbFswXSApID9cclxuICAgICAgICAgICAgICAgIGFsbCA6XHJcbiAgICAgICAgICAgICAgICBqUXVlcnkudW5pcXVlKCBhbGwgKSApO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGFuZFNlbGY6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQoIHRoaXMucHJldk9iamVjdCApO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuLy8gQSBwYWluZnVsbHkgc2ltcGxlIGNoZWNrIHRvIHNlZSBpZiBhbiBlbGVtZW50IGlzIGRpc2Nvbm5lY3RlZFxyXG4vLyBmcm9tIGEgZG9jdW1lbnQgKHNob3VsZCBiZSBpbXByb3ZlZCwgd2hlcmUgZmVhc2libGUpLlxyXG4gICAgZnVuY3Rpb24gaXNEaXNjb25uZWN0ZWQoIG5vZGUgKSB7XHJcbiAgICAgICAgcmV0dXJuICFub2RlIHx8ICFub2RlLnBhcmVudE5vZGUgfHwgbm9kZS5wYXJlbnROb2RlLm5vZGVUeXBlID09PSAxMTtcclxuICAgIH1cclxuXHJcbiAgICBqUXVlcnkuZWFjaCh7XHJcbiAgICAgICAgcGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcclxuICAgICAgICAgICAgdmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xyXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIgKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xyXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsICk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5udGgoIGVsZW0sIDIsIFwibmV4dFNpYmxpbmdcIiApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkubnRoKCBlbGVtLCAyLCBcInByZXZpb3VzU2libGluZ1wiICk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBuZXh0QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcHJldkFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBuZXh0VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwgKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHByZXZVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xyXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNpYmxpbmdzOiBmdW5jdGlvbiggZWxlbSApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5zaWJsaW5nKCBlbGVtLnBhcmVudE5vZGUuZmlyc3RDaGlsZCwgZWxlbSApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xyXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LnNpYmxpbmcoIGVsZW0uZmlyc3RDaGlsZCApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29udGVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xyXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcImlmcmFtZVwiICkgP1xyXG4gICAgICAgICAgICBlbGVtLmNvbnRlbnREb2N1bWVudCB8fCBlbGVtLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQgOlxyXG4gICAgICAgICAgICAgICAgalF1ZXJ5Lm1ha2VBcnJheSggZWxlbS5jaGlsZE5vZGVzICk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xyXG4gICAgICAgIGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcclxuICAgICAgICAgICAgdmFyIHJldCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCAhcnVudGlsLnRlc3QoIG5hbWUgKSApIHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gdW50aWw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xyXG4gICAgICAgICAgICAgICAgcmV0ID0galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIHJldCApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXQgPSB0aGlzLmxlbmd0aCA+IDEgJiYgIWd1YXJhbnRlZWRVbmlxdWVbIG5hbWUgXSA/IGpRdWVyeS51bmlxdWUoIHJldCApIDogcmV0O1xyXG5cclxuICAgICAgICAgICAgaWYgKCAodGhpcy5sZW5ndGggPiAxIHx8IHJtdWx0aXNlbGVjdG9yLnRlc3QoIHNlbGVjdG9yICkpICYmIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XHJcbiAgICAgICAgICAgICAgICByZXQgPSByZXQucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCwgbmFtZSwgc2xpY2UuY2FsbCggYXJndW1lbnRzICkuam9pbihcIixcIikgKTtcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcblxyXG4gICAgalF1ZXJ5LmV4dGVuZCh7XHJcbiAgICAgICAgZmlsdGVyOiBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcclxuICAgICAgICAgICAgaWYgKCBub3QgKSB7XHJcbiAgICAgICAgICAgICAgICBleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZWxlbXMubGVuZ3RoID09PSAxID9cclxuICAgICAgICAgICAgICAgIGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvcihlbGVtc1swXSwgZXhwcikgPyBbIGVsZW1zWzBdIF0gOiBbXSA6XHJcbiAgICAgICAgICAgICAgICBqUXVlcnkuZmluZC5tYXRjaGVzKGV4cHIsIGVsZW1zKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBkaXI6IGZ1bmN0aW9uKCBlbGVtLCBkaXIsIHVudGlsICkge1xyXG4gICAgICAgICAgICB2YXIgbWF0Y2hlZCA9IFtdLFxyXG4gICAgICAgICAgICAgICAgY3VyID0gZWxlbVsgZGlyIF07XHJcblxyXG4gICAgICAgICAgICB3aGlsZSAoIGN1ciAmJiBjdXIubm9kZVR5cGUgIT09IDkgJiYgKHVudGlsID09PSB1bmRlZmluZWQgfHwgY3VyLm5vZGVUeXBlICE9PSAxIHx8ICFqUXVlcnkoIGN1ciApLmlzKCB1bnRpbCApKSApIHtcclxuICAgICAgICAgICAgICAgIGlmICggY3VyLm5vZGVUeXBlID09PSAxICkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWQucHVzaCggY3VyICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjdXIgPSBjdXJbZGlyXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlZDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBudGg6IGZ1bmN0aW9uKCBjdXIsIHJlc3VsdCwgZGlyLCBlbGVtICkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgfHwgMTtcclxuICAgICAgICAgICAgdmFyIG51bSA9IDA7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCA7IGN1cjsgY3VyID0gY3VyW2Rpcl0gKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIGN1ci5ub2RlVHlwZSA9PT0gMSAmJiArK251bSA9PT0gcmVzdWx0ICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gY3VyO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNpYmxpbmc6IGZ1bmN0aW9uKCBuLCBlbGVtICkge1xyXG4gICAgICAgICAgICB2YXIgciA9IFtdO1xyXG5cclxuICAgICAgICAgICAgZm9yICggOyBuOyBuID0gbi5uZXh0U2libGluZyApIHtcclxuICAgICAgICAgICAgICAgIGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHIucHVzaCggbiApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcjtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XHJcbiAgICBmdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIGtlZXAgKSB7XHJcblxyXG4gICAgICAgIC8vIENhbid0IHBhc3MgbnVsbCBvciB1bmRlZmluZWQgdG8gaW5kZXhPZiBpbiBGaXJlZm94IDRcclxuICAgICAgICAvLyBTZXQgdG8gMCB0byBza2lwIHN0cmluZyBjaGVja1xyXG4gICAgICAgIHF1YWxpZmllciA9IHF1YWxpZmllciB8fCAwO1xyXG5cclxuICAgICAgICBpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5ncmVwKGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXRWYWwgPSAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0VmFsID09PSBrZWVwO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICggcXVhbGlmaWVyLm5vZGVUeXBlICkge1xyXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmdyZXAoZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICggZWxlbSA9PT0gcXVhbGlmaWVyICkgPT09IGtlZXA7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCB0eXBlb2YgcXVhbGlmaWVyID09PSBcInN0cmluZ1wiICkge1xyXG4gICAgICAgICAgICB2YXIgZmlsdGVyZWQgPSBqUXVlcnkuZ3JlcChlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGlzU2ltcGxlLnRlc3QoIHF1YWxpZmllciApICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5maWx0ZXIocXVhbGlmaWVyLCBmaWx0ZXJlZCwgIWtlZXApO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcXVhbGlmaWVyID0galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBmaWx0ZXJlZCApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4galF1ZXJ5LmdyZXAoZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xyXG4gICAgICAgICAgICByZXR1cm4gKCBqUXVlcnkuaW5BcnJheSggZWxlbSwgcXVhbGlmaWVyICkgPj0gMCApID09PSBrZWVwO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVNhZmVGcmFnbWVudCggZG9jdW1lbnQgKSB7XHJcbiAgICAgICAgdmFyIGxpc3QgPSBub2RlTmFtZXMuc3BsaXQoIFwifFwiICksXHJcbiAgICAgICAgICAgIHNhZmVGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xyXG5cclxuICAgICAgICBpZiAoIHNhZmVGcmFnLmNyZWF0ZUVsZW1lbnQgKSB7XHJcbiAgICAgICAgICAgIHdoaWxlICggbGlzdC5sZW5ndGggKSB7XHJcbiAgICAgICAgICAgICAgICBzYWZlRnJhZy5jcmVhdGVFbGVtZW50KFxyXG4gICAgICAgICAgICAgICAgICAgIGxpc3QucG9wKClcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNhZmVGcmFnO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBub2RlTmFtZXMgPSBcImFiYnJ8YXJ0aWNsZXxhc2lkZXxhdWRpb3xjYW52YXN8ZGF0YWxpc3R8ZGV0YWlsc3xmaWdjYXB0aW9ufGZpZ3VyZXxmb290ZXJ8XCIgK1xyXG4gICAgICAgICAgICBcImhlYWRlcnxoZ3JvdXB8bWFya3xtZXRlcnxuYXZ8b3V0cHV0fHByb2dyZXNzfHNlY3Rpb258c3VtbWFyeXx0aW1lfHZpZGVvXCIsXHJcbiAgICAgICAgcmlubGluZWpRdWVyeSA9IC8galF1ZXJ5XFxkKz1cIig/OlxcZCt8bnVsbClcIi9nLFxyXG4gICAgICAgIHJsZWFkaW5nV2hpdGVzcGFjZSA9IC9eXFxzKy8sXHJcbiAgICAgICAgcnhodG1sVGFnID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW1xcdzpdKylbXj5dKilcXC8+L2lnLFxyXG4gICAgICAgIHJ0YWdOYW1lID0gLzwoW1xcdzpdKykvLFxyXG4gICAgICAgIHJ0Ym9keSA9IC88dGJvZHkvaSxcclxuICAgICAgICByaHRtbCA9IC88fCYjP1xcdys7LyxcclxuICAgICAgICBybm9Jbm5lcmh0bWwgPSAvPCg/OnNjcmlwdHxzdHlsZSkvaSxcclxuICAgICAgICBybm9jYWNoZSA9IC88KD86c2NyaXB0fG9iamVjdHxlbWJlZHxvcHRpb258c3R5bGUpL2ksXHJcbiAgICAgICAgcm5vc2hpbWNhY2hlID0gbmV3IFJlZ0V4cChcIjwoPzpcIiArIG5vZGVOYW1lcyArIFwiKVwiLCBcImlcIiksXHJcbiAgICAvLyBjaGVja2VkPVwiY2hlY2tlZFwiIG9yIGNoZWNrZWRcclxuICAgICAgICByY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXHJcbiAgICAgICAgcnNjcmlwdFR5cGUgPSAvXFwvKGphdmF8ZWNtYSlzY3JpcHQvaSxcclxuICAgICAgICByY2xlYW5TY3JpcHQgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfFxcLVxcLSkvLFxyXG4gICAgICAgIHdyYXBNYXAgPSB7XHJcbiAgICAgICAgICAgIG9wdGlvbjogWyAxLCBcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIiwgXCI8L3NlbGVjdD5cIiBdLFxyXG4gICAgICAgICAgICBsZWdlbmQ6IFsgMSwgXCI8ZmllbGRzZXQ+XCIsIFwiPC9maWVsZHNldD5cIiBdLFxyXG4gICAgICAgICAgICB0aGVhZDogWyAxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiIF0sXHJcbiAgICAgICAgICAgIHRyOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCIgXSxcclxuICAgICAgICAgICAgdGQ6IFsgMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIiBdLFxyXG4gICAgICAgICAgICBjb2w6IFsgMiwgXCI8dGFibGU+PHRib2R5PjwvdGJvZHk+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxyXG4gICAgICAgICAgICBhcmVhOiBbIDEsIFwiPG1hcD5cIiwgXCI8L21hcD5cIiBdLFxyXG4gICAgICAgICAgICBfZGVmYXVsdDogWyAwLCBcIlwiLCBcIlwiIF1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNhZmVGcmFnbWVudCA9IGNyZWF0ZVNhZmVGcmFnbWVudCggZG9jdW1lbnQgKTtcclxuXHJcbiAgICB3cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XHJcbiAgICB3cmFwTWFwLnRib2R5ID0gd3JhcE1hcC50Zm9vdCA9IHdyYXBNYXAuY29sZ3JvdXAgPSB3cmFwTWFwLmNhcHRpb24gPSB3cmFwTWFwLnRoZWFkO1xyXG4gICAgd3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XHJcblxyXG4vLyBJRSBjYW4ndCBzZXJpYWxpemUgPGxpbms+IGFuZCA8c2NyaXB0PiB0YWdzIG5vcm1hbGx5XHJcbiAgICBpZiAoICFqUXVlcnkuc3VwcG9ydC5odG1sU2VyaWFsaXplICkge1xyXG4gICAgICAgIHdyYXBNYXAuX2RlZmF1bHQgPSBbIDEsIFwiZGl2PGRpdj5cIiwgXCI8L2Rpdj5cIiBdO1xyXG4gICAgfVxyXG5cclxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xyXG4gICAgICAgIHRleHQ6IGZ1bmN0aW9uKCB0ZXh0ICkge1xyXG4gICAgICAgICAgICBpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKHRleHQpICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi50ZXh0KCB0ZXh0LmNhbGwodGhpcywgaSwgc2VsZi50ZXh0KCkpICk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCB0eXBlb2YgdGV4dCAhPT0gXCJvYmplY3RcIiAmJiB0ZXh0ICE9PSB1bmRlZmluZWQgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbXB0eSgpLmFwcGVuZCggKHRoaXNbMF0gJiYgdGhpc1swXS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50KS5jcmVhdGVUZXh0Tm9kZSggdGV4dCApICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkudGV4dCggdGhpcyApO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHdyYXBBbGw6IGZ1bmN0aW9uKCBodG1sICkge1xyXG4gICAgICAgICAgICBpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkodGhpcykud3JhcEFsbCggaHRtbC5jYWxsKHRoaXMsIGkpICk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCB0aGlzWzBdICkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcclxuICAgICAgICAgICAgICAgIHZhciB3cmFwID0galF1ZXJ5KCBodG1sLCB0aGlzWzBdLm93bmVyRG9jdW1lbnQgKS5lcSgwKS5jbG9uZSh0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHRoaXNbMF0ucGFyZW50Tm9kZSApIHtcclxuICAgICAgICAgICAgICAgICAgICB3cmFwLmluc2VydEJlZm9yZSggdGhpc1swXSApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHdyYXAubWFwKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCBlbGVtLmZpcnN0Q2hpbGQgJiYgZWxlbS5maXJzdENoaWxkLm5vZGVUeXBlID09PSAxICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gZWxlbS5maXJzdENoaWxkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW07XHJcbiAgICAgICAgICAgICAgICB9KS5hcHBlbmQoIHRoaXMgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgd3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcclxuICAgICAgICAgICAgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KHRoaXMpLndyYXBJbm5lciggaHRtbC5jYWxsKHRoaXMsIGkpICk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBjb250ZW50cy5sZW5ndGggKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudHMud3JhcEFsbCggaHRtbCApO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hcHBlbmQoIGh0bWwgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgd3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7XHJcbiAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaSkge1xyXG4gICAgICAgICAgICAgICAgalF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaXNGdW5jdGlvbiA/IGh0bWwuY2FsbCh0aGlzLCBpKSA6IGh0bWwgKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdW53cmFwOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50KCkuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGlmICggIWpRdWVyeS5ub2RlTmFtZSggdGhpcywgXCJib2R5XCIgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pLmVuZCgpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGFwcGVuZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvbU1hbmlwKGFyZ3VtZW50cywgdHJ1ZSwgZnVuY3Rpb24oIGVsZW0gKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZCggZWxlbSApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBwcmVwZW5kOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9tTWFuaXAoYXJndW1lbnRzLCB0cnVlLCBmdW5jdGlvbiggZWxlbSApIHtcclxuICAgICAgICAgICAgICAgIGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcy5maXJzdENoaWxkICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJlZm9yZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICggdGhpc1swXSAmJiB0aGlzWzBdLnBhcmVudE5vZGUgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kb21NYW5pcChhcmd1bWVudHMsIGZhbHNlLCBmdW5jdGlvbiggZWxlbSApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzICk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcclxuICAgICAgICAgICAgICAgIHZhciBzZXQgPSBqUXVlcnkuY2xlYW4oIGFyZ3VtZW50cyApO1xyXG4gICAgICAgICAgICAgICAgc2V0LnB1c2guYXBwbHkoIHNldCwgdGhpcy50b0FycmF5KCkgKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayggc2V0LCBcImJlZm9yZVwiLCBhcmd1bWVudHMgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGFmdGVyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKCB0aGlzWzBdICYmIHRoaXNbMF0ucGFyZW50Tm9kZSApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRvbU1hbmlwKGFyZ3VtZW50cywgZmFsc2UsIGZ1bmN0aW9uKCBlbGVtICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNldCA9IHRoaXMucHVzaFN0YWNrKCB0aGlzLCBcImFmdGVyXCIsIGFyZ3VtZW50cyApO1xyXG4gICAgICAgICAgICAgICAgc2V0LnB1c2guYXBwbHkoIHNldCwgalF1ZXJ5LmNsZWFuKGFyZ3VtZW50cykgKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBrZWVwRGF0YSBpcyBmb3IgaW50ZXJuYWwgdXNlIG9ubHktLWRvIG5vdCBkb2N1bWVudFxyXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCBrZWVwRGF0YSApIHtcclxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBlbGVtOyAoZWxlbSA9IHRoaXNbaV0pICE9IG51bGw7IGkrKyApIHtcclxuICAgICAgICAgICAgICAgIGlmICggIXNlbGVjdG9yIHx8IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBbIGVsZW0gXSApLmxlbmd0aCApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoICFrZWVwRGF0YSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuY2xlYW5EYXRhKCBlbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuY2xlYW5EYXRhKCBbIGVsZW0gXSApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZWxlbSApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZW1wdHk6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGVsZW07IChlbGVtID0gdGhpc1tpXSkgIT0gbnVsbDsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXHJcbiAgICAgICAgICAgICAgICBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmNsZWFuRGF0YSggZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKCBlbGVtLmZpcnN0Q2hpbGQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5yZW1vdmVDaGlsZCggZWxlbS5maXJzdENoaWxkICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XHJcbiAgICAgICAgICAgIGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XHJcbiAgICAgICAgICAgIGRlZXBEYXRhQW5kRXZlbnRzID0gZGVlcERhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGRhdGFBbmRFdmVudHMgOiBkZWVwRGF0YUFuZEV2ZW50cztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5jbG9uZSggdGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgaHRtbDogZnVuY3Rpb24oIHZhbHVlICkge1xyXG4gICAgICAgICAgICBpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1swXSAmJiB0aGlzWzBdLm5vZGVUeXBlID09PSAxID9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzWzBdLmlubmVySFRNTC5yZXBsYWNlKHJpbmxpbmVqUXVlcnksIFwiXCIpIDpcclxuICAgICAgICAgICAgICAgICAgICBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNlZSBpZiB3ZSBjYW4gdGFrZSBhIHNob3J0Y3V0IGFuZCBqdXN0IHVzZSBpbm5lckhUTUxcclxuICAgICAgICAgICAgfSBlbHNlIGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9Jbm5lcmh0bWwudGVzdCggdmFsdWUgKSAmJlxyXG4gICAgICAgICAgICAgICAgKGpRdWVyeS5zdXBwb3J0LmxlYWRpbmdXaGl0ZXNwYWNlIHx8ICFybGVhZGluZ1doaXRlc3BhY2UudGVzdCggdmFsdWUgKSkgJiZcclxuICAgICAgICAgICAgICAgICF3cmFwTWFwWyAocnRhZ05hbWUuZXhlYyggdmFsdWUgKSB8fCBbXCJcIiwgXCJcIl0pWzFdLnRvTG93ZXJDYXNlKCkgXSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocnhodG1sVGFnLCBcIjwkMT48LyQyPlwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGlzW2ldLm5vZGVUeXBlID09PSAxICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmNsZWFuRGF0YSggdGhpc1tpXS5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbaV0uaW5uZXJIVE1MID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxyXG4gICAgICAgICAgICAgICAgfSBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGkpe1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaHRtbCggdmFsdWUuY2FsbCh0aGlzLCBpLCBzZWxmLmh0bWwoKSkgKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1wdHkoKS5hcHBlbmQoIHZhbHVlICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJlcGxhY2VXaXRoOiBmdW5jdGlvbiggdmFsdWUgKSB7XHJcbiAgICAgICAgICAgIGlmICggdGhpc1swXSAmJiB0aGlzWzBdLnBhcmVudE5vZGUgKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgZWxlbWVudHMgYXJlIHJlbW92ZWQgZnJvbSB0aGUgRE9NIGJlZm9yZSB0aGV5IGFyZSBpbnNlcnRlZFxyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjYW4gaGVscCBmaXggcmVwbGFjaW5nIGEgcGFyZW50IHdpdGggY2hpbGQgZWxlbWVudHNcclxuICAgICAgICAgICAgICAgIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxmID0galF1ZXJ5KHRoaXMpLCBvbGQgPSBzZWxmLmh0bWwoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZXBsYWNlV2l0aCggdmFsdWUuY2FsbCggdGhpcywgaSwgb2xkICkgKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIiApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGpRdWVyeSggdmFsdWUgKS5kZXRhY2goKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5uZXh0U2libGluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkoIHRoaXMgKS5yZW1vdmUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBuZXh0ICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkobmV4dCkuYmVmb3JlKCB2YWx1ZSApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeShwYXJlbnQpLmFwcGVuZCggdmFsdWUgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA/XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoU3RhY2soIGpRdWVyeShqUXVlcnkuaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZSgpIDogdmFsdWUpLCBcInJlcGxhY2VXaXRoXCIsIHZhbHVlICkgOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBkZXRhY2g6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlKCBzZWxlY3RvciwgdHJ1ZSApO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGRvbU1hbmlwOiBmdW5jdGlvbiggYXJncywgdGFibGUsIGNhbGxiYWNrICkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0cywgZmlyc3QsIGZyYWdtZW50LCBwYXJlbnQsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGFyZ3NbMF0sXHJcbiAgICAgICAgICAgICAgICBzY3JpcHRzID0gW107XHJcblxyXG4gICAgICAgICAgICAvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcclxuICAgICAgICAgICAgaWYgKCAhalF1ZXJ5LnN1cHBvcnQuY2hlY2tDbG9uZSAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAzICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiByY2hlY2tlZC50ZXN0KCB2YWx1ZSApICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkodGhpcykuZG9tTWFuaXAoIGFyZ3MsIHRhYmxlLCBjYWxsYmFjaywgdHJ1ZSApO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24odmFsdWUpICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGYgPSBqUXVlcnkodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJnc1swXSA9IHZhbHVlLmNhbGwodGhpcywgaSwgdGFibGUgPyBzZWxmLmh0bWwoKSA6IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kb21NYW5pcCggYXJncywgdGFibGUsIGNhbGxiYWNrICk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCB0aGlzWzBdICkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gdmFsdWUgJiYgdmFsdWUucGFyZW50Tm9kZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBpbiBhIGZyYWdtZW50LCBqdXN0IHVzZSB0aGF0IGluc3RlYWQgb2YgYnVpbGRpbmcgYSBuZXcgb25lXHJcbiAgICAgICAgICAgICAgICBpZiAoIGpRdWVyeS5zdXBwb3J0LnBhcmVudE5vZGUgJiYgcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSA9PT0gMTEgJiYgcGFyZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSB0aGlzLmxlbmd0aCApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0geyBmcmFnbWVudDogcGFyZW50IH07XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0galF1ZXJ5LmJ1aWxkRnJhZ21lbnQoIGFyZ3MsIHRoaXMsIHNjcmlwdHMgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmcmFnbWVudCA9IHJlc3VsdHMuZnJhZ21lbnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcclxuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZyYWdtZW50ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICggZmlyc3QgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFibGUgPSB0YWJsZSAmJiBqUXVlcnkubm9kZU5hbWUoIGZpcnN0LCBcInRyXCIgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGgsIGxhc3RJbmRleCA9IGwgLSAxOyBpIDwgbDsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFibGUgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QodGhpc1tpXSwgZmlyc3QpIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2ldLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgd2UgZG8gbm90IGxlYWsgbWVtb3J5IGJ5IGluYWR2ZXJ0ZW50bHkgZGlzY2FyZGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG9yaWdpbmFsIGZyYWdtZW50ICh3aGljaCBtaWdodCBoYXZlIGF0dGFjaGVkIGRhdGEpIGluc3RlYWQgb2ZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzaW5nIGl0OyBpbiBhZGRpdGlvbiwgdXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBvYmplY3QgZm9yIHRoZSBsYXN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdGVtIGluc3RlYWQgb2YgZmlyc3QgYmVjYXVzZSBpdCBjYW4gZW5kIHVwIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIGNlcnRhaW4gc2l0dWF0aW9ucyAoQnVnICM4MDcwKS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZyYWdtZW50cyBmcm9tIHRoZSBmcmFnbWVudCBjYWNoZSBtdXN0IGFsd2F5cyBiZSBjbG9uZWQgYW5kIG5ldmVyIHVzZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIHBsYWNlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5jYWNoZWFibGUgfHwgKCBsID4gMSAmJiBpIDwgbGFzdEluZGV4ICkgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5jbG9uZSggZnJhZ21lbnQsIHRydWUsIHRydWUgKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBzY3JpcHRzLmxlbmd0aCApIHtcclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZWFjaCggc2NyaXB0cywgZXZhbFNjcmlwdCApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBmdW5jdGlvbiByb290KCBlbGVtLCBjdXIgKSB7XHJcbiAgICAgICAgcmV0dXJuIGpRdWVyeS5ub2RlTmFtZShlbGVtLCBcInRhYmxlXCIpID9cclxuICAgICAgICAgICAgKGVsZW0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0Ym9keVwiKVswXSB8fFxyXG4gICAgICAgICAgICBlbGVtLmFwcGVuZENoaWxkKGVsZW0ub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGJvZHlcIikpKSA6XHJcbiAgICAgICAgICAgIGVsZW07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcclxuXHJcbiAgICAgICAgaWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxIHx8ICFqUXVlcnkuaGFzRGF0YSggc3JjICkgKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB0eXBlLCBpLCBsLFxyXG4gICAgICAgICAgICBvbGREYXRhID0galF1ZXJ5Ll9kYXRhKCBzcmMgKSxcclxuICAgICAgICAgICAgY3VyRGF0YSA9IGpRdWVyeS5fZGF0YSggZGVzdCwgb2xkRGF0YSApLFxyXG4gICAgICAgICAgICBldmVudHMgPSBvbGREYXRhLmV2ZW50cztcclxuXHJcbiAgICAgICAgaWYgKCBldmVudHMgKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBjdXJEYXRhLmhhbmRsZTtcclxuICAgICAgICAgICAgY3VyRGF0YS5ldmVudHMgPSB7fTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xyXG4gICAgICAgICAgICAgICAgZm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSArICggZXZlbnRzWyB0eXBlIF1bIGkgXS5uYW1lc3BhY2UgPyBcIi5cIiA6IFwiXCIgKSArIGV2ZW50c1sgdHlwZSBdWyBpIF0ubmFtZXNwYWNlLCBldmVudHNbIHR5cGUgXVsgaSBdLCBldmVudHNbIHR5cGUgXVsgaSBdLmRhdGEgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gbWFrZSB0aGUgY2xvbmVkIHB1YmxpYyBkYXRhIG9iamVjdCBhIGNvcHkgZnJvbSB0aGUgb3JpZ2luYWxcclxuICAgICAgICBpZiAoIGN1ckRhdGEuZGF0YSApIHtcclxuICAgICAgICAgICAgY3VyRGF0YS5kYXRhID0galF1ZXJ5LmV4dGVuZCgge30sIGN1ckRhdGEuZGF0YSApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjbG9uZUZpeEF0dHJpYnV0ZXMoIHNyYywgZGVzdCApIHtcclxuICAgICAgICB2YXIgbm9kZU5hbWU7XHJcblxyXG4gICAgICAgIC8vIFdlIGRvIG5vdCBuZWVkIHRvIGRvIGFueXRoaW5nIGZvciBub24tRWxlbWVudHNcclxuICAgICAgICBpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNsZWFyQXR0cmlidXRlcyByZW1vdmVzIHRoZSBhdHRyaWJ1dGVzLCB3aGljaCB3ZSBkb24ndCB3YW50LFxyXG4gICAgICAgIC8vIGJ1dCBhbHNvIHJlbW92ZXMgdGhlIGF0dGFjaEV2ZW50IGV2ZW50cywgd2hpY2ggd2UgKmRvKiB3YW50XHJcbiAgICAgICAgaWYgKCBkZXN0LmNsZWFyQXR0cmlidXRlcyApIHtcclxuICAgICAgICAgICAgZGVzdC5jbGVhckF0dHJpYnV0ZXMoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIG1lcmdlQXR0cmlidXRlcywgaW4gY29udHJhc3QsIG9ubHkgbWVyZ2VzIGJhY2sgb24gdGhlXHJcbiAgICAgICAgLy8gb3JpZ2luYWwgYXR0cmlidXRlcywgbm90IHRoZSBldmVudHNcclxuICAgICAgICBpZiAoIGRlc3QubWVyZ2VBdHRyaWJ1dGVzICkge1xyXG4gICAgICAgICAgICBkZXN0Lm1lcmdlQXR0cmlidXRlcyggc3JjICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgICAgICAgLy8gSUU2LTggZmFpbCB0byBjbG9uZSBjaGlsZHJlbiBpbnNpZGUgb2JqZWN0IGVsZW1lbnRzIHRoYXQgdXNlXHJcbiAgICAgICAgLy8gdGhlIHByb3ByaWV0YXJ5IGNsYXNzaWQgYXR0cmlidXRlIHZhbHVlIChyYXRoZXIgdGhhbiB0aGUgdHlwZVxyXG4gICAgICAgIC8vIGF0dHJpYnV0ZSkgdG8gaWRlbnRpZnkgdGhlIHR5cGUgb2YgY29udGVudCB0byBkaXNwbGF5XHJcbiAgICAgICAgaWYgKCBub2RlTmFtZSA9PT0gXCJvYmplY3RcIiApIHtcclxuICAgICAgICAgICAgZGVzdC5vdXRlckhUTUwgPSBzcmMub3V0ZXJIVE1MO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIChzcmMudHlwZSA9PT0gXCJjaGVja2JveFwiIHx8IHNyYy50eXBlID09PSBcInJhZGlvXCIpICkge1xyXG4gICAgICAgICAgICAvLyBJRTYtOCBmYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94XHJcbiAgICAgICAgICAgIC8vIG9yIHJhZGlvIGJ1dHRvbi4gV29yc2UsIElFNi03IGZhaWwgdG8gZ2l2ZSB0aGUgY2xvbmVkIGVsZW1lbnRcclxuICAgICAgICAgICAgLy8gYSBjaGVja2VkIGFwcGVhcmFuY2UgaWYgdGhlIGRlZmF1bHRDaGVja2VkIHZhbHVlIGlzbid0IGFsc28gc2V0XHJcbiAgICAgICAgICAgIGlmICggc3JjLmNoZWNrZWQgKSB7XHJcbiAgICAgICAgICAgICAgICBkZXN0LmRlZmF1bHRDaGVja2VkID0gZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElFNi03IGdldCBjb25mdXNlZCBhbmQgZW5kIHVwIHNldHRpbmcgdGhlIHZhbHVlIG9mIGEgY2xvbmVkXHJcbiAgICAgICAgICAgIC8vIGNoZWNrYm94L3JhZGlvIGJ1dHRvbiB0byBhbiBlbXB0eSBzdHJpbmcgaW5zdGVhZCBvZiBcIm9uXCJcclxuICAgICAgICAgICAgaWYgKCBkZXN0LnZhbHVlICE9PSBzcmMudmFsdWUgKSB7XHJcbiAgICAgICAgICAgICAgICBkZXN0LnZhbHVlID0gc3JjLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJRTYtOCBmYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZFxyXG4gICAgICAgICAgICAvLyBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcIm9wdGlvblwiICkge1xyXG4gICAgICAgICAgICBkZXN0LnNlbGVjdGVkID0gc3JjLmRlZmF1bHRTZWxlY3RlZDtcclxuXHJcbiAgICAgICAgICAgIC8vIElFNi04IGZhaWxzIHRvIHNldCB0aGUgZGVmYXVsdFZhbHVlIHRvIHRoZSBjb3JyZWN0IHZhbHVlIHdoZW5cclxuICAgICAgICAgICAgLy8gY2xvbmluZyBvdGhlciB0eXBlcyBvZiBpbnB1dCBmaWVsZHNcclxuICAgICAgICB9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIgKSB7XHJcbiAgICAgICAgICAgIGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEV2ZW50IGRhdGEgZ2V0cyByZWZlcmVuY2VkIGluc3RlYWQgb2YgY29waWVkIGlmIHRoZSBleHBhbmRvXHJcbiAgICAgICAgLy8gZ2V0cyBjb3BpZWQgdG9vXHJcbiAgICAgICAgZGVzdC5yZW1vdmVBdHRyaWJ1dGUoIGpRdWVyeS5leHBhbmRvICk7XHJcbiAgICB9XHJcblxyXG4gICAgalF1ZXJ5LmJ1aWxkRnJhZ21lbnQgPSBmdW5jdGlvbiggYXJncywgbm9kZXMsIHNjcmlwdHMgKSB7XHJcbiAgICAgICAgdmFyIGZyYWdtZW50LCBjYWNoZWFibGUsIGNhY2hlcmVzdWx0cywgZG9jLFxyXG4gICAgICAgICAgICBmaXJzdCA9IGFyZ3NbIDAgXTtcclxuXHJcbiAgICAgICAgLy8gbm9kZXMgbWF5IGNvbnRhaW4gZWl0aGVyIGFuIGV4cGxpY2l0IGRvY3VtZW50IG9iamVjdCxcclxuICAgICAgICAvLyBhIGpRdWVyeSBjb2xsZWN0aW9uIG9yIGNvbnRleHQgb2JqZWN0LlxyXG4gICAgICAgIC8vIElmIG5vZGVzWzBdIGNvbnRhaW5zIGEgdmFsaWQgb2JqZWN0IHRvIGFzc2lnbiB0byBkb2NcclxuICAgICAgICBpZiAoIG5vZGVzICYmIG5vZGVzWzBdICkge1xyXG4gICAgICAgICAgICBkb2MgPSBub2Rlc1swXS5vd25lckRvY3VtZW50IHx8IG5vZGVzWzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgYW4gYXR0ciBvYmplY3QgZG9lc24ndCBpbmNvcnJlY3RseSBzdGFuZCBpbiBhcyBhIGRvY3VtZW50IG9iamVjdFxyXG4gICAgICAgIC8vIENocm9tZSBhbmQgRmlyZWZveCBzZWVtIHRvIGFsbG93IHRoaXMgdG8gb2NjdXIgYW5kIHdpbGwgdGhyb3cgZXhjZXB0aW9uXHJcbiAgICAgICAgLy8gRml4ZXMgIzg5NTBcclxuICAgICAgICBpZiAoICFkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCApIHtcclxuICAgICAgICAgICAgZG9jID0gZG9jdW1lbnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBPbmx5IGNhY2hlIFwic21hbGxcIiAoMS8yIEtCKSBIVE1MIHN0cmluZ3MgdGhhdCBhcmUgYXNzb2NpYXRlZCB3aXRoIHRoZSBtYWluIGRvY3VtZW50XHJcbiAgICAgICAgLy8gQ2xvbmluZyBvcHRpb25zIGxvc2VzIHRoZSBzZWxlY3RlZCBzdGF0ZSwgc28gZG9uJ3QgY2FjaGUgdGhlbVxyXG4gICAgICAgIC8vIElFIDYgZG9lc24ndCBsaWtlIGl0IHdoZW4geW91IHB1dCA8b2JqZWN0PiBvciA8ZW1iZWQ+IGVsZW1lbnRzIGluIGEgZnJhZ21lbnRcclxuICAgICAgICAvLyBBbHNvLCBXZWJLaXQgZG9lcyBub3QgY2xvbmUgJ2NoZWNrZWQnIGF0dHJpYnV0ZXMgb24gY2xvbmVOb2RlLCBzbyBkb24ndCBjYWNoZVxyXG4gICAgICAgIC8vIExhc3RseSwgSUU2LDcsOCB3aWxsIG5vdCBjb3JyZWN0bHkgcmV1c2UgY2FjaGVkIGZyYWdtZW50cyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIHVua25vd24gZWxlbXMgIzEwNTAxXHJcbiAgICAgICAgaWYgKCBhcmdzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgZmlyc3QgPT09IFwic3RyaW5nXCIgJiYgZmlyc3QubGVuZ3RoIDwgNTEyICYmIGRvYyA9PT0gZG9jdW1lbnQgJiZcclxuICAgICAgICAgICAgZmlyc3QuY2hhckF0KDApID09PSBcIjxcIiAmJiAhcm5vY2FjaGUudGVzdCggZmlyc3QgKSAmJlxyXG4gICAgICAgICAgICAoalF1ZXJ5LnN1cHBvcnQuY2hlY2tDbG9uZSB8fCAhcmNoZWNrZWQudGVzdCggZmlyc3QgKSkgJiZcclxuICAgICAgICAgICAgKGpRdWVyeS5zdXBwb3J0Lmh0bWw1Q2xvbmUgfHwgIXJub3NoaW1jYWNoZS50ZXN0KCBmaXJzdCApKSApIHtcclxuXHJcbiAgICAgICAgICAgIGNhY2hlYWJsZSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICBjYWNoZXJlc3VsdHMgPSBqUXVlcnkuZnJhZ21lbnRzWyBmaXJzdCBdO1xyXG4gICAgICAgICAgICBpZiAoIGNhY2hlcmVzdWx0cyAmJiBjYWNoZXJlc3VsdHMgIT09IDEgKSB7XHJcbiAgICAgICAgICAgICAgICBmcmFnbWVudCA9IGNhY2hlcmVzdWx0cztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCAhZnJhZ21lbnQgKSB7XHJcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcclxuICAgICAgICAgICAgalF1ZXJ5LmNsZWFuKCBhcmdzLCBkb2MsIGZyYWdtZW50LCBzY3JpcHRzICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIGNhY2hlYWJsZSApIHtcclxuICAgICAgICAgICAgalF1ZXJ5LmZyYWdtZW50c1sgZmlyc3QgXSA9IGNhY2hlcmVzdWx0cyA/IGZyYWdtZW50IDogMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7IGZyYWdtZW50OiBmcmFnbWVudCwgY2FjaGVhYmxlOiBjYWNoZWFibGUgfTtcclxuICAgIH07XHJcblxyXG4gICAgalF1ZXJ5LmZyYWdtZW50cyA9IHt9O1xyXG5cclxuICAgIGpRdWVyeS5lYWNoKHtcclxuICAgICAgICBhcHBlbmRUbzogXCJhcHBlbmRcIixcclxuICAgICAgICBwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxyXG4gICAgICAgIGluc2VydEJlZm9yZTogXCJiZWZvcmVcIixcclxuICAgICAgICBpbnNlcnRBZnRlcjogXCJhZnRlclwiLFxyXG4gICAgICAgIHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxyXG4gICAgfSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xyXG4gICAgICAgIGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xyXG4gICAgICAgICAgICB2YXIgcmV0ID0gW10sXHJcbiAgICAgICAgICAgICAgICBpbnNlcnQgPSBqUXVlcnkoIHNlbGVjdG9yICksXHJcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSB0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzWzBdLnBhcmVudE5vZGU7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgPT09IDExICYmIHBhcmVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSAmJiBpbnNlcnQubGVuZ3RoID09PSAxICkge1xyXG4gICAgICAgICAgICAgICAgaW5zZXJ0WyBvcmlnaW5hbCBdKCB0aGlzWzBdICk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbnNlcnQubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtcyA9ICggaSA+IDAgPyB0aGlzLmNsb25lKHRydWUpIDogdGhpcyApLmdldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSggaW5zZXJ0W2ldIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdCggZWxlbXMgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCwgbmFtZSwgaW5zZXJ0LnNlbGVjdG9yICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0QWxsKCBlbGVtICkge1xyXG4gICAgICAgIGlmICggdHlwZW9mIGVsZW0uZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcIipcIiApO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCB0eXBlb2YgZWxlbS5xdWVyeVNlbGVjdG9yQWxsICE9PSBcInVuZGVmaW5lZFwiICkge1xyXG4gICAgICAgICAgICByZXR1cm4gZWxlbS5xdWVyeVNlbGVjdG9yQWxsKCBcIipcIiApO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuLy8gVXNlZCBpbiBjbGVhbiwgZml4ZXMgdGhlIGRlZmF1bHRDaGVja2VkIHByb3BlcnR5XHJcbiAgICBmdW5jdGlvbiBmaXhEZWZhdWx0Q2hlY2tlZCggZWxlbSApIHtcclxuICAgICAgICBpZiAoIGVsZW0udHlwZSA9PT0gXCJjaGVja2JveFwiIHx8IGVsZW0udHlwZSA9PT0gXCJyYWRpb1wiICkge1xyXG4gICAgICAgICAgICBlbGVtLmRlZmF1bHRDaGVja2VkID0gZWxlbS5jaGVja2VkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuLy8gRmluZHMgYWxsIGlucHV0cyBhbmQgcGFzc2VzIHRoZW0gdG8gZml4RGVmYXVsdENoZWNrZWRcclxuICAgIGZ1bmN0aW9uIGZpbmRJbnB1dHMoIGVsZW0gKSB7XHJcbiAgICAgICAgdmFyIG5vZGVOYW1lID0gKCBlbGVtLm5vZGVOYW1lIHx8IFwiXCIgKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiApIHtcclxuICAgICAgICAgICAgZml4RGVmYXVsdENoZWNrZWQoIGVsZW0gKTtcclxuICAgICAgICAgICAgLy8gU2tpcCBzY3JpcHRzLCBnZXQgb3RoZXIgY2hpbGRyZW5cclxuICAgICAgICB9IGVsc2UgaWYgKCBub2RlTmFtZSAhPT0gXCJzY3JpcHRcIiAmJiB0eXBlb2YgZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcclxuICAgICAgICAgICAgalF1ZXJ5LmdyZXAoIGVsZW0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbnB1dFwiKSwgZml4RGVmYXVsdENoZWNrZWQgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4vLyBEZXJpdmVkIEZyb206IGh0dHA6Ly93d3cuaWVjc3MuY29tL3NoaW1wcm92ZS9qYXZhc2NyaXB0L3NoaW1wcm92ZS4xLTAtMS5qc1xyXG4gICAgZnVuY3Rpb24gc2hpbUNsb25lTm9kZSggZWxlbSApIHtcclxuICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xyXG4gICAgICAgIHNhZmVGcmFnbWVudC5hcHBlbmRDaGlsZCggZGl2ICk7XHJcblxyXG4gICAgICAgIGRpdi5pbm5lckhUTUwgPSBlbGVtLm91dGVySFRNTDtcclxuICAgICAgICByZXR1cm4gZGl2LmZpcnN0Q2hpbGQ7XHJcbiAgICB9XHJcblxyXG4gICAgalF1ZXJ5LmV4dGVuZCh7XHJcbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcclxuICAgICAgICAgICAgdmFyIHNyY0VsZW1lbnRzLFxyXG4gICAgICAgICAgICAgICAgZGVzdEVsZW1lbnRzLFxyXG4gICAgICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgLy8gSUU8PTggZG9lcyBub3QgcHJvcGVybHkgY2xvbmUgZGV0YWNoZWQsIHVua25vd24gZWxlbWVudCBub2Rlc1xyXG4gICAgICAgICAgICAgICAgY2xvbmUgPSBqUXVlcnkuc3VwcG9ydC5odG1sNUNsb25lIHx8ICFybm9zaGltY2FjaGUudGVzdCggXCI8XCIgKyBlbGVtLm5vZGVOYW1lICkgP1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW0uY2xvbmVOb2RlKCB0cnVlICkgOlxyXG4gICAgICAgICAgICAgICAgICAgIHNoaW1DbG9uZU5vZGUoIGVsZW0gKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggKCFqUXVlcnkuc3VwcG9ydC5ub0Nsb25lRXZlbnQgfHwgIWpRdWVyeS5zdXBwb3J0Lm5vQ2xvbmVDaGVja2VkKSAmJlxyXG4gICAgICAgICAgICAgICAgKGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgZWxlbS5ub2RlVHlwZSA9PT0gMTEpICYmICFqUXVlcnkuaXNYTUxEb2MoZWxlbSkgKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJRSBjb3BpZXMgZXZlbnRzIGJvdW5kIHZpYSBhdHRhY2hFdmVudCB3aGVuIHVzaW5nIGNsb25lTm9kZS5cclxuICAgICAgICAgICAgICAgIC8vIENhbGxpbmcgZGV0YWNoRXZlbnQgb24gdGhlIGNsb25lIHdpbGwgYWxzbyByZW1vdmUgdGhlIGV2ZW50c1xyXG4gICAgICAgICAgICAgICAgLy8gZnJvbSB0aGUgb3JpZ2luYWwuIEluIG9yZGVyIHRvIGdldCBhcm91bmQgdGhpcywgd2UgdXNlIHNvbWVcclxuICAgICAgICAgICAgICAgIC8vIHByb3ByaWV0YXJ5IG1ldGhvZHMgdG8gY2xlYXIgdGhlIGV2ZW50cy4gVGhhbmtzIHRvIE1vb1Rvb2xzXHJcbiAgICAgICAgICAgICAgICAvLyBndXlzIGZvciB0aGlzIGhvdG5lc3MuXHJcblxyXG4gICAgICAgICAgICAgICAgY2xvbmVGaXhBdHRyaWJ1dGVzKCBlbGVtLCBjbG9uZSApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVzaW5nIFNpenpsZSBoZXJlIGlzIGNyYXp5IHNsb3csIHNvIHdlIHVzZSBnZXRFbGVtZW50c0J5VGFnTmFtZSBpbnN0ZWFkXHJcbiAgICAgICAgICAgICAgICBzcmNFbGVtZW50cyA9IGdldEFsbCggZWxlbSApO1xyXG4gICAgICAgICAgICAgICAgZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFdlaXJkIGl0ZXJhdGlvbiBiZWNhdXNlIElFIHdpbGwgcmVwbGFjZSB0aGUgbGVuZ3RoIHByb3BlcnR5XHJcbiAgICAgICAgICAgICAgICAvLyB3aXRoIGFuIGVsZW1lbnQgaWYgeW91IGFyZSBjbG9uaW5nIHRoZSBib2R5IGFuZCBvbmUgb2YgdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBlbGVtZW50cyBvbiB0aGUgcGFnZSBoYXMgYSBuYW1lIG9yIGlkIG9mIFwibGVuZ3RoXCJcclxuICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyBzcmNFbGVtZW50c1tpXTsgKytpICkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBkZXN0aW5hdGlvbiBub2RlIGlzIG5vdCBudWxsOyBGaXhlcyAjOTU4N1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggZGVzdEVsZW1lbnRzW2ldICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZUZpeEF0dHJpYnV0ZXMoIHNyY0VsZW1lbnRzW2ldLCBkZXN0RWxlbWVudHNbaV0gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENvcHkgdGhlIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCB0byB0aGUgY2xvbmVcclxuICAgICAgICAgICAgaWYgKCBkYXRhQW5kRXZlbnRzICkge1xyXG4gICAgICAgICAgICAgICAgY2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcclxuICAgICAgICAgICAgICAgICAgICBzcmNFbGVtZW50cyA9IGdldEFsbCggZWxlbSApO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IDA7IHNyY0VsZW1lbnRzW2ldOyArK2kgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lQ29weUV2ZW50KCBzcmNFbGVtZW50c1tpXSwgZGVzdEVsZW1lbnRzW2ldICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzcmNFbGVtZW50cyA9IGRlc3RFbGVtZW50cyA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcclxuICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNsZWFuOiBmdW5jdGlvbiggZWxlbXMsIGNvbnRleHQsIGZyYWdtZW50LCBzY3JpcHRzICkge1xyXG4gICAgICAgICAgICB2YXIgY2hlY2tTY3JpcHRUeXBlO1xyXG5cclxuICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XHJcblxyXG4gICAgICAgICAgICAvLyAhY29udGV4dC5jcmVhdGVFbGVtZW50IGZhaWxzIGluIElFIHdpdGggYW4gZXJyb3IgYnV0IHJldHVybnMgdHlwZW9mICdvYmplY3QnXHJcbiAgICAgICAgICAgIGlmICggdHlwZW9mIGNvbnRleHQuY3JlYXRlRWxlbWVudCA9PT0gXCJ1bmRlZmluZWRcIiApIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dFswXSAmJiBjb250ZXh0WzBdLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciByZXQgPSBbXSwgajtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgZWxlbTsgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJudW1iZXJcIiApIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtICs9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCAhZWxlbSApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IGh0bWwgc3RyaW5nIGludG8gRE9NIG5vZGVzXHJcbiAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSA9IGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoIGVsZW0gKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXggXCJYSFRNTFwiLXN0eWxlIHRhZ3MgaW4gYWxsIGJyb3dzZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0gPSBlbGVtLnJlcGxhY2UocnhodG1sVGFnLCBcIjwkMT48LyQyPlwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyaW0gd2hpdGVzcGFjZSwgb3RoZXJ3aXNlIGluZGV4T2Ygd29uJ3Qgd29yayBhcyBleHBlY3RlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFnID0gKCBydGFnTmFtZS5leGVjKCBlbGVtICkgfHwgW1wiXCIsIFwiXCJdIClbMV0udG9Mb3dlckNhc2UoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGggPSB3cmFwWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGl2ID0gY29udGV4dC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHdyYXBwZXIgZWxlbWVudCB0byB1bmtub3duIGVsZW1lbnQgc2FmZSBkb2MgZnJhZ21lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjb250ZXh0ID09PSBkb2N1bWVudCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgZnJhZ21lbnQgd2UndmUgYWxyZWFkeSBjcmVhdGVkIGZvciB0aGlzIGRvY3VtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYWZlRnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRpdiApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGEgZnJhZ21lbnQgY3JlYXRlZCB3aXRoIHRoZSBvd25lciBkb2N1bWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlU2FmZUZyYWdtZW50KCBjb250ZXh0ICkuYXBwZW5kQ2hpbGQoIGRpdiApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHbyB0byBodG1sIGFuZCBiYWNrLCB0aGVuIHBlZWwgb2ZmIGV4dHJhIHdyYXBwZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSB3cmFwWzFdICsgZWxlbSArIHdyYXBbMl07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRvIHRoZSByaWdodCBkZXB0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGRlcHRoLS0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXYgPSBkaXYubGFzdENoaWxkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgSUUncyBhdXRvaW5zZXJ0ZWQgPHRib2R5PiBmcm9tIHRhYmxlIGZyYWdtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFqUXVlcnkuc3VwcG9ydC50Ym9keSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdHJpbmcgd2FzIGEgPHRhYmxlPiwgKm1heSogaGF2ZSBzcHVyaW91cyA8dGJvZHk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFzQm9keSA9IHJ0Ym9keS50ZXN0KGVsZW0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRib2R5ID0gdGFnID09PSBcInRhYmxlXCIgJiYgIWhhc0JvZHkgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpdi5maXJzdENoaWxkICYmIGRpdi5maXJzdENoaWxkLmNoaWxkTm9kZXMgOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RyaW5nIHdhcyBhIGJhcmUgPHRoZWFkPiBvciA8dGZvb3Q+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBbMV0gPT09IFwiPHRhYmxlPlwiICYmICFoYXNCb2R5ID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpdi5jaGlsZE5vZGVzIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGogPSB0Ym9keS5sZW5ndGggLSAxOyBqID49IDAgOyAtLWogKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBqUXVlcnkubm9kZU5hbWUoIHRib2R5WyBqIF0sIFwidGJvZHlcIiApICYmICF0Ym9keVsgaiBdLmNoaWxkTm9kZXMubGVuZ3RoICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0Ym9keVsgaiBdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHRib2R5WyBqIF0gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElFIGNvbXBsZXRlbHkga2lsbHMgbGVhZGluZyB3aGl0ZXNwYWNlIHdoZW4gaW5uZXJIVE1MIGlzIHVzZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhalF1ZXJ5LnN1cHBvcnQubGVhZGluZ1doaXRlc3BhY2UgJiYgcmxlYWRpbmdXaGl0ZXNwYWNlLnRlc3QoIGVsZW0gKSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpdi5pbnNlcnRCZWZvcmUoIGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoIHJsZWFkaW5nV2hpdGVzcGFjZS5leGVjKGVsZW0pWzBdICksIGRpdi5maXJzdENoaWxkICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0gPSBkaXYuY2hpbGROb2RlcztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVzZXRzIGRlZmF1bHRDaGVja2VkIGZvciBhbnkgcmFkaW9zIGFuZCBjaGVja2JveGVzXHJcbiAgICAgICAgICAgICAgICAvLyBhYm91dCB0byBiZSBhcHBlbmRlZCB0byB0aGUgRE9NIGluIElFIDYvNyAoIzgwNjApXHJcbiAgICAgICAgICAgICAgICB2YXIgbGVuO1xyXG4gICAgICAgICAgICAgICAgaWYgKCAhalF1ZXJ5LnN1cHBvcnQuYXBwZW5kQ2hlY2tlZCApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGVsZW1bMF0gJiYgdHlwZW9mIChsZW4gPSBlbGVtLmxlbmd0aCkgPT09IFwibnVtYmVyXCIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGogPSAwOyBqIDwgbGVuOyBqKysgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5kSW5wdXRzKCBlbGVtW2pdICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5kSW5wdXRzKCBlbGVtICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICggZWxlbS5ub2RlVHlwZSApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXQucHVzaCggZWxlbSApO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXQgPSBqUXVlcnkubWVyZ2UoIHJldCwgZWxlbSApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIGZyYWdtZW50ICkge1xyXG4gICAgICAgICAgICAgICAgY2hlY2tTY3JpcHRUeXBlID0gZnVuY3Rpb24oIGVsZW0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFlbGVtLnR5cGUgfHwgcnNjcmlwdFR5cGUudGVzdCggZWxlbS50eXBlICk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgZm9yICggaSA9IDA7IHJldFtpXTsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggc2NyaXB0cyAmJiBqUXVlcnkubm9kZU5hbWUoIHJldFtpXSwgXCJzY3JpcHRcIiApICYmICghcmV0W2ldLnR5cGUgfHwgcmV0W2ldLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0L2phdmFzY3JpcHRcIikgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdHMucHVzaCggcmV0W2ldLnBhcmVudE5vZGUgPyByZXRbaV0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggcmV0W2ldICkgOiByZXRbaV0gKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCByZXRbaV0ubm9kZVR5cGUgPT09IDEgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIganNUYWdzID0galF1ZXJ5LmdyZXAoIHJldFtpXS5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJzY3JpcHRcIiApLCBjaGVja1NjcmlwdFR5cGUgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQuc3BsaWNlLmFwcGx5KCByZXQsIFtpICsgMSwgMF0uY29uY2F0KCBqc1RhZ3MgKSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKCByZXRbaV0gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgY2xlYW5EYXRhOiBmdW5jdGlvbiggZWxlbXMgKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhLCBpZCxcclxuICAgICAgICAgICAgICAgIGNhY2hlID0galF1ZXJ5LmNhY2hlLFxyXG4gICAgICAgICAgICAgICAgc3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLFxyXG4gICAgICAgICAgICAgICAgZGVsZXRlRXhwYW5kbyA9IGpRdWVyeS5zdXBwb3J0LmRlbGV0ZUV4cGFuZG87XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGVsZW07IChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcclxuICAgICAgICAgICAgICAgIGlmICggZWxlbS5ub2RlTmFtZSAmJiBqUXVlcnkubm9EYXRhW2VsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKV0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWQgPSBlbGVtWyBqUXVlcnkuZXhwYW5kbyBdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggaWQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGNhY2hlWyBpZCBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGRhdGEgJiYgZGF0YS5ldmVudHMgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciB0eXBlIGluIGRhdGEuZXZlbnRzICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTnVsbCB0aGUgRE9NIHJlZmVyZW5jZSB0byBhdm9pZCBJRTYvNy84IGxlYWsgKCM3MDU0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGRhdGEuaGFuZGxlICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5oYW5kbGUuZWxlbSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggZGVsZXRlRXhwYW5kbyApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGVsZW1bIGpRdWVyeS5leHBhbmRvIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGVsZW0ucmVtb3ZlQXR0cmlidXRlICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZSggalF1ZXJ5LmV4cGFuZG8gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVsgaWQgXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGZ1bmN0aW9uIGV2YWxTY3JpcHQoIGksIGVsZW0gKSB7XHJcbiAgICAgICAgaWYgKCBlbGVtLnNyYyApIHtcclxuICAgICAgICAgICAgalF1ZXJ5LmFqYXgoe1xyXG4gICAgICAgICAgICAgICAgdXJsOiBlbGVtLnNyYyxcclxuICAgICAgICAgICAgICAgIGFzeW5jOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiBcInNjcmlwdFwiXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGpRdWVyeS5nbG9iYWxFdmFsKCAoIGVsZW0udGV4dCB8fCBlbGVtLnRleHRDb250ZW50IHx8IGVsZW0uaW5uZXJIVE1MIHx8IFwiXCIgKS5yZXBsYWNlKCByY2xlYW5TY3JpcHQsIFwiLyokMCovXCIgKSApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XHJcbiAgICAgICAgICAgIGVsZW0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZWxlbSApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG5cclxuXHJcbiAgICB2YXIgcmFscGhhID0gL2FscGhhXFwoW14pXSpcXCkvaSxcclxuICAgICAgICByb3BhY2l0eSA9IC9vcGFjaXR5PShbXildKikvLFxyXG4gICAgLy8gZml4ZWQgZm9yIElFOSwgc2VlICM4MzQ2XHJcbiAgICAgICAgcnVwcGVyID0gLyhbQS1aXXxebXMpL2csXHJcbiAgICAgICAgcm51bXB4ID0gL14tP1xcZCsoPzpweCk/JC9pLFxyXG4gICAgICAgIHJudW0gPSAvXi0/XFxkLyxcclxuICAgICAgICBycmVsTnVtID0gL14oW1xcLStdKT0oW1xcLSsuXFxkZV0rKS8sXHJcblxyXG4gICAgICAgIGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxyXG4gICAgICAgIGNzc1dpZHRoID0gWyBcIkxlZnRcIiwgXCJSaWdodFwiIF0sXHJcbiAgICAgICAgY3NzSGVpZ2h0ID0gWyBcIlRvcFwiLCBcIkJvdHRvbVwiIF0sXHJcbiAgICAgICAgY3VyQ1NTLFxyXG5cclxuICAgICAgICBnZXRDb21wdXRlZFN0eWxlLFxyXG4gICAgICAgIGN1cnJlbnRTdHlsZTtcclxuXHJcbiAgICBqUXVlcnkuZm4uY3NzID0gZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xyXG4gICAgICAgIC8vIFNldHRpbmcgJ3VuZGVmaW5lZCcgaXMgYSBuby1vcFxyXG4gICAgICAgIGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBqUXVlcnkuYWNjZXNzKCB0aGlzLCBuYW1lLCB2YWx1ZSwgdHJ1ZSwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XHJcbiAgICAgICAgICAgICAgICBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUsIHZhbHVlICkgOlxyXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBqUXVlcnkuZXh0ZW5kKHtcclxuICAgICAgICAvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRcclxuICAgICAgICAvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcclxuICAgICAgICBjc3NIb29rczoge1xyXG4gICAgICAgICAgICBvcGFjaXR5OiB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGNvbXB1dGVkICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiwgXCJvcGFjaXR5XCIgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5zdHlsZS5vcGFjaXR5O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIEV4Y2x1ZGUgdGhlIGZvbGxvd2luZyBjc3MgcHJvcGVydGllcyB0byBhZGQgcHhcclxuICAgICAgICBjc3NOdW1iZXI6IHtcclxuICAgICAgICAgICAgXCJmaWxsT3BhY2l0eVwiOiB0cnVlLFxyXG4gICAgICAgICAgICBcImZvbnRXZWlnaHRcIjogdHJ1ZSxcclxuICAgICAgICAgICAgXCJsaW5lSGVpZ2h0XCI6IHRydWUsXHJcbiAgICAgICAgICAgIFwib3BhY2l0eVwiOiB0cnVlLFxyXG4gICAgICAgICAgICBcIm9ycGhhbnNcIjogdHJ1ZSxcclxuICAgICAgICAgICAgXCJ3aWRvd3NcIjogdHJ1ZSxcclxuICAgICAgICAgICAgXCJ6SW5kZXhcIjogdHJ1ZSxcclxuICAgICAgICAgICAgXCJ6b29tXCI6IHRydWVcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBBZGQgaW4gcHJvcGVydGllcyB3aG9zZSBuYW1lcyB5b3Ugd2lzaCB0byBmaXggYmVmb3JlXHJcbiAgICAgICAgLy8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxyXG4gICAgICAgIGNzc1Byb3BzOiB7XHJcbiAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSBmbG9hdCBjc3MgcHJvcGVydHlcclxuICAgICAgICAgICAgXCJmbG9hdFwiOiBqUXVlcnkuc3VwcG9ydC5jc3NGbG9hdCA/IFwiY3NzRmxvYXRcIiA6IFwic3R5bGVGbG9hdFwiXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcclxuICAgICAgICBzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcclxuICAgICAgICAgICAgLy8gRG9uJ3Qgc2V0IHN0eWxlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXHJcbiAgICAgICAgICAgIGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcclxuICAgICAgICAgICAgdmFyIHJldCwgdHlwZSwgb3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICksXHJcbiAgICAgICAgICAgICAgICBzdHlsZSA9IGVsZW0uc3R5bGUsIGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xyXG5cclxuICAgICAgICAgICAgbmFtZSA9IGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSB8fCBvcmlnTmFtZTtcclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxyXG4gICAgICAgICAgICBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlID0gdHlwZW9mIHZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgcmVsYXRpdmUgbnVtYmVyIHN0cmluZ3MgKCs9IG9yIC09KSB0byByZWxhdGl2ZSBudW1iZXJzLiAjNzM0NVxyXG4gICAgICAgICAgICAgICAgaWYgKCB0eXBlID09PSBcInN0cmluZ1wiICYmIChyZXQgPSBycmVsTnVtLmV4ZWMoIHZhbHVlICkpICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gKCArKCByZXRbMV0gKyAxKSAqICtyZXRbMl0gKSArIHBhcnNlRmxvYXQoIGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKSApO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeGVzIGJ1ZyAjOTIzN1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBcIm51bWJlclwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IE5hTiBhbmQgbnVsbCB2YWx1ZXMgYXJlbid0IHNldC4gU2VlOiAjNzExNlxyXG4gICAgICAgICAgICAgICAgaWYgKCB2YWx1ZSA9PSBudWxsIHx8IHR5cGUgPT09IFwibnVtYmVyXCIgJiYgaXNOYU4oIHZhbHVlICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIGEgbnVtYmVyIHdhcyBwYXNzZWQgaW4sIGFkZCAncHgnIHRvIHRoZSAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxyXG4gICAgICAgICAgICAgICAgaWYgKCB0eXBlID09PSBcIm51bWJlclwiICYmICFqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IFwicHhcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcclxuICAgICAgICAgICAgICAgIGlmICggIWhvb2tzIHx8ICEoXCJzZXRcIiBpbiBob29rcykgfHwgKHZhbHVlID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSApKSAhPT0gdW5kZWZpbmVkICkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdyYXBwZWQgdG8gcHJldmVudCBJRSBmcm9tIHRocm93aW5nIGVycm9ycyB3aGVuICdpbnZhbGlkJyB2YWx1ZXMgYXJlIHByb3ZpZGVkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRml4ZXMgYnVnICM1NTA5XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2goZSkge31cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgbm9uLWNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcclxuICAgICAgICAgICAgICAgIGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBmYWxzZSwgZXh0cmEgKSkgIT09IHVuZGVmaW5lZCApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3R5bGVbIG5hbWUgXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhICkge1xyXG4gICAgICAgICAgICB2YXIgcmV0LCBob29rcztcclxuXHJcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxyXG4gICAgICAgICAgICBuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApO1xyXG4gICAgICAgICAgICBob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xyXG4gICAgICAgICAgICBuYW1lID0galF1ZXJ5LmNzc1Byb3BzWyBuYW1lIF0gfHwgbmFtZTtcclxuXHJcbiAgICAgICAgICAgIC8vIGNzc0Zsb2F0IG5lZWRzIGEgc3BlY2lhbCB0cmVhdG1lbnRcclxuICAgICAgICAgICAgaWYgKCBuYW1lID09PSBcImNzc0Zsb2F0XCIgKSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lID0gXCJmbG9hdFwiO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxyXG4gICAgICAgICAgICBpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKSkgIT09IHVuZGVmaW5lZCApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpZiBhIHdheSB0byBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGV4aXN0cywgdXNlIHRoYXRcclxuICAgICAgICAgICAgfSBlbHNlIGlmICggY3VyQ1NTICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1ckNTUyggZWxlbSwgbmFtZSApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gQSBtZXRob2QgZm9yIHF1aWNrbHkgc3dhcHBpbmcgaW4vb3V0IENTUyBwcm9wZXJ0aWVzIHRvIGdldCBjb3JyZWN0IGNhbGN1bGF0aW9uc1xyXG4gICAgICAgIHN3YXA6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjayApIHtcclxuICAgICAgICAgICAgdmFyIG9sZCA9IHt9O1xyXG5cclxuICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBuYW1lIGluIG9wdGlvbnMgKSB7XHJcbiAgICAgICAgICAgICAgICBvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcclxuICAgICAgICAgICAgICAgIGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY2FsbGJhY2suY2FsbCggZWxlbSApO1xyXG5cclxuICAgICAgICAgICAgLy8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXHJcbiAgICAgICAgICAgIGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcclxuICAgICAgICAgICAgICAgIGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9sZFsgbmFtZSBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4vLyBERVBSRUNBVEVELCBVc2UgalF1ZXJ5LmNzcygpIGluc3RlYWRcclxuICAgIGpRdWVyeS5jdXJDU1MgPSBqUXVlcnkuY3NzO1xyXG5cclxuICAgIGpRdWVyeS5lYWNoKFtcImhlaWdodFwiLCBcIndpZHRoXCJdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcclxuICAgICAgICBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSA9IHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGNvbXB1dGVkICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggZWxlbS5vZmZzZXRXaWR0aCAhPT0gMCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFdIKCBlbGVtLCBuYW1lLCBleHRyYSApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5zd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGdldFdIKCBlbGVtLCBuYW1lLCBleHRyYSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcclxuICAgICAgICAgICAgICAgIGlmICggcm51bXB4LnRlc3QoIHZhbHVlICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIG5lZ2F0aXZlIHdpZHRoIGFuZCBoZWlnaHQgdmFsdWVzICMxNTk5XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KCB2YWx1ZSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHZhbHVlID49IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKCAhalF1ZXJ5LnN1cHBvcnQub3BhY2l0eSApIHtcclxuICAgICAgICBqUXVlcnkuY3NzSG9va3Mub3BhY2l0eSA9IHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJRSB1c2VzIGZpbHRlcnMgZm9yIG9wYWNpdHlcclxuICAgICAgICAgICAgICAgIHJldHVybiByb3BhY2l0eS50ZXN0KCAoY29tcHV0ZWQgJiYgZWxlbS5jdXJyZW50U3R5bGUgPyBlbGVtLmN1cnJlbnRTdHlsZS5maWx0ZXIgOiBlbGVtLnN0eWxlLmZpbHRlcikgfHwgXCJcIiApID9cclxuICAgICAgICAgICAgICAgICggcGFyc2VGbG9hdCggUmVnRXhwLiQxICkgLyAxMDAgKSArIFwiXCIgOlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkID8gXCIxXCIgOiBcIlwiO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBlbGVtLnN0eWxlLFxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdHlsZSA9IGVsZW0uY3VycmVudFN0eWxlLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHkgPSBqUXVlcnkuaXNOdW1lcmljKCB2YWx1ZSApID8gXCJhbHBoYShvcGFjaXR5PVwiICsgdmFsdWUgKiAxMDAgKyBcIilcIiA6IFwiXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyID0gY3VycmVudFN0eWxlICYmIGN1cnJlbnRTdHlsZS5maWx0ZXIgfHwgc3R5bGUuZmlsdGVyIHx8IFwiXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSUUgaGFzIHRyb3VibGUgd2l0aCBvcGFjaXR5IGlmIGl0IGRvZXMgbm90IGhhdmUgbGF5b3V0XHJcbiAgICAgICAgICAgICAgICAvLyBGb3JjZSBpdCBieSBzZXR0aW5nIHRoZSB6b29tIGxldmVsXHJcbiAgICAgICAgICAgICAgICBzdHlsZS56b29tID0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpZiBzZXR0aW5nIG9wYWNpdHkgdG8gMSwgYW5kIG5vIG90aGVyIGZpbHRlcnMgZXhpc3QgLSBhdHRlbXB0IHRvIHJlbW92ZSBmaWx0ZXIgYXR0cmlidXRlICM2NjUyXHJcbiAgICAgICAgICAgICAgICBpZiAoIHZhbHVlID49IDEgJiYgalF1ZXJ5LnRyaW0oIGZpbHRlci5yZXBsYWNlKCByYWxwaGEsIFwiXCIgKSApID09PSBcIlwiICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTZXR0aW5nIHN0eWxlLmZpbHRlciB0byBudWxsLCBcIlwiICYgXCIgXCIgc3RpbGwgbGVhdmUgXCJmaWx0ZXI6XCIgaW4gdGhlIGNzc1RleHRcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBcImZpbHRlcjpcIiBpcyBwcmVzZW50IGF0IGFsbCwgY2xlYXJUeXBlIGlzIGRpc2FibGVkLCB3ZSB3YW50IHRvIGF2b2lkIHRoaXNcclxuICAgICAgICAgICAgICAgICAgICAvLyBzdHlsZS5yZW1vdmVBdHRyaWJ1dGUgaXMgSUUgT25seSwgYnV0IHNvIGFwcGFyZW50bHkgaXMgdGhpcyBjb2RlIHBhdGguLi5cclxuICAgICAgICAgICAgICAgICAgICBzdHlsZS5yZW1vdmVBdHRyaWJ1dGUoIFwiZmlsdGVyXCIgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgdGhlcmUgaXMgbm8gZmlsdGVyIHN0eWxlIGFwcGxpZWQgaW4gYSBjc3MgcnVsZSwgd2UgYXJlIGRvbmVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGN1cnJlbnRTdHlsZSAmJiAhY3VycmVudFN0eWxlLmZpbHRlciApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UsIHNldCBuZXcgZmlsdGVyIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgc3R5bGUuZmlsdGVyID0gcmFscGhhLnRlc3QoIGZpbHRlciApID9cclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXIucmVwbGFjZSggcmFscGhhLCBvcGFjaXR5ICkgOlxyXG4gICAgICAgICAgICAgICAgZmlsdGVyICsgXCIgXCIgKyBvcGFjaXR5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBqUXVlcnkoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy8gVGhpcyBob29rIGNhbm5vdCBiZSBhZGRlZCB1bnRpbCBET00gcmVhZHkgYmVjYXVzZSB0aGUgc3VwcG9ydCB0ZXN0XHJcbiAgICAgICAgLy8gZm9yIGl0IGlzIG5vdCBydW4gdW50aWwgYWZ0ZXIgRE9NIHJlYWR5XHJcbiAgICAgICAgaWYgKCAhalF1ZXJ5LnN1cHBvcnQucmVsaWFibGVNYXJnaW5SaWdodCApIHtcclxuICAgICAgICAgICAgalF1ZXJ5LmNzc0hvb2tzLm1hcmdpblJpZ2h0ID0ge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2ViS2l0IEJ1ZyAxMzM0MyAtIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyB3cm9uZyB2YWx1ZSBmb3IgbWFyZ2luLXJpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV29yayBhcm91bmQgYnkgdGVtcG9yYXJpbHkgc2V0dGluZyBlbGVtZW50IGRpc3BsYXkgdG8gaW5saW5lLWJsb2NrXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldDtcclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuc3dhcCggZWxlbSwgeyBcImRpc3BsYXlcIjogXCJpbmxpbmUtYmxvY2tcIiB9LCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjb21wdXRlZCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IGN1ckNTUyggZWxlbSwgXCJtYXJnaW4tcmlnaHRcIiwgXCJtYXJnaW5SaWdodFwiICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBlbGVtLnN0eWxlLm1hcmdpblJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoIGRvY3VtZW50LmRlZmF1bHRWaWV3ICYmIGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUgKSB7XHJcbiAgICAgICAgZ2V0Q29tcHV0ZWRTdHlsZSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xyXG4gICAgICAgICAgICB2YXIgcmV0LCBkZWZhdWx0VmlldywgY29tcHV0ZWRTdHlsZTtcclxuXHJcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoIHJ1cHBlciwgXCItJDFcIiApLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIChkZWZhdWx0VmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldykgJiZcclxuICAgICAgICAgICAgICAgIChjb21wdXRlZFN0eWxlID0gZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSwgbnVsbCApKSApIHtcclxuICAgICAgICAgICAgICAgIHJldCA9IGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApO1xyXG4gICAgICAgICAgICAgICAgaWYgKCByZXQgPT09IFwiXCIgJiYgIWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgZWxlbSApICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldCA9IGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY3VycmVudFN0eWxlICkge1xyXG4gICAgICAgIGN1cnJlbnRTdHlsZSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xyXG4gICAgICAgICAgICB2YXIgbGVmdCwgcnNMZWZ0LCB1bmNvbXB1dGVkLFxyXG4gICAgICAgICAgICAgICAgcmV0ID0gZWxlbS5jdXJyZW50U3R5bGUgJiYgZWxlbS5jdXJyZW50U3R5bGVbIG5hbWUgXSxcclxuICAgICAgICAgICAgICAgIHN0eWxlID0gZWxlbS5zdHlsZTtcclxuXHJcbiAgICAgICAgICAgIC8vIEF2b2lkIHNldHRpbmcgcmV0IHRvIGVtcHR5IHN0cmluZyBoZXJlXHJcbiAgICAgICAgICAgIC8vIHNvIHdlIGRvbid0IGRlZmF1bHQgdG8gYXV0b1xyXG4gICAgICAgICAgICBpZiAoIHJldCA9PT0gbnVsbCAmJiBzdHlsZSAmJiAodW5jb21wdXRlZCA9IHN0eWxlWyBuYW1lIF0pICkge1xyXG4gICAgICAgICAgICAgICAgcmV0ID0gdW5jb21wdXRlZDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRnJvbSB0aGUgYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1xyXG4gICAgICAgICAgICAvLyBodHRwOi8vZXJpay5lYWUubmV0L2FyY2hpdmVzLzIwMDcvMDcvMjcvMTguNTQuMTUvI2NvbW1lbnQtMTAyMjkxXHJcblxyXG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBub3QgZGVhbGluZyB3aXRoIGEgcmVndWxhciBwaXhlbCBudW1iZXJcclxuICAgICAgICAgICAgLy8gYnV0IGEgbnVtYmVyIHRoYXQgaGFzIGEgd2VpcmQgZW5kaW5nLCB3ZSBuZWVkIHRvIGNvbnZlcnQgaXQgdG8gcGl4ZWxzXHJcbiAgICAgICAgICAgIGlmICggIXJudW1weC50ZXN0KCByZXQgKSAmJiBybnVtLnRlc3QoIHJldCApICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcclxuICAgICAgICAgICAgICAgIGxlZnQgPSBzdHlsZS5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgcnNMZWZ0ID0gZWxlbS5ydW50aW1lU3R5bGUgJiYgZWxlbS5ydW50aW1lU3R5bGUubGVmdDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XHJcbiAgICAgICAgICAgICAgICBpZiAoIHJzTGVmdCApIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtLnJ1bnRpbWVTdHlsZS5sZWZ0ID0gZWxlbS5jdXJyZW50U3R5bGUubGVmdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN0eWxlLmxlZnQgPSBuYW1lID09PSBcImZvbnRTaXplXCIgPyBcIjFlbVwiIDogKCByZXQgfHwgMCApO1xyXG4gICAgICAgICAgICAgICAgcmV0ID0gc3R5bGUucGl4ZWxMZWZ0ICsgXCJweFwiO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcclxuICAgICAgICAgICAgICAgIHN0eWxlLmxlZnQgPSBsZWZ0O1xyXG4gICAgICAgICAgICAgICAgaWYgKCByc0xlZnQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5ydW50aW1lU3R5bGUubGVmdCA9IHJzTGVmdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiYXV0b1wiIDogcmV0O1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgY3VyQ1NTID0gZ2V0Q29tcHV0ZWRTdHlsZSB8fCBjdXJyZW50U3R5bGU7XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0V0goIGVsZW0sIG5hbWUsIGV4dHJhICkge1xyXG5cclxuICAgICAgICAvLyBTdGFydCB3aXRoIG9mZnNldCBwcm9wZXJ0eVxyXG4gICAgICAgIHZhciB2YWwgPSBuYW1lID09PSBcIndpZHRoXCIgPyBlbGVtLm9mZnNldFdpZHRoIDogZWxlbS5vZmZzZXRIZWlnaHQsXHJcbiAgICAgICAgICAgIHdoaWNoID0gbmFtZSA9PT0gXCJ3aWR0aFwiID8gY3NzV2lkdGggOiBjc3NIZWlnaHQsXHJcbiAgICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgICBsZW4gPSB3aGljaC5sZW5ndGg7XHJcblxyXG4gICAgICAgIGlmICggdmFsID4gMCApIHtcclxuICAgICAgICAgICAgaWYgKCBleHRyYSAhPT0gXCJib3JkZXJcIiApIHtcclxuICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggIWV4dHJhICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgLT0gcGFyc2VGbG9hdCggalF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyB3aGljaFsgaSBdICkgKSB8fCAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGV4dHJhID09PSBcIm1hcmdpblwiICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgKz0gcGFyc2VGbG9hdCggalF1ZXJ5LmNzcyggZWxlbSwgZXh0cmEgKyB3aGljaFsgaSBdICkgKSB8fCAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCAtPSBwYXJzZUZsb2F0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgd2hpY2hbIGkgXSArIFwiV2lkdGhcIiApICkgfHwgMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB2YWwgKyBcInB4XCI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gY29tcHV0ZWQgdGhlbiB1bmNvbXB1dGVkIGNzcyBpZiBuZWNlc3NhcnlcclxuICAgICAgICB2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIG5hbWUgKTtcclxuICAgICAgICBpZiAoIHZhbCA8IDAgfHwgdmFsID09IG51bGwgKSB7XHJcbiAgICAgICAgICAgIHZhbCA9IGVsZW0uc3R5bGVbIG5hbWUgXSB8fCAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBOb3JtYWxpemUgXCJcIiwgYXV0bywgYW5kIHByZXBhcmUgZm9yIGV4dHJhXHJcbiAgICAgICAgdmFsID0gcGFyc2VGbG9hdCggdmFsICkgfHwgMDtcclxuXHJcbiAgICAgICAgLy8gQWRkIHBhZGRpbmcsIGJvcmRlciwgbWFyZ2luXHJcbiAgICAgICAgaWYgKCBleHRyYSApIHtcclxuICAgICAgICAgICAgZm9yICggOyBpIDwgbGVuOyBpKysgKSB7XHJcbiAgICAgICAgICAgICAgICB2YWwgKz0gcGFyc2VGbG9hdCggalF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyB3aGljaFsgaSBdICkgKSB8fCAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKCBleHRyYSAhPT0gXCJwYWRkaW5nXCIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsICs9IHBhcnNlRmxvYXQoIGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyB3aGljaFsgaSBdICsgXCJXaWR0aFwiICkgKSB8fCAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCBleHRyYSA9PT0gXCJtYXJnaW5cIiApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWwgKz0gcGFyc2VGbG9hdCggalF1ZXJ5LmNzcyggZWxlbSwgZXh0cmEgKyB3aGljaFsgaSBdICkgKSB8fCAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdmFsICsgXCJweFwiO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICggalF1ZXJ5LmV4cHIgJiYgalF1ZXJ5LmV4cHIuZmlsdGVycyApIHtcclxuICAgICAgICBqUXVlcnkuZXhwci5maWx0ZXJzLmhpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtICkge1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSBlbGVtLm9mZnNldFdpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gZWxlbS5vZmZzZXRIZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKCB3aWR0aCA9PT0gMCAmJiBoZWlnaHQgPT09IDAgKSB8fCAoIWpRdWVyeS5zdXBwb3J0LnJlbGlhYmxlSGlkZGVuT2Zmc2V0cyAmJiAoKGVsZW0uc3R5bGUgJiYgZWxlbS5zdHlsZS5kaXNwbGF5KSB8fCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApKSA9PT0gXCJub25lXCIpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGpRdWVyeS5leHByLmZpbHRlcnMudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xyXG4gICAgICAgICAgICByZXR1cm4gIWpRdWVyeS5leHByLmZpbHRlcnMuaGlkZGVuKCBlbGVtICk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuXHJcbiAgICB2YXIgcjIwID0gLyUyMC9nLFxyXG4gICAgICAgIHJicmFja2V0ID0gL1xcW1xcXSQvLFxyXG4gICAgICAgIHJDUkxGID0gL1xccj9cXG4vZyxcclxuICAgICAgICByaGFzaCA9IC8jLiokLyxcclxuICAgICAgICByaGVhZGVycyA9IC9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKVxccj8kL21nLCAvLyBJRSBsZWF2ZXMgYW4gXFxyIGNoYXJhY3RlciBhdCBFT0xcclxuICAgICAgICByaW5wdXQgPSAvXig/OmNvbG9yfGRhdGV8ZGF0ZXRpbWV8ZGF0ZXRpbWUtbG9jYWx8ZW1haWx8aGlkZGVufG1vbnRofG51bWJlcnxwYXNzd29yZHxyYW5nZXxzZWFyY2h8dGVsfHRleHR8dGltZXx1cmx8d2VlaykkL2ksXHJcbiAgICAvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cclxuICAgICAgICBybG9jYWxQcm90b2NvbCA9IC9eKD86YWJvdXR8YXBwfGFwcFxcLXN0b3JhZ2V8LitcXC1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcclxuICAgICAgICBybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcclxuICAgICAgICBycHJvdG9jb2wgPSAvXlxcL1xcLy8sXHJcbiAgICAgICAgcnF1ZXJ5ID0gL1xcPy8sXHJcbiAgICAgICAgcnNjcmlwdCA9IC88c2NyaXB0XFxiW148XSooPzooPyE8XFwvc2NyaXB0Pik8W148XSopKjxcXC9zY3JpcHQ+L2dpLFxyXG4gICAgICAgIHJzZWxlY3RUZXh0YXJlYSA9IC9eKD86c2VsZWN0fHRleHRhcmVhKS9pLFxyXG4gICAgICAgIHJzcGFjZXNBamF4ID0gL1xccysvLFxyXG4gICAgICAgIHJ0cyA9IC8oWz8mXSlfPVteJl0qLyxcclxuICAgICAgICBydXJsID0gL14oW1xcd1xcK1xcLlxcLV0rOikoPzpcXC9cXC8oW15cXC8/IzpdKikoPzo6KFxcZCspKT8pPy8sXHJcblxyXG4gICAgLy8gS2VlcCBhIGNvcHkgb2YgdGhlIG9sZCBsb2FkIG1ldGhvZFxyXG4gICAgICAgIF9sb2FkID0galF1ZXJ5LmZuLmxvYWQsXHJcblxyXG4gICAgLyogUHJlZmlsdGVyc1xyXG4gICAgICogMSkgVGhleSBhcmUgdXNlZnVsIHRvIGludHJvZHVjZSBjdXN0b20gZGF0YVR5cGVzIChzZWUgYWpheC9qc29ucC5qcyBmb3IgYW4gZXhhbXBsZSlcclxuICAgICAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XHJcbiAgICAgKiAgICAtIEJFRk9SRSBhc2tpbmcgZm9yIGEgdHJhbnNwb3J0XHJcbiAgICAgKiAgICAtIEFGVEVSIHBhcmFtIHNlcmlhbGl6YXRpb24gKHMuZGF0YSBpcyBhIHN0cmluZyBpZiBzLnByb2Nlc3NEYXRhIGlzIHRydWUpXHJcbiAgICAgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXHJcbiAgICAgKiA0KSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXHJcbiAgICAgKiA1KSBleGVjdXRpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBjb250aW51ZSBkb3duIHRvIFwiKlwiIGlmIG5lZWRlZFxyXG4gICAgICovXHJcbiAgICAgICAgcHJlZmlsdGVycyA9IHt9LFxyXG5cclxuICAgIC8qIFRyYW5zcG9ydHMgYmluZGluZ3NcclxuICAgICAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcclxuICAgICAqIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcclxuICAgICAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFwiKlwiIGlmIG5lZWRlZFxyXG4gICAgICovXHJcbiAgICAgICAgdHJhbnNwb3J0cyA9IHt9LFxyXG5cclxuICAgIC8vIERvY3VtZW50IGxvY2F0aW9uXHJcbiAgICAgICAgYWpheExvY2F0aW9uLFxyXG5cclxuICAgIC8vIERvY3VtZW50IGxvY2F0aW9uIHNlZ21lbnRzXHJcbiAgICAgICAgYWpheExvY1BhcnRzLFxyXG5cclxuICAgIC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKCMxMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxyXG4gICAgICAgIGFsbFR5cGVzID0gW1wiKi9cIl0gKyBbXCIqXCJdO1xyXG5cclxuLy8gIzgxMzgsIElFIG1heSB0aHJvdyBhbiBleGNlcHRpb24gd2hlbiBhY2Nlc3NpbmdcclxuLy8gYSBmaWVsZCBmcm9tIHdpbmRvdy5sb2NhdGlvbiBpZiBkb2N1bWVudC5kb21haW4gaGFzIGJlZW4gc2V0XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGFqYXhMb2NhdGlvbiA9IGxvY2F0aW9uLmhyZWY7XHJcbiAgICB9IGNhdGNoKCBlICkge1xyXG4gICAgICAgIC8vIFVzZSB0aGUgaHJlZiBhdHRyaWJ1dGUgb2YgYW4gQSBlbGVtZW50XHJcbiAgICAgICAgLy8gc2luY2UgSUUgd2lsbCBtb2RpZnkgaXQgZ2l2ZW4gZG9jdW1lbnQubG9jYXRpb25cclxuICAgICAgICBhamF4TG9jYXRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xyXG4gICAgICAgIGFqYXhMb2NhdGlvbi5ocmVmID0gXCJcIjtcclxuICAgICAgICBhamF4TG9jYXRpb24gPSBhamF4TG9jYXRpb24uaHJlZjtcclxuICAgIH1cclxuXHJcbi8vIFNlZ21lbnQgbG9jYXRpb24gaW50byBwYXJ0c1xyXG4gICAgYWpheExvY1BhcnRzID0gcnVybC5leGVjKCBhamF4TG9jYXRpb24udG9Mb3dlckNhc2UoKSApIHx8IFtdO1xyXG5cclxuLy8gQmFzZSBcImNvbnN0cnVjdG9yXCIgZm9yIGpRdWVyeS5hamF4UHJlZmlsdGVyIGFuZCBqUXVlcnkuYWpheFRyYW5zcG9ydFxyXG4gICAgZnVuY3Rpb24gYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUgKSB7XHJcblxyXG4gICAgICAgIC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYyApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggdHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXCJzdHJpbmdcIiApIHtcclxuICAgICAgICAgICAgICAgIGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XHJcbiAgICAgICAgICAgICAgICBkYXRhVHlwZUV4cHJlc3Npb24gPSBcIipcIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZnVuYyApICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLnNwbGl0KCByc3BhY2VzQWpheCApLFxyXG4gICAgICAgICAgICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IGRhdGFUeXBlcy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdCxcclxuICAgICAgICAgICAgICAgICAgICBwbGFjZUJlZm9yZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGb3IgZWFjaCBkYXRhVHlwZSBpbiB0aGUgZGF0YVR5cGVFeHByZXNzaW9uXHJcbiAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSBdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGNvbnRyb2wgaWYgd2UncmUgYXNrZWQgdG8gYWRkIGJlZm9yZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFueSBleGlzdGluZyBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VCZWZvcmUgPSAvXlxcKy8udGVzdCggZGF0YVR5cGUgKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHBsYWNlQmVmb3JlICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZSA9IGRhdGFUeXBlLnN1YnN0ciggMSApIHx8IFwiKlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsaXN0ID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gd2UgYWRkIHRvIHRoZSBzdHJ1Y3R1cmUgYWNjb3JkaW5nbHlcclxuICAgICAgICAgICAgICAgICAgICBsaXN0WyBwbGFjZUJlZm9yZSA/IFwidW5zaGlmdFwiIDogXCJwdXNoXCIgXSggZnVuYyApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xyXG4gICAgZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZSAvKiBpbnRlcm5hbCAqLywgaW5zcGVjdGVkIC8qIGludGVybmFsICovICkge1xyXG5cclxuICAgICAgICBkYXRhVHlwZSA9IGRhdGFUeXBlIHx8IG9wdGlvbnMuZGF0YVR5cGVzWyAwIF07XHJcbiAgICAgICAgaW5zcGVjdGVkID0gaW5zcGVjdGVkIHx8IHt9O1xyXG5cclxuICAgICAgICBpbnNwZWN0ZWRbIGRhdGFUeXBlIF0gPSB0cnVlO1xyXG5cclxuICAgICAgICB2YXIgbGlzdCA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSxcclxuICAgICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICAgIGxlbmd0aCA9IGxpc3QgPyBsaXN0Lmxlbmd0aCA6IDAsXHJcbiAgICAgICAgICAgIGV4ZWN1dGVPbmx5ID0gKCBzdHJ1Y3R1cmUgPT09IHByZWZpbHRlcnMgKSxcclxuICAgICAgICAgICAgc2VsZWN0aW9uO1xyXG5cclxuICAgICAgICBmb3IgKCA7IGkgPCBsZW5ndGggJiYgKCBleGVjdXRlT25seSB8fCAhc2VsZWN0aW9uICk7IGkrKyApIHtcclxuICAgICAgICAgICAgc2VsZWN0aW9uID0gbGlzdFsgaSBdKCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XHJcbiAgICAgICAgICAgIC8vIElmIHdlIGdvdCByZWRpcmVjdGVkIHRvIGFub3RoZXIgZGF0YVR5cGVcclxuICAgICAgICAgICAgLy8gd2UgdHJ5IHRoZXJlIGlmIGV4ZWN1dGluZyBvbmx5IGFuZCBub3QgZG9uZSBhbHJlYWR5XHJcbiAgICAgICAgICAgIGlmICggdHlwZW9mIHNlbGVjdGlvbiA9PT0gXCJzdHJpbmdcIiApIHtcclxuICAgICAgICAgICAgICAgIGlmICggIWV4ZWN1dGVPbmx5IHx8IGluc3BlY3RlZFsgc2VsZWN0aW9uIF0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBzZWxlY3Rpb24gKTtcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24gPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RydWN0dXJlLCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSLCBzZWxlY3Rpb24sIGluc3BlY3RlZCApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHdlJ3JlIG9ubHkgZXhlY3V0aW5nIG9yIG5vdGhpbmcgd2FzIHNlbGVjdGVkXHJcbiAgICAgICAgLy8gd2UgdHJ5IHRoZSBjYXRjaGFsbCBkYXRhVHlwZSBpZiBub3QgZG9uZSBhbHJlYWR5XHJcbiAgICAgICAgaWYgKCAoIGV4ZWN1dGVPbmx5IHx8ICFzZWxlY3Rpb24gKSAmJiAhaW5zcGVjdGVkWyBcIipcIiBdICkge1xyXG4gICAgICAgICAgICBzZWxlY3Rpb24gPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyhcclxuICAgICAgICAgICAgICAgIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiwgXCIqXCIsIGluc3BlY3RlZCApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB1bm5lY2Vzc2FyeSB3aGVuIG9ubHkgZXhlY3V0aW5nIChwcmVmaWx0ZXJzKVxyXG4gICAgICAgIC8vIGJ1dCBpdCdsbCBiZSBpZ25vcmVkIGJ5IHRoZSBjYWxsZXIgaW4gdGhhdCBjYXNlXHJcbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbjtcclxuICAgIH1cclxuXHJcbi8vIEEgc3BlY2lhbCBleHRlbmQgZm9yIGFqYXggb3B0aW9uc1xyXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxyXG4vLyBGaXhlcyAjOTg4N1xyXG4gICAgZnVuY3Rpb24gYWpheEV4dGVuZCggdGFyZ2V0LCBzcmMgKSB7XHJcbiAgICAgICAgdmFyIGtleSwgZGVlcCxcclxuICAgICAgICAgICAgZmxhdE9wdGlvbnMgPSBqUXVlcnkuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIGZvciAoIGtleSBpbiBzcmMgKSB7XHJcbiAgICAgICAgICAgIGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xyXG4gICAgICAgICAgICAgICAgKCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIGRlZXAgKSB7XHJcbiAgICAgICAgICAgIGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcclxuICAgICAgICBsb2FkOiBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xyXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiB1cmwgIT09IFwic3RyaW5nXCIgJiYgX2xvYWQgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX2xvYWQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIERvbid0IGRvIGEgcmVxdWVzdCBpZiBubyBlbGVtZW50cyBhcmUgYmVpbmcgcmVxdWVzdGVkXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoICF0aGlzLmxlbmd0aCApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgb2ZmID0gdXJsLmluZGV4T2YoIFwiIFwiICk7XHJcbiAgICAgICAgICAgIGlmICggb2ZmID49IDAgKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSB1cmwuc2xpY2UoIG9mZiwgdXJsLmxlbmd0aCApO1xyXG4gICAgICAgICAgICAgICAgdXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRGVmYXVsdCB0byBhIEdFVCByZXF1ZXN0XHJcbiAgICAgICAgICAgIHZhciB0eXBlID0gXCJHRVRcIjtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHdhcyBwcm92aWRlZFxyXG4gICAgICAgICAgICBpZiAoIHBhcmFtcyApIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIGl0J3MgYSBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHBhcmFtcztcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmdcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0galF1ZXJ5LnBhcmFtKCBwYXJhbXMsIGpRdWVyeS5hamF4U2V0dGluZ3MudHJhZGl0aW9uYWwgKTtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlID0gXCJQT1NUXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIC8vIFJlcXVlc3QgdGhlIHJlbW90ZSBkb2N1bWVudFxyXG4gICAgICAgICAgICBqUXVlcnkuYWpheCh7XHJcbiAgICAgICAgICAgICAgICB1cmw6IHVybCxcclxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogXCJodG1sXCIsXHJcbiAgICAgICAgICAgICAgICBkYXRhOiBwYXJhbXMsXHJcbiAgICAgICAgICAgICAgICAvLyBDb21wbGV0ZSBjYWxsYmFjayAocmVzcG9uc2VUZXh0IGlzIHVzZWQgaW50ZXJuYWxseSlcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbigganFYSFIsIHN0YXR1cywgcmVzcG9uc2VUZXh0ICkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSByZXNwb25zZSBhcyBzcGVjaWZpZWQgYnkgdGhlIGpxWEhSIG9iamVjdFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlVGV4dCA9IGpxWEhSLnJlc3BvbnNlVGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBzdWNjZXNzZnVsLCBpbmplY3QgdGhlIEhUTUwgaW50byBhbGwgdGhlIG1hdGNoZWQgZWxlbWVudHNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGpxWEhSLmlzUmVzb2x2ZWQoKSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIzQ4MjU6IEdldCB0aGUgYWN0dWFsIHJlc3BvbnNlIGluIGNhc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSBkYXRhRmlsdGVyIGlzIHByZXNlbnQgaW4gYWpheFNldHRpbmdzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpxWEhSLmRvbmUoZnVuY3Rpb24oIHIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVRleHQgPSByO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VlIGlmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmh0bWwoIHNlbGVjdG9yID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIGR1bW15IGRpdiB0byBob2xkIHRoZSByZXN1bHRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkoXCI8ZGl2PlwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5qZWN0IHRoZSBjb250ZW50cyBvZiB0aGUgZG9jdW1lbnQgaW4sIHJlbW92aW5nIHRoZSBzY3JpcHRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBhdm9pZCBhbnkgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnMgaW4gSUVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKHJlc3BvbnNlVGV4dC5yZXBsYWNlKHJzY3JpcHQsIFwiXCIpKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMb2NhdGUgdGhlIHNwZWNpZmllZCBlbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maW5kKHNlbGVjdG9yKSA6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm90LCBqdXN0IGluamVjdCB0aGUgZnVsbCByZXN1bHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlVGV4dCApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjYWxsYmFjayApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lYWNoKCBjYWxsYmFjaywgWyByZXNwb25zZVRleHQsIHN0YXR1cywganFYSFIgXSApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LnBhcmFtKCB0aGlzLnNlcmlhbGl6ZUFycmF5KCkgKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KCB0aGlzLmVsZW1lbnRzICkgOiB0aGlzO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWUgJiYgIXRoaXMuZGlzYWJsZWQgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKCB0aGlzLmNoZWNrZWQgfHwgcnNlbGVjdFRleHRhcmVhLnRlc3QoIHRoaXMubm9kZU5hbWUgKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByaW5wdXQudGVzdCggdGhpcy50eXBlICkgKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKCBpLCBlbGVtICl7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsID09IG51bGwgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmlzQXJyYXkoIHZhbCApID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCwgaSApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcclxuICAgICAgICAgICAgICAgIH0pLmdldCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuLy8gQXR0YWNoIGEgYnVuY2ggb2YgZnVuY3Rpb25zIGZvciBoYW5kbGluZyBjb21tb24gQUpBWCBldmVudHNcclxuICAgIGpRdWVyeS5lYWNoKCBcImFqYXhTdGFydCBhamF4U3RvcCBhamF4Q29tcGxldGUgYWpheEVycm9yIGFqYXhTdWNjZXNzIGFqYXhTZW5kXCIuc3BsaXQoIFwiIFwiICksIGZ1bmN0aW9uKCBpLCBvICl7XHJcbiAgICAgICAgalF1ZXJ5LmZuWyBvIF0gPSBmdW5jdGlvbiggZiApe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vbiggbywgZiApO1xyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxuXHJcbiAgICBqUXVlcnkuZWFjaCggWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbiggaSwgbWV0aG9kICkge1xyXG4gICAgICAgIGpRdWVyeVsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSApIHtcclxuICAgICAgICAgICAgLy8gc2hpZnQgYXJndW1lbnRzIGlmIGRhdGEgYXJndW1lbnQgd2FzIG9taXR0ZWRcclxuICAgICAgICAgICAgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZGF0YSApICkge1xyXG4gICAgICAgICAgICAgICAgdHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGRhdGE7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmFqYXgoe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogbWV0aG9kLFxyXG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXHJcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgICAgICAgICAgc3VjY2VzczogY2FsbGJhY2ssXHJcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogdHlwZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcblxyXG4gICAgalF1ZXJ5LmV4dGVuZCh7XHJcblxyXG4gICAgICAgIGdldFNjcmlwdDogZnVuY3Rpb24oIHVybCwgY2FsbGJhY2sgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgZGF0YSwgY2FsbGJhY2ssIFwianNvblwiICk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcclxuICAgICAgICAvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuXHJcbiAgICAgICAgLy8gSWYgdGFyZ2V0IGlzIG9taXR0ZWQsIHdyaXRlcyBpbnRvIGFqYXhTZXR0aW5ncy5cclxuICAgICAgICBhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xyXG4gICAgICAgICAgICBpZiAoIHNldHRpbmdzICkge1xyXG4gICAgICAgICAgICAgICAgLy8gQnVpbGRpbmcgYSBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgICAgICAgICAgIGFqYXhFeHRlbmQoIHRhcmdldCwgalF1ZXJ5LmFqYXhTZXR0aW5ncyApO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5nc1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBqUXVlcnkuYWpheFNldHRpbmdzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFqYXhFeHRlbmQoIHRhcmdldCwgc2V0dGluZ3MgKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBhamF4U2V0dGluZ3M6IHtcclxuICAgICAgICAgICAgdXJsOiBhamF4TG9jYXRpb24sXHJcbiAgICAgICAgICAgIGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QoIGFqYXhMb2NQYXJ0c1sgMSBdICksXHJcbiAgICAgICAgICAgIGdsb2JhbDogdHJ1ZSxcclxuICAgICAgICAgICAgdHlwZTogXCJHRVRcIixcclxuICAgICAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsXHJcbiAgICAgICAgICAgIHByb2Nlc3NEYXRhOiB0cnVlLFxyXG4gICAgICAgICAgICBhc3luYzogdHJ1ZSxcclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgIHRpbWVvdXQ6IDAsXHJcbiAgICAgICAgICAgICBkYXRhOiBudWxsLFxyXG4gICAgICAgICAgICAgZGF0YVR5cGU6IG51bGwsXHJcbiAgICAgICAgICAgICB1c2VybmFtZTogbnVsbCxcclxuICAgICAgICAgICAgIHBhc3N3b3JkOiBudWxsLFxyXG4gICAgICAgICAgICAgY2FjaGU6IG51bGwsXHJcbiAgICAgICAgICAgICB0cmFkaXRpb25hbDogZmFsc2UsXHJcbiAgICAgICAgICAgICBoZWFkZXJzOiB7fSxcclxuICAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICBhY2NlcHRzOiB7XHJcbiAgICAgICAgICAgICAgICB4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLFxyXG4gICAgICAgICAgICAgICAgaHRtbDogXCJ0ZXh0L2h0bWxcIixcclxuICAgICAgICAgICAgICAgIHRleHQ6IFwidGV4dC9wbGFpblwiLFxyXG4gICAgICAgICAgICAgICAganNvbjogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIixcclxuICAgICAgICAgICAgICAgIFwiKlwiOiBhbGxUeXBlc1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgY29udGVudHM6IHtcclxuICAgICAgICAgICAgICAgIHhtbDogL3htbC8sXHJcbiAgICAgICAgICAgICAgICBodG1sOiAvaHRtbC8sXHJcbiAgICAgICAgICAgICAgICBqc29uOiAvanNvbi9cclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHJlc3BvbnNlRmllbGRzOiB7XHJcbiAgICAgICAgICAgICAgICB4bWw6IFwicmVzcG9uc2VYTUxcIixcclxuICAgICAgICAgICAgICAgIHRleHQ6IFwicmVzcG9uc2VUZXh0XCJcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8vIExpc3Qgb2YgZGF0YSBjb252ZXJ0ZXJzXHJcbiAgICAgICAgICAgIC8vIDEpIGtleSBmb3JtYXQgaXMgXCJzb3VyY2VfdHlwZSBkZXN0aW5hdGlvbl90eXBlXCIgKGEgc2luZ2xlIHNwYWNlIGluLWJldHdlZW4pXHJcbiAgICAgICAgICAgIC8vIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWQgZm9yIHNvdXJjZV90eXBlXHJcbiAgICAgICAgICAgIGNvbnZlcnRlcnM6IHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IGFueXRoaW5nIHRvIHRleHRcclxuICAgICAgICAgICAgICAgIFwiKiB0ZXh0XCI6IHdpbmRvdy5TdHJpbmcsXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXHJcbiAgICAgICAgICAgICAgICBcInRleHQgaHRtbFwiOiB0cnVlLFxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cclxuICAgICAgICAgICAgICAgIFwidGV4dCBqc29uXCI6IGpRdWVyeS5wYXJzZUpTT04sXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgdGV4dCBhcyB4bWxcclxuICAgICAgICAgICAgICAgIFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvLyBGb3Igb3B0aW9ucyB0aGF0IHNob3VsZG4ndCBiZSBkZWVwIGV4dGVuZGVkOlxyXG4gICAgICAgICAgICAvLyB5b3UgY2FuIGFkZCB5b3VyIG93biBjdXN0b20gb3B0aW9ucyBoZXJlIGlmXHJcbiAgICAgICAgICAgIC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXHJcbiAgICAgICAgICAgIC8vIGRlZXAgZXh0ZW5kZWQgKHNlZSBhamF4RXh0ZW5kKVxyXG4gICAgICAgICAgICBmbGF0T3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHVybDogdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzICksXHJcbiAgICAgICAgYWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzICksXHJcblxyXG4gICAgICAgIC8vIE1haW4gbWV0aG9kXHJcbiAgICAgICAgYWpheDogZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXHJcbiAgICAgICAgICAgIGlmICggdHlwZW9mIHVybCA9PT0gXCJvYmplY3RcIiApIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB1cmw7XHJcbiAgICAgICAgICAgICAgICB1cmwgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgdmFyIC8vIENyZWF0ZSB0aGUgZmluYWwgb3B0aW9ucyBvYmplY3RcclxuICAgICAgICAgICAgICAgIHMgPSBqUXVlcnkuYWpheFNldHVwKCB7fSwgb3B0aW9ucyApLFxyXG4gICAgICAgICAgICAvLyBDYWxsYmFja3MgY29udGV4dFxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tDb250ZXh0ID0gcy5jb250ZXh0IHx8IHMsXHJcbiAgICAgICAgICAgIC8vIENvbnRleHQgZm9yIGdsb2JhbCBldmVudHNcclxuICAgICAgICAgICAgLy8gSXQncyB0aGUgY2FsbGJhY2tDb250ZXh0IGlmIG9uZSB3YXMgcHJvdmlkZWQgaW4gdGhlIG9wdGlvbnNcclxuICAgICAgICAgICAgLy8gYW5kIGlmIGl0J3MgYSBET00gbm9kZSBvciBhIGpRdWVyeSBjb2xsZWN0aW9uXHJcbiAgICAgICAgICAgICAgICBnbG9iYWxFdmVudENvbnRleHQgPSBjYWxsYmFja0NvbnRleHQgIT09IHMgJiZcclxuICAgICAgICAgICAgICAgICggY2FsbGJhY2tDb250ZXh0Lm5vZGVUeXBlIHx8IGNhbGxiYWNrQ29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSApID9cclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDogalF1ZXJ5LmV2ZW50LFxyXG4gICAgICAgICAgICAvLyBEZWZlcnJlZHNcclxuICAgICAgICAgICAgICAgIGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksXHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZURlZmVycmVkID0galF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXHJcbiAgICAgICAgICAgIC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXHJcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LFxyXG4gICAgICAgICAgICAvLyBpZk1vZGlmaWVkIGtleVxyXG4gICAgICAgICAgICAgICAgaWZNb2RpZmllZEtleSxcclxuICAgICAgICAgICAgLy8gSGVhZGVycyAodGhleSBhcmUgc2VudCBhbGwgYXQgb25jZSlcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RIZWFkZXJzID0ge30sXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0SGVhZGVyc05hbWVzID0ge30sXHJcbiAgICAgICAgICAgIC8vIFJlc3BvbnNlIGhlYWRlcnNcclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlSGVhZGVyc1N0cmluZyxcclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlSGVhZGVycyxcclxuICAgICAgICAgICAgLy8gdHJhbnNwb3J0XHJcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQsXHJcbiAgICAgICAgICAgIC8vIHRpbWVvdXQgaGFuZGxlXHJcbiAgICAgICAgICAgICAgICB0aW1lb3V0VGltZXIsXHJcbiAgICAgICAgICAgIC8vIENyb3NzLWRvbWFpbiBkZXRlY3Rpb24gdmFyc1xyXG4gICAgICAgICAgICAgICAgcGFydHMsXHJcbiAgICAgICAgICAgIC8vIFRoZSBqcVhIUiBzdGF0ZVxyXG4gICAgICAgICAgICAgICAgc3RhdGUgPSAwLFxyXG4gICAgICAgICAgICAvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcclxuICAgICAgICAgICAgICAgIGZpcmVHbG9iYWxzLFxyXG4gICAgICAgICAgICAvLyBMb29wIHZhcmlhYmxlXHJcbiAgICAgICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICAvLyBGYWtlIHhoclxyXG4gICAgICAgICAgICAgICAganFYSFIgPSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJlYWR5U3RhdGU6IDAsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENhY2hlcyB0aGUgaGVhZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFzdGF0ZSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBsbmFtZSBdID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbG5hbWUgXSB8fCBuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJhdyBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAgICBnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUgPT09IDIgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcclxuICAgICAgICAgICAgICAgICAgICBnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHN0YXRlID09PSAyICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhcmVzcG9uc2VIZWFkZXJzICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlSGVhZGVycyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKCAoIG1hdGNoID0gcmhlYWRlcnMuZXhlYyggcmVzcG9uc2VIZWFkZXJzU3RyaW5nICkgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpIF0gPSBtYXRjaFsgMiBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gcmVzcG9uc2VIZWFkZXJzWyBrZXkudG9Mb3dlckNhc2UoKSBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG1hdGNoO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE92ZXJyaWRlcyByZXNwb25zZSBjb250ZW50LXR5cGUgaGVhZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIXN0YXRlICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5taW1lVHlwZSA9IHR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FuY2VsIHRoZSByZXF1ZXN0XHJcbiAgICAgICAgICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0ID0gc3RhdHVzVGV4dCB8fCBcImFib3J0XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdHJhbnNwb3J0ICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0LmFib3J0KCBzdGF0dXNUZXh0ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSggMCwgc3RhdHVzVGV4dCApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXHJcbiAgICAgICAgICAgIC8vIEl0IGlzIGRlZmluZWQgaGVyZSBiZWNhdXNlIGpzbGludCBjb21wbGFpbnMgaWYgaXQgaXMgZGVjbGFyZWRcclxuICAgICAgICAgICAgLy8gYXQgdGhlIGVuZCBvZiB0aGUgZnVuY3Rpb24gKHdoaWNoIHdvdWxkIGJlIG1vcmUgbG9naWNhbCBhbmQgcmVhZGFibGUpXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGRvbmUoIHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENhbGxlZCBvbmNlXHJcbiAgICAgICAgICAgICAgICBpZiAoIHN0YXRlID09PSAyICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTdGF0ZSBpcyBcImRvbmVcIiBub3dcclxuICAgICAgICAgICAgICAgIHN0YXRlID0gMjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDbGVhciB0aW1lb3V0IGlmIGl0IGV4aXN0c1xyXG4gICAgICAgICAgICAgICAgaWYgKCB0aW1lb3V0VGltZXIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxyXG4gICAgICAgICAgICAgICAgLy8gKG5vIG1hdHRlciBob3cgbG9uZyB0aGUganFYSFIgb2JqZWN0IHdpbGwgYmUgdXNlZClcclxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXHJcbiAgICAgICAgICAgICAgICByZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFwiXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU2V0IHJlYWR5U3RhdGVcclxuICAgICAgICAgICAgICAgIGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGlzU3VjY2VzcyxcclxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzLFxyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gcmVzcG9uc2VzID8gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RNb2RpZmllZCxcclxuICAgICAgICAgICAgICAgICAgICBldGFnO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIHN1Y2Nlc3NmdWwsIGhhbmRsZSB0eXBlIGNoYWluaW5nXHJcbiAgICAgICAgICAgICAgICBpZiAoIHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0ICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggcy5pZk1vZGlmaWVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAoIGxhc3RNb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkxhc3QtTW9kaWZpZWRcIiApICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkubGFzdE1vZGlmaWVkWyBpZk1vZGlmaWVkS2V5IF0gPSBsYXN0TW9kaWZpZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAoIGV0YWcgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJFdGFnXCIgKSApICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV0YWdbIGlmTW9kaWZpZWRLZXkgXSA9IGV0YWc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG5vdCBtb2RpZmllZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggc3RhdHVzID09PSAzMDQgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0ID0gXCJub3Rtb2RpZmllZFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1N1Y2Nlc3MgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzID0gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0ID0gXCJzdWNjZXNzXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1N1Y2Nlc3MgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYSBwYXJzZXJlcnJvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dCA9IFwicGFyc2VyZXJyb3JcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHRcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIG5vcm1hbGl6ZSBzdGF0dXNUZXh0IGFuZCBzdGF0dXMgZm9yIG5vbi1hYm9ydHNcclxuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IHN0YXR1c1RleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhc3RhdHVzVGV4dCB8fCBzdGF0dXMgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQgPSBcImVycm9yXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc3RhdHVzIDwgMCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3RcclxuICAgICAgICAgICAgICAgIGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcclxuICAgICAgICAgICAgICAgIGpxWEhSLnN0YXR1c1RleHQgPSBcIlwiICsgKCBuYXRpdmVTdGF0dXNUZXh0IHx8IHN0YXR1c1RleHQgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTdWNjZXNzL0Vycm9yXHJcbiAgICAgICAgICAgICAgICBpZiAoIGlzU3VjY2VzcyApIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIHN1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSIF0gKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3NcclxuICAgICAgICAgICAgICAgIGpxWEhSLnN0YXR1c0NvZGUoIHN0YXR1c0NvZGUgKTtcclxuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGUgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBmaXJlR2xvYmFscyApIHtcclxuICAgICAgICAgICAgICAgICAgICBnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4XCIgKyAoIGlzU3VjY2VzcyA/IFwiU3VjY2Vzc1wiIDogXCJFcnJvclwiICksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29tcGxldGVcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlRGVmZXJyZWQuZmlyZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCBdICk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBmaXJlR2xvYmFscyApIHtcclxuICAgICAgICAgICAgICAgICAgICBnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4Q29tcGxldGVcIiwgWyBqcVhIUiwgcyBdICk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhKCAtLWpRdWVyeS5hY3RpdmUgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0b3BcIiApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQXR0YWNoIGRlZmVycmVkc1xyXG4gICAgICAgICAgICBkZWZlcnJlZC5wcm9taXNlKCBqcVhIUiApO1xyXG4gICAgICAgICAgICBqcVhIUi5zdWNjZXNzID0ganFYSFIuZG9uZTtcclxuICAgICAgICAgICAganFYSFIuZXJyb3IgPSBqcVhIUi5mYWlsO1xyXG4gICAgICAgICAgICBqcVhIUi5jb21wbGV0ZSA9IGNvbXBsZXRlRGVmZXJyZWQuYWRkO1xyXG5cclxuICAgICAgICAgICAgLy8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3NcclxuICAgICAgICAgICAganFYSFIuc3RhdHVzQ29kZSA9IGZ1bmN0aW9uKCBtYXAgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIG1hcCApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdG1wO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggc3RhdGUgPCAyICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB0bXAgaW4gbWFwICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZVsgdG1wIF0gPSBbIHN0YXR1c0NvZGVbdG1wXSwgbWFwW3RtcF0gXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IG1hcFsganFYSFIuc3RhdHVzIF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpxWEhSLnRoZW4oIHRtcCwgdG1wICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvLyBSZW1vdmUgaGFzaCBjaGFyYWN0ZXIgKCM3NTMxOiBhbmQgc3RyaW5nIHByb21vdGlvbilcclxuICAgICAgICAgICAgLy8gQWRkIHByb3RvY29sIGlmIG5vdCBwcm92aWRlZCAoIzU4NjY6IElFNyBpc3N1ZSB3aXRoIHByb3RvY29sLWxlc3MgdXJscylcclxuICAgICAgICAgICAgLy8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXHJcbiAgICAgICAgICAgIHMudXJsID0gKCAoIHVybCB8fCBzLnVybCApICsgXCJcIiApLnJlcGxhY2UoIHJoYXNoLCBcIlwiICkucmVwbGFjZSggcnByb3RvY29sLCBhamF4TG9jUGFydHNbIDEgXSArIFwiLy9cIiApO1xyXG5cclxuICAgICAgICAgICAgLy8gRXh0cmFjdCBkYXRhVHlwZXMgbGlzdFxyXG4gICAgICAgICAgICBzLmRhdGFUeXBlcyA9IGpRdWVyeS50cmltKCBzLmRhdGFUeXBlIHx8IFwiKlwiICkudG9Mb3dlckNhc2UoKS5zcGxpdCggcnNwYWNlc0FqYXggKTtcclxuXHJcbiAgICAgICAgICAgIC8vIERldGVybWluZSBpZiBhIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyXHJcbiAgICAgICAgICAgIGlmICggcy5jcm9zc0RvbWFpbiA9PSBudWxsICkge1xyXG4gICAgICAgICAgICAgICAgcGFydHMgPSBydXJsLmV4ZWMoIHMudXJsLnRvTG93ZXJDYXNlKCkgKTtcclxuICAgICAgICAgICAgICAgIHMuY3Jvc3NEb21haW4gPSAhISggcGFydHMgJiZcclxuICAgICAgICAgICAgICAgICAgICAoIHBhcnRzWyAxIF0gIT0gYWpheExvY1BhcnRzWyAxIF0gfHwgcGFydHNbIDIgXSAhPSBhamF4TG9jUGFydHNbIDIgXSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICggcGFydHNbIDMgXSB8fCAoIHBhcnRzWyAxIF0gPT09IFwiaHR0cDpcIiA/IDgwIDogNDQzICkgKSAhPVxyXG4gICAgICAgICAgICAgICAgICAgICggYWpheExvY1BhcnRzWyAzIF0gfHwgKCBhamF4TG9jUGFydHNbIDEgXSA9PT0gXCJodHRwOlwiID8gODAgOiA0NDMgKSApIClcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgZGF0YSBpZiBub3QgYWxyZWFkeSBhIHN0cmluZ1xyXG4gICAgICAgICAgICBpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFwic3RyaW5nXCIgKSB7XHJcbiAgICAgICAgICAgICAgICBzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBcHBseSBwcmVmaWx0ZXJzXHJcbiAgICAgICAgICAgIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYSBwcmVmaWxlciwgc3RvcCB0aGVyZVxyXG4gICAgICAgICAgICBpZiAoIHN0YXRlID09PSAyICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xyXG4gICAgICAgICAgICBmaXJlR2xvYmFscyA9IHMuZ2xvYmFsO1xyXG5cclxuICAgICAgICAgICAgLy8gVXBwZXJjYXNlIHRoZSB0eXBlXHJcbiAgICAgICAgICAgIHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xyXG5cclxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcclxuICAgICAgICAgICAgcy5oYXNDb250ZW50ID0gIXJub0NvbnRlbnQudGVzdCggcy50eXBlICk7XHJcblxyXG4gICAgICAgICAgICAvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXHJcbiAgICAgICAgICAgIGlmICggZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwICkge1xyXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0YXJ0XCIgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTW9yZSBvcHRpb25zIGhhbmRsaW5nIGZvciByZXF1ZXN0cyB3aXRoIG5vIGNvbnRlbnRcclxuICAgICAgICAgICAgaWYgKCAhcy5oYXNDb250ZW50ICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIGRhdGEgaXMgYXZhaWxhYmxlLCBhcHBlbmQgZGF0YSB0byB1cmxcclxuICAgICAgICAgICAgICAgIGlmICggcy5kYXRhICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIHMudXJsICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzLmRhdGE7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gR2V0IGlmTW9kaWZpZWRLZXkgYmVmb3JlIGFkZGluZyB0aGUgYW50aS1jYWNoZSBwYXJhbWV0ZXJcclxuICAgICAgICAgICAgICAgIGlmTW9kaWZpZWRLZXkgPSBzLnVybDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgYW50aS1jYWNoZSBpbiB1cmwgaWYgbmVlZGVkXHJcbiAgICAgICAgICAgICAgICBpZiAoIHMuY2FjaGUgPT09IGZhbHNlICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHMgPSBqUXVlcnkubm93KCksXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJ5IHJlcGxhY2luZyBfPSBpZiBpdCBpcyB0aGVyZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBzLnVybC5yZXBsYWNlKCBydHMsIFwiJDFfPVwiICsgdHMgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm90aGluZyB3YXMgcmVwbGFjZWQsIGFkZCB0aW1lc3RhbXAgdG8gdGhlIGVuZFxyXG4gICAgICAgICAgICAgICAgICAgIHMudXJsID0gcmV0ICsgKCAoIHJldCA9PT0gcy51cmwgKSA/ICggcnF1ZXJ5LnRlc3QoIHMudXJsICkgPyBcIiZcIiA6IFwiP1wiICkgKyBcIl89XCIgKyB0cyA6IFwiXCIgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50XHJcbiAgICAgICAgICAgIGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xyXG4gICAgICAgICAgICAgICAganFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxyXG4gICAgICAgICAgICBpZiAoIHMuaWZNb2RpZmllZCApIHtcclxuICAgICAgICAgICAgICAgIGlmTW9kaWZpZWRLZXkgPSBpZk1vZGlmaWVkS2V5IHx8IHMudXJsO1xyXG4gICAgICAgICAgICAgICAgaWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBpZk1vZGlmaWVkS2V5IF0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAganFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Nb2RpZmllZC1TaW5jZVwiLCBqUXVlcnkubGFzdE1vZGlmaWVkWyBpZk1vZGlmaWVkS2V5IF0gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICggalF1ZXJ5LmV0YWdbIGlmTW9kaWZpZWRLZXkgXSApIHtcclxuICAgICAgICAgICAgICAgICAgICBqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU5vbmUtTWF0Y2hcIiwgalF1ZXJ5LmV0YWdbIGlmTW9kaWZpZWRLZXkgXSApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlXHJcbiAgICAgICAgICAgIGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXHJcbiAgICAgICAgICAgICAgICBcIkFjY2VwdFwiLFxyXG4gICAgICAgICAgICAgICAgcy5kYXRhVHlwZXNbIDAgXSAmJiBzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWzBdIF0gP1xyXG4gICAgICAgICAgICAgICAgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1swXSBdICsgKCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcclxuICAgICAgICAgICAgICAgICAgICBzLmFjY2VwdHNbIFwiKlwiIF1cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxyXG4gICAgICAgICAgICBmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcclxuICAgICAgICAgICAgICAgIGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIGksIHMuaGVhZGVyc1sgaSBdICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcclxuICAgICAgICAgICAgaWYgKCBzLmJlZm9yZVNlbmQgJiYgKCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBzdGF0ZSA9PT0gMiApICkge1xyXG4gICAgICAgICAgICAgICAgLy8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeVxyXG4gICAgICAgICAgICAgICAganFYSFIuYWJvcnQoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xyXG4gICAgICAgICAgICBmb3IgKCBpIGluIHsgc3VjY2VzczogMSwgZXJyb3I6IDEsIGNvbXBsZXRlOiAxIH0gKSB7XHJcbiAgICAgICAgICAgICAgICBqcVhIUlsgaSBdKCBzWyBpIF0gKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHRyYW5zcG9ydFxyXG4gICAgICAgICAgICB0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxyXG4gICAgICAgICAgICBpZiAoICF0cmFuc3BvcnQgKSB7XHJcbiAgICAgICAgICAgICAgICBkb25lKCAtMSwgXCJObyBUcmFuc3BvcnRcIiApO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAganFYSFIucmVhZHlTdGF0ZSA9IDE7XHJcbiAgICAgICAgICAgICAgICAvLyBTZW5kIGdsb2JhbCBldmVudFxyXG4gICAgICAgICAgICAgICAgaWYgKCBmaXJlR2xvYmFscyApIHtcclxuICAgICAgICAgICAgICAgICAgICBnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4U2VuZFwiLCBbIGpxWEhSLCBzIF0gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFRpbWVvdXRcclxuICAgICAgICAgICAgICAgIGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpxWEhSLmFib3J0KCBcInRpbWVvdXRcIiApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIHMudGltZW91dCApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFByb3BhZ2F0ZSBleGNlcHRpb24gYXMgZXJyb3IgaWYgbm90IGRvbmVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHN0YXRlIDwgMiApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSggLTEsIGUgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2ltcGx5IHJldGhyb3cgb3RoZXJ3aXNlXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBqcVhIUjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxyXG4gICAgICAgIC8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xyXG4gICAgICAgIHBhcmFtOiBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XHJcbiAgICAgICAgICAgIHZhciBzID0gW10sXHJcbiAgICAgICAgICAgICAgICBhZGQgPSBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHJldHVybiBpdHMgdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApID8gdmFsdWUoKSA6IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHNbIHMubGVuZ3RoIF0gPSBlbmNvZGVVUklDb21wb25lbnQoIGtleSApICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoIHZhbHVlICk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy8gU2V0IHRyYWRpdGlvbmFsIHRvIHRydWUgZm9yIGpRdWVyeSA8PSAxLjMuMiBiZWhhdmlvci5cclxuICAgICAgICAgICAgaWYgKCB0cmFkaXRpb25hbCA9PT0gdW5kZWZpbmVkICkge1xyXG4gICAgICAgICAgICAgICAgdHJhZGl0aW9uYWwgPSBqUXVlcnkuYWpheFNldHRpbmdzLnRyYWRpdGlvbmFsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxyXG4gICAgICAgICAgICBpZiAoIGpRdWVyeS5pc0FycmF5KCBhICkgfHwgKCBhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGEgKSApICkge1xyXG4gICAgICAgICAgICAgICAgLy8gU2VyaWFsaXplIHRoZSBmb3JtIGVsZW1lbnRzXHJcbiAgICAgICAgICAgICAgICBqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkKCB0aGlzLm5hbWUsIHRoaXMudmFsdWUgKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXHJcbiAgICAgICAgICAgICAgICAvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cclxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBwcmVmaXggaW4gYSApIHtcclxuICAgICAgICAgICAgICAgICAgICBidWlsZFBhcmFtcyggcHJlZml4LCBhWyBwcmVmaXggXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXHJcbiAgICAgICAgICAgIHJldHVybiBzLmpvaW4oIFwiJlwiICkucmVwbGFjZSggcjIwLCBcIitcIiApO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGZ1bmN0aW9uIGJ1aWxkUGFyYW1zKCBwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCApIHtcclxuICAgICAgICBpZiAoIGpRdWVyeS5pc0FycmF5KCBvYmogKSApIHtcclxuICAgICAgICAgICAgLy8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXHJcbiAgICAgICAgICAgIGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkKCBwcmVmaXgsIHYgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGFycmF5IGl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0c1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG51bWVyaWMgaW5kZXggdG8gcmVzb2x2ZSBkZXNlcmlhbGl6YXRpb24gYW1iaWd1aXR5IGlzc3Vlcy5cclxuICAgICAgICAgICAgICAgICAgICAvLyBOb3RlIHRoYXQgcmFjayAoYXMgb2YgMS4wLjApIGNhbid0IGN1cnJlbnRseSBkZXNlcmlhbGl6ZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5lc3RlZCBhcnJheXMgcHJvcGVybHksIGFuZCBhdHRlbXB0aW5nIHRvIGRvIHNvIG1heSBjYXVzZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGEgc2VydmVyIGVycm9yLiBQb3NzaWJsZSBmaXhlcyBhcmUgdG8gbW9kaWZ5IHJhY2snc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRlc2VyaWFsaXphdGlvbiBhbGdvcml0aG0gb3IgdG8gcHJvdmlkZSBhbiBvcHRpb24gb3IgZmxhZ1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGZvcmNlIGFycmF5IHNlcmlhbGl6YXRpb24gdG8gYmUgc2hhbGxvdy5cclxuICAgICAgICAgICAgICAgICAgICBidWlsZFBhcmFtcyggcHJlZml4ICsgXCJbXCIgKyAoIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiIHx8IGpRdWVyeS5pc0FycmF5KHYpID8gaSA6IFwiXCIgKSArIFwiXVwiLCB2LCB0cmFkaXRpb25hbCwgYWRkICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCAhdHJhZGl0aW9uYWwgJiYgb2JqICE9IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiApIHtcclxuICAgICAgICAgICAgLy8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgbmFtZSBpbiBvYmogKSB7XHJcbiAgICAgICAgICAgICAgICBidWlsZFBhcmFtcyggcHJlZml4ICsgXCJbXCIgKyBuYW1lICsgXCJdXCIsIG9ialsgbmFtZSBdLCB0cmFkaXRpb25hbCwgYWRkICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxyXG4gICAgICAgICAgICBhZGQoIHByZWZpeCwgb2JqICk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuLy8gVGhpcyBpcyBzdGlsbCBvbiB0aGUgalF1ZXJ5IG9iamVjdC4uLiBmb3Igbm93XHJcbi8vIFdhbnQgdG8gbW92ZSB0aGlzIHRvIGpRdWVyeS5hamF4IHNvbWUgZGF5XHJcbiAgICBqUXVlcnkuZXh0ZW5kKHtcclxuXHJcbiAgICAgICAgLy8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXHJcbiAgICAgICAgYWN0aXZlOiAwLFxyXG5cclxuICAgICAgICAvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XHJcbiAgICAgICAgbGFzdE1vZGlmaWVkOiB7fSxcclxuICAgICAgICBldGFnOiB7fVxyXG5cclxuICAgIH0pO1xyXG5cclxuICAgIC8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcclxuICAgICAqIC0gc2V0cyBhbGwgcmVzcG9uc2VYWFggZmllbGRzIGFjY29yZGluZ2x5XHJcbiAgICAgKiAtIGZpbmRzIHRoZSByaWdodCBkYXRhVHlwZSAobWVkaWF0ZXMgYmV0d2VlbiBjb250ZW50LXR5cGUgYW5kIGV4cGVjdGVkIGRhdGFUeXBlKVxyXG4gICAgICogLSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKSB7XHJcblxyXG4gICAgICAgIHZhciBjb250ZW50cyA9IHMuY29udGVudHMsXHJcbiAgICAgICAgICAgIGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLFxyXG4gICAgICAgICAgICByZXNwb25zZUZpZWxkcyA9IHMucmVzcG9uc2VGaWVsZHMsXHJcbiAgICAgICAgICAgIGN0LFxyXG4gICAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgICBmaW5hbERhdGFUeXBlLFxyXG4gICAgICAgICAgICBmaXJzdERhdGFUeXBlO1xyXG5cclxuICAgICAgICAvLyBGaWxsIHJlc3BvbnNlWFhYIGZpZWxkc1xyXG4gICAgICAgIGZvciAoIHR5cGUgaW4gcmVzcG9uc2VGaWVsZHMgKSB7XHJcbiAgICAgICAgICAgIGlmICggdHlwZSBpbiByZXNwb25zZXMgKSB7XHJcbiAgICAgICAgICAgICAgICBqcVhIUlsgcmVzcG9uc2VGaWVsZHNbdHlwZV0gXSA9IHJlc3BvbnNlc1sgdHlwZSBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgYXV0byBkYXRhVHlwZSBhbmQgZ2V0IGNvbnRlbnQtdHlwZSBpbiB0aGUgcHJvY2Vzc1xyXG4gICAgICAgIHdoaWxlKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XHJcbiAgICAgICAgICAgIGRhdGFUeXBlcy5zaGlmdCgpO1xyXG4gICAgICAgICAgICBpZiAoIGN0ID09PSB1bmRlZmluZWQgKSB7XHJcbiAgICAgICAgICAgICAgICBjdCA9IHMubWltZVR5cGUgfHwganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiY29udGVudC10eXBlXCIgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXHJcbiAgICAgICAgaWYgKCBjdCApIHtcclxuICAgICAgICAgICAgZm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcclxuICAgICAgICAgICAgICAgIGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGVzLnVuc2hpZnQoIHR5cGUgKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSByZXNwb25zZSBmb3IgdGhlIGV4cGVjdGVkIGRhdGFUeXBlXHJcbiAgICAgICAgaWYgKCBkYXRhVHlwZXNbIDAgXSBpbiByZXNwb25zZXMgKSB7XHJcbiAgICAgICAgICAgIGZpbmFsRGF0YVR5cGUgPSBkYXRhVHlwZXNbIDAgXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXHJcbiAgICAgICAgICAgIGZvciAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCAhZGF0YVR5cGVzWyAwIF0gfHwgcy5jb252ZXJ0ZXJzWyB0eXBlICsgXCIgXCIgKyBkYXRhVHlwZXNbMF0gXSApIHtcclxuICAgICAgICAgICAgICAgICAgICBmaW5hbERhdGFUeXBlID0gdHlwZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlyc3REYXRhVHlwZSA9IHR5cGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gT3IganVzdCB1c2UgZmlyc3Qgb25lXHJcbiAgICAgICAgICAgIGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXHJcbiAgICAgICAgLy8gV2UgYWRkIHRoZSBkYXRhVHlwZSB0byB0aGUgbGlzdCBpZiBuZWVkZWRcclxuICAgICAgICAvLyBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXHJcbiAgICAgICAgaWYgKCBmaW5hbERhdGFUeXBlICkge1xyXG4gICAgICAgICAgICBpZiAoIGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1sgMCBdICkge1xyXG4gICAgICAgICAgICAgICAgZGF0YVR5cGVzLnVuc2hpZnQoIGZpbmFsRGF0YVR5cGUgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuLy8gQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxyXG4gICAgZnVuY3Rpb24gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlICkge1xyXG5cclxuICAgICAgICAvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxyXG4gICAgICAgIGlmICggcy5kYXRhRmlsdGVyICkge1xyXG4gICAgICAgICAgICByZXNwb25zZSA9IHMuZGF0YUZpbHRlciggcmVzcG9uc2UsIHMuZGF0YVR5cGUgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcyxcclxuICAgICAgICAgICAgY29udmVydGVycyA9IHt9LFxyXG4gICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICBrZXksXHJcbiAgICAgICAgICAgIGxlbmd0aCA9IGRhdGFUeXBlcy5sZW5ndGgsXHJcbiAgICAgICAgICAgIHRtcCxcclxuICAgICAgICAvLyBDdXJyZW50IGFuZCBwcmV2aW91cyBkYXRhVHlwZXNcclxuICAgICAgICAgICAgY3VycmVudCA9IGRhdGFUeXBlc1sgMCBdLFxyXG4gICAgICAgICAgICBwcmV2LFxyXG4gICAgICAgIC8vIENvbnZlcnNpb24gZXhwcmVzc2lvblxyXG4gICAgICAgICAgICBjb252ZXJzaW9uLFxyXG4gICAgICAgIC8vIENvbnZlcnNpb24gZnVuY3Rpb25cclxuICAgICAgICAgICAgY29udixcclxuICAgICAgICAvLyBDb252ZXJzaW9uIGZ1bmN0aW9ucyAodHJhbnNpdGl2ZSBjb252ZXJzaW9uKVxyXG4gICAgICAgICAgICBjb252MSxcclxuICAgICAgICAgICAgY29udjI7XHJcblxyXG4gICAgICAgIC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBjaGFpblxyXG4gICAgICAgIGZvciAoIGkgPSAxOyBpIDwgbGVuZ3RoOyBpKysgKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgY29udmVydGVycyBtYXBcclxuICAgICAgICAgICAgLy8gd2l0aCBsb3dlcmNhc2VkIGtleXNcclxuICAgICAgICAgICAgaWYgKCBpID09PSAxICkge1xyXG4gICAgICAgICAgICAgICAgZm9yICgga2V5IGluIHMuY29udmVydGVycyApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnRlcnNbIGtleS50b0xvd2VyQ2FzZSgpIF0gPSBzLmNvbnZlcnRlcnNbIGtleSBdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSBkYXRhVHlwZXNcclxuICAgICAgICAgICAgcHJldiA9IGN1cnJlbnQ7XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBkYXRhVHlwZXNbIGkgXTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIGN1cnJlbnQgaXMgYXV0byBkYXRhVHlwZSwgdXBkYXRlIGl0IHRvIHByZXZcclxuICAgICAgICAgICAgaWYgKCBjdXJyZW50ID09PSBcIipcIiApIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBwcmV2O1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gYXV0byBhbmQgZGF0YVR5cGVzIGFyZSBhY3R1YWxseSBkaWZmZXJlbnRcclxuICAgICAgICAgICAgfSBlbHNlIGlmICggcHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGNvbnZlcnRlclxyXG4gICAgICAgICAgICAgICAgY29udmVyc2lvbiA9IHByZXYgKyBcIiBcIiArIGN1cnJlbnQ7XHJcbiAgICAgICAgICAgICAgICBjb252ID0gY29udmVydGVyc1sgY29udmVyc2lvbiBdIHx8IGNvbnZlcnRlcnNbIFwiKiBcIiArIGN1cnJlbnQgXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBkaXJlY3QgY29udmVydGVyLCBzZWFyY2ggdHJhbnNpdGl2ZWx5XHJcbiAgICAgICAgICAgICAgICBpZiAoICFjb252ICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnYyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIGNvbnYxIGluIGNvbnZlcnRlcnMgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IGNvbnYxLnNwbGl0KCBcIiBcIiApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRtcFsgMCBdID09PSBwcmV2IHx8IHRtcFsgMCBdID09PSBcIipcIiApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnYyID0gY29udmVydGVyc1sgdG1wWzFdICsgXCIgXCIgKyBjdXJyZW50IF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNvbnYyICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnYxID0gY29udmVydGVyc1sgY29udjEgXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNvbnYxID09PSB0cnVlICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb252ID0gY29udjI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggY29udjIgPT09IHRydWUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnYgPSBjb252MTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBmb3VuZCBubyBjb252ZXJ0ZXIsIGRpc3BhdGNoIGFuIGVycm9yXHJcbiAgICAgICAgICAgICAgICBpZiAoICEoIGNvbnYgfHwgY29udjIgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXJyb3IoIFwiTm8gY29udmVyc2lvbiBmcm9tIFwiICsgY29udmVyc2lvbi5yZXBsYWNlKFwiIFwiLFwiIHRvIFwiKSApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gSWYgZm91bmQgY29udmVydGVyIGlzIG5vdCBhbiBlcXVpdmFsZW5jZVxyXG4gICAgICAgICAgICAgICAgaWYgKCBjb252ICE9PSB0cnVlICkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgd2l0aCAxIG9yIDIgY29udmVydGVycyBhY2NvcmRpbmdseVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gY29udiA/IGNvbnYoIHJlc3BvbnNlICkgOiBjb252MiggY29udjEocmVzcG9uc2UpICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG5cclxuICAgIHZhciBqc2MgPSBqUXVlcnkubm93KCksXHJcbiAgICAgICAganNyZSA9IC8oXFw9KVxcPygmfCQpfFxcP1xcPy9pO1xyXG5cclxuLy8gRGVmYXVsdCBqc29ucCBzZXR0aW5nc1xyXG4gICAgalF1ZXJ5LmFqYXhTZXR1cCh7XHJcbiAgICAgICAganNvbnA6IFwiY2FsbGJhY2tcIixcclxuICAgICAgICBqc29ucENhbGxiYWNrOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5leHBhbmRvICsgXCJfXCIgKyAoIGpzYysrICk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcclxuICAgIGpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xyXG5cclxuICAgICAgICB2YXIgaW5zcGVjdERhdGEgPSBzLmNvbnRlbnRUeXBlID09PSBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICYmXHJcbiAgICAgICAgICAgICggdHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiApO1xyXG5cclxuICAgICAgICBpZiAoIHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiB8fFxyXG4gICAgICAgICAgICBzLmpzb25wICE9PSBmYWxzZSAmJiAoIGpzcmUudGVzdCggcy51cmwgKSB8fFxyXG4gICAgICAgICAgICBpbnNwZWN0RGF0YSAmJiBqc3JlLnRlc3QoIHMuZGF0YSApICkgKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzcG9uc2VDb250YWluZXIsXHJcbiAgICAgICAgICAgICAgICBqc29ucENhbGxiYWNrID0gcy5qc29ucENhbGxiYWNrID1cclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgPyBzLmpzb25wQ2FsbGJhY2soKSA6IHMuanNvbnBDYWxsYmFjayxcclxuICAgICAgICAgICAgICAgIHByZXZpb3VzID0gd2luZG93WyBqc29ucENhbGxiYWNrIF0sXHJcbiAgICAgICAgICAgICAgICB1cmwgPSBzLnVybCxcclxuICAgICAgICAgICAgICAgIGRhdGEgPSBzLmRhdGEsXHJcbiAgICAgICAgICAgICAgICByZXBsYWNlID0gXCIkMVwiICsganNvbnBDYWxsYmFjayArIFwiJDJcIjtcclxuXHJcbiAgICAgICAgICAgIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XHJcbiAgICAgICAgICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgganNyZSwgcmVwbGFjZSApO1xyXG4gICAgICAgICAgICAgICAgaWYgKCBzLnVybCA9PT0gdXJsICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggaW5zcGVjdERhdGEgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLnJlcGxhY2UoIGpzcmUsIHJlcGxhY2UgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzLmRhdGEgPT09IGRhdGEgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBjYWxsYmFjayBtYW51YWxseVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gKC9cXD8vLnRlc3QoIHVybCApID8gXCImXCIgOiBcIj9cIikgKyBzLmpzb25wICsgXCI9XCIgKyBqc29ucENhbGxiYWNrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcy51cmwgPSB1cmw7XHJcbiAgICAgICAgICAgIHMuZGF0YSA9IGRhdGE7XHJcblxyXG4gICAgICAgICAgICAvLyBJbnN0YWxsIGNhbGxiYWNrXHJcbiAgICAgICAgICAgIHdpbmRvd1sganNvbnBDYWxsYmFjayBdID0gZnVuY3Rpb24oIHJlc3BvbnNlICkge1xyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VDb250YWluZXIgPSBbIHJlc3BvbnNlIF07XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvLyBDbGVhbi11cCBmdW5jdGlvblxyXG4gICAgICAgICAgICBqcVhIUi5hbHdheXMoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTZXQgY2FsbGJhY2sgYmFjayB0byBwcmV2aW91cyB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgd2luZG93WyBqc29ucENhbGxiYWNrIF0gPSBwcmV2aW91cztcclxuICAgICAgICAgICAgICAgIC8vIENhbGwgaWYgaXQgd2FzIGEgZnVuY3Rpb24gYW5kIHdlIGhhdmUgYSByZXNwb25zZVxyXG4gICAgICAgICAgICAgICAgaWYgKCByZXNwb25zZUNvbnRhaW5lciAmJiBqUXVlcnkuaXNGdW5jdGlvbiggcHJldmlvdXMgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICB3aW5kb3dbIGpzb25wQ2FsbGJhY2sgXSggcmVzcG9uc2VDb250YWluZXJbIDAgXSApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cclxuICAgICAgICAgICAgcy5jb252ZXJ0ZXJzW1wic2NyaXB0IGpzb25cIl0gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5lcnJvcigganNvbnBDYWxsYmFjayArIFwiIHdhcyBub3QgY2FsbGVkXCIgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy8gZm9yY2UganNvbiBkYXRhVHlwZVxyXG4gICAgICAgICAgICBzLmRhdGFUeXBlc1sgMCBdID0gXCJqc29uXCI7XHJcblxyXG4gICAgICAgICAgICAvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcclxuICAgICAgICAgICAgcmV0dXJuIFwic2NyaXB0XCI7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG5cclxuXHJcblxyXG4vLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxyXG4gICAgalF1ZXJ5LmFqYXhTZXR1cCh7XHJcbiAgICAgICAgYWNjZXB0czoge1xyXG4gICAgICAgICAgICBzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29udGVudHM6IHtcclxuICAgICAgICAgICAgc2NyaXB0OiAvamF2YXNjcmlwdHxlY21hc2NyaXB0L1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29udmVydGVyczoge1xyXG4gICAgICAgICAgICBcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCB0ZXh0ICkge1xyXG4gICAgICAgICAgICAgICAgalF1ZXJ5Lmdsb2JhbEV2YWwoIHRleHQgKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4vLyBIYW5kbGUgY2FjaGUncyBzcGVjaWFsIGNhc2UgYW5kIGdsb2JhbFxyXG4gICAgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xyXG4gICAgICAgIGlmICggcy5jYWNoZSA9PT0gdW5kZWZpbmVkICkge1xyXG4gICAgICAgICAgICBzLmNhY2hlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICggcy5jcm9zc0RvbWFpbiApIHtcclxuICAgICAgICAgICAgcy50eXBlID0gXCJHRVRcIjtcclxuICAgICAgICAgICAgcy5nbG9iYWwgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbi8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxyXG4gICAgalF1ZXJ5LmFqYXhUcmFuc3BvcnQoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKHMpIHtcclxuXHJcbiAgICAgICAgLy8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiByZXF1ZXN0c1xyXG4gICAgICAgIGlmICggcy5jcm9zc0RvbWFpbiApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBzY3JpcHQsXHJcbiAgICAgICAgICAgICAgICBoZWFkID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJoZWFkXCIgKVswXSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG5cclxuICAgICAgICAgICAgICAgIHNlbmQ6IGZ1bmN0aW9uKCBfLCBjYWxsYmFjayApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBzY3JpcHQuYXN5bmMgPSBcImFzeW5jXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggcy5zY3JpcHRDaGFyc2V0ICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHQuY2hhcnNldCA9IHMuc2NyaXB0Q2hhcnNldDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdC5zcmMgPSBzLnVybDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQXR0YWNoIGhhbmRsZXJzIGZvciBhbGwgYnJvd3NlcnNcclxuICAgICAgICAgICAgICAgICAgICBzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCBfLCBpc0Fib3J0ICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpc0Fib3J0IHx8ICFzY3JpcHQucmVhZHlTdGF0ZSB8fCAvbG9hZGVkfGNvbXBsZXRlLy50ZXN0KCBzY3JpcHQucmVhZHlTdGF0ZSApICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBtZW1vcnkgbGVhayBpbiBJRVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc2NyaXB0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGhlYWQgJiYgc2NyaXB0LnBhcmVudE5vZGUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZC5yZW1vdmVDaGlsZCggc2NyaXB0ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVyZWZlcmVuY2UgdGhlIHNjcmlwdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0ID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGxiYWNrIGlmIG5vdCBhYm9ydFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhaXNBYm9ydCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayggMjAwLCBcInN1Y2Nlc3NcIiApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgaW5zZXJ0QmVmb3JlIGluc3RlYWQgb2YgYXBwZW5kQ2hpbGQgIHRvIGNpcmN1bXZlbnQgYW4gSUU2IGJ1Zy5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGFyaXNlcyB3aGVuIGEgYmFzZSBub2RlIGlzIHVzZWQgKCMyNzA5IGFuZCAjNDM3OCkuXHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZC5pbnNlcnRCZWZvcmUoIHNjcmlwdCwgaGVhZC5maXJzdENoaWxkICk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIGFib3J0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHNjcmlwdCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0Lm9ubG9hZCggMCwgMSApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcblxyXG5cclxuXHJcbiAgICB2YXIgLy8gIzUyODA6IEludGVybmV0IEV4cGxvcmVyIHdpbGwga2VlcCBjb25uZWN0aW9ucyBhbGl2ZSBpZiB3ZSBkb24ndCBhYm9ydCBvbiB1bmxvYWRcclxuICAgICAgICB4aHJPblVubG9hZEFib3J0ID0gd2luZG93LkFjdGl2ZVhPYmplY3QgPyBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgLy8gQWJvcnQgYWxsIHBlbmRpbmcgcmVxdWVzdHNcclxuICAgICAgICAgICAgZm9yICggdmFyIGtleSBpbiB4aHJDYWxsYmFja3MgKSB7XHJcbiAgICAgICAgICAgICAgICB4aHJDYWxsYmFja3NbIGtleSBdKCAwLCAxICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IDogZmFsc2UsXHJcbiAgICAgICAgeGhySWQgPSAwLFxyXG4gICAgICAgIHhockNhbGxiYWNrcztcclxuXHJcbi8vIEZ1bmN0aW9ucyB0byBjcmVhdGUgeGhyc1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlU3RhbmRhcmRYSFIoKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICB9IGNhdGNoKCBlICkge31cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVBY3RpdmVYSFIoKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuQWN0aXZlWE9iamVjdCggXCJNaWNyb3NvZnQuWE1MSFRUUFwiICk7XHJcbiAgICAgICAgfSBjYXRjaCggZSApIHt9XHJcbiAgICB9XHJcblxyXG4vLyBDcmVhdGUgdGhlIHJlcXVlc3Qgb2JqZWN0XHJcbi8vIChUaGlzIGlzIHN0aWxsIGF0dGFjaGVkIHRvIGFqYXhTZXR0aW5ncyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSlcclxuICAgIGpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gd2luZG93LkFjdGl2ZVhPYmplY3QgP1xyXG4gICAgICAgIC8qIE1pY3Jvc29mdCBmYWlsZWQgdG8gcHJvcGVybHlcclxuICAgICAgICAgKiBpbXBsZW1lbnQgdGhlIFhNTEh0dHBSZXF1ZXN0IGluIElFNyAoY2FuJ3QgcmVxdWVzdCBsb2NhbCBmaWxlcyksXHJcbiAgICAgICAgICogc28gd2UgdXNlIHRoZSBBY3RpdmVYT2JqZWN0IHdoZW4gaXQgaXMgYXZhaWxhYmxlXHJcbiAgICAgICAgICogQWRkaXRpb25hbGx5IFhNTEh0dHBSZXF1ZXN0IGNhbiBiZSBkaXNhYmxlZCBpbiBJRTcvSUU4IHNvXHJcbiAgICAgICAgICogd2UgbmVlZCBhIGZhbGxiYWNrLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuaXNMb2NhbCAmJiBjcmVhdGVTdGFuZGFyZFhIUigpIHx8IGNyZWF0ZUFjdGl2ZVhIUigpO1xyXG4gICAgICAgIH0gOlxyXG4gICAgICAgIC8vIEZvciBhbGwgb3RoZXIgYnJvd3NlcnMsIHVzZSB0aGUgc3RhbmRhcmQgWE1MSHR0cFJlcXVlc3Qgb2JqZWN0XHJcbiAgICAgICAgY3JlYXRlU3RhbmRhcmRYSFI7XHJcblxyXG4vLyBEZXRlcm1pbmUgc3VwcG9ydCBwcm9wZXJ0aWVzXHJcbiAgICAoZnVuY3Rpb24oIHhociApIHtcclxuICAgICAgICBqUXVlcnkuZXh0ZW5kKCBqUXVlcnkuc3VwcG9ydCwge1xyXG4gICAgICAgICAgICBhamF4OiAhIXhocixcclxuICAgICAgICAgICAgY29yczogISF4aHIgJiYgKCBcIndpdGhDcmVkZW50aWFsc1wiIGluIHhociApXHJcbiAgICAgICAgfSk7XHJcbiAgICB9KSggalF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKSApO1xyXG5cclxuLy8gQ3JlYXRlIHRyYW5zcG9ydCBpZiB0aGUgYnJvd3NlciBjYW4gcHJvdmlkZSBhbiB4aHJcclxuICAgIGlmICggalF1ZXJ5LnN1cHBvcnQuYWpheCApIHtcclxuXHJcbiAgICAgICAgalF1ZXJ5LmFqYXhUcmFuc3BvcnQoZnVuY3Rpb24oIHMgKSB7XHJcbiAgICAgICAgICAgIC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3RcclxuICAgICAgICAgICAgaWYgKCAhcy5jcm9zc0RvbWFpbiB8fCBqUXVlcnkuc3VwcG9ydC5jb3JzICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBjYWxsYmFjaztcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbmQ6IGZ1bmN0aW9uKCBoZWFkZXJzLCBjb21wbGV0ZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCBhIG5ldyB4aHJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhociA9IHMueGhyKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3BlbiB0aGUgc29ja2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhc3NpbmcgbnVsbCB1c2VybmFtZSwgZ2VuZXJhdGVzIGEgbG9naW4gcG9wdXAgb24gT3BlcmEgKCMyODY1KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHMudXNlcm5hbWUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIub3Blbiggcy50eXBlLCBzLnVybCwgcy5hc3luYywgcy51c2VybmFtZSwgcy5wYXNzd29yZCApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLm9wZW4oIHMudHlwZSwgcy51cmwsIHMuYXN5bmMgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHMueGhyRmllbGRzICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggaSBpbiBzLnhockZpZWxkcyApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHJbIGkgXSA9IHMueGhyRmllbGRzWyBpIF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE92ZXJyaWRlIG1pbWUgdHlwZSBpZiBuZWVkZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLm92ZXJyaWRlTWltZVR5cGUoIHMubWltZVR5cGUgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIXMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbXCJYLVJlcXVlc3RlZC1XaXRoXCJdICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmVlZCBhbiBleHRyYSB0cnkvY2F0Y2ggZm9yIGNyb3NzIGRvbWFpbiByZXF1ZXN0cyBpbiBGaXJlZm94IDNcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGkgaW4gaGVhZGVycyApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2goIF8gKSB7fVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG8gc2VuZCB0aGUgcmVxdWVzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24gd2hpY2ggaXMgYWN0dWFsbHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlZCBpbiBqUXVlcnkuYWpheCAoc28gbm8gdHJ5L2NhdGNoIGhlcmUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZW5kKCAoIHMuaGFzQ29udGVudCAmJiBzLmRhdGEgKSB8fCBudWxsICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMaXN0ZW5lclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uKCBfLCBpc0Fib3J0ICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0dXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZUhlYWRlcnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhtbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJlZm94IHRocm93cyBleGNlcHRpb25zIHdoZW4gYWNjZXNzaW5nIHByb3BlcnRpZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIGFuIHhociB3aGVuIGEgbmV0d29yayBlcnJvciBvY2N1cmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vaGVscGZ1bC5rbm9icy1kaWFscy5jb20vaW5kZXgucGhwL0NvbXBvbmVudF9yZXR1cm5lZF9mYWlsdXJlX2NvZGU6XzB4ODAwNDAxMTFfKE5TX0VSUk9SX05PVF9BVkFJTEFCTEUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXYXMgbmV2ZXIgY2FsbGVkIGFuZCBpcyBhYm9ydGVkIG9yIGNvbXBsZXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjYWxsYmFjayAmJiAoIGlzQWJvcnQgfHwgeGhyLnJlYWR5U3RhdGUgPT09IDQgKSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgY2FsbGVkIG9uY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3Qga2VlcCBhcyBhY3RpdmUgYW55bW9yZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGhhbmRsZSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBqUXVlcnkubm9vcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggeGhyT25VbmxvYWRBYm9ydCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgeGhyQ2FsbGJhY2tzWyBoYW5kbGUgXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQncyBhbiBhYm9ydFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGlzQWJvcnQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBYm9ydCBpdCBtYW51YWxseSBpZiBuZWVkZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggeGhyLnJlYWR5U3RhdGUgIT09IDQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLmFib3J0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSB4aHIuc3RhdHVzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VIZWFkZXJzID0geGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VzID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4bWwgPSB4aHIucmVzcG9uc2VYTUw7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IHJlc3BvbnNlIGxpc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggeG1sICYmIHhtbC5kb2N1bWVudEVsZW1lbnQgLyogIzQ5NTggKi8gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VzLnhtbCA9IHhtbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlcy50ZXh0ID0geGhyLnJlc3BvbnNlVGV4dDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJlZm94IHRocm93cyBhbiBleGNlcHRpb24gd2hlbiBhY2Nlc3NpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YXR1c1RleHQgZm9yIGZhdWx0eSBjcm9zcy1kb21haW4gcmVxdWVzdHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dCA9IHhoci5zdGF0dXNUZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCggZSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBub3JtYWxpemUgd2l0aCBXZWJraXQgZ2l2aW5nIGFuIGVtcHR5IHN0YXR1c1RleHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0ID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgc3RhdHVzIGZvciBub24gc3RhbmRhcmQgYmVoYXZpb3JzXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlcXVlc3QgaXMgbG9jYWwgYW5kIHdlIGhhdmUgZGF0YTogYXNzdW1lIGEgc3VjY2Vzc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKHN1Y2Nlc3Mgd2l0aCBubyBkYXRhIHdvbid0IGdldCBub3RpZmllZCwgdGhhdCdzIHRoZSBiZXN0IHdlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYW4gZG8gZ2l2ZW4gY3VycmVudCBpbXBsZW1lbnRhdGlvbnMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFzdGF0dXMgJiYgcy5pc0xvY2FsICYmICFzLmNyb3NzRG9tYWluICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IHJlc3BvbnNlcy50ZXh0ID8gMjAwIDogNDA0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElFIC0gIzE0NTA6IHNvbWV0aW1lcyByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDEyMjMgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gMjA0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCggZmlyZWZveEFjY2Vzc0V4Y2VwdGlvbiApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFpc0Fib3J0ICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZSggLTEsIGZpcmVmb3hBY2Nlc3NFeGNlcHRpb24gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCBjb21wbGV0ZSBpZiBuZWVkZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcmVzcG9uc2VzICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlKCBzdGF0dXMsIHN0YXR1c1RleHQsIHJlc3BvbnNlcywgcmVzcG9uc2VIZWFkZXJzICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSdyZSBpbiBzeW5jIG1vZGUgb3IgaXQncyBpbiBjYWNoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgaGFzIGJlZW4gcmV0cmlldmVkIGRpcmVjdGx5IChJRTYgJiBJRTcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gbWFudWFsbHkgZmlyZSB0aGUgY2FsbGJhY2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhcy5hc3luYyB8fCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGUgPSArK3hocklkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB4aHJPblVubG9hZEFib3J0ICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgYWN0aXZlIHhocnMgY2FsbGJhY2tzIGxpc3QgaWYgbmVlZGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGF0dGFjaCB0aGUgdW5sb2FkIGhhbmRsZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICF4aHJDYWxsYmFja3MgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhockNhbGxiYWNrcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkoIHdpbmRvdyApLnVubG9hZCggeGhyT25VbmxvYWRBYm9ydCApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdG8gbGlzdCBvZiBhY3RpdmUgeGhycyBjYWxsYmFja3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHJDYWxsYmFja3NbIGhhbmRsZSBdID0gY2FsbGJhY2s7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gY2FsbGJhY2s7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBhYm9ydDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY2FsbGJhY2sgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygwLDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG5cclxuICAgIHZhciBlbGVtZGlzcGxheSA9IHt9LFxyXG4gICAgICAgIGlmcmFtZSwgaWZyYW1lRG9jLFxyXG4gICAgICAgIHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxyXG4gICAgICAgIHJmeG51bSA9IC9eKFsrXFwtXT0pPyhbXFxkKy5cXC1dKykoW2EteiVdKikkL2ksXHJcbiAgICAgICAgdGltZXJJZCxcclxuICAgICAgICBmeEF0dHJzID0gW1xyXG4gICAgICAgICAgICAvLyBoZWlnaHQgYW5pbWF0aW9uc1xyXG4gICAgICAgICAgICBbIFwiaGVpZ2h0XCIsIFwibWFyZ2luVG9wXCIsIFwibWFyZ2luQm90dG9tXCIsIFwicGFkZGluZ1RvcFwiLCBcInBhZGRpbmdCb3R0b21cIiBdLFxyXG4gICAgICAgICAgICAvLyB3aWR0aCBhbmltYXRpb25zXHJcbiAgICAgICAgICAgIFsgXCJ3aWR0aFwiLCBcIm1hcmdpbkxlZnRcIiwgXCJtYXJnaW5SaWdodFwiLCBcInBhZGRpbmdMZWZ0XCIsIFwicGFkZGluZ1JpZ2h0XCIgXSxcclxuICAgICAgICAgICAgLy8gb3BhY2l0eSBhbmltYXRpb25zXHJcbiAgICAgICAgICAgIFsgXCJvcGFjaXR5XCIgXVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgZnhOb3c7XHJcblxyXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XHJcbiAgICAgICAgc2hvdzogZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xyXG4gICAgICAgICAgICB2YXIgZWxlbSwgZGlzcGxheTtcclxuXHJcbiAgICAgICAgICAgIGlmICggc3BlZWQgfHwgc3BlZWQgPT09IDAgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRlKCBnZW5GeChcInNob3dcIiwgMyksIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBqID0gdGhpcy5sZW5ndGg7IGkgPCBqOyBpKysgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbSA9IHRoaXNbIGkgXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtLnN0eWxlICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGlubGluZSBkaXNwbGF5IG9mIHRoaXMgZWxlbWVudCB0byBsZWFybiBpZiBpdCBpc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBiZWluZyBoaWRkZW4gYnkgY2FzY2FkZWQgcnVsZXMgb3Igbm90XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIWpRdWVyeS5fZGF0YShlbGVtLCBcIm9sZGRpc3BsYXlcIikgJiYgZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGVsZW1lbnRzIHdoaWNoIGhhdmUgYmVlbiBvdmVycmlkZGVuIHdpdGggZGlzcGxheTogbm9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiBhIHN0eWxlc2hlZXQgdG8gd2hhdGV2ZXIgdGhlIGRlZmF1bHQgYnJvd3NlciBzdHlsZSBpc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3Igc3VjaCBhbiBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZGlzcGxheSA9PT0gXCJcIiAmJiBqUXVlcnkuY3NzKGVsZW0sIFwiZGlzcGxheVwiKSA9PT0gXCJub25lXCIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuX2RhdGEoIGVsZW0sIFwib2xkZGlzcGxheVwiLCBkZWZhdWx0RGlzcGxheShlbGVtLm5vZGVOYW1lKSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgZGlzcGxheSBvZiBtb3N0IG9mIHRoZSBlbGVtZW50cyBpbiBhIHNlY29uZCBsb29wXHJcbiAgICAgICAgICAgICAgICAvLyB0byBhdm9pZCB0aGUgY29uc3RhbnQgcmVmbG93XHJcbiAgICAgICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGo7IGkrKyApIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtID0gdGhpc1sgaSBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGVsZW0uc3R5bGUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGRpc3BsYXkgPT09IFwiXCIgfHwgZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnN0eWxlLmRpc3BsYXkgPSBqUXVlcnkuX2RhdGEoIGVsZW0sIFwib2xkZGlzcGxheVwiICkgfHwgXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGhpZGU6IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcclxuICAgICAgICAgICAgaWYgKCBzcGVlZCB8fCBzcGVlZCA9PT0gMCApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUoIGdlbkZ4KFwiaGlkZVwiLCAzKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2spO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbGVtLCBkaXNwbGF5LFxyXG4gICAgICAgICAgICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGogPSB0aGlzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBqOyBpKysgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbSA9IHRoaXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtLnN0eWxlICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZGlzcGxheSAhPT0gXCJub25lXCIgJiYgIWpRdWVyeS5fZGF0YSggZWxlbSwgXCJvbGRkaXNwbGF5XCIgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5fZGF0YSggZWxlbSwgXCJvbGRkaXNwbGF5XCIsIGRpc3BsYXkgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIGRpc3BsYXkgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3BcclxuICAgICAgICAgICAgICAgIC8vIHRvIGF2b2lkIHRoZSBjb25zdGFudCByZWZsb3dcclxuICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgajsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggdGhpc1tpXS5zdHlsZSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tpXS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gU2F2ZSB0aGUgb2xkIHRvZ2dsZSBmdW5jdGlvblxyXG4gICAgICAgIF90b2dnbGU6IGpRdWVyeS5mbi50b2dnbGUsXHJcblxyXG4gICAgICAgIHRvZ2dsZTogZnVuY3Rpb24oIGZuLCBmbjIsIGNhbGxiYWNrICkge1xyXG4gICAgICAgICAgICB2YXIgYm9vbCA9IHR5cGVvZiBmbiA9PT0gXCJib29sZWFuXCI7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKGZuKSAmJiBqUXVlcnkuaXNGdW5jdGlvbihmbjIpICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdG9nZ2xlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGZuID09IG51bGwgfHwgYm9vbCApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBib29sID8gZm4gOiBqUXVlcnkodGhpcykuaXMoXCI6aGlkZGVuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSh0aGlzKVsgc3RhdGUgPyBcInNob3dcIiA6IFwiaGlkZVwiIF0oKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0ZShnZW5GeChcInRvZ2dsZVwiLCAzKSwgZm4sIGZuMiwgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBmYWRlVG86IGZ1bmN0aW9uKCBzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2sgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcihcIjpoaWRkZW5cIikuY3NzKFwib3BhY2l0eVwiLCAwKS5zaG93KCkuZW5kKClcclxuICAgICAgICAgICAgICAgIC5hbmltYXRlKHtvcGFjaXR5OiB0b30sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBhbmltYXRlOiBmdW5jdGlvbiggcHJvcCwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XHJcbiAgICAgICAgICAgIHZhciBvcHRhbGwgPSBqUXVlcnkuc3BlZWQoIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wICkgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKCBvcHRhbGwuY29tcGxldGUsIFsgZmFsc2UgXSApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBEbyBub3QgY2hhbmdlIHJlZmVyZW5jZWQgcHJvcGVydGllcyBhcyBwZXItcHJvcGVydHkgZWFzaW5nIHdpbGwgYmUgbG9zdFxyXG4gICAgICAgICAgICBwcm9wID0galF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKTtcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGRvQW5pbWF0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgLy8gWFhYICd0aGlzJyBkb2VzIG5vdCBhbHdheXMgaGF2ZSBhIG5vZGVOYW1lIHdoZW4gcnVubmluZyB0aGVcclxuICAgICAgICAgICAgICAgIC8vIHRlc3Qgc3VpdGVcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Ll9tYXJrKCB0aGlzICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG9wdCA9IGpRdWVyeS5leHRlbmQoIHt9LCBvcHRhbGwgKSxcclxuICAgICAgICAgICAgICAgICAgICBpc0VsZW1lbnQgPSB0aGlzLm5vZGVUeXBlID09PSAxLFxyXG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbiA9IGlzRWxlbWVudCAmJiBqUXVlcnkodGhpcykuaXMoXCI6aGlkZGVuXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsIHZhbCwgcCwgZSxcclxuICAgICAgICAgICAgICAgICAgICBwYXJ0cywgc3RhcnQsIGVuZCwgdW5pdCxcclxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gd2lsbCBzdG9yZSBwZXIgcHJvcGVydHkgZWFzaW5nIGFuZCBiZSB1c2VkIHRvIGRldGVybWluZSB3aGVuIGFuIGFuaW1hdGlvbiBpcyBjb21wbGV0ZVxyXG4gICAgICAgICAgICAgICAgb3B0LmFuaW1hdGVkUHJvcGVydGllcyA9IHt9O1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIHAgaW4gcHJvcCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvcGVydHkgbmFtZSBub3JtYWxpemF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIHAgKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHAgIT09IG5hbWUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BbIG5hbWUgXSA9IHByb3BbIHAgXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHByb3BbIHAgXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHByb3BbIG5hbWUgXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZWFzaW5nIHJlc29sdXRpb246IHBlciBwcm9wZXJ0eSA+IG9wdC5zcGVjaWFsRWFzaW5nID4gb3B0LmVhc2luZyA+ICdzd2luZycgKGRlZmF1bHQpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBqUXVlcnkuaXNBcnJheSggdmFsICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdC5hbmltYXRlZFByb3BlcnRpZXNbIG5hbWUgXSA9IHZhbFsgMSBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBwcm9wWyBuYW1lIF0gPSB2YWxbIDAgXTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHQuYW5pbWF0ZWRQcm9wZXJ0aWVzWyBuYW1lIF0gPSBvcHQuc3BlY2lhbEVhc2luZyAmJiBvcHQuc3BlY2lhbEVhc2luZ1sgbmFtZSBdIHx8IG9wdC5lYXNpbmcgfHwgJ3N3aW5nJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggdmFsID09PSBcImhpZGVcIiAmJiBoaWRkZW4gfHwgdmFsID09PSBcInNob3dcIiAmJiAhaGlkZGVuICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0LmNvbXBsZXRlLmNhbGwoIHRoaXMgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggaXNFbGVtZW50ICYmICggbmFtZSA9PT0gXCJoZWlnaHRcIiB8fCBuYW1lID09PSBcIndpZHRoXCIgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgbm90aGluZyBzbmVha3Mgb3V0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hhbmdlIHRoZSBvdmVyZmxvdyBhdHRyaWJ1dGUgd2hlbiBvdmVyZmxvd1ggYW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG92ZXJmbG93WSBhcmUgc2V0IHRvIHRoZSBzYW1lIHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdC5vdmVyZmxvdyA9IFsgdGhpcy5zdHlsZS5vdmVyZmxvdywgdGhpcy5zdHlsZS5vdmVyZmxvd1gsIHRoaXMuc3R5bGUub3ZlcmZsb3dZIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgZGlzcGxheSBwcm9wZXJ0eSB0byBpbmxpbmUtYmxvY2sgZm9yIGhlaWdodC93aWR0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmltYXRpb25zIG9uIGlubGluZSBlbGVtZW50cyB0aGF0IGFyZSBoYXZpbmcgd2lkdGgvaGVpZ2h0IGFuaW1hdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggalF1ZXJ5LmNzcyggdGhpcywgXCJkaXNwbGF5XCIgKSA9PT0gXCJpbmxpbmVcIiAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmNzcyggdGhpcywgXCJmbG9hdFwiICkgPT09IFwibm9uZVwiICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlubGluZS1sZXZlbCBlbGVtZW50cyBhY2NlcHQgaW5saW5lLWJsb2NrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmxvY2stbGV2ZWwgZWxlbWVudHMgbmVlZCB0byBiZSBpbmxpbmUgd2l0aCBsYXlvdXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIWpRdWVyeS5zdXBwb3J0LmlubGluZUJsb2NrTmVlZHNMYXlvdXQgfHwgZGVmYXVsdERpc3BsYXkoIHRoaXMubm9kZU5hbWUgKSA9PT0gXCJpbmxpbmVcIiApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZS56b29tID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIG9wdC5vdmVyZmxvdyAhPSBudWxsICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIHAgaW4gcHJvcCApIHtcclxuICAgICAgICAgICAgICAgICAgICBlID0gbmV3IGpRdWVyeS5meCggdGhpcywgb3B0LCBwICk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gcHJvcFsgcCBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHJmeHR5cGVzLnRlc3QoIHZhbCApICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJhY2tzIHdoZXRoZXIgdG8gc2hvdyBvciBoaWRlIGJhc2VkIG9uIHByaXZhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGF0YSBhdHRhY2hlZCB0byB0aGUgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSBqUXVlcnkuX2RhdGEoIHRoaXMsIFwidG9nZ2xlXCIgKyBwICkgfHwgKCB2YWwgPT09IFwidG9nZ2xlXCIgPyBoaWRkZW4gPyBcInNob3dcIiA6IFwiaGlkZVwiIDogMCApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG1ldGhvZCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5fZGF0YSggdGhpcywgXCJ0b2dnbGVcIiArIHAsIG1ldGhvZCA9PT0gXCJzaG93XCIgPyBcImhpZGVcIiA6IFwic2hvd1wiICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlWyBtZXRob2QgXSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZVsgdmFsIF0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0cyA9IHJmeG51bS5leGVjKCB2YWwgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBlLmN1cigpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBwYXJ0cyApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IHBhcnNlRmxvYXQoIHBhcnRzWzJdICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bml0ID0gcGFydHNbM10gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwIF0gPyBcIlwiIDogXCJweFwiICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBjb21wdXRlIHN0YXJ0aW5nIHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHVuaXQgIT09IFwicHhcIiApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuc3R5bGUoIHRoaXMsIHAsIChlbmQgfHwgMSkgKyB1bml0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9ICggKGVuZCB8fCAxKSAvIGUuY3VyKCkgKSAqIHN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5zdHlsZSggdGhpcywgcCwgc3RhcnQgKyB1bml0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBhICs9Ly09IHRva2VuIHdhcyBwcm92aWRlZCwgd2UncmUgZG9pbmcgYSByZWxhdGl2ZSBhbmltYXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcGFydHNbMV0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gKCAocGFydHNbIDEgXSA9PT0gXCItPVwiID8gLTEgOiAxKSAqIGVuZCApICsgc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5jdXN0b20oIHN0YXJ0LCBlbmQsIHVuaXQgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmN1c3RvbSggc3RhcnQsIHZhbCwgXCJcIiApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZvciBKUyBzdHJpY3QgY29tcGxpYW5jZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cclxuICAgICAgICAgICAgICAgIHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XHJcbiAgICAgICAgICAgIGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XHJcbiAgICAgICAgICAgICAgICBnb3RvRW5kID0gY2xlYXJRdWV1ZTtcclxuICAgICAgICAgICAgICAgIGNsZWFyUXVldWUgPSB0eXBlO1xyXG4gICAgICAgICAgICAgICAgdHlwZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIGNsZWFyUXVldWUgJiYgdHlwZSAhPT0gZmFsc2UgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCxcclxuICAgICAgICAgICAgICAgICAgICBoYWRUaW1lcnMgPSBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICB0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBqUXVlcnkuX2RhdGEoIHRoaXMgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBjbGVhciBtYXJrZXIgY291bnRlcnMgaWYgd2Uga25vdyB0aGV5IHdvbid0IGJlXHJcbiAgICAgICAgICAgICAgICBpZiAoICFnb3RvRW5kICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5fdW5tYXJrKCB0cnVlLCB0aGlzICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc3RvcFF1ZXVlKCBlbGVtLCBkYXRhLCBpbmRleCApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaG9va3MgPSBkYXRhWyBpbmRleCBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVEYXRhKCBlbGVtLCBpbmRleCwgdHJ1ZSApO1xyXG4gICAgICAgICAgICAgICAgICAgIGhvb2tzLnN0b3AoIGdvdG9FbmQgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHR5cGUgPT0gbnVsbCApIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCBpbmRleCBpbiBkYXRhICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICYmIGluZGV4LmluZGV4T2YoXCIucnVuXCIpID09PSBpbmRleC5sZW5ndGggLSA0ICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcFF1ZXVlKCB0aGlzLCBkYXRhLCBpbmRleCApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggZGF0YVsgaW5kZXggPSB0eXBlICsgXCIucnVuXCIgXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKXtcclxuICAgICAgICAgICAgICAgICAgICBzdG9wUXVldWUoIHRoaXMsIGRhdGEsIGluZGV4ICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmICh0eXBlID09IG51bGwgfHwgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlKSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBnb3RvRW5kICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvcmNlIHRoZSBuZXh0IHN0ZXAgdG8gYmUgdGhlIGxhc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyc1sgaW5kZXggXSggdHJ1ZSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXJzWyBpbmRleCBdLnNhdmVTdGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhZFRpbWVycyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWRcclxuICAgICAgICAgICAgICAgIC8vIHRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2ggd2lsbCBkZXF1ZXVlXHJcbiAgICAgICAgICAgICAgICAvLyBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZFxyXG4gICAgICAgICAgICAgICAgaWYgKCAhKCBnb3RvRW5kICYmIGhhZFRpbWVycyApICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9KTtcclxuXHJcbi8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xyXG4gICAgICAgIHNldFRpbWVvdXQoIGNsZWFyRnhOb3csIDAgKTtcclxuICAgICAgICByZXR1cm4gKCBmeE5vdyA9IGpRdWVyeS5ub3coKSApO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNsZWFyRnhOb3coKSB7XHJcbiAgICAgICAgZnhOb3cgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4vLyBHZW5lcmF0ZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhIHN0YW5kYXJkIGFuaW1hdGlvblxyXG4gICAgZnVuY3Rpb24gZ2VuRngoIHR5cGUsIG51bSApIHtcclxuICAgICAgICB2YXIgb2JqID0ge307XHJcblxyXG4gICAgICAgIGpRdWVyeS5lYWNoKCBmeEF0dHJzLmNvbmNhdC5hcHBseShbXSwgZnhBdHRycy5zbGljZSggMCwgbnVtICkpLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgb2JqWyB0aGlzIF0gPSB0eXBlO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfVxyXG5cclxuLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xyXG4gICAgalF1ZXJ5LmVhY2goe1xyXG4gICAgICAgIHNsaWRlRG93bjogZ2VuRngoIFwic2hvd1wiLCAxICksXHJcbiAgICAgICAgc2xpZGVVcDogZ2VuRngoIFwiaGlkZVwiLCAxICksXHJcbiAgICAgICAgc2xpZGVUb2dnbGU6IGdlbkZ4KCBcInRvZ2dsZVwiLCAxICksXHJcbiAgICAgICAgZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXHJcbiAgICAgICAgZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxyXG4gICAgICAgIGZhZGVUb2dnbGU6IHsgb3BhY2l0eTogXCJ0b2dnbGVcIiB9XHJcbiAgICB9LCBmdW5jdGlvbiggbmFtZSwgcHJvcHMgKSB7XHJcbiAgICAgICAgalF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUoIHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxuXHJcbiAgICBqUXVlcnkuZXh0ZW5kKHtcclxuICAgICAgICBzcGVlZDogZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGZuICkge1xyXG4gICAgICAgICAgICB2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcIm9iamVjdFwiID8galF1ZXJ5LmV4dGVuZCgge30sIHNwZWVkICkgOiB7XHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxyXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogc3BlZWQsXHJcbiAgICAgICAgICAgICAgICBlYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKCBlYXNpbmcgKSAmJiBlYXNpbmdcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5vZmYgPyAwIDogdHlwZW9mIG9wdC5kdXJhdGlvbiA9PT0gXCJudW1iZXJcIiA/IG9wdC5kdXJhdGlvbiA6XHJcbiAgICAgICAgICAgICAgICBvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyA/IGpRdWVyeS5meC5zcGVlZHNbIG9wdC5kdXJhdGlvbiBdIDogalF1ZXJ5LmZ4LnNwZWVkcy5fZGVmYXVsdDtcclxuXHJcbiAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxyXG4gICAgICAgICAgICBpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcclxuICAgICAgICAgICAgICAgIG9wdC5xdWV1ZSA9IFwiZnhcIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUXVldWVpbmdcclxuICAgICAgICAgICAgb3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcclxuXHJcbiAgICAgICAgICAgIG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCBub1VubWFyayApIHtcclxuICAgICAgICAgICAgICAgIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdC5vbGQgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICBvcHQub2xkLmNhbGwoIHRoaXMgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIG9wdC5xdWV1ZSApIHtcclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBub1VubWFyayAhPT0gZmFsc2UgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Ll91bm1hcmsoIHRoaXMgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBvcHQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZWFzaW5nOiB7XHJcbiAgICAgICAgICAgIGxpbmVhcjogZnVuY3Rpb24oIHAsIG4sIGZpcnN0TnVtLCBkaWZmICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0TnVtICsgZGlmZiAqIHA7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN3aW5nOiBmdW5jdGlvbiggcCwgbiwgZmlyc3ROdW0sIGRpZmYgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKCAoIC1NYXRoLmNvcyggcCpNYXRoLlBJICkgLyAyICkgKyAwLjUgKSAqIGRpZmYgKyBmaXJzdE51bTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHRpbWVyczogW10sXHJcblxyXG4gICAgICAgIGZ4OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCApIHtcclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuICAgICAgICAgICAgdGhpcy5lbGVtID0gZWxlbTtcclxuICAgICAgICAgICAgdGhpcy5wcm9wID0gcHJvcDtcclxuXHJcbiAgICAgICAgICAgIG9wdGlvbnMub3JpZyA9IG9wdGlvbnMub3JpZyB8fCB7fTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSk7XHJcblxyXG4gICAgalF1ZXJ5LmZ4LnByb3RvdHlwZSA9IHtcclxuICAgICAgICAvLyBTaW1wbGUgZnVuY3Rpb24gZm9yIHNldHRpbmcgYSBzdHlsZSB2YWx1ZVxyXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICggalF1ZXJ5LmZ4LnN0ZXBbIHRoaXMucHJvcCBdIHx8IGpRdWVyeS5meC5zdGVwLl9kZWZhdWx0ICkoIHRoaXMgKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgc2l6ZVxyXG4gICAgICAgIGN1cjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5lbGVtWyB0aGlzLnByb3AgXSAhPSBudWxsICYmICghdGhpcy5lbGVtLnN0eWxlIHx8IHRoaXMuZWxlbS5zdHlsZVsgdGhpcy5wcm9wIF0gPT0gbnVsbCkgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtWyB0aGlzLnByb3AgXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHBhcnNlZCxcclxuICAgICAgICAgICAgICAgIHIgPSBqUXVlcnkuY3NzKCB0aGlzLmVsZW0sIHRoaXMucHJvcCApO1xyXG4gICAgICAgICAgICAvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMCxcclxuICAgICAgICAgICAgLy8gY29tcGxleCB2YWx1ZXMgc3VjaCBhcyBcInJvdGF0ZSgxcmFkKVwiIGFyZSByZXR1cm5lZCBhcyBpcyxcclxuICAgICAgICAgICAgLy8gc2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQuXHJcbiAgICAgICAgICAgIHJldHVybiBpc05hTiggcGFyc2VkID0gcGFyc2VGbG9hdCggciApICkgPyAhciB8fCByID09PSBcImF1dG9cIiA/IDAgOiByIDogcGFyc2VkO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIFN0YXJ0IGFuIGFuaW1hdGlvbiBmcm9tIG9uZSBudW1iZXIgdG8gYW5vdGhlclxyXG4gICAgICAgIGN1c3RvbTogZnVuY3Rpb24oIGZyb20sIHRvLCB1bml0ICkge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgICAgICAgICBmeCA9IGpRdWVyeS5meDtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKTtcclxuICAgICAgICAgICAgdGhpcy5lbmQgPSB0bztcclxuICAgICAgICAgICAgdGhpcy5ub3cgPSB0aGlzLnN0YXJ0ID0gZnJvbTtcclxuICAgICAgICAgICAgdGhpcy5wb3MgPSB0aGlzLnN0YXRlID0gMDtcclxuICAgICAgICAgICAgdGhpcy51bml0ID0gdW5pdCB8fCB0aGlzLnVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyB0aGlzLnByb3AgXSA/IFwiXCIgOiBcInB4XCIgKTtcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHQoIGdvdG9FbmQgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5zdGVwKCBnb3RvRW5kICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHQucXVldWUgPSB0aGlzLm9wdGlvbnMucXVldWU7XHJcbiAgICAgICAgICAgIHQuZWxlbSA9IHRoaXMuZWxlbTtcclxuICAgICAgICAgICAgdC5zYXZlU3RhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGlmICggc2VsZi5vcHRpb25zLmhpZGUgJiYgalF1ZXJ5Ll9kYXRhKCBzZWxmLmVsZW0sIFwiZnhzaG93XCIgKyBzZWxmLnByb3AgKSA9PT0gdW5kZWZpbmVkICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5fZGF0YSggc2VsZi5lbGVtLCBcImZ4c2hvd1wiICsgc2VsZi5wcm9wLCBzZWxmLnN0YXJ0ICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBpZiAoIHQoKSAmJiBqUXVlcnkudGltZXJzLnB1c2godCkgJiYgIXRpbWVySWQgKSB7XHJcbiAgICAgICAgICAgICAgICB0aW1lcklkID0gc2V0SW50ZXJ2YWwoIGZ4LnRpY2ssIGZ4LmludGVydmFsICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBTaW1wbGUgJ3Nob3cnIGZ1bmN0aW9uXHJcbiAgICAgICAgc2hvdzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhU2hvdyA9IGpRdWVyeS5fZGF0YSggdGhpcy5lbGVtLCBcImZ4c2hvd1wiICsgdGhpcy5wcm9wICk7XHJcblxyXG4gICAgICAgICAgICAvLyBSZW1lbWJlciB3aGVyZSB3ZSBzdGFydGVkLCBzbyB0aGF0IHdlIGNhbiBnbyBiYWNrIHRvIGl0IGxhdGVyXHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vcmlnWyB0aGlzLnByb3AgXSA9IGRhdGFTaG93IHx8IGpRdWVyeS5zdHlsZSggdGhpcy5lbGVtLCB0aGlzLnByb3AgKTtcclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNob3cgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgLy8gQmVnaW4gdGhlIGFuaW1hdGlvblxyXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB3ZSBzdGFydCBhdCBhIHNtYWxsIHdpZHRoL2hlaWdodCB0byBhdm9pZCBhbnkgZmxhc2ggb2YgY29udGVudFxyXG4gICAgICAgICAgICBpZiAoIGRhdGFTaG93ICE9PSB1bmRlZmluZWQgKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3cgaXMgcGlja2luZyB1cCB3aGVyZSBhIHByZXZpb3VzIGhpZGUgb3Igc2hvdyBsZWZ0IG9mZlxyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXN0b20oIHRoaXMuY3VyKCksIGRhdGFTaG93ICk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1c3RvbSggdGhpcy5wcm9wID09PSBcIndpZHRoXCIgfHwgdGhpcy5wcm9wID09PSBcImhlaWdodFwiID8gMSA6IDAsIHRoaXMuY3VyKCkgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU3RhcnQgYnkgc2hvd2luZyB0aGUgZWxlbWVudFxyXG4gICAgICAgICAgICBqUXVlcnkoIHRoaXMuZWxlbSApLnNob3coKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBTaW1wbGUgJ2hpZGUnIGZ1bmN0aW9uXHJcbiAgICAgICAgaGlkZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIC8vIFJlbWVtYmVyIHdoZXJlIHdlIHN0YXJ0ZWQsIHNvIHRoYXQgd2UgY2FuIGdvIGJhY2sgdG8gaXQgbGF0ZXJcclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9yaWdbIHRoaXMucHJvcCBdID0galF1ZXJ5Ll9kYXRhKCB0aGlzLmVsZW0sIFwiZnhzaG93XCIgKyB0aGlzLnByb3AgKSB8fCBqUXVlcnkuc3R5bGUoIHRoaXMuZWxlbSwgdGhpcy5wcm9wICk7XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5oaWRlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIC8vIEJlZ2luIHRoZSBhbmltYXRpb25cclxuICAgICAgICAgICAgdGhpcy5jdXN0b20oIHRoaXMuY3VyKCksIDAgKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBFYWNoIHN0ZXAgb2YgYW4gYW5pbWF0aW9uXHJcbiAgICAgICAgc3RlcDogZnVuY3Rpb24oIGdvdG9FbmQgKSB7XHJcbiAgICAgICAgICAgIHZhciBwLCBuLCBjb21wbGV0ZSxcclxuICAgICAgICAgICAgICAgIHQgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxyXG4gICAgICAgICAgICAgICAgZG9uZSA9IHRydWUsXHJcbiAgICAgICAgICAgICAgICBlbGVtID0gdGhpcy5lbGVtLFxyXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHJcbiAgICAgICAgICAgIGlmICggZ290b0VuZCB8fCB0ID49IG9wdGlvbnMuZHVyYXRpb24gKyB0aGlzLnN0YXJ0VGltZSApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubm93ID0gdGhpcy5lbmQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IHRoaXMuc3RhdGUgPSAxO1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmFuaW1hdGVkUHJvcGVydGllc1sgdGhpcy5wcm9wIF0gPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIHAgaW4gb3B0aW9ucy5hbmltYXRlZFByb3BlcnRpZXMgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBvcHRpb25zLmFuaW1hdGVkUHJvcGVydGllc1sgcCBdICE9PSB0cnVlICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICggZG9uZSApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgb3ZlcmZsb3dcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIG9wdGlvbnMub3ZlcmZsb3cgIT0gbnVsbCAmJiAhalF1ZXJ5LnN1cHBvcnQuc2hyaW5rV3JhcEJsb2NrcyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5lYWNoKCBbIFwiXCIsIFwiWFwiLCBcIllcIiBdLCBmdW5jdGlvbiggaW5kZXgsIHZhbHVlICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zdHlsZVsgXCJvdmVyZmxvd1wiICsgdmFsdWUgXSA9IG9wdGlvbnMub3ZlcmZsb3dbIGluZGV4IF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSGlkZSB0aGUgZWxlbWVudCBpZiB0aGUgXCJoaWRlXCIgb3BlcmF0aW9uIHdhcyBkb25lXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBvcHRpb25zLmhpZGUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeSggZWxlbSApLmhpZGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBwcm9wZXJ0aWVzLCBpZiB0aGUgaXRlbSBoYXMgYmVlbiBoaWRkZW4gb3Igc2hvd25cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIG9wdGlvbnMuaGlkZSB8fCBvcHRpb25zLnNob3cgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIHAgaW4gb3B0aW9ucy5hbmltYXRlZFByb3BlcnRpZXMgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuc3R5bGUoIGVsZW0sIHAsIG9wdGlvbnMub3JpZ1sgcCBdICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkucmVtb3ZlRGF0YSggZWxlbSwgXCJmeHNob3dcIiArIHAsIHRydWUgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRvZ2dsZSBkYXRhIGlzIG5vIGxvbmdlciBuZWVkZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVEYXRhKCBlbGVtLCBcInRvZ2dsZVwiICsgcCwgdHJ1ZSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBFeGVjdXRlIHRoZSBjb21wbGV0ZSBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGluIHRoZSBldmVudCB0aGF0IHRoZSBjb21wbGV0ZSBmdW5jdGlvbiB0aHJvd3MgYW4gZXhjZXB0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgbXVzdCBlbnN1cmUgaXQgd29uJ3QgYmUgY2FsbGVkIHR3aWNlLiAjNTY4NFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZSA9IG9wdGlvbnMuY29tcGxldGU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjb21wbGV0ZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY29tcGxldGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGUuY2FsbCggZWxlbSApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gY2xhc3NpY2FsIGVhc2luZyBjYW5ub3QgYmUgdXNlZCB3aXRoIGFuIEluZmluaXR5IGR1cmF0aW9uXHJcbiAgICAgICAgICAgICAgICBpZiAoIG9wdGlvbnMuZHVyYXRpb24gPT0gSW5maW5pdHkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3cgPSB0O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuID0gdCAtIHRoaXMuc3RhcnRUaW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBuIC8gb3B0aW9ucy5kdXJhdGlvbjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUGVyZm9ybSB0aGUgZWFzaW5nIGZ1bmN0aW9uLCBkZWZhdWx0cyB0byBzd2luZ1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9zID0galF1ZXJ5LmVhc2luZ1sgb3B0aW9ucy5hbmltYXRlZFByb3BlcnRpZXNbdGhpcy5wcm9wXSBdKCB0aGlzLnN0YXRlLCBuLCAwLCAxLCBvcHRpb25zLmR1cmF0aW9uICk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3cgPSB0aGlzLnN0YXJ0ICsgKCAodGhpcy5lbmQgLSB0aGlzLnN0YXJ0KSAqIHRoaXMucG9zICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBQZXJmb3JtIHRoZSBuZXh0IHN0ZXAgb2YgdGhlIGFuaW1hdGlvblxyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBqUXVlcnkuZXh0ZW5kKCBqUXVlcnkuZngsIHtcclxuICAgICAgICB0aWNrOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHRpbWVyLFxyXG4gICAgICAgICAgICAgICAgdGltZXJzID0galF1ZXJ5LnRpbWVycyxcclxuICAgICAgICAgICAgICAgIGkgPSAwO1xyXG5cclxuICAgICAgICAgICAgZm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgdGltZXIgPSB0aW1lcnNbIGkgXTtcclxuICAgICAgICAgICAgICAgIC8vIENoZWNrcyB0aGUgdGltZXIgaGFzIG5vdCBhbHJlYWR5IGJlZW4gcmVtb3ZlZFxyXG4gICAgICAgICAgICAgICAgaWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZXJzLnNwbGljZSggaS0tLCAxICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggIXRpbWVycy5sZW5ndGggKSB7XHJcbiAgICAgICAgICAgICAgICBqUXVlcnkuZnguc3RvcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgaW50ZXJ2YWw6IDEzLFxyXG5cclxuICAgICAgICBzdG9wOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCggdGltZXJJZCApO1xyXG4gICAgICAgICAgICB0aW1lcklkID0gbnVsbDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzcGVlZHM6IHtcclxuICAgICAgICAgICAgc2xvdzogNjAwLFxyXG4gICAgICAgICAgICBmYXN0OiAyMDAsXHJcbiAgICAgICAgICAgIC8vIERlZmF1bHQgc3BlZWRcclxuICAgICAgICAgICAgX2RlZmF1bHQ6IDQwMFxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHN0ZXA6IHtcclxuICAgICAgICAgICAgb3BhY2l0eTogZnVuY3Rpb24oIGZ4ICkge1xyXG4gICAgICAgICAgICAgICAgalF1ZXJ5LnN0eWxlKCBmeC5lbGVtLCBcIm9wYWNpdHlcIiwgZngubm93ICk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBfZGVmYXVsdDogZnVuY3Rpb24oIGZ4ICkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCBmeC5lbGVtLnN0eWxlICYmIGZ4LmVsZW0uc3R5bGVbIGZ4LnByb3AgXSAhPSBudWxsICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZ4LmVsZW0uc3R5bGVbIGZ4LnByb3AgXSA9IGZ4Lm5vdyArIGZ4LnVuaXQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGZ4LmVsZW1bIGZ4LnByb3AgXSA9IGZ4Lm5vdztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuLy8gQWRkcyB3aWR0aC9oZWlnaHQgc3RlcCBmdW5jdGlvbnNcclxuLy8gRG8gbm90IHNldCBhbnl0aGluZyBiZWxvdyAwXHJcbiAgICBqUXVlcnkuZWFjaChbIFwid2lkdGhcIiwgXCJoZWlnaHRcIiBdLCBmdW5jdGlvbiggaSwgcHJvcCApIHtcclxuICAgICAgICBqUXVlcnkuZnguc3RlcFsgcHJvcCBdID0gZnVuY3Rpb24oIGZ4ICkge1xyXG4gICAgICAgICAgICBqUXVlcnkuc3R5bGUoIGZ4LmVsZW0sIHByb3AsIE1hdGgubWF4KDAsIGZ4Lm5vdykgKyBmeC51bml0ICk7XHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG5cclxuICAgIGlmICggalF1ZXJ5LmV4cHIgJiYgalF1ZXJ5LmV4cHIuZmlsdGVycyApIHtcclxuICAgICAgICBqUXVlcnkuZXhwci5maWx0ZXJzLmFuaW1hdGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZ3JlcChqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcclxuICAgICAgICAgICAgfSkubGVuZ3RoO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4vLyBUcnkgdG8gcmVzdG9yZSB0aGUgZGVmYXVsdCBkaXNwbGF5IHZhbHVlIG9mIGFuIGVsZW1lbnRcclxuICAgIGZ1bmN0aW9uIGRlZmF1bHREaXNwbGF5KCBub2RlTmFtZSApIHtcclxuXHJcbiAgICAgICAgaWYgKCAhZWxlbWRpc3BsYXlbIG5vZGVOYW1lIF0gKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHksXHJcbiAgICAgICAgICAgICAgICBlbGVtID0galF1ZXJ5KCBcIjxcIiArIG5vZGVOYW1lICsgXCI+XCIgKS5hcHBlbmRUbyggYm9keSApLFxyXG4gICAgICAgICAgICAgICAgZGlzcGxheSA9IGVsZW0uY3NzKCBcImRpc3BsYXlcIiApO1xyXG4gICAgICAgICAgICBlbGVtLnJlbW92ZSgpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgdGhlIHNpbXBsZSB3YXkgZmFpbHMsXHJcbiAgICAgICAgICAgIC8vIGdldCBlbGVtZW50J3MgcmVhbCBkZWZhdWx0IGRpc3BsYXkgYnkgYXR0YWNoaW5nIGl0IHRvIGEgdGVtcCBpZnJhbWVcclxuICAgICAgICAgICAgaWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiB8fCBkaXNwbGF5ID09PSBcIlwiICkge1xyXG4gICAgICAgICAgICAgICAgLy8gTm8gaWZyYW1lIHRvIHVzZSB5ZXQsIHNvIGNyZWF0ZSBpdFxyXG4gICAgICAgICAgICAgICAgaWYgKCAhaWZyYW1lICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaWZyYW1lXCIgKTtcclxuICAgICAgICAgICAgICAgICAgICBpZnJhbWUuZnJhbWVCb3JkZXIgPSBpZnJhbWUud2lkdGggPSBpZnJhbWUuaGVpZ2h0ID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBib2R5LmFwcGVuZENoaWxkKCBpZnJhbWUgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBjYWNoZWFibGUgY29weSBvZiB0aGUgaWZyYW1lIGRvY3VtZW50IG9uIGZpcnN0IGNhbGwuXHJcbiAgICAgICAgICAgICAgICAvLyBJRSBhbmQgT3BlcmEgd2lsbCBhbGxvdyB1cyB0byByZXVzZSB0aGUgaWZyYW1lRG9jIHdpdGhvdXQgcmUtd3JpdGluZyB0aGUgZmFrZSBIVE1MXHJcbiAgICAgICAgICAgICAgICAvLyBkb2N1bWVudCB0byBpdDsgV2ViS2l0ICYgRmlyZWZveCB3b24ndCBhbGxvdyByZXVzaW5nIHRoZSBpZnJhbWUgZG9jdW1lbnQuXHJcbiAgICAgICAgICAgICAgICBpZiAoICFpZnJhbWVEb2MgfHwgIWlmcmFtZS5jcmVhdGVFbGVtZW50ICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmcmFtZURvYyA9ICggaWZyYW1lLmNvbnRlbnRXaW5kb3cgfHwgaWZyYW1lLmNvbnRlbnREb2N1bWVudCApLmRvY3VtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmcmFtZURvYy53cml0ZSggKCBkb2N1bWVudC5jb21wYXRNb2RlID09PSBcIkNTUzFDb21wYXRcIiA/IFwiPCFkb2N0eXBlIGh0bWw+XCIgOiBcIlwiICkgKyBcIjxodG1sPjxib2R5PlwiICk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWZyYW1lRG9jLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZWxlbSA9IGlmcmFtZURvYy5jcmVhdGVFbGVtZW50KCBub2RlTmFtZSApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmcmFtZURvYy5ib2R5LmFwcGVuZENoaWxkKCBlbGVtICk7XHJcblxyXG4gICAgICAgICAgICAgICAgZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XHJcbiAgICAgICAgICAgICAgICBib2R5LnJlbW92ZUNoaWxkKCBpZnJhbWUgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU3RvcmUgdGhlIGNvcnJlY3QgZGVmYXVsdCBkaXNwbGF5XHJcbiAgICAgICAgICAgIGVsZW1kaXNwbGF5WyBub2RlTmFtZSBdID0gZGlzcGxheTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBlbGVtZGlzcGxheVsgbm9kZU5hbWUgXTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuXHJcbiAgICB2YXIgcnRhYmxlID0gL150KD86YWJsZXxkfGgpJC9pLFxyXG4gICAgICAgIHJyb290ID0gL14oPzpib2R5fGh0bWwpJC9pO1xyXG5cclxuICAgIGlmICggXCJnZXRCb3VuZGluZ0NsaWVudFJlY3RcIiBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgKSB7XHJcbiAgICAgICAgalF1ZXJ5LmZuLm9mZnNldCA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xyXG4gICAgICAgICAgICB2YXIgZWxlbSA9IHRoaXNbMF0sIGJveDtcclxuXHJcbiAgICAgICAgICAgIGlmICggb3B0aW9ucyApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoICFlbGVtIHx8ICFlbGVtLm93bmVyRG9jdW1lbnQgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBlbGVtID09PSBlbGVtLm93bmVyRG9jdW1lbnQuYm9keSApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkub2Zmc2V0LmJvZHlPZmZzZXQoIGVsZW0gKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGJveCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2goZSkge31cclxuXHJcbiAgICAgICAgICAgIHZhciBkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQsXHJcbiAgICAgICAgICAgICAgICBkb2NFbGVtID0gZG9jLmRvY3VtZW50RWxlbWVudDtcclxuXHJcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSdyZSBub3QgZGVhbGluZyB3aXRoIGEgZGlzY29ubmVjdGVkIERPTSBub2RlXHJcbiAgICAgICAgICAgIGlmICggIWJveCB8fCAhalF1ZXJ5LmNvbnRhaW5zKCBkb2NFbGVtLCBlbGVtICkgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYm94ID8geyB0b3A6IGJveC50b3AsIGxlZnQ6IGJveC5sZWZ0IH0gOiB7IHRvcDogMCwgbGVmdDogMCB9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgYm9keSA9IGRvYy5ib2R5LFxyXG4gICAgICAgICAgICAgICAgd2luID0gZ2V0V2luZG93KGRvYyksXHJcbiAgICAgICAgICAgICAgICBjbGllbnRUb3AgID0gZG9jRWxlbS5jbGllbnRUb3AgIHx8IGJvZHkuY2xpZW50VG9wICB8fCAwLFxyXG4gICAgICAgICAgICAgICAgY2xpZW50TGVmdCA9IGRvY0VsZW0uY2xpZW50TGVmdCB8fCBib2R5LmNsaWVudExlZnQgfHwgMCxcclxuICAgICAgICAgICAgICAgIHNjcm9sbFRvcCAgPSB3aW4ucGFnZVlPZmZzZXQgfHwgalF1ZXJ5LnN1cHBvcnQuYm94TW9kZWwgJiYgZG9jRWxlbS5zY3JvbGxUb3AgIHx8IGJvZHkuc2Nyb2xsVG9wLFxyXG4gICAgICAgICAgICAgICAgc2Nyb2xsTGVmdCA9IHdpbi5wYWdlWE9mZnNldCB8fCBqUXVlcnkuc3VwcG9ydC5ib3hNb2RlbCAmJiBkb2NFbGVtLnNjcm9sbExlZnQgfHwgYm9keS5zY3JvbGxMZWZ0LFxyXG4gICAgICAgICAgICAgICAgdG9wICA9IGJveC50b3AgICsgc2Nyb2xsVG9wICAtIGNsaWVudFRvcCxcclxuICAgICAgICAgICAgICAgIGxlZnQgPSBib3gubGVmdCArIHNjcm9sbExlZnQgLSBjbGllbnRMZWZ0O1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfTtcclxuICAgICAgICB9O1xyXG5cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgalF1ZXJ5LmZuLm9mZnNldCA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xyXG4gICAgICAgICAgICB2YXIgZWxlbSA9IHRoaXNbMF07XHJcblxyXG4gICAgICAgICAgICBpZiAoIG9wdGlvbnMgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5vZmZzZXQuc2V0T2Zmc2V0KCB0aGlzLCBvcHRpb25zLCBpICk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCAhZWxlbSB8fCAhZWxlbS5vd25lckRvY3VtZW50ICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggZWxlbSA9PT0gZWxlbS5vd25lckRvY3VtZW50LmJvZHkgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5Lm9mZnNldC5ib2R5T2Zmc2V0KCBlbGVtICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBjb21wdXRlZFN0eWxlLFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0UGFyZW50ID0gZWxlbS5vZmZzZXRQYXJlbnQsXHJcbiAgICAgICAgICAgICAgICBwcmV2T2Zmc2V0UGFyZW50ID0gZWxlbSxcclxuICAgICAgICAgICAgICAgIGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudCxcclxuICAgICAgICAgICAgICAgIGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgYm9keSA9IGRvYy5ib2R5LFxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdFZpZXcgPSBkb2MuZGVmYXVsdFZpZXcsXHJcbiAgICAgICAgICAgICAgICBwcmV2Q29tcHV0ZWRTdHlsZSA9IGRlZmF1bHRWaWV3ID8gZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSwgbnVsbCApIDogZWxlbS5jdXJyZW50U3R5bGUsXHJcbiAgICAgICAgICAgICAgICB0b3AgPSBlbGVtLm9mZnNldFRvcCxcclxuICAgICAgICAgICAgICAgIGxlZnQgPSBlbGVtLm9mZnNldExlZnQ7XHJcblxyXG4gICAgICAgICAgICB3aGlsZSAoIChlbGVtID0gZWxlbS5wYXJlbnROb2RlKSAmJiBlbGVtICE9PSBib2R5ICYmIGVsZW0gIT09IGRvY0VsZW0gKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIGpRdWVyeS5zdXBwb3J0LmZpeGVkUG9zaXRpb24gJiYgcHJldkNvbXB1dGVkU3R5bGUucG9zaXRpb24gPT09IFwiZml4ZWRcIiApIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjb21wdXRlZFN0eWxlID0gZGVmYXVsdFZpZXcgPyBkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsZW0sIG51bGwpIDogZWxlbS5jdXJyZW50U3R5bGU7XHJcbiAgICAgICAgICAgICAgICB0b3AgIC09IGVsZW0uc2Nyb2xsVG9wO1xyXG4gICAgICAgICAgICAgICAgbGVmdCAtPSBlbGVtLnNjcm9sbExlZnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBlbGVtID09PSBvZmZzZXRQYXJlbnQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9wICArPSBlbGVtLm9mZnNldFRvcDtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0ICs9IGVsZW0ub2Zmc2V0TGVmdDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBqUXVlcnkuc3VwcG9ydC5kb2VzTm90QWRkQm9yZGVyICYmICEoalF1ZXJ5LnN1cHBvcnQuZG9lc0FkZEJvcmRlckZvclRhYmxlQW5kQ2VsbHMgJiYgcnRhYmxlLnRlc3QoZWxlbS5ub2RlTmFtZSkpICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgICs9IHBhcnNlRmxvYXQoIGNvbXB1dGVkU3R5bGUuYm9yZGVyVG9wV2lkdGggICkgfHwgMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCArPSBwYXJzZUZsb2F0KCBjb21wdXRlZFN0eWxlLmJvcmRlckxlZnRXaWR0aCApIHx8IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBwcmV2T2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFBhcmVudCA9IGVsZW0ub2Zmc2V0UGFyZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICggalF1ZXJ5LnN1cHBvcnQuc3VidHJhY3RzQm9yZGVyRm9yT3ZlcmZsb3dOb3RWaXNpYmxlICYmIGNvbXB1dGVkU3R5bGUub3ZlcmZsb3cgIT09IFwidmlzaWJsZVwiICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvcCAgKz0gcGFyc2VGbG9hdCggY29tcHV0ZWRTdHlsZS5ib3JkZXJUb3BXaWR0aCAgKSB8fCAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgKz0gcGFyc2VGbG9hdCggY29tcHV0ZWRTdHlsZS5ib3JkZXJMZWZ0V2lkdGggKSB8fCAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHByZXZDb21wdXRlZFN0eWxlID0gY29tcHV0ZWRTdHlsZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBwcmV2Q29tcHV0ZWRTdHlsZS5wb3NpdGlvbiA9PT0gXCJyZWxhdGl2ZVwiIHx8IHByZXZDb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xyXG4gICAgICAgICAgICAgICAgdG9wICArPSBib2R5Lm9mZnNldFRvcDtcclxuICAgICAgICAgICAgICAgIGxlZnQgKz0gYm9keS5vZmZzZXRMZWZ0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIGpRdWVyeS5zdXBwb3J0LmZpeGVkUG9zaXRpb24gJiYgcHJldkNvbXB1dGVkU3R5bGUucG9zaXRpb24gPT09IFwiZml4ZWRcIiApIHtcclxuICAgICAgICAgICAgICAgIHRvcCAgKz0gTWF0aC5tYXgoIGRvY0VsZW0uc2Nyb2xsVG9wLCBib2R5LnNjcm9sbFRvcCApO1xyXG4gICAgICAgICAgICAgICAgbGVmdCArPSBNYXRoLm1heCggZG9jRWxlbS5zY3JvbGxMZWZ0LCBib2R5LnNjcm9sbExlZnQgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGpRdWVyeS5vZmZzZXQgPSB7XHJcblxyXG4gICAgICAgIGJvZHlPZmZzZXQ6IGZ1bmN0aW9uKCBib2R5ICkge1xyXG4gICAgICAgICAgICB2YXIgdG9wID0gYm9keS5vZmZzZXRUb3AsXHJcbiAgICAgICAgICAgICAgICBsZWZ0ID0gYm9keS5vZmZzZXRMZWZ0O1xyXG5cclxuICAgICAgICAgICAgaWYgKCBqUXVlcnkuc3VwcG9ydC5kb2VzTm90SW5jbHVkZU1hcmdpbkluQm9keU9mZnNldCApIHtcclxuICAgICAgICAgICAgICAgIHRvcCAgKz0gcGFyc2VGbG9hdCggalF1ZXJ5LmNzcyhib2R5LCBcIm1hcmdpblRvcFwiKSApIHx8IDA7XHJcbiAgICAgICAgICAgICAgICBsZWZ0ICs9IHBhcnNlRmxvYXQoIGpRdWVyeS5jc3MoYm9keSwgXCJtYXJnaW5MZWZ0XCIpICkgfHwgMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xyXG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cclxuICAgICAgICAgICAgaWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcclxuICAgICAgICAgICAgICAgIGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBjdXJFbGVtID0galF1ZXJ5KCBlbGVtICksXHJcbiAgICAgICAgICAgICAgICBjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpLFxyXG4gICAgICAgICAgICAgICAgY3VyQ1NTVG9wID0galF1ZXJ5LmNzcyggZWxlbSwgXCJ0b3BcIiApLFxyXG4gICAgICAgICAgICAgICAgY3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwibGVmdFwiICksXHJcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiYgalF1ZXJ5LmluQXJyYXkoXCJhdXRvXCIsIFtjdXJDU1NUb3AsIGN1ckNTU0xlZnRdKSA+IC0xLFxyXG4gICAgICAgICAgICAgICAgcHJvcHMgPSB7fSwgY3VyUG9zaXRpb24gPSB7fSwgY3VyVG9wLCBjdXJMZWZ0O1xyXG5cclxuICAgICAgICAgICAgLy8gbmVlZCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbiBpZiBlaXRoZXIgdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXHJcbiAgICAgICAgICAgIGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcclxuICAgICAgICAgICAgICAgIGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcclxuICAgICAgICAgICAgICAgIGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcclxuICAgICAgICAgICAgICAgIGN1ckxlZnQgPSBwYXJzZUZsb2F0KCBjdXJDU1NMZWZ0ICkgfHwgMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggb3B0aW9ucyApICkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMuY2FsbCggZWxlbSwgaSwgY3VyT2Zmc2V0ICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggb3B0aW9ucy50b3AgIT0gbnVsbCApIHtcclxuICAgICAgICAgICAgICAgIHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCBvcHRpb25zLmxlZnQgIT0gbnVsbCApIHtcclxuICAgICAgICAgICAgICAgIHByb3BzLmxlZnQgPSAoIG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0ICkgKyBjdXJMZWZ0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIFwidXNpbmdcIiBpbiBvcHRpb25zICkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy51c2luZy5jYWxsKCBlbGVtLCBwcm9wcyApO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY3VyRWxlbS5jc3MoIHByb3BzICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcclxuXHJcbiAgICAgICAgcG9zaXRpb246IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoICF0aGlzWzBdICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBlbGVtID0gdGhpc1swXSxcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCAqcmVhbCogb2Zmc2V0UGFyZW50XHJcbiAgICAgICAgICAgICAgICBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCgpLFxyXG5cclxuICAgICAgICAgICAgLy8gR2V0IGNvcnJlY3Qgb2Zmc2V0c1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0ICAgICAgID0gdGhpcy5vZmZzZXQoKSxcclxuICAgICAgICAgICAgICAgIHBhcmVudE9mZnNldCA9IHJyb290LnRlc3Qob2Zmc2V0UGFyZW50WzBdLm5vZGVOYW1lKSA/IHsgdG9wOiAwLCBsZWZ0OiAwIH0gOiBvZmZzZXRQYXJlbnQub2Zmc2V0KCk7XHJcblxyXG4gICAgICAgICAgICAvLyBTdWJ0cmFjdCBlbGVtZW50IG1hcmdpbnNcclxuICAgICAgICAgICAgLy8gbm90ZTogd2hlbiBhbiBlbGVtZW50IGhhcyBtYXJnaW46IGF1dG8gdGhlIG9mZnNldExlZnQgYW5kIG1hcmdpbkxlZnRcclxuICAgICAgICAgICAgLy8gYXJlIHRoZSBzYW1lIGluIFNhZmFyaSBjYXVzaW5nIG9mZnNldC5sZWZ0IHRvIGluY29ycmVjdGx5IGJlIDBcclxuICAgICAgICAgICAgb2Zmc2V0LnRvcCAgLT0gcGFyc2VGbG9hdCggalF1ZXJ5LmNzcyhlbGVtLCBcIm1hcmdpblRvcFwiKSApIHx8IDA7XHJcbiAgICAgICAgICAgIG9mZnNldC5sZWZ0IC09IHBhcnNlRmxvYXQoIGpRdWVyeS5jc3MoZWxlbSwgXCJtYXJnaW5MZWZ0XCIpICkgfHwgMDtcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCBvZmZzZXRQYXJlbnQgYm9yZGVyc1xyXG4gICAgICAgICAgICBwYXJlbnRPZmZzZXQudG9wICArPSBwYXJzZUZsb2F0KCBqUXVlcnkuY3NzKG9mZnNldFBhcmVudFswXSwgXCJib3JkZXJUb3BXaWR0aFwiKSApIHx8IDA7XHJcbiAgICAgICAgICAgIHBhcmVudE9mZnNldC5sZWZ0ICs9IHBhcnNlRmxvYXQoIGpRdWVyeS5jc3Mob2Zmc2V0UGFyZW50WzBdLCBcImJvcmRlckxlZnRXaWR0aFwiKSApIHx8IDA7XHJcblxyXG4gICAgICAgICAgICAvLyBTdWJ0cmFjdCB0aGUgdHdvIG9mZnNldHNcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHRvcDogIG9mZnNldC50b3AgIC0gcGFyZW50T2Zmc2V0LnRvcCxcclxuICAgICAgICAgICAgICAgIGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnQuYm9keTtcclxuICAgICAgICAgICAgICAgIHdoaWxlICggb2Zmc2V0UGFyZW50ICYmICghcnJvb3QudGVzdChvZmZzZXRQYXJlbnQubm9kZU5hbWUpICYmIGpRdWVyeS5jc3Mob2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIpID09PSBcInN0YXRpY1wiKSApIHtcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9mZnNldFBhcmVudDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG5cclxuLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXHJcbiAgICBqUXVlcnkuZWFjaCggW1wiTGVmdFwiLCBcIlRvcFwiXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XHJcbiAgICAgICAgdmFyIG1ldGhvZCA9IFwic2Nyb2xsXCIgKyBuYW1lO1xyXG5cclxuICAgICAgICBqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcclxuICAgICAgICAgICAgdmFyIGVsZW0sIHdpbjtcclxuXHJcbiAgICAgICAgICAgIGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtID0gdGhpc1sgMCBdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggIWVsZW0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgd2luID0gZ2V0V2luZG93KCBlbGVtICk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBzY3JvbGwgb2Zmc2V0XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luID8gKFwicGFnZVhPZmZzZXRcIiBpbiB3aW4pID8gd2luWyBpID8gXCJwYWdlWU9mZnNldFwiIDogXCJwYWdlWE9mZnNldFwiIF0gOlxyXG4gICAgICAgICAgICAgICAgalF1ZXJ5LnN1cHBvcnQuYm94TW9kZWwgJiYgd2luLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgbWV0aG9kIF0gfHxcclxuICAgICAgICAgICAgICAgIHdpbi5kb2N1bWVudC5ib2R5WyBtZXRob2QgXSA6XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbVsgbWV0aG9kIF07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNldCB0aGUgc2Nyb2xsIG9mZnNldFxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgd2luID0gZ2V0V2luZG93KCB0aGlzICk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCB3aW4gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2luLnNjcm9sbFRvKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhaSA/IHZhbCA6IGpRdWVyeSggd2luICkuc2Nyb2xsTGVmdCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpID8gdmFsIDogalF1ZXJ5KCB3aW4gKS5zY3JvbGxUb3AoKVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzWyBtZXRob2QgXSA9IHZhbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG5cclxuICAgIGZ1bmN0aW9uIGdldFdpbmRvdyggZWxlbSApIHtcclxuICAgICAgICByZXR1cm4galF1ZXJ5LmlzV2luZG93KCBlbGVtICkgP1xyXG4gICAgICAgICAgICBlbGVtIDpcclxuICAgICAgICAgICAgZWxlbS5ub2RlVHlwZSA9PT0gOSA/XHJcbiAgICAgICAgICAgIGVsZW0uZGVmYXVsdFZpZXcgfHwgZWxlbS5wYXJlbnRXaW5kb3cgOlxyXG4gICAgICAgICAgICAgICAgZmFsc2U7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcblxyXG4vLyBDcmVhdGUgd2lkdGgsIGhlaWdodCwgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcclxuICAgIGpRdWVyeS5lYWNoKFsgXCJIZWlnaHRcIiwgXCJXaWR0aFwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xyXG5cclxuICAgICAgICB2YXIgdHlwZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgICAgICAgLy8gaW5uZXJIZWlnaHQgYW5kIGlubmVyV2lkdGhcclxuICAgICAgICBqUXVlcnkuZm5bIFwiaW5uZXJcIiArIG5hbWUgXSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgZWxlbSA9IHRoaXNbMF07XHJcbiAgICAgICAgICAgIHJldHVybiBlbGVtID9cclxuICAgICAgICAgICAgICAgIGVsZW0uc3R5bGUgP1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoIGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIFwicGFkZGluZ1wiICkgKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpc1sgdHlwZSBdKCkgOlxyXG4gICAgICAgICAgICAgICAgbnVsbDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aFxyXG4gICAgICAgIGpRdWVyeS5mblsgXCJvdXRlclwiICsgbmFtZSBdID0gZnVuY3Rpb24oIG1hcmdpbiApIHtcclxuICAgICAgICAgICAgdmFyIGVsZW0gPSB0aGlzWzBdO1xyXG4gICAgICAgICAgICByZXR1cm4gZWxlbSA/XHJcbiAgICAgICAgICAgICAgICBlbGVtLnN0eWxlID9cclxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KCBqUXVlcnkuY3NzKCBlbGVtLCB0eXBlLCBtYXJnaW4gPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApICkgOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXNbIHR5cGUgXSgpIDpcclxuICAgICAgICAgICAgICAgIG51bGw7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgalF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggc2l6ZSApIHtcclxuICAgICAgICAgICAgLy8gR2V0IHdpbmRvdyB3aWR0aCBvciBoZWlnaHRcclxuICAgICAgICAgICAgdmFyIGVsZW0gPSB0aGlzWzBdO1xyXG4gICAgICAgICAgICBpZiAoICFlbGVtICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpemUgPT0gbnVsbCA/IG51bGwgOiB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBzaXplICkgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZlsgdHlwZSBdKCBzaXplLmNhbGwoIHRoaXMsIGksIHNlbGZbIHR5cGUgXSgpICkgKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xyXG4gICAgICAgICAgICAgICAgLy8gRXZlcnlvbmUgZWxzZSB1c2UgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IG9yIGRvY3VtZW50LmJvZHkgZGVwZW5kaW5nIG9uIFF1aXJrcyB2cyBTdGFuZGFyZHMgbW9kZVxyXG4gICAgICAgICAgICAgICAgLy8gM3JkIGNvbmRpdGlvbiBhbGxvd3MgTm9raWEgc3VwcG9ydCwgYXMgaXQgc3VwcG9ydHMgdGhlIGRvY0VsZW0gcHJvcCBidXQgbm90IENTUzFDb21wYXRcclxuICAgICAgICAgICAgICAgIHZhciBkb2NFbGVtUHJvcCA9IGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdLFxyXG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSBlbGVtLmRvY3VtZW50LmJvZHk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5kb2N1bWVudC5jb21wYXRNb2RlID09PSBcIkNTUzFDb21wYXRcIiAmJiBkb2NFbGVtUHJvcCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGJvZHkgJiYgYm9keVsgXCJjbGllbnRcIiArIG5hbWUgXSB8fCBkb2NFbGVtUHJvcDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0sIHdoaWNoZXZlciBpcyBncmVhdGVyXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5kb2N1bWVudEVsZW1lbnRbXCJjbGllbnRcIiArIG5hbWVdLFxyXG4gICAgICAgICAgICAgICAgICAgIGVsZW0uYm9keVtcInNjcm9sbFwiICsgbmFtZV0sIGVsZW0uZG9jdW1lbnRFbGVtZW50W1wic2Nyb2xsXCIgKyBuYW1lXSxcclxuICAgICAgICAgICAgICAgICAgICBlbGVtLmJvZHlbXCJvZmZzZXRcIiArIG5hbWVdLCBlbGVtLmRvY3VtZW50RWxlbWVudFtcIm9mZnNldFwiICsgbmFtZV1cclxuICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gR2V0IG9yIHNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcclxuICAgICAgICAgICAgfSBlbHNlIGlmICggc2l6ZSA9PT0gdW5kZWZpbmVkICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9yaWcgPSBqUXVlcnkuY3NzKCBlbGVtLCB0eXBlICksXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gcGFyc2VGbG9hdCggb3JpZyApO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkuaXNOdW1lcmljKCByZXQgKSA/IHJldCA6IG9yaWc7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU2V0IHRoZSB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQgKGRlZmF1bHQgdG8gcGl4ZWxzIGlmIHZhbHVlIGlzIHVuaXRsZXNzKVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3NzKCB0eXBlLCB0eXBlb2Ygc2l6ZSA9PT0gXCJzdHJpbmdcIiA/IHNpemUgOiBzaXplICsgXCJweFwiICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0pO1xyXG5cclxuXHJcblxyXG5cclxuLy8gRXhwb3NlIGpRdWVyeSB0byB0aGUgZ2xvYmFsIG9iamVjdFxyXG4gICAgd2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0galF1ZXJ5O1xyXG5cclxuLy8gRXhwb3NlIGpRdWVyeSBhcyBhbiBBTUQgbW9kdWxlLCBidXQgb25seSBmb3IgQU1EIGxvYWRlcnMgdGhhdFxyXG4vLyB1bmRlcnN0YW5kIHRoZSBpc3N1ZXMgd2l0aCBsb2FkaW5nIG11bHRpcGxlIHZlcnNpb25zIG9mIGpRdWVyeVxyXG4vLyBpbiBhIHBhZ2UgdGhhdCBhbGwgbWlnaHQgY2FsbCBkZWZpbmUoKS4gVGhlIGxvYWRlciB3aWxsIGluZGljYXRlXHJcbi8vIHRoZXkgaGF2ZSBzcGVjaWFsIGFsbG93YW5jZXMgZm9yIG11bHRpcGxlIGpRdWVyeSB2ZXJzaW9ucyBieVxyXG4vLyBzcGVjaWZ5aW5nIGRlZmluZS5hbWQualF1ZXJ5ID0gdHJ1ZS4gUmVnaXN0ZXIgYXMgYSBuYW1lZCBtb2R1bGUsXHJcbi8vIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXIgZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSxcclxuLy8gYnV0IG5vdCB1c2UgYSBwcm9wZXIgY29uY2F0ZW5hdGlvbiBzY3JpcHQgdGhhdCB1bmRlcnN0YW5kcyBhbm9ueW1vdXNcclxuLy8gQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3Qgd2F5IHRvIHJlZ2lzdGVyLlxyXG4vLyBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZSBkZXJpdmVkIGZyb21cclxuLy8gZmlsZSBuYW1lcywgYW5kIGpRdWVyeSBpcyBub3JtYWxseSBkZWxpdmVyZWQgaW4gYSBsb3dlcmNhc2UgZmlsZSBuYW1lLlxyXG4vLyBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzIHRvIGNhbGxcclxuLy8gbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cclxuICAgIGlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgJiYgZGVmaW5lLmFtZC5qUXVlcnkgKSB7XHJcbiAgICAgICAgZGVmaW5lKCBcImpxdWVyeVwiLCBbXSwgZnVuY3Rpb24gKCkgeyByZXR1cm4galF1ZXJ5OyB9ICk7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbn0pKCB3aW5kb3cgKTtcclxuXHJcbndpbmRvdy5qUXVlcnkubm9Db25mbGljdCgpO1xyXG5yZXR1cm4gd2luZG93LmpRdWVyeTtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZSgndW5kZWZpbmVkJyA9PT0gdHlwZW9mIHdpbmRvdyA/IHVuZGVmaW5lZCA6IHdpbmRvdyk7XHJcbm1vZHVsZS5leHBvcnRzLmNyZWF0ZSA9IGNyZWF0ZTtcclxufSgpKTtcclxuIiwiLypcclxuICogQ29weXJpZ2h0IDIwMTIgU21hbGwgQmF0Y2gsIEluYy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3RcclxuICogdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2ZcclxuICogdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUXHJcbiAqIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZVxyXG4gKiBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlclxyXG4gKiB0aGUgTGljZW5zZS5cclxuICovXHJcbjsoZnVuY3Rpb24od2luZG93LGRvY3VtZW50LHVuZGVmaW5lZCl7XHJcbmZ1bmN0aW9uIGkoYSl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbYV19fXZhciBqO2Z1bmN0aW9uIG4oYSxiKXt2YXIgYz1hcmd1bWVudHMubGVuZ3RoPjI/QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDIpOltdO3JldHVybiBmdW5jdGlvbigpe2MucHVzaC5hcHBseShjLGFyZ3VtZW50cyk7cmV0dXJuIGIuYXBwbHkoYSxjKX19O2Z1bmN0aW9uIG8oYSxiKXt0aGlzLks9YTt0aGlzLmM9Yn1vLnByb3RvdHlwZS5jcmVhdGVFbGVtZW50PWZ1bmN0aW9uKGEsYixjKXthPXRoaXMuSy5jcmVhdGVFbGVtZW50KGEpO2lmKGIpZm9yKHZhciBkIGluIGIpaWYoYi5oYXNPd25Qcm9wZXJ0eShkKSlkPT1cInN0eWxlXCI/cSh0aGlzLGEsYltkXSk6YS5zZXRBdHRyaWJ1dGUoZCxiW2RdKTtjJiZhLmFwcGVuZENoaWxkKHRoaXMuSy5jcmVhdGVUZXh0Tm9kZShjKSk7cmV0dXJuIGF9O2Z1bmN0aW9uIHIoYSxiLGMpe2E9YS5LLmdldEVsZW1lbnRzQnlUYWdOYW1lKGIpWzBdO2lmKCFhKWE9ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O2lmKGEmJmEubGFzdENoaWxkKXthLmluc2VydEJlZm9yZShjLGEubGFzdENoaWxkKTtyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2V9ZnVuY3Rpb24gYWEoYSxiKXtmdW5jdGlvbiBjKCl7ZG9jdW1lbnQuYm9keT9iKCk6c2V0VGltZW91dChjLDApfWMoKX1cclxuZnVuY3Rpb24gcyhhLGIpe2lmKGIucGFyZW50Tm9kZSl7Yi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGIpO3JldHVybiB0cnVlfXJldHVybiBmYWxzZX1mdW5jdGlvbiB0KGEsYil7cmV0dXJuIGEuY3JlYXRlRWxlbWVudChcImxpbmtcIix7cmVsOlwic3R5bGVzaGVldFwiLGhyZWY6Yn0pfWZ1bmN0aW9uIHUoYSxiKXtyZXR1cm4gYS5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIse3NyYzpifSl9ZnVuY3Rpb24gdihhLGIsYyl7YT1iLmNsYXNzTmFtZS5zcGxpdCgvXFxzKy8pO2Zvcih2YXIgZD0wLGU9YS5sZW5ndGg7ZDxlO2QrKylpZihhW2RdPT1jKXJldHVybjthLnB1c2goYyk7Yi5jbGFzc05hbWU9YS5qb2luKFwiIFwiKS5yZXBsYWNlKC9eXFxzKy8sXCJcIil9XHJcbmZ1bmN0aW9uIHcoYSxiLGMpe2E9Yi5jbGFzc05hbWUuc3BsaXQoL1xccysvKTtmb3IodmFyIGQ9W10sZT0wLGY9YS5sZW5ndGg7ZTxmO2UrKylhW2VdIT1jJiZkLnB1c2goYVtlXSk7Yi5jbGFzc05hbWU9ZC5qb2luKFwiIFwiKS5yZXBsYWNlKC9eXFxzKy8sXCJcIikucmVwbGFjZSgvXFxzKyQvLFwiXCIpfWZ1bmN0aW9uIHgoYSxiLGMpe2E9Yi5jbGFzc05hbWUuc3BsaXQoL1xccysvKTtiPTA7Zm9yKHZhciBkPWEubGVuZ3RoO2I8ZDtiKyspaWYoYVtiXT09YylyZXR1cm4gdHJ1ZTtyZXR1cm4gZmFsc2V9ZnVuY3Rpb24gcShhLGIsYyl7aWYoYS5jLmdldE5hbWUoKT09XCJNU0lFXCIpYi5zdHlsZS5jc3NUZXh0PWM7ZWxzZSBiLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsYyl9O2Z1bmN0aW9uIHkoYSxiLGMsZCxlLGYsZyxoKXt0aGlzLkJhPWE7dGhpcy5IYT1iO3RoaXMub2E9Yzt0aGlzLm5hPWQ7dGhpcy5FYT1lO3RoaXMuRGE9Zjt0aGlzLm1hPWc7dGhpcy5JYT1ofWo9eS5wcm90b3R5cGU7ai5nZXROYW1lPWkoXCJCYVwiKTtqLnhhPWkoXCJIYVwiKTtqLlk9aShcIm9hXCIpO2oudWE9aShcIm5hXCIpO2oudmE9aShcIkVhXCIpO2oud2E9aShcIkRhXCIpO2oudGE9aShcIm1hXCIpO2oudz1pKFwiSWFcIik7ZnVuY3Rpb24geihhLGIpe3RoaXMuYz1hO3RoaXMuaz1ifXZhciBiYT1uZXcgeShcIlVua25vd25cIixcIlVua25vd25cIixcIlVua25vd25cIixcIlVua25vd25cIixcIlVua25vd25cIixcIlVua25vd25cIix1bmRlZmluZWQsZmFsc2UpO3oucHJvdG90eXBlLnBhcnNlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYy5pbmRleE9mKFwiTVNJRVwiKSE9LTE/Y2EodGhpcyk6dGhpcy5jLmluZGV4T2YoXCJPcGVyYVwiKSE9LTE/ZGEodGhpcyk6dGhpcy5jLmluZGV4T2YoXCJBcHBsZVdlYktpdFwiKSE9LTE/ZWEodGhpcyk6dGhpcy5jLmluZGV4T2YoXCJHZWNrb1wiKSE9LTE/ZmEodGhpcyk6YmF9O1xyXG5mdW5jdGlvbiBBKGEpe3ZhciBiPUMoYSxhLmMsLyhpUG9kfGlQYWR8aVBob25lfEFuZHJvaWQpLywxKTtpZihiIT1cIlwiKXJldHVybiBiO2E9QyhhLGEuYywvKExpbnV4fE1hY19Qb3dlclBDfE1hY2ludG9zaHxXaW5kb3dzKS8sMSk7aWYoYSE9XCJcIil7aWYoYT09XCJNYWNfUG93ZXJQQ1wiKWE9XCJNYWNpbnRvc2hcIjtyZXR1cm4gYX1yZXR1cm5cIlVua25vd25cIn1mdW5jdGlvbiBEKGEpe3ZhciBiPUMoYSxhLmMsLyhPUyBYfFdpbmRvd3MgTlR8QW5kcm9pZCkgKFteOyldKykvLDIpO2lmKGIpcmV0dXJuIGI7aWYoYj1DKGEsYS5jLC8oaVBob25lICk/T1MgKFtcXGRfXSspLywyKSlyZXR1cm4gYjtpZihhPUMoYSxhLmMsL0xpbnV4IChbaVxcZF0rKS8sMSkpcmV0dXJuIGE7cmV0dXJuXCJVbmtub3duXCJ9XHJcbmZ1bmN0aW9uIGNhKGEpe3ZhciBiPUMoYSxhLmMsLyhNU0lFIFtcXGRcXHdcXC5dKykvLDEpO2lmKGIhPVwiXCIpe3ZhciBjPWIuc3BsaXQoXCIgXCIpO2I9Y1swXTtjPWNbMV07cmV0dXJuIG5ldyB5KGIsYyxiLGMsQShhKSxEKGEpLEUoYSxhLmspLEYoYSxjKT49Nil9cmV0dXJuIG5ldyB5KFwiTVNJRVwiLFwiVW5rbm93blwiLFwiTVNJRVwiLFwiVW5rbm93blwiLEEoYSksRChhKSxFKGEsYS5rKSxmYWxzZSl9XHJcbmZ1bmN0aW9uIGRhKGEpe3ZhciBiPVwiVW5rbm93blwiLGM9XCJVbmtub3duXCIsZD1DKGEsYS5jLC8oUHJlc3RvXFwvW1xcZFxcd1xcLl0rKS8sMSk7aWYoZCE9XCJcIil7Yz1kLnNwbGl0KFwiL1wiKTtiPWNbMF07Yz1jWzFdfWVsc2V7aWYoYS5jLmluZGV4T2YoXCJHZWNrb1wiKSE9LTEpYj1cIkdlY2tvXCI7ZD1DKGEsYS5jLC9ydjooW15cXCldKykvLDEpO2lmKGQhPVwiXCIpYz1kfWlmKGEuYy5pbmRleE9mKFwiVmVyc2lvbi9cIikhPS0xKXtkPUMoYSxhLmMsL1ZlcnNpb25cXC8oW1xcZFxcLl0rKS8sMSk7aWYoZCE9XCJcIilyZXR1cm4gbmV3IHkoXCJPcGVyYVwiLGQsYixjLEEoYSksRChhKSxFKGEsYS5rKSxGKGEsZCk+PTEwKX1kPUMoYSxhLmMsL09wZXJhW1xcLyBdKFtcXGRcXC5dKykvLDEpO2lmKGQhPVwiXCIpcmV0dXJuIG5ldyB5KFwiT3BlcmFcIixkLGIsYyxBKGEpLEQoYSksRShhLGEuayksRihhLGQpPj0xMCk7cmV0dXJuIG5ldyB5KFwiT3BlcmFcIixcIlVua25vd25cIixiLGMsQShhKSxEKGEpLEUoYSxhLmspLGZhbHNlKX1cclxuZnVuY3Rpb24gZWEoYSl7dmFyIGI9QShhKSxjPUQoYSksZD1DKGEsYS5jLC9BcHBsZVdlYktpdFxcLyhbXFxkXFwuXFwrXSspLywxKTtpZihkPT1cIlwiKWQ9XCJVbmtub3duXCI7dmFyIGU9XCJVbmtub3duXCI7aWYoYS5jLmluZGV4T2YoXCJDaHJvbWVcIikhPS0xKWU9XCJDaHJvbWVcIjtlbHNlIGlmKGEuYy5pbmRleE9mKFwiU2FmYXJpXCIpIT0tMSllPVwiU2FmYXJpXCI7ZWxzZSBpZihhLmMuaW5kZXhPZihcIkFkb2JlQUlSXCIpIT0tMSllPVwiQWRvYmVBSVJcIjt2YXIgZj1cIlVua25vd25cIjtpZihhLmMuaW5kZXhPZihcIlZlcnNpb24vXCIpIT0tMSlmPUMoYSxhLmMsL1ZlcnNpb25cXC8oW1xcZFxcLlxcd10rKS8sMSk7ZWxzZSBpZihlPT1cIkNocm9tZVwiKWY9QyhhLGEuYywvQ2hyb21lXFwvKFtcXGRcXC5dKykvLDEpO2Vsc2UgaWYoZT09XCJBZG9iZUFJUlwiKWY9QyhhLGEuYywvQWRvYmVBSVJcXC8oW1xcZFxcLl0rKS8sMSk7dmFyIGc9ZmFsc2U7aWYoZT09XCJBZG9iZUFJUlwiKXtnPUMoYSxmLC9cXGQrXFwuKFxcZCspLywxKTtnPUYoYSxmKT4yfHxcclxuRihhLGYpPT0yJiZwYXJzZUludChnLDEwKT49NX1lbHNle2c9QyhhLGQsL1xcZCtcXC4oXFxkKykvLDEpO2c9RihhLGQpPj01MjZ8fEYoYSxkKT49NTI1JiZwYXJzZUludChnLDEwKT49MTN9cmV0dXJuIG5ldyB5KGUsZixcIkFwcGxlV2ViS2l0XCIsZCxiLGMsRShhLGEuayksZyl9XHJcbmZ1bmN0aW9uIGZhKGEpe3ZhciBiPVwiVW5rbm93blwiLGM9XCJVbmtub3duXCIsZD1mYWxzZTtpZihhLmMuaW5kZXhPZihcIkZpcmVmb3hcIikhPS0xKXtiPVwiRmlyZWZveFwiO3ZhciBlPUMoYSxhLmMsL0ZpcmVmb3hcXC8oW1xcZFxcd1xcLl0rKS8sMSk7aWYoZSE9XCJcIil7ZD1DKGEsZSwvXFxkK1xcLihcXGQrKS8sMSk7Yz1lO2Q9ZSE9XCJcIiYmRihhLGUpPj0zJiZwYXJzZUludChkLDEwKT49NX19ZWxzZSBpZihhLmMuaW5kZXhPZihcIk1vemlsbGFcIikhPS0xKWI9XCJNb3ppbGxhXCI7ZT1DKGEsYS5jLC9ydjooW15cXCldKykvLDEpO2lmKGU9PVwiXCIpZT1cIlVua25vd25cIjtlbHNlIGlmKCFkKXtkPUYoYSxlKTt2YXIgZj1wYXJzZUludChDKGEsZSwvXFxkK1xcLihcXGQrKS8sMSksMTApLGc9cGFyc2VJbnQoQyhhLGUsL1xcZCtcXC5cXGQrXFwuKFxcZCspLywxKSwxMCk7ZD1kPjF8fGQ9PTEmJmY+OXx8ZD09MSYmZj09OSYmZz49Mnx8ZS5tYXRjaCgvMVxcLjlcXC4xYlsxMjNdLykhPW51bGx8fGUubWF0Y2goLzFcXC45XFwuMVxcLltcXGRcXC5dKy8pIT1cclxubnVsbH1yZXR1cm4gbmV3IHkoYixjLFwiR2Vja29cIixlLEEoYSksRChhKSxFKGEsYS5rKSxkKX1mdW5jdGlvbiBGKGEsYil7YT1DKGEsYiwvKFxcZCspLywxKTtpZihhIT1cIlwiKXJldHVybiBwYXJzZUludChhLDEwKTtyZXR1cm4tMX1mdW5jdGlvbiBDKGEsYixjLGQpe2lmKChhPWIubWF0Y2goYykpJiZhW2RdKXJldHVybiBhW2RdO3JldHVyblwiXCJ9ZnVuY3Rpb24gRShhLGIpe2lmKGIuZG9jdW1lbnRNb2RlKXJldHVybiBiLmRvY3VtZW50TW9kZX07ZnVuY3Rpb24gZ2EoYSxiLGMsZCl7dGhpcy5hPWE7dGhpcy5nPWI7dGhpcy5VPWM7dGhpcy5qPWR8fGhhO3RoaXMuaD1uZXcgRyhcIi1cIil9dmFyIGhhPVwid2ZcIjtmdW5jdGlvbiBIKGEpe3YoYS5hLGEuZyxhLmguZShhLmosXCJsb2FkaW5nXCIpKTtJKGEsXCJsb2FkaW5nXCIpfWZ1bmN0aW9uIEooYSl7dyhhLmEsYS5nLGEuaC5lKGEuaixcImxvYWRpbmdcIikpO3goYS5hLGEuZyxhLmguZShhLmosXCJhY3RpdmVcIikpfHx2KGEuYSxhLmcsYS5oLmUoYS5qLFwiaW5hY3RpdmVcIikpO0koYSxcImluYWN0aXZlXCIpfWZ1bmN0aW9uIGlhKGEpe3coYS5hLGEuZyxhLmguZShhLmosXCJsb2FkaW5nXCIpKTt3KGEuYSxhLmcsYS5oLmUoYS5qLFwiaW5hY3RpdmVcIikpO3YoYS5hLGEuZyxhLmguZShhLmosXCJhY3RpdmVcIikpO0koYSxcImFjdGl2ZVwiKX1mdW5jdGlvbiBJKGEsYixjLGQpe2EuVVtiXSYmYS5VW2JdKGMsZCl9O2Z1bmN0aW9uIGphKCl7dGhpcy5mYT17fX1mdW5jdGlvbiBrYShhLGIpe3ZhciBjPVtdO2Zvcih2YXIgZCBpbiBiKWlmKGIuaGFzT3duUHJvcGVydHkoZCkpe3ZhciBlPWEuZmFbZF07ZSYmYy5wdXNoKGUoYltkXSkpfXJldHVybiBjfTtmdW5jdGlvbiBMKGEsYixjLGQsZSl7dGhpcy5hPWE7dGhpcy5BPWI7dGhpcy5uPWM7dGhpcy51PWQ7dGhpcy5EPWU7dGhpcy5WPTA7dGhpcy5qYT10aGlzLmVhPWZhbHNlfUwucHJvdG90eXBlLndhdGNoPWZ1bmN0aW9uKGEsYixjLGQsZSl7Zm9yKHZhciBmPWEubGVuZ3RoLGc9MDtnPGY7ZysrKXt2YXIgaD1hW2ddO2JbaF18fChiW2hdPVtcIm40XCJdKTt0aGlzLlYrPWJbaF0ubGVuZ3RofWlmKGUpdGhpcy5lYT1lO2ZvcihnPTA7ZzxmO2crKyl7aD1hW2ddO2U9YltoXTtmb3IodmFyIGw9Y1toXSxrPTAsbT1lLmxlbmd0aDtrPG07aysrKXt2YXIgQj1lW2tdLHA9dGhpcy5BLEs9aDt2KHAuYSxwLmcscC5oLmUocC5qLEssQixcImxvYWRpbmdcIikpO0kocCxcImZvbnRsb2FkaW5nXCIsSyxCKTtwPW4odGhpcyx0aGlzLnFhKTtLPW4odGhpcyx0aGlzLnJhKTsobmV3IGQocCxLLHRoaXMuYSx0aGlzLm4sdGhpcy51LHRoaXMuRCxoLEIsbCkpLnN0YXJ0KCl9fX07XHJcbkwucHJvdG90eXBlLnFhPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5BO3coYy5hLGMuZyxjLmguZShjLmosYSxiLFwibG9hZGluZ1wiKSk7dyhjLmEsYy5nLGMuaC5lKGMuaixhLGIsXCJpbmFjdGl2ZVwiKSk7dihjLmEsYy5nLGMuaC5lKGMuaixhLGIsXCJhY3RpdmVcIikpO0koYyxcImZvbnRhY3RpdmVcIixhLGIpO3RoaXMuamE9dHJ1ZTtNKHRoaXMpfTtMLnByb3RvdHlwZS5yYT1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuQTt3KGMuYSxjLmcsYy5oLmUoYy5qLGEsYixcImxvYWRpbmdcIikpO3goYy5hLGMuZyxjLmguZShjLmosYSxiLFwiYWN0aXZlXCIpKXx8dihjLmEsYy5nLGMuaC5lKGMuaixhLGIsXCJpbmFjdGl2ZVwiKSk7SShjLFwiZm9udGluYWN0aXZlXCIsYSxiKTtNKHRoaXMpfTtmdW5jdGlvbiBNKGEpe2lmKC0tYS5WPT0wJiZhLmVhKWEuamE/aWEoYS5BKTpKKGEuQSl9O2Z1bmN0aW9uIE4oYSxiLGMsZCxlLGYsZyxoLGwpe3RoaXMuSD1hO3RoaXMuJD1iO3RoaXMuYT1jO3RoaXMubj1kO3RoaXMudT1lO3RoaXMuRD1mO3RoaXMuQWE9bmV3IGxhO3RoaXMudj1uZXcgTzt0aGlzLkw9Zzt0aGlzLkI9aDt0aGlzLnNhPWx8fG1hO3RoaXMuTz1uYSh0aGlzLG9hKTt0aGlzLlA9bmEodGhpcyxwYSk7dGhpcy5jYT10aGlzLk87dGhpcy5kYT10aGlzLlA7dGhpcy5RPVAodGhpcyxvYSk7dGhpcy5SPVAodGhpcyxwYSl9dmFyIG9hPVwiYXJpYWwsJ1VSVyBHb3RoaWMgTCcsc2Fucy1zZXJpZlwiLHBhPVwiR2VvcmdpYSwnQ2VudHVyeSBTY2hvb2xib29rIEwnLHNlcmlmXCIsbWE9XCJCRVNic3d5XCI7Ti5wcm90b3R5cGUuc3RhcnQ9ZnVuY3Rpb24oKXt0aGlzLmlhPXRoaXMuRCgpO3RoaXMuSigpfTtcclxuTi5wcm90b3R5cGUuSj1mdW5jdGlvbigpe3ZhciBhPXRoaXMubi5wKHRoaXMuUSksYj10aGlzLm4ucCh0aGlzLlIpO2lmKCh0aGlzLk8hPWF8fHRoaXMuUCE9YikmJnRoaXMuY2E9PWEmJnRoaXMuZGE9PWIpUSh0aGlzLHRoaXMuSCk7ZWxzZSBpZih0aGlzLkQoKS10aGlzLmlhPj01RTMpUSh0aGlzLHRoaXMuJCk7ZWxzZXt0aGlzLmNhPWE7dGhpcy5kYT1iO3FhKHRoaXMpfX07ZnVuY3Rpb24gcWEoYSl7YS51KGZ1bmN0aW9uKGIsYyl7cmV0dXJuIGZ1bmN0aW9uKCl7Yy5jYWxsKGIpfX0oYSxhLkopLDI1KX1mdW5jdGlvbiBRKGEsYil7cyhhLmEsYS5RKTtzKGEuYSxhLlIpO2IoYS5MLGEuQil9ZnVuY3Rpb24gbmEoYSxiKXtiPVAoYSxiLHRydWUpO3ZhciBjPWEubi5wKGIpO3MoYS5hLGIpO3JldHVybiBjfWZ1bmN0aW9uIFAoYSxiLGMpe2I9YS5hLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIse3N0eWxlOlIoYSxiLGEuQixjKX0sYS5zYSk7cihhLmEsXCJib2R5XCIsYik7cmV0dXJuIGJ9XHJcbmZ1bmN0aW9uIFIoYSxiLGMsZCl7Yz1hLnYuZXhwYW5kKGMpO3JldHVyblwicG9zaXRpb246YWJzb2x1dGU7dG9wOi05OTlweDtsZWZ0Oi05OTlweDtmb250LXNpemU6MzAwcHg7d2lkdGg6YXV0bztoZWlnaHQ6YXV0bztsaW5lLWhlaWdodDpub3JtYWw7bWFyZ2luOjA7cGFkZGluZzowO2ZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC1mYW1pbHk6XCIrKGQ/XCJcIjphLkFhLnF1b3RlKGEuTCkrXCIsXCIpK2IrXCI7XCIrY307ZnVuY3Rpb24gUyhhLGIsYyxkLGUpe3RoaXMuYT1hO3RoaXMuWD1iO3RoaXMuZz1jO3RoaXMudT1kO3RoaXMuYz1lO3RoaXMuTT10aGlzLk49MH1TLnByb3RvdHlwZS5xPWZ1bmN0aW9uKGEsYil7dGhpcy5YLmZhW2FdPWJ9O1MucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24oYSl7dmFyIGI9bmV3IGdhKHRoaXMuYSx0aGlzLmcsYSk7dGhpcy5jLncoKT9yYSh0aGlzLGIsYSk6SihiKX07Uy5wcm90b3R5cGUueWE9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9YS5aP2EuWigpOk47aWYoZClhLmxvYWQobih0aGlzLHRoaXMuQ2EsYixjLGUpKTtlbHNle2E9LS10aGlzLk49PTA7dGhpcy5NLS07aWYoYSl0aGlzLk09PTA/SihiKTpIKGIpO2Mud2F0Y2goW10se30se30sZSxhKX19O1xyXG5TLnByb3RvdHlwZS5DYT1mdW5jdGlvbihhLGIsYyxkLGUsZil7dmFyIGc9LS10aGlzLk49PTA7ZyYmSChhKTt0aGlzLnUobih0aGlzLGZ1bmN0aW9uKGgsbCxrLG0sQixwKXtoLndhdGNoKGwsa3x8e30sbXx8e30sQixwKX0sYixkLGUsZixjLGcpKX07ZnVuY3Rpb24gcmEoYSxiLGMpe2M9a2EoYS5YLGMpO2EuTT1hLk49Yy5sZW5ndGg7Zm9yKHZhciBkPW5ldyBMKGEuYSxiLHtwOmZ1bmN0aW9uKGgpe3JldHVybiBoLm9mZnNldFdpZHRofX0sYS51LGZ1bmN0aW9uKCl7cmV0dXJuKG5ldyBEYXRlKS5nZXRUaW1lKCl9KSxlPTAsZj1jLmxlbmd0aDtlPGY7ZSsrKXt2YXIgZz1jW2VdO2cueihhLmMsbihhLGEueWEsZyxiLGQpKX19O2Z1bmN0aW9uIEcoYSl7dGhpcy56YT1hfHxzYX12YXIgc2E9XCItXCI7Ry5wcm90b3R5cGUuZT1mdW5jdGlvbigpe2Zvcih2YXIgYT1bXSxiPTA7Yjxhcmd1bWVudHMubGVuZ3RoO2IrKylhLnB1c2goYXJndW1lbnRzW2JdLnJlcGxhY2UoL1tcXFdfXSsvZyxcIlwiKS50b0xvd2VyQ2FzZSgpKTtyZXR1cm4gYS5qb2luKHRoaXMuemEpfTtmdW5jdGlvbiBsYSgpe3RoaXMuaGE9XCInXCJ9bGEucHJvdG90eXBlLnF1b3RlPWZ1bmN0aW9uKGEpe3ZhciBiPVtdO2E9YS5zcGxpdCgvLFxccyovKTtmb3IodmFyIGM9MDtjPGEubGVuZ3RoO2MrKyl7dmFyIGQ9YVtjXS5yZXBsYWNlKC9bJ1wiXS9nLFwiXCIpO2QuaW5kZXhPZihcIiBcIik9PS0xP2IucHVzaChkKTpiLnB1c2godGhpcy5oYStkK3RoaXMuaGEpfXJldHVybiBiLmpvaW4oXCIsXCIpfTtmdW5jdGlvbiBPKCl7dGhpcy5HPXRhO3RoaXMubz11YX12YXIgdGE9W1wiZm9udC1zdHlsZVwiLFwiZm9udC13ZWlnaHRcIl0sdWE9e1wiZm9udC1zdHlsZVwiOltbXCJuXCIsXCJub3JtYWxcIl0sW1wiaVwiLFwiaXRhbGljXCJdLFtcIm9cIixcIm9ibGlxdWVcIl1dLFwiZm9udC13ZWlnaHRcIjpbW1wiMVwiLFwiMTAwXCJdLFtcIjJcIixcIjIwMFwiXSxbXCIzXCIsXCIzMDBcIl0sW1wiNFwiLFwiNDAwXCJdLFtcIjVcIixcIjUwMFwiXSxbXCI2XCIsXCI2MDBcIl0sW1wiN1wiLFwiNzAwXCJdLFtcIjhcIixcIjgwMFwiXSxbXCI5XCIsXCI5MDBcIl0sW1wiNFwiLFwibm9ybWFsXCJdLFtcIjdcIixcImJvbGRcIl1dfTtmdW5jdGlvbiBUKGEsYixjKXt0aGlzLmFhPWE7dGhpcy5GYT1iO3RoaXMubz1jfVQucHJvdG90eXBlLmNvbXBhY3Q9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9MDtjPHRoaXMuby5sZW5ndGg7YysrKWlmKGI9PXRoaXMub1tjXVsxXSl7YVt0aGlzLmFhXT10aGlzLm9bY11bMF07cmV0dXJufX07XHJcblQucHJvdG90eXBlLmV4cGFuZD1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0wO2M8dGhpcy5vLmxlbmd0aDtjKyspaWYoYj09dGhpcy5vW2NdWzBdKXthW3RoaXMuYWFdPXRoaXMuRmErXCI6XCIrdGhpcy5vW2NdWzFdO3JldHVybn19O08ucHJvdG90eXBlLmNvbXBhY3Q9ZnVuY3Rpb24oYSl7dmFyIGI9W1wiblwiLFwiNFwiXTthPWEuc3BsaXQoXCI7XCIpO2Zvcih2YXIgYz0wLGQ9YS5sZW5ndGg7YzxkO2MrKyl7dmFyIGU9YVtjXS5yZXBsYWNlKC9cXHMrL2csXCJcIikuc3BsaXQoXCI6XCIpO2lmKGUubGVuZ3RoPT0yKXt2YXIgZj1lWzFdO2E6e2U9ZVswXTtmb3IodmFyIGc9MDtnPHRoaXMuRy5sZW5ndGg7ZysrKWlmKGU9PXRoaXMuR1tnXSl7ZT1uZXcgVChnLGUsdGhpcy5vW2VdKTticmVhayBhfWU9bnVsbH1lJiZlLmNvbXBhY3QoYixmKX19cmV0dXJuIGIuam9pbihcIlwiKX07XHJcbk8ucHJvdG90eXBlLmV4cGFuZD1mdW5jdGlvbihhKXtpZihhLmxlbmd0aCE9MilyZXR1cm4gbnVsbDtmb3IodmFyIGI9W251bGwsbnVsbF0sYz0wLGQ9dGhpcy5HLmxlbmd0aDtjPGQ7YysrKXt2YXIgZT10aGlzLkdbY10sZj1hLnN1YnN0cihjLDEpOyhuZXcgVChjLGUsdGhpcy5vW2VdKSkuZXhwYW5kKGIsZil9cmV0dXJuIGJbMF0mJmJbMV0/Yi5qb2luKFwiO1wiKStcIjtcIjpudWxsfTt3aW5kb3cuV2ViRm9udD1mdW5jdGlvbigpe3ZhciBhPShuZXcgeihuYXZpZ2F0b3IudXNlckFnZW50LGRvY3VtZW50KSkucGFyc2UoKTtyZXR1cm4gbmV3IFMobmV3IG8oZG9jdW1lbnQsYSksbmV3IGphLGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxmdW5jdGlvbihiLGMpe3NldFRpbWVvdXQoYixjKX0sYSl9KCk7d2luZG93LldlYkZvbnQubG9hZD13aW5kb3cuV2ViRm9udC5sb2FkO3dpbmRvdy5XZWJGb250LmFkZE1vZHVsZT13aW5kb3cuV2ViRm9udC5xO3kucHJvdG90eXBlLmdldE5hbWU9eS5wcm90b3R5cGUuZ2V0TmFtZTt5LnByb3RvdHlwZS5nZXRWZXJzaW9uPXkucHJvdG90eXBlLnhhO3kucHJvdG90eXBlLmdldEVuZ2luZT15LnByb3RvdHlwZS5ZO3kucHJvdG90eXBlLmdldEVuZ2luZVZlcnNpb249eS5wcm90b3R5cGUudWE7eS5wcm90b3R5cGUuZ2V0UGxhdGZvcm09eS5wcm90b3R5cGUudmE7eS5wcm90b3R5cGUuZ2V0UGxhdGZvcm1WZXJzaW9uPXkucHJvdG90eXBlLndhO1xyXG55LnByb3RvdHlwZS5nZXREb2N1bWVudE1vZGU9eS5wcm90b3R5cGUudGE7eS5wcm90b3R5cGUuaXNTdXBwb3J0aW5nV2ViRm9udD15LnByb3RvdHlwZS53O2Z1bmN0aW9uIFUoYSxiKXt0aGlzLmE9YTt0aGlzLmQ9Yn12YXIgdmE9e3JlZ3VsYXI6XCJuNFwiLGJvbGQ6XCJuN1wiLGl0YWxpYzpcImk0XCIsYm9sZGl0YWxpYzpcImk3XCIscjpcIm40XCIsYjpcIm43XCIsaTpcImk0XCIsYmk6XCJpN1wifTtVLnByb3RvdHlwZS56PWZ1bmN0aW9uKGEsYil7cmV0dXJuIGIoYS53KCkpfTtcclxuVS5wcm90b3R5cGUubG9hZD1mdW5jdGlvbihhKXtyKHRoaXMuYSxcImhlYWRcIix0KHRoaXMuYSwoXCJodHRwczpcIj09ZG9jdW1lbnQubG9jYXRpb24ucHJvdG9jb2w/XCJodHRwczpcIjpcImh0dHA6XCIpK1wiLy93ZWJmb250cy5mb250c2xpdmUuY29tL2Nzcy9cIit0aGlzLmQua2V5K1wiLmNzc1wiKSk7dmFyIGI7Yj10aGlzLmQuZmFtaWxpZXM7dmFyIGMsZCxlO2M9W107ZD17fTtmb3IodmFyIGY9MCxnPWIubGVuZ3RoO2Y8ZztmKyspe2U9dm9pZCAwO3ZhciBoPXZvaWQgMDtoPXZvaWQgMDtoPWJbZl0uc3BsaXQoXCI6XCIpO2U9aFswXTtoPWhbMV0/d2EodGhpcyxoWzFdKTpbXCJuNFwiXTtlPXtXOmUsVDpofTtjLnB1c2goZS5XKTtkW2UuV109ZS5UfWI9e3BhOmMsVDpkfTthKGIucGEsYi5UKX07XHJcbmZ1bmN0aW9uIHdhKGEsYil7YT1iLnNwbGl0KFwiLFwiKTtiPVtdO2Zvcih2YXIgYz0wLGQ9YS5sZW5ndGg7YzxkO2MrKyl7dmFyIGU9YVtjXTtpZihlKXt2YXIgZj12YVtlXTtiLnB1c2goZj9mOmUpfX1yZXR1cm4gYn13aW5kb3cuV2ViRm9udC5xKFwiYXNjZW5kZXJcIixmdW5jdGlvbihhKXt2YXIgYj0obmV3IHoobmF2aWdhdG9yLnVzZXJBZ2VudCxkb2N1bWVudCkpLnBhcnNlKCk7cmV0dXJuIG5ldyBVKG5ldyBvKGRvY3VtZW50LGIpLGEpfSk7ZnVuY3Rpb24gVihhLGIsYyxkLGUsZixnLGgsbCl7Vi5HYS5jYWxsKHRoaXMsYSxiLGMsZCxlLGYsZyxoLGwpO2E9W1wiVGltZXMgTmV3IFJvbWFuXCIsXCJMdWNpZGEgU2FucyBVbmljb2RlXCIsXCJDb3VyaWVyIE5ld1wiLFwiVGFob21hXCIsXCJBcmlhbFwiLFwiTWljcm9zb2Z0IFNhbnMgU2VyaWZcIixcIlRpbWVzXCIsXCJMdWNpZGEgQ29uc29sZVwiLFwiU2Fuc1wiLFwiU2VyaWZcIixcIk1vbm9zcGFjZVwiXTtiPWEubGVuZ3RoO2M9e307ZD1QKHRoaXMsYVswXSx0cnVlKTtjW3RoaXMubi5wKGQpXT10cnVlO2ZvcihlPTE7ZTxiO2UrKyl7Zj1hW2VdO3EodGhpcy5hLGQsUih0aGlzLGYsdGhpcy5CLHRydWUpKTtjW3RoaXMubi5wKGQpXT10cnVlO2lmKHRoaXMuQlsxXSE9XCI0XCIpe3EodGhpcy5hLGQsUih0aGlzLGYsdGhpcy5CWzBdK1wiNFwiLHRydWUpKTtjW3RoaXMubi5wKGQpXT10cnVlfX1zKHRoaXMuYSxkKTt0aGlzLnQ9Yzt0aGlzLmxhPWZhbHNlfVxyXG4oZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7fWMucHJvdG90eXBlPWEucHJvdG90eXBlO2IucHJvdG90eXBlPW5ldyBjO2IuR2E9YTtiLkphPWEucHJvdG90eXBlfSkoTixWKTt2YXIgeGE9e0FyaW1vOnRydWUsQ291c2luZTp0cnVlLFRpbm9zOnRydWV9O1YucHJvdG90eXBlLko9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLm4ucCh0aGlzLlEpLGI9dGhpcy5uLnAodGhpcy5SKTtpZighdGhpcy5sYSYmYT09YiYmdGhpcy50W2FdKXt0aGlzLnQ9e307dGhpcy5sYT10aGlzLnRbYV09dHJ1ZX1pZigodGhpcy5PIT1hfHx0aGlzLlAhPWIpJiYhdGhpcy50W2FdJiYhdGhpcy50W2JdKVEodGhpcyx0aGlzLkgpO2Vsc2UgaWYodGhpcy5EKCktdGhpcy5pYT49NUUzKXRoaXMudFthXSYmdGhpcy50W2JdJiZ4YVt0aGlzLkxdP1EodGhpcyx0aGlzLkgpOlEodGhpcyx0aGlzLiQpO2Vsc2UgcWEodGhpcyl9O2Z1bmN0aW9uIHlhKGEpe3RoaXMuST1hP2E6KFwiaHR0cHM6XCI9PXdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbD9cImh0dHBzOlwiOlwiaHR0cDpcIikremE7dGhpcy5mPVtdO3RoaXMuUz1bXX12YXIgemE9XCIvL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2Nzc1wiO3lhLnByb3RvdHlwZS5lPWZ1bmN0aW9uKCl7aWYodGhpcy5mLmxlbmd0aD09MCl0aHJvdyBuZXcgRXJyb3IoXCJObyBmb250cyB0byBsb2FkICFcIik7aWYodGhpcy5JLmluZGV4T2YoXCJraXQ9XCIpIT0tMSlyZXR1cm4gdGhpcy5JO2Zvcih2YXIgYT10aGlzLmYubGVuZ3RoLGI9W10sYz0wO2M8YTtjKyspYi5wdXNoKHRoaXMuZltjXS5yZXBsYWNlKC8gL2csXCIrXCIpKTthPXRoaXMuSStcIj9mYW1pbHk9XCIrYi5qb2luKFwiJTdDXCIpO2lmKHRoaXMuUy5sZW5ndGg+MClhKz1cIiZzdWJzZXQ9XCIrdGhpcy5TLmpvaW4oXCIsXCIpO3JldHVybiBhfTtmdW5jdGlvbiBBYShhKXt0aGlzLmY9YTt0aGlzLmdhPVtdO3RoaXMua2E9e307dGhpcy5GPXt9O3RoaXMudj1uZXcgT312YXIgQmE9e3VsdHJhbGlnaHQ6XCJuMlwiLGxpZ2h0OlwibjNcIixyZWd1bGFyOlwibjRcIixib2xkOlwibjdcIixpdGFsaWM6XCJpNFwiLGJvbGRpdGFsaWM6XCJpN1wiLHVsOlwibjJcIixsOlwibjNcIixyOlwibjRcIixiOlwibjdcIixpOlwiaTRcIixiaTpcImk3XCJ9LENhPXtsYXRpbjptYSxjeXJpbGxpYzpcIiYjMTA4MTsmIzExMDM7JiMxMDQ2O1wiLGdyZWVrOlwiJiM5NDU7JiM5NDY7JiM5MzE7XCIsa2htZXI6XCImI3gxNzgwOyYjeDE3ODE7JiN4MTc4MjtcIixIYW51bWFuOlwiJiN4MTc4MDsmI3gxNzgxOyYjeDE3ODI7XCJ9O1xyXG5BYS5wcm90b3R5cGUucGFyc2U9ZnVuY3Rpb24oKXtmb3IodmFyIGE9dGhpcy5mLmxlbmd0aCxiPTA7YjxhO2IrKyl7dmFyIGM9dGhpcy5mW2JdLnNwbGl0KFwiOlwiKSxkPWNbMF0sZT1bXCJuNFwiXTtpZihjLmxlbmd0aD49Mil7dmFyIGY9Y1sxXSxnPVtdO2lmKGYpe2Y9Zi5zcGxpdChcIixcIik7Zm9yKHZhciBoPWYubGVuZ3RoLGw9MDtsPGg7bCsrKXt2YXIgaztrPWZbbF07aWYoay5tYXRjaCgvXltcXHcgXSskLykpe3ZhciBtPUJhW2tdO2lmKG0paz1tO2Vsc2V7bT1rLm1hdGNoKC9eKFxcZCopKFxcdyopJC8pO2s9bVsxXTttPW1bMl07az0oaz10aGlzLnYuZXhwYW5kKFttP206XCJuXCIsaz9rLnN1YnN0cigwLDEpOlwiNFwiXS5qb2luKFwiXCIpKSk/dGhpcy52LmNvbXBhY3Qoayk6bnVsbH19ZWxzZSBrPVwiXCI7ayYmZy5wdXNoKGspfX1pZihnLmxlbmd0aD4wKWU9ZztpZihjLmxlbmd0aD09Myl7Yz1jWzJdO2c9W107Yz1jP2Muc3BsaXQoXCIsXCIpOmc7aWYoYy5sZW5ndGg+MClpZihjPUNhW2NbMF1dKXRoaXMuRltkXT1cclxuY319aWYoIXRoaXMuRltkXSlpZihjPUNhW2RdKXRoaXMuRltkXT1jO3RoaXMuZ2EucHVzaChkKTt0aGlzLmthW2RdPWV9fTtmdW5jdGlvbiBXKGEsYixjKXt0aGlzLmM9YTt0aGlzLmE9Yjt0aGlzLmQ9Y31XLnByb3RvdHlwZS56PWZ1bmN0aW9uKGEsYil7YihhLncoKSl9O1cucHJvdG90eXBlLlo9ZnVuY3Rpb24oKXtpZih0aGlzLmMuWSgpPT1cIkFwcGxlV2ViS2l0XCIpcmV0dXJuIFY7cmV0dXJuIE59O1cucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5hO3RoaXMuYy5nZXROYW1lKCk9PVwiTVNJRVwiJiZ0aGlzLmQuYmxvY2tpbmchPXRydWU/YWEoYixuKHRoaXMsdGhpcy5iYSxhKSk6dGhpcy5iYShhKX07XHJcblcucHJvdG90eXBlLmJhPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj10aGlzLmEsYz1uZXcgeWEodGhpcy5kLmFwaSksZD10aGlzLmQuZmFtaWxpZXMsZT1kLmxlbmd0aCxmPTA7ZjxlO2YrKyl7dmFyIGc9ZFtmXS5zcGxpdChcIjpcIik7Zy5sZW5ndGg9PTMmJmMuUy5wdXNoKGcucG9wKCkpO2MuZi5wdXNoKGcuam9pbihcIjpcIikpfWQ9bmV3IEFhKGQpO2QucGFyc2UoKTtyKGIsXCJoZWFkXCIsdChiLGMuZSgpKSk7YShkLmdhLGQua2EsZC5GKX07d2luZG93LldlYkZvbnQucShcImdvb2dsZVwiLGZ1bmN0aW9uKGEpe3ZhciBiPShuZXcgeihuYXZpZ2F0b3IudXNlckFnZW50LGRvY3VtZW50KSkucGFyc2UoKTtyZXR1cm4gbmV3IFcoYixuZXcgbyhkb2N1bWVudCxiKSxhKX0pO2Z1bmN0aW9uIFgoYSxiKXt0aGlzLmE9YTt0aGlzLmQ9Yn1YLnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj10aGlzLmQudXJsc3x8W10sYz10aGlzLmQuZmFtaWxpZXN8fFtdLGQ9MCxlPWIubGVuZ3RoO2Q8ZTtkKyspcih0aGlzLmEsXCJoZWFkXCIsdCh0aGlzLmEsYltkXSkpO2EoYyl9O1gucHJvdG90eXBlLno9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYihhLncoKSl9O3dpbmRvdy5XZWJGb250LnEoXCJjdXN0b21cIixmdW5jdGlvbihhKXt2YXIgYj0obmV3IHoobmF2aWdhdG9yLnVzZXJBZ2VudCxkb2N1bWVudCkpLnBhcnNlKCk7cmV0dXJuIG5ldyBYKG5ldyBvKGRvY3VtZW50LGIpLGEpfSk7ZnVuY3Rpb24gWShhLGIsYyl7dGhpcy5tPWE7dGhpcy5hPWI7dGhpcy5kPWM7dGhpcy5mPVtdO3RoaXMucz17fTt0aGlzLnY9bmV3IE99WS5wcm90b3R5cGUuQz1mdW5jdGlvbihhKXtyZXR1cm4oXCJodHRwczpcIj09dGhpcy5tLmxvY2F0aW9uLnByb3RvY29sP1wiaHR0cHM6XCI6XCJodHRwOlwiKSsodGhpcy5kLmFwaXx8XCIvL2YuZm9udGRlY2suY29tL3MvY3NzL2pzL1wiKSt0aGlzLm0uZG9jdW1lbnQubG9jYXRpb24uaG9zdG5hbWUrXCIvXCIrYStcIi5qc1wifTtcclxuWS5wcm90b3R5cGUuej1mdW5jdGlvbihhLGIpe2E9dGhpcy5kLmlkO3ZhciBjPXRoaXM7aWYoYSl7dGhpcy5tLl9fd2ViZm9udGZvbnRkZWNrbW9kdWxlX198fCh0aGlzLm0uX193ZWJmb250Zm9udGRlY2ttb2R1bGVfXz17fSk7dGhpcy5tLl9fd2ViZm9udGZvbnRkZWNrbW9kdWxlX19bYV09ZnVuY3Rpb24oZCxlKXtmb3IodmFyIGY9MCxnPWUuZm9udHMubGVuZ3RoO2Y8ZzsrK2Ype3ZhciBoPWUuZm9udHNbZl07Yy5mLnB1c2goaC5uYW1lKTtjLnNbaC5uYW1lXT1bYy52LmNvbXBhY3QoXCJmb250LXdlaWdodDpcIitoLndlaWdodCtcIjtmb250LXN0eWxlOlwiK2guc3R5bGUpXX1iKGQpfTtyKHRoaXMuYSxcImhlYWRcIix1KHRoaXMuYSx0aGlzLkMoYSkpKX1lbHNlIGIodHJ1ZSl9O1kucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24oYSl7YSh0aGlzLmYsdGhpcy5zKX07XHJcbndpbmRvdy5XZWJGb250LnEoXCJmb250ZGVja1wiLGZ1bmN0aW9uKGEpe3ZhciBiPShuZXcgeihuYXZpZ2F0b3IudXNlckFnZW50LGRvY3VtZW50KSkucGFyc2UoKTtyZXR1cm4gbmV3IFkod2luZG93LG5ldyBvKGRvY3VtZW50LGIpLGEpfSk7ZnVuY3Rpb24gWihhLGIsYyxkLGUpe3RoaXMubT1hO3RoaXMuYz1iO3RoaXMuYT1jO3RoaXMuaz1kO3RoaXMuZD1lO3RoaXMuZj1bXTt0aGlzLnM9e319XHJcbloucHJvdG90eXBlLno9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLGQ9Yy5kLnByb2plY3RJZDtpZihkKXt2YXIgZT11KGMuYSxjLkMoZCkpO2UuaWQ9XCJfX01vbm90eXBlQVBJU2NyaXB0X19cIitkO2Uub25yZWFkeXN0YXRlY2hhbmdlPWZ1bmN0aW9uKGYpe2lmKGUucmVhZHlTdGF0ZT09PVwibG9hZGVkXCJ8fGUucmVhZHlTdGF0ZT09PVwiY29tcGxldGVcIil7ZS5vbnJlYWR5c3RhdGVjaGFuZ2U9bnVsbDtlLm9ubG9hZChmKX19O2Uub25sb2FkPWZ1bmN0aW9uKCl7aWYoYy5tW1wiX19tdGlfZm50THN0XCIrZF0pe3ZhciBmPWMubVtcIl9fbXRpX2ZudExzdFwiK2RdKCk7aWYoZiYmZi5sZW5ndGgpe3ZhciBnO2ZvcihnPTA7ZzxmLmxlbmd0aDtnKyspYy5mLnB1c2goZltnXS5mb250ZmFtaWx5KX19YihhLncoKSl9O3IodGhpcy5hLFwiaGVhZFwiLGUpfWVsc2UgYih0cnVlKX07XHJcbloucHJvdG90eXBlLkM9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5wcm90b2NvbCgpLGM9KHRoaXMuZC5hcGl8fFwiZmFzdC5mb250cy5jb20vanNhcGlcIikucmVwbGFjZSgvXi4qaHR0cChzPyk6KFxcL1xcLyk/LyxcIlwiKTtyZXR1cm4gYitcIi8vXCIrYytcIi9cIithK1wiLmpzXCJ9O1oucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24oYSl7YSh0aGlzLmYsdGhpcy5zKX07Wi5wcm90b3R5cGUucHJvdG9jb2w9ZnVuY3Rpb24oKXt2YXIgYT1bXCJodHRwOlwiLFwiaHR0cHM6XCJdLGI9YVswXTtpZih0aGlzLmsmJnRoaXMuay5sb2NhdGlvbiYmdGhpcy5rLmxvY2F0aW9uLnByb3RvY29sKXt2YXIgYz0wO2ZvcihjPTA7YzxhLmxlbmd0aDtjKyspaWYodGhpcy5rLmxvY2F0aW9uLnByb3RvY29sPT09YVtjXSlyZXR1cm4gdGhpcy5rLmxvY2F0aW9uLnByb3RvY29sfXJldHVybiBifTtcclxud2luZG93LldlYkZvbnQucShcIm1vbm90eXBlXCIsZnVuY3Rpb24oYSl7dmFyIGI9KG5ldyB6KG5hdmlnYXRvci51c2VyQWdlbnQsZG9jdW1lbnQpKS5wYXJzZSgpO3JldHVybiBuZXcgWih3aW5kb3csYixuZXcgbyhkb2N1bWVudCxiKSxkb2N1bWVudCxhKX0pO2Z1bmN0aW9uICQoYSxiLGMpe3RoaXMubT1hO3RoaXMuYT1iO3RoaXMuZD1jO3RoaXMuZj1bXTt0aGlzLnM9e319JC5wcm90b3R5cGUuQz1mdW5jdGlvbihhKXt2YXIgYj1cImh0dHBzOlwiPT13aW5kb3cubG9jYXRpb24ucHJvdG9jb2w/XCJodHRwczpcIjpcImh0dHA6XCI7cmV0dXJuKHRoaXMuZC5hcGl8fGIrXCIvL3VzZS50eXBla2l0LmNvbVwiKStcIi9cIithK1wiLmpzXCJ9OyQucHJvdG90eXBlLno9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmQuaWQsZD10aGlzLmQsZT10aGlzO2lmKGMpe3RoaXMubS5fX3dlYmZvbnR0eXBla2l0bW9kdWxlX198fCh0aGlzLm0uX193ZWJmb250dHlwZWtpdG1vZHVsZV9fPXt9KTt0aGlzLm0uX193ZWJmb250dHlwZWtpdG1vZHVsZV9fW2NdPWZ1bmN0aW9uKGYpe2YoYSxkLGZ1bmN0aW9uKGcsaCxsKXtlLmY9aDtlLnM9bDtiKGcpfSl9O3IodGhpcy5hLFwiaGVhZFwiLHUodGhpcy5hLHRoaXMuQyhjKSkpfWVsc2UgYih0cnVlKX07XHJcbiQucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24oYSl7YSh0aGlzLmYsdGhpcy5zKX07d2luZG93LldlYkZvbnQucShcInR5cGVraXRcIixmdW5jdGlvbihhKXt2YXIgYj0obmV3IHoobmF2aWdhdG9yLnVzZXJBZ2VudCxkb2N1bWVudCkpLnBhcnNlKCk7cmV0dXJuIG5ldyAkKHdpbmRvdyxuZXcgbyhkb2N1bWVudCxiKSxhKX0pO3dpbmRvdy5XZWJGb250Q29uZmlnJiZ3aW5kb3cuV2ViRm9udC5sb2FkKHdpbmRvdy5XZWJGb250Q29uZmlnKTtcclxufSkodGhpcyxkb2N1bWVudCk7XHJcbiIsIi8vIC0qLSBNb2RlOiBKYXZhU2NyaXB0OyB0YWItd2lkdGg6IDI7IGluZGVudC10YWJzLW1vZGU6IG5pbDsgLSotXHJcbi8vIHZpbTpzZXQgZnQ9amF2YXNjcmlwdCB0cz0yIHN3PTIgc3RzPTIgY2luZGVudDpcclxudmFyIEFqYXggPSAoZnVuY3Rpb24oJCwgd2luZG93LCB1bmRlZmluZWQpIHtcclxuICAgIHZhciBBamF4ID0gZnVuY3Rpb24oZGlzcGF0Y2hlcikge1xyXG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgIHZhciBwZW5kaW5nID0gMDtcclxuICAgICAgdmFyIGNvdW50ID0gMDtcclxuICAgICAgdmFyIHBlbmRpbmdMaXN0ID0ge307XHJcblxyXG4gICAgICAvLyBtZXJnZSBkYXRhIHdpbGwgZ2V0IG1lcmdlZCBpbnRvIHRoZSByZXNwb25zZSBkYXRhXHJcbiAgICAgIC8vIGJlZm9yZSBjYWxsaW5nIHRoZSBjYWxsYmFja1xyXG4gICAgICB2YXIgYWpheENhbGwgPSBmdW5jdGlvbihkYXRhLCBjYWxsYmFjaywgbWVyZ2UpIHtcclxuICAgICAgICBtZXJnZSA9IG1lcmdlIHx8IHt9O1xyXG4gICAgICAgIGRpc3BhdGNoZXIucG9zdCgnc3BpbicpO1xyXG4gICAgICAgIHBlbmRpbmcrKztcclxuICAgICAgICB2YXIgaWQgPSBjb3VudCsrO1xyXG5cclxuICAgICAgICAvLyBzcGVjaWFsIHZhbHVlOiBgbWVyZ2Uua2VlcCA9IHRydWVgIHByZXZlbnRzIG9ic29sZXNjZW5jZVxyXG4gICAgICAgIHBlbmRpbmdMaXN0W2lkXSA9IG1lcmdlLmtlZXAgfHwgZmFsc2U7XHJcbiAgICAgICAgZGVsZXRlIG1lcmdlLmtlZXA7XHJcblxyXG4gICAgICAgIC8vIElmIG5vIHByb3RvY29sIHZlcnNpb24gaXMgZXhwbGljaXRseSBzZXQsIHNldCBpdCB0byBjdXJyZW50XHJcbiAgICAgICAgaWYgKGRhdGFbJ3Byb3RvY29sJ10gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgLy8gVE9ETzogRXh0cmFjdCB0aGUgcHJvdG9jb2wgdmVyc2lvbiBzb21ld2hlcmUgZ2xvYmFsXHJcbiAgICAgICAgICBkYXRhWydwcm90b2NvbCddID0gMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vdmFyIHVybCA9IFwidGVzdC1qc29uL1wiO1xyXG4gICAgICAgIHZhciB1cmwgPSBcInRlc3QtanNvbi1zaW1wbGUvXCI7XHJcbiAgICAgICAgdmFyIG1ldGhvZCA9IFwiR0VUXCI7XHJcbiAgICAgICAgc3dpdGNoKGRhdGEuYWN0aW9uKXtcclxuICAgICAgICAgIGNhc2UgXCJ3aG9hbWlcIjpcclxuICAgICAgICAgICAgdXJsICs9IFwidXNlci5qc29uXCI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBcImdldERvY3VtZW50XCI6XHJcbiAgICAgICAgICAgIHVybCArPSBcImRvY3VtZW50Lmpzb25cIjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIFwibG9hZENvbmZcIjpcclxuICAgICAgICAgICAgdXJsICs9IFwiY29uZmlnLmpzb25cIjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIFwiZ2V0Q29sbGVjdGlvbkluZm9ybWF0aW9uXCI6XHJcbiAgICAgICAgICAgIHVybCArPSBcImNvbGxlY3Rpb24uanNvblwiO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgXCJsb2dpblwiOlxyXG4gICAgICAgICAgICB1cmwgKz0gXCJsb2dpbi5qc29uXCI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBcImNyZWF0ZUFyY1wiOlxyXG4gICAgICAgICAgICB1cmwgKz0gXCJhZGRSZWxhdGlvbi5qc29uXCI7XHJcbiAgICAgICAgICAgIC8vVE9ETyBtZXRob2QgPSBcIlBPU1RcIjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIFwiYXJjT3BlbkRpYWxvZ1wiOlxyXG4gICAgICAgICAgICB1cmwgKz0gXCJhZGRSZWxhdGlvbjIuanNvblwiO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgXCJjcmVhdGVTcGFuXCI6XHJcbiAgICAgICAgICAgIHVybCArPSBcImNyZWF0ZVRva2VuLmpzb25cIjtcclxuICAgICAgICAgICAgLy9UT0RPIG1ldGhvZCA9IFwiUE9TVFwiO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHVybCArPSBcImVtcHR5Lmpzb25cIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgJC5hamF4KHtcclxuICAgICAgICAgIC8vUmVtb3ZlZCBieSBSZW5hdWQgb24gMjAxNi0wMy0xMFxyXG4gICAgICAgICAgLyp1cmw6ICdhamF4LmNnaScsXHJcbiAgICAgICAgICAgZGF0YTogZGF0YSxcclxuICAgICAgICAgICB0eXBlOiAnUE9TVCcsKi9cclxuICAgICAgICAgIC8vXHJcbiAgICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgICAgdXJsOiB1cmwsXHJcbiAgICAgICAgICB0eXBlOiBtZXRob2QsXHJcbiAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihyZXNwb25zZSkge1xyXG4gICAgICAgICAgICBwZW5kaW5nLS07XHJcbiAgICAgICAgICAgIC8vIElmIG5vIGV4Y2VwdGlvbiBpcyBzZXQsIHZlcmlmeSB0aGUgc2VydmVyIHJlc3VsdHNcclxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmV4Y2VwdGlvbiA9PSB1bmRlZmluZWQgJiYgcmVzcG9uc2UuYWN0aW9uICE9PSBkYXRhLmFjdGlvbikge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0FjdGlvbiAnICsgZGF0YS5hY3Rpb24gK1xyXG4gICAgICAgICAgICAgICAgJyByZXR1cm5lZCB0aGUgcmVzdWx0cyBvZiBhY3Rpb24gJyArIHJlc3BvbnNlLmFjdGlvbik7XHJcbiAgICAgICAgICAgICAgcmVzcG9uc2UuZXhjZXB0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ21lc3NhZ2VzJywgW1tbJ1Byb3RvY29sIGVycm9yOiBBY3Rpb24nICsgZGF0YS5hY3Rpb24gKyAnIHJldHVybmVkIHRoZSByZXN1bHRzIG9mIGFjdGlvbiAnICsgcmVzcG9uc2UuYWN0aW9uICsgJyBtYXliZSB0aGUgc2VydmVyIGlzIHVuYWJsZSB0byBydW4sIHBsZWFzZSBydW4gdG9vbHMvdHJvdWJsZXNob290aW5nLnNoIGZyb20geW91ciBpbnN0YWxsYXRpb24gdG8gZGlhZ25vc2UgaXQnLCAnZXJyb3InLCAtMV1dXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIHRoZSByZXF1ZXN0IGlzIG9ic29sZXRlLCBkbyBub3RoaW5nOyBpZiBub3QuLi5cclxuICAgICAgICAgICAgaWYgKHBlbmRpbmdMaXN0Lmhhc093blByb3BlcnR5KGlkKSkge1xyXG4gICAgICAgICAgICAgIGRpc3BhdGNoZXIucG9zdCgnbWVzc2FnZXMnLCBbcmVzcG9uc2UubWVzc2FnZXNdKTtcclxuICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuZXhjZXB0aW9uID09ICdjb25maWd1cmF0aW9uRXJyb3InXHJcbiAgICAgICAgICAgICAgICAgIHx8IHJlc3BvbnNlLmV4Y2VwdGlvbiA9PSAncHJvdG9jb2xWZXJzaW9uTWlzbWF0Y2gnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGEgbm8tcmVzY3VlIGNyaXRpY2FsIGZhaWx1cmUuXHJcbiAgICAgICAgICAgICAgICAvLyBTdG9wICpldmVyeXRoaW5nKi5cclxuICAgICAgICAgICAgICAgIHBlbmRpbmdMaXN0ID0ge307XHJcbiAgICAgICAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ3NjcmVhbWluZ0hhbHQnKTtcclxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhZCBhIHByb3RvY29sIG1pc21hdGNoLCBwcm9tcHQgdGhlIHVzZXIgZm9yIGEgcmVsb2FkXHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuZXhjZXB0aW9uID09ICdwcm90b2NvbFZlcnNpb25NaXNtYXRjaCcpIHtcclxuICAgICAgICAgICAgICAgICAgaWYoY29uZmlybSgnVGhlIHNlcnZlciBpcyBydW5uaW5nIGEgZGlmZmVyZW50IHZlcnNpb24gJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAnZnJvbSBicmF0IHRoYW4geW91ciBjbGllbnQsIHBvc3NpYmx5IGR1ZSB0byBhICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgJ3NlcnZlciB1cGdyYWRlLiBXb3VsZCB5b3UgbGlrZSB0byByZWxvYWQgdGhlICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgJ2N1cnJlbnQgcGFnZSB0byB1cGRhdGUgeW91ciBjbGllbnQgdG8gdGhlIGxhdGVzdCAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICd2ZXJzaW9uPycpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ21lc3NhZ2VzJywgW1tbJ0ZhdGFsIEVycm9yOiBQcm90b2NvbCAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ3ZlcnNpb24gbWlzbWF0Y2gsIHBsZWFzZSBjb250YWN0IHRoZSBhZG1pbmlzdHJhdG9yJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Vycm9yJywgLTFdXV0pO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBkZWxldGUgcGVuZGluZ0xpc3RbaWRdO1xyXG5cclxuICAgICAgICAgICAgICAvLyBpZiAuZXhjZXB0aW9uIGlzIGp1c3QgQm9vbGVhbiB0cnVlLCBkbyBub3QgcHJvY2Vzc1xyXG4gICAgICAgICAgICAgIC8vIHRoZSBjYWxsYmFjazsgaWYgaXQgaXMgYW55dGhpbmcgZWxzZSwgdGhlXHJcbiAgICAgICAgICAgICAgLy8gY2FsbGJhY2sgaXMgcmVzcG9uc2libGUgZm9yIGhhbmRsaW5nIGl0XHJcbiAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmV4Y2VwdGlvbiA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAkKCcjd2FpdGVyJykuZGlhbG9nKCdjbG9zZScpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICQuZXh0ZW5kKHJlc3BvbnNlLCBtZXJnZSk7XHJcbiAgICAgICAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoMCwgY2FsbGJhY2ssIFtyZXNwb25zZV0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ3Vuc3BpbicpO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGVycm9yOiBmdW5jdGlvbihyZXNwb25zZSwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pIHtcclxuICAgICAgICAgICAgcGVuZGluZy0tO1xyXG4gICAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ3Vuc3BpbicpO1xyXG4gICAgICAgICAgICAkKCcjd2FpdGVyJykuZGlhbG9nKCdjbG9zZScpO1xyXG4gICAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ21lc3NhZ2VzJywgW1tbJ0Vycm9yOiBBY3Rpb24nICsgZGF0YS5hY3Rpb24gKyAnIGZhaWxlZCBvbiBlcnJvciAnICsgcmVzcG9uc2Uuc3RhdHVzVGV4dCwgJ2Vycm9yJ11dXSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IodGV4dFN0YXR1cyArICc6JywgZXJyb3JUaHJvd24sIHJlc3BvbnNlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gaWQ7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgaXNSZWxvYWRPa2F5ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy8gZG8gbm90IHJlbG9hZCB3aGlsZSBkYXRhIGlzIHBlbmRpbmdcclxuICAgICAgICByZXR1cm4gcGVuZGluZyA9PSAwO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdmFyIG1ha2VPYnNvbGV0ZSA9IGZ1bmN0aW9uKGFsbCkge1xyXG4gICAgICAgIGlmIChhbGwpIHtcclxuICAgICAgICAgIHBlbmRpbmdMaXN0ID0ge307XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICQuZWFjaChwZW5kaW5nTGlzdCwgZnVuY3Rpb24oaWQsIGtlZXApIHtcclxuICAgICAgICAgICAgaWYgKCFrZWVwKSBkZWxldGUgcGVuZGluZ0xpc3RbaWRdO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBkaXNwYXRjaGVyLlxyXG4gICAgICAgICAgb24oJ2lzUmVsb2FkT2theScsIGlzUmVsb2FkT2theSkuXHJcbiAgICAgICAgICBvbignbWFrZUFqYXhPYnNvbGV0ZScsIG1ha2VPYnNvbGV0ZSkuXHJcbiAgICAgICAgICBvbignYWpheCcsIGFqYXhDYWxsKTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIEFqYXg7XHJcbn0pKGpRdWVyeSwgd2luZG93KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQWpheDtcclxuIiwiLy8gLSotIE1vZGU6IEphdmFTY3JpcHQ7IHRhYi13aWR0aDogMjsgaW5kZW50LXRhYnMtbW9kZTogbmlsOyAtKi1cclxuLy8gdmltOnNldCBmdD1qYXZhc2NyaXB0IHRzPTIgc3c9MiBzdHM9MiBjaW5kZW50OlxyXG52YXIgQW5ub3RhdG9yVUkgPSAoZnVuY3Rpb24oJCwgd2luZG93LCB1bmRlZmluZWQpIHtcclxuICAgIHZhciBBbm5vdGF0b3JVSSA9IGZ1bmN0aW9uKGRpc3BhdGNoZXIsIHN2Zykge1xyXG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgIHZhciBhcmNEcmFnT3JpZ2luID0gbnVsbDtcclxuICAgICAgdmFyIGFyY0RyYWdPcmlnaW5Cb3ggPSBudWxsO1xyXG4gICAgICB2YXIgYXJjRHJhZ09yaWdpbkdyb3VwID0gbnVsbDtcclxuICAgICAgdmFyIGFyY0RyYWdBcmMgPSBudWxsO1xyXG4gICAgICB2YXIgYXJjRHJhZ0p1c3RTdGFydGVkID0gZmFsc2U7XHJcbiAgICAgIHZhciBzb3VyY2VEYXRhID0gbnVsbDtcclxuICAgICAgdmFyIGRhdGEgPSBudWxsO1xyXG4gICAgICB2YXIgc2VhcmNoQ29uZmlnID0gbnVsbDtcclxuICAgICAgdmFyIHNwYW5PcHRpb25zID0gbnVsbDtcclxuICAgICAgdmFyIHJhcGlkU3Bhbk9wdGlvbnMgPSBudWxsO1xyXG4gICAgICB2YXIgYXJjT3B0aW9ucyA9IG51bGw7XHJcbiAgICAgIHZhciBzcGFuS2V5bWFwID0gbnVsbDtcclxuICAgICAgdmFyIGtleW1hcCA9IG51bGw7XHJcbiAgICAgIHZhciBjb2xsID0gbnVsbDtcclxuICAgICAgdmFyIGRvYyA9IG51bGw7XHJcbiAgICAgIHZhciByZXNlbGVjdGVkU3BhbiA9IG51bGw7XHJcbiAgICAgIHZhciBzZWxlY3RlZEZyYWdtZW50ID0gbnVsbDtcclxuICAgICAgdmFyIGVkaXRlZFNwYW4gPSBudWxsO1xyXG4gICAgICB2YXIgZWRpdGVkRnJhZ21lbnQgPSBudWxsO1xyXG4gICAgICB2YXIgcmVwZWF0aW5nQXJjVHlwZXMgPSBbXTtcclxuICAgICAgdmFyIHNwYW5UeXBlcyA9IG51bGw7XHJcbiAgICAgIHZhciBlbnRpdHlBdHRyaWJ1dGVUeXBlcyA9IG51bGw7XHJcbiAgICAgIHZhciBldmVudEF0dHJpYnV0ZVR5cGVzID0gbnVsbDtcclxuICAgICAgdmFyIGFsbEF0dHJpYnV0ZVR5cGVzID0gbnVsbDsgLy8gVE9ETzogdGVtcCB3b3JrYXJvdW5kLCByZW1vdmVcclxuICAgICAgdmFyIHJlbGF0aW9uVHlwZXNIYXNoID0gbnVsbDtcclxuICAgICAgdmFyIHNob3dWYWxpZEF0dHJpYnV0ZXM7IC8vIGNhbGxiYWNrIGZ1bmN0aW9uXHJcbiAgICAgIHZhciBzaG93VmFsaWROb3JtYWxpemF0aW9uczsgLy8gY2FsbGJhY2sgZnVuY3Rpb25cclxuICAgICAgdmFyIGRyYWdTdGFydGVkQXQgPSBudWxsO1xyXG4gICAgICB2YXIgc2VsUmVjdCA9IG51bGw7XHJcbiAgICAgIHZhciBsYXN0U3RhcnRSZWMgPSBudWxsO1xyXG4gICAgICB2YXIgbGFzdEVuZFJlYyA9IG51bGw7XHJcblxyXG4gICAgICB2YXIgZHJhZ2dlZEFyY0hlaWdodCA9IDMwO1xyXG4gICAgICB2YXIgc3BhblR5cGVzVG9TaG93QmVmb3JlQ29sbGFwc2UgPSAzMDtcclxuICAgICAgdmFyIG1heE5vcm1TZWFyY2hIaXN0b3J5ID0gMTA7XHJcblxyXG4gICAgICAvLyBUT0RPOiB0aGlzIGlzIGFuIHVnbHkgaGFjaywgcmVtb3ZlIChzZWUgY29tbWVudCB3aXRoIGFzc2lnbm1lbnQpXHJcbiAgICAgIHZhciBsYXN0UmFwaWRBbm5vdGF0aW9uRXZlbnQgPSBudWxsO1xyXG4gICAgICAvLyBUT0RPOiBhbm90aGVyIGF2b2lkYWJsZSBnbG9iYWw7IHRyeSB0byB3b3JrIHdpdGhvdXRcclxuICAgICAgdmFyIHJhcGlkQW5ub3RhdGlvbkRpYWxvZ1Zpc2libGUgPSBmYWxzZTtcclxuXHJcbiAgICAgIC8vIGFtb3VudCBieSB3aGljaCB0byBsaWdodGVuIChhZGp1c3QgXCJMXCIgaW4gSFNMIHNwYWNlKSBzcGFuXHJcbiAgICAgIC8vIGNvbG9ycyBmb3IgdHlwZSBzZWxlY3Rpb24gYm94IEJHIGRpc3BsYXkuIDA9bm8gbGlnaHRlbmluZyxcclxuICAgICAgLy8gMT13aGl0ZSBCRyAobm8gY29sb3IpXHJcbiAgICAgIHZhciBzcGFuQm94VGV4dEJnQ29sb3JMaWdodGVuID0gMC40O1xyXG5cclxuICAgICAgLy8gZm9yIGRvdWJsZS1jbGljayBzZWxlY3Rpb24gc2ltdWxhdGlvbiBoYWNrXHJcbiAgICAgIHZhciBsYXN0RG91YmxlQ2xpY2tlZENodW5rSWQgPSBudWxsO1xyXG5cclxuICAgICAgLy8gZm9yIG5vcm1hbGl6YXRpb246IFVSTHMgYmFzZXMgYnkgbm9ybSBEQiBuYW1lXHJcbiAgICAgIHZhciBub3JtRGJVcmxCeURiTmFtZSA9IHt9O1xyXG4gICAgICB2YXIgbm9ybURiVXJsQmFzZUJ5RGJOYW1lID0ge307XHJcbiAgICAgIC8vIGZvciBub3JtYWxpemF0aW9uOiBhcHByb3ByaWF0ZSBEQnMgcGVyIHR5cGVcclxuICAgICAgdmFyIG5vcm1EYnNCeVR5cGUgPSB7fTtcclxuICAgICAgLy8gZm9yIG5vcm1hbGl6YXRpb25cclxuICAgICAgdmFyIG9sZFNwYW5Ob3JtSWRWYWx1ZSA9ICcnO1xyXG4gICAgICB2YXIgbGFzdE5vcm1TZWFyY2hlcyA9IFtdO1xyXG5cclxuICAgICAgdGhhdC51c2VyID0gbnVsbDtcclxuICAgICAgdmFyIHN2Z0VsZW1lbnQgPSAkKHN2Zy5fc3ZnKTtcclxuICAgICAgdmFyIHN2Z0lkID0gc3ZnRWxlbWVudC5wYXJlbnQoKS5hdHRyKCdpZCcpO1xyXG5cclxuICAgICAgdmFyIHN0cmlwTnVtZXJpY1N1ZmZpeCA9IGZ1bmN0aW9uKHMpIHtcclxuICAgICAgICAvLyB1dGlsaXR5IGZ1bmN0aW9uLCBvcmlnaW5hbGx5IGZvciBzdHJpcHBpbmcgbnVtZXJpeCBzdWZmaXhlc1xyXG4gICAgICAgIC8vIGZyb20gYXJjIHR5cGVzIChlLmcuIFwiVGhlbWUyXCIgLT4gXCJUaGVtZVwiKS4gRm9yIHZhbHVlc1xyXG4gICAgICAgIC8vIHdpdGhvdXQgc3VmZml4ZXMgKGluY2x1ZGluZyBub24tc3RyaW5ncyksIHJldHVybnMgZ2l2ZW4gdmFsdWUuXHJcbiAgICAgICAgaWYgKHR5cGVvZihzKSAhPSBcInN0cmluZ1wiKSB7ICAgICAgICAgIFxyXG4gICAgICAgICAgcmV0dXJuIHM7IC8vIGNhbid0IHN0cmlwXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBtID0gcy5tYXRjaCgvXiguKj8pKFxcZCopJC8pO1xyXG4gICAgICAgIHJldHVybiBtWzFdOyAvLyBhbHdheXMgbWF0Y2hlc1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgaGlkZUZvcm0gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBrZXltYXAgPSBudWxsO1xyXG4gICAgICAgIHJhcGlkQW5ub3RhdGlvbkRpYWxvZ1Zpc2libGUgPSBmYWxzZTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciBjbGVhclNlbGVjdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5yZW1vdmVBbGxSYW5nZXMoKTtcclxuICAgICAgICBpZiAoc2VsUmVjdCAhPSBudWxsKSB7XHJcbiAgICAgICAgICBmb3IodmFyIHM9MDsgcyAhPSBzZWxSZWN0Lmxlbmd0aDsgcysrKSB7XHJcbiAgICAgICAgICAgIHNlbFJlY3Rbc10ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzZWxSZWN0W3NdKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHNlbFJlY3QgPSBudWxsO1xyXG4gICAgICAgICAgbGFzdFN0YXJ0UmVjID0gbnVsbDtcclxuICAgICAgICAgIGxhc3RFbmRSZWMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciBtYWtlU2VsUmVjdCA9IGZ1bmN0aW9uKHJ4LCByeSwgcncsIHJoLCBjb2wpIHtcclxuICAgICAgICB2YXIgc2VsUmVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwicmVjdFwiKTtcclxuICAgICAgICBzZWxSZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwid2lkdGhcIiwgcncpO1xyXG4gICAgICAgIHNlbFJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJoZWlnaHRcIiwgcmgpO1xyXG4gICAgICAgIHNlbFJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4XCIsIHJ4KTtcclxuICAgICAgICBzZWxSZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCByeSk7XHJcbiAgICAgICAgc2VsUmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGxcIiwgY29sID09IHVuZGVmaW5lZCA/IFwibGlnaHRibHVlXCIgOiBjb2wpO1xyXG4gICAgICAgIHJldHVybiBzZWxSZWN0O1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdmFyIG9uS2V5RG93biA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgIHZhciBjb2RlID0gZXZ0LndoaWNoO1xyXG5cclxuICAgICAgICBpZiAoY29kZSA9PT0gJC51aS5rZXlDb2RlLkVTQ0FQRSkge1xyXG4gICAgICAgICAgc3RvcEFyY0RyYWcoKTtcclxuICAgICAgICAgIGlmIChyZXNlbGVjdGVkU3Bhbikge1xyXG4gICAgICAgICAgICAkKHJlc2VsZWN0ZWRTcGFuLnJlY3QpLnJlbW92ZUNsYXNzKCdyZXNlbGVjdCcpO1xyXG4gICAgICAgICAgICByZXNlbGVjdGVkU3BhbiA9IG51bGw7XHJcbiAgICAgICAgICAgIHN2Z0VsZW1lbnQucmVtb3ZlQ2xhc3MoJ3Jlc2VsZWN0Jyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBpbiByYXBpZCBhbm5vdGF0aW9uIG1vZGUsIHByaW9yaXRpemUgdGhlIGtleXMgMC4uOSBmb3IgdGhlXHJcbiAgICAgICAgLy8gb3JkZXJlZCBjaG9pY2VzIGluIHRoZSBxdWljayBhbm5vdGF0aW9uIGRpYWxvZy5cclxuICAgICAgICBpZiAoQ29uZmlndXJhdGlvbi5yYXBpZE1vZGVPbiAmJiByYXBpZEFubm90YXRpb25EaWFsb2dWaXNpYmxlICYmIFxyXG4gICAgICAgICAgICBcIjBcIi5jaGFyQ29kZUF0KCkgPD0gY29kZSAmJiBjb2RlIDw9IFwiOVwiLmNoYXJDb2RlQXQoKSkge1xyXG4gICAgICAgICAgdmFyIGlkeCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XHJcbiAgICAgICAgICB2YXIgJGlucHV0ID0gJCgnI3JhcGlkX3NwYW5fJytpZHgpO1xyXG4gICAgICAgICAgaWYgKCRpbnB1dC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgJGlucHV0LmNsaWNrKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWtleW1hcCkgcmV0dXJuO1xyXG5cclxuICAgICAgICAvLyBkaXNhYmxlIHNob3J0Y3V0cyB3aGVuIHdvcmtpbmcgd2l0aCBlbGVtZW50cyB0aGF0IHlvdSBjb3VsZFxyXG4gICAgICAgIC8vIGNvbmNlaXZhYmx5IHR5cGUgaW5cclxuICAgICAgICB2YXIgdGFyZ2V0ID0gZXZ0LnRhcmdldDtcclxuICAgICAgICB2YXIgbm9kZU5hbWUgPSB0YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICB2YXIgbm9kZVR5cGUgPSB0YXJnZXQudHlwZSAmJiB0YXJnZXQudHlwZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGlmIChub2RlTmFtZSA9PSAnaW5wdXQnICYmIChub2RlVHlwZSA9PSAndGV4dCcgfHwgbm9kZVR5cGUgPT0gJ3Bhc3N3b3JkJykpIHJldHVybjtcclxuICAgICAgICBpZiAobm9kZU5hbWUgPT0gJ3RleHRhcmVhJyB8fCBub2RlTmFtZSA9PSAnc2VsZWN0JykgcmV0dXJuO1xyXG5cclxuICAgICAgICB2YXIgcHJlZml4ID0gJyc7XHJcbiAgICAgICAgaWYgKGV2dC5hbHRLZXkpIHtcclxuICAgICAgICAgIHByZWZpeCA9IFwiQS1cIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV2dC5jdHJsS2V5KSB7XHJcbiAgICAgICAgICBwcmVmaXggPSBcIkMtXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChldnQuc2hpZnRLZXkpIHtcclxuICAgICAgICAgIHByZWZpeCA9IFwiUy1cIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJpbmRpbmcgPSBrZXltYXBbcHJlZml4ICsgY29kZV07XHJcbiAgICAgICAgaWYgKCFiaW5kaW5nKSBiaW5kaW5nID0ga2V5bWFwW3ByZWZpeCArIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSldO1xyXG4gICAgICAgIGlmIChiaW5kaW5nKSB7XHJcbiAgICAgICAgICB2YXIgYm91bmRJbnB1dCA9ICQoJyMnICsgYmluZGluZylbMF07XHJcbiAgICAgICAgICBpZiAoYm91bmRJbnB1dCAmJiAhYm91bmRJbnB1dC5kaXNhYmxlZCkge1xyXG4gICAgICAgICAgICBib3VuZElucHV0LmNsaWNrKCk7XHJcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgdmFyIG9uRGJsQ2xpY2sgPSBmdW5jdGlvbihldnQpIHtcclxuICAgICAgICAvLyBtdXN0IGJlIGxvZ2dlZCBpblxyXG4gICAgICAgIC8vUmVtb3ZlZCBieSBSZW5hdWQgb24gMjAxNi0wMy0xMFxyXG4gICAgICAgIC8vaWYgKHRoYXQudXNlciA9PT0gbnVsbCkgcmV0dXJuO1xyXG4gICAgICAgIC8vIG11c3Qgbm90IGJlIHJlc2VsZWN0aW5nIGEgc3BhbiBvciBhbiBhcmNcclxuICAgICAgICBpZiAocmVzZWxlY3RlZFNwYW4gfHwgYXJjRHJhZ09yaWdpbikgcmV0dXJuO1xyXG5cclxuICAgICAgICB2YXIgdGFyZ2V0ID0gJChldnQudGFyZ2V0KTtcclxuICAgICAgICB2YXIgaWQ7XHJcblxyXG4gICAgICAgIC8vIGRvIHdlIGVkaXQgYW4gYXJjP1xyXG4gICAgICAgIGlmIChpZCA9IHRhcmdldC5hdHRyKCdkYXRhLWFyYy1yb2xlJykpIHtcclxuICAgICAgICAgIC8vIFRPRE9cclxuICAgICAgICAgIGNsZWFyU2VsZWN0aW9uKCk7XHJcbiAgICAgICAgICB2YXIgb3JpZ2luU3BhbklkID0gdGFyZ2V0LmF0dHIoJ2RhdGEtYXJjLW9yaWdpbicpO1xyXG4gICAgICAgICAgdmFyIHRhcmdldFNwYW5JZCA9IHRhcmdldC5hdHRyKCdkYXRhLWFyYy10YXJnZXQnKTtcclxuICAgICAgICAgIHZhciB0eXBlID0gdGFyZ2V0LmF0dHIoJ2RhdGEtYXJjLXJvbGUnKTtcclxuICAgICAgICAgIHZhciBvcmlnaW5TcGFuID0gZGF0YS5zcGFuc1tvcmlnaW5TcGFuSWRdO1xyXG4gICAgICAgICAgdmFyIHRhcmdldFNwYW4gPSBkYXRhLnNwYW5zW3RhcmdldFNwYW5JZF07XHJcbiAgICAgICAgICBhcmNPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBhY3Rpb246ICdjcmVhdGVBcmMnLFxyXG4gICAgICAgICAgICBvcmlnaW46IG9yaWdpblNwYW5JZCxcclxuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXRTcGFuSWQsXHJcbiAgICAgICAgICAgIG9sZF90YXJnZXQ6IHRhcmdldFNwYW5JZCxcclxuICAgICAgICAgICAgdHlwZTogdHlwZSxcclxuICAgICAgICAgICAgb2xkX3R5cGU6IHR5cGUsXHJcbiAgICAgICAgICAgIGNvbGxlY3Rpb246IGNvbGwsXHJcbiAgICAgICAgICAgICdkb2N1bWVudCc6IGRvY1xyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIHZhciBldmVudERlc2NJZCA9IHRhcmdldC5hdHRyKCdkYXRhLWFyYy1lZCcpO1xyXG4gICAgICAgICAgaWYgKGV2ZW50RGVzY0lkKSB7XHJcbiAgICAgICAgICAgIHZhciBldmVudERlc2MgPSBkYXRhLmV2ZW50RGVzY3NbZXZlbnREZXNjSWRdO1xyXG4gICAgICAgICAgICBpZiAoZXZlbnREZXNjLmVxdWl2KSB7XHJcbiAgICAgICAgICAgICAgYXJjT3B0aW9uc1snbGVmdCddID0gZXZlbnREZXNjLmxlZnRTcGFucy5qb2luKCcsJyk7XHJcbiAgICAgICAgICAgICAgYXJjT3B0aW9uc1sncmlnaHQnXSA9IGV2ZW50RGVzYy5yaWdodFNwYW5zLmpvaW4oJywnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgJCgnI2FyY19vcmlnaW4nKS50ZXh0KFV0aWwuc3BhbkRpc3BsYXlGb3JtKHNwYW5UeXBlcywgb3JpZ2luU3Bhbi50eXBlKSArICcgKFwiJyArIG9yaWdpblNwYW4udGV4dCArICdcIiknKTtcclxuICAgICAgICAgICQoJyNhcmNfdGFyZ2V0JykudGV4dChVdGlsLnNwYW5EaXNwbGF5Rm9ybShzcGFuVHlwZXMsIHRhcmdldFNwYW4udHlwZSkgKyAnIChcIicgKyB0YXJnZXRTcGFuLnRleHQgKyAnXCIpJyk7XHJcbiAgICAgICAgICB2YXIgYXJjSWQgPSBldmVudERlc2NJZCB8fCBbb3JpZ2luU3BhbklkLCB0eXBlLCB0YXJnZXRTcGFuSWRdO1xyXG4gICAgICAgICAgZmlsbEFyY1R5cGVzQW5kRGlzcGxheUZvcm0oZXZ0LCBvcmlnaW5TcGFuLnR5cGUsIHRhcmdldFNwYW4udHlwZSwgdHlwZSwgYXJjSWQpO1xyXG4gICAgICAgICAgLy8gZm9yIHByZWNpc2UgdGltaW5nLCBsb2cgZGlhbG9nIGRpc3BsYXkgdG8gdXNlci5cclxuICAgICAgICAgIGRpc3BhdGNoZXIucG9zdCgnbG9nQWN0aW9uJywgWydhcmNFZGl0U2VsZWN0ZWQnXSk7XHJcblxyXG4gICAgICAgIC8vIGlmIG5vdCBhbiBhcmMsIHRoZW4gZG8gd2UgZWRpdCBhIHNwYW4/XHJcbiAgICAgICAgfSBlbHNlIGlmIChpZCA9IHRhcmdldC5hdHRyKCdkYXRhLXNwYW4taWQnKSkge1xyXG4gICAgICAgICAgY2xlYXJTZWxlY3Rpb24oKTtcclxuICAgICAgICAgIGVkaXRlZFNwYW4gPSBkYXRhLnNwYW5zW2lkXTtcclxuICAgICAgICAgIGVkaXRlZEZyYWdtZW50ID0gdGFyZ2V0LmF0dHIoJ2RhdGEtZnJhZ21lbnQtaWQnKTtcclxuICAgICAgICAgIHZhciBvZmZzZXRzID0gW107XHJcbiAgICAgICAgICAkLmVhY2goZWRpdGVkU3Bhbi5mcmFnbWVudHMsIGZ1bmN0aW9uKGZyYWdtZW50Tm8sIGZyYWdtZW50KSB7XHJcbiAgICAgICAgICAgIG9mZnNldHMucHVzaChbZnJhZ21lbnQuZnJvbSwgZnJhZ21lbnQudG9dKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgc3Bhbk9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGFjdGlvbjogJ2NyZWF0ZVNwYW4nLFxyXG4gICAgICAgICAgICBvZmZzZXRzOiBvZmZzZXRzLFxyXG4gICAgICAgICAgICB0eXBlOiBlZGl0ZWRTcGFuLnR5cGUsXHJcbiAgICAgICAgICAgIGlkOiBpZCxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgICBmaWxsU3BhblR5cGVzQW5kRGlzcGxheUZvcm0oZXZ0LCBlZGl0ZWRTcGFuLnRleHQsIGVkaXRlZFNwYW4pO1xyXG4gICAgICAgICAgLy8gZm9yIHByZWNpc2UgdGltaW5nLCBsb2cgYW5ub3RhdGlvbiBkaXNwbGF5IHRvIHVzZXIuXHJcbiAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ2xvZ0FjdGlvbicsIFsnc3BhbkVkaXRTZWxlY3RlZCddKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGlmIG5vdCBhbiBhcmMgb3IgYSBzcGFuLCBpcyB0aGlzIGEgZG91YmxlLWNsaWNrIG9uIHRleHQ/XHJcbiAgICAgICAgZWxzZSBpZiAoaWQgPSB0YXJnZXQuYXR0cignZGF0YS1jaHVuay1pZCcpKSB7XHJcbiAgICAgICAgICAvLyByZW1lbWJlciB3aGF0IHdhcyBjbGlja2VkICh0aGlzIGlzIGluIHByZXBhcmF0aW9uIGZvclxyXG4gICAgICAgICAgLy8gc2ltdWxhdGluZyBkb3VibGUtY2xpY2sgc2VsZWN0aW9uIG9uIGJyb3dzZXJzIHRoYXQgZG9cclxuICAgICAgICAgIC8vIG5vdCBzdXBwb3J0IGl0LlxyXG4gICAgICAgICAgbGFzdERvdWJsZUNsaWNrZWRDaHVua0lkID0gaWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgdmFyIHN0YXJ0QXJjRHJhZyA9IGZ1bmN0aW9uKG9yaWdpbklkKSB7XHJcbiAgICAgICAgY2xlYXJTZWxlY3Rpb24oKTtcclxuICAgICAgICBzdmdFbGVtZW50LmFkZENsYXNzKCd1bnNlbGVjdGFibGUnKTtcclxuICAgICAgICBzdmdQb3NpdGlvbiA9IHN2Z0VsZW1lbnQub2Zmc2V0KCk7XHJcbiAgICAgICAgYXJjRHJhZ09yaWdpbiA9IG9yaWdpbklkO1xyXG4gICAgICAgIGFyY0RyYWdBcmMgPSBzdmcucGF0aChzdmcuY3JlYXRlUGF0aCgpLCB7XHJcbiAgICAgICAgICBtYXJrZXJFbmQ6ICd1cmwoI2RyYWdfYXJyb3cpJyxcclxuICAgICAgICAgICdjbGFzcyc6ICdkcmFnX3N0cm9rZScsXHJcbiAgICAgICAgICBmaWxsOiAnbm9uZScsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYXJjRHJhZ09yaWdpbkdyb3VwID0gJChkYXRhLnNwYW5zW2FyY0RyYWdPcmlnaW5dLmdyb3VwKTtcclxuICAgICAgICBhcmNEcmFnT3JpZ2luR3JvdXAuYWRkQ2xhc3MoJ2hpZ2hsaWdodCcpO1xyXG4gICAgICAgIGFyY0RyYWdPcmlnaW5Cb3ggPSBVdGlsLnJlYWxCQm94KGRhdGEuc3BhbnNbYXJjRHJhZ09yaWdpbl0uaGVhZEZyYWdtZW50KTtcclxuICAgICAgICBhcmNEcmFnT3JpZ2luQm94LmNlbnRlciA9IGFyY0RyYWdPcmlnaW5Cb3gueCArIGFyY0RyYWdPcmlnaW5Cb3gud2lkdGggLyAyO1xyXG5cclxuICAgICAgICBhcmNEcmFnSnVzdFN0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdmFyIGdldFZhbGlkQXJjVHlwZXNGb3JEcmFnID0gZnVuY3Rpb24odGFyZ2V0SWQsIHRhcmdldFR5cGUpIHtcclxuICAgICAgICB2YXIgYXJjVHlwZSA9IHN0cmlwTnVtZXJpY1N1ZmZpeChhcmNPcHRpb25zICYmIGFyY09wdGlvbnMudHlwZSk7XHJcbiAgICAgICAgaWYgKCFhcmNEcmFnT3JpZ2luIHx8IHRhcmdldElkID09IGFyY0RyYWdPcmlnaW4pIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICB2YXIgb3JpZ2luVHlwZSA9IGRhdGEuc3BhbnNbYXJjRHJhZ09yaWdpbl0udHlwZTtcclxuICAgICAgICB2YXIgc3BhblR5cGUgPSBzcGFuVHlwZXNbb3JpZ2luVHlwZV07XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIGlmIChzcGFuVHlwZSAmJiBzcGFuVHlwZS5hcmNzKSB7XHJcbiAgICAgICAgICAkLmVhY2goc3BhblR5cGUuYXJjcywgZnVuY3Rpb24oYXJjTm8sIGFyYykge1xyXG4gICAgICAgICAgICBpZiAoYXJjVHlwZSAmJiBhcmNUeXBlICE9IGFyYy50eXBlKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBpZiAoJC5pbkFycmF5KHRhcmdldFR5cGUsIGFyYy50YXJnZXRzKSAhPSAtMSkge1xyXG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFyYy50eXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgb25Nb3VzZURvd24gPSBmdW5jdGlvbihldnQpIHtcclxuICAgICAgICBkcmFnU3RhcnRlZEF0ID0gZXZ0OyAvLyBYWFggZG8gd2UgcmVhbGx5IG5lZWQgdGhlIHdob2xlIGV2dD9cclxuICAgICAgICAvL1JlbW92ZWQgYnkgUmVuYXVkIG9uIDIwMTYtMDMtMTBcclxuICAgICAgICAvL2lmICghdGhhdC51c2VyIHx8IGFyY0RyYWdPcmlnaW4pIHJldHVybjtcclxuICAgICAgICBpZiAoYXJjRHJhZ09yaWdpbikgcmV0dXJuO1xyXG4gICAgICAgIHZhciB0YXJnZXQgPSAkKGV2dC50YXJnZXQpO1xyXG4gICAgICAgIHZhciBpZDtcclxuICAgICAgICAvLyBpcyBpdCBhcmMgZHJhZyBzdGFydD9cclxuICAgICAgICBpZiAoaWQgPSB0YXJnZXQuYXR0cignZGF0YS1zcGFuLWlkJykpIHtcclxuICAgICAgICAgIGFyY09wdGlvbnMgPSBudWxsO1xyXG4gICAgICAgICAgc3RhcnRBcmNEcmFnKGlkKTtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgb25Nb3VzZU1vdmUgPSBmdW5jdGlvbihldnQpIHtcclxuICAgICAgICBpZiAoYXJjRHJhZ09yaWdpbikge1xyXG4gICAgICAgICAgaWYgKGFyY0RyYWdKdXN0U3RhcnRlZCkge1xyXG4gICAgICAgICAgICAvLyBzaG93IHRoZSBwb3NzaWJsZSB0YXJnZXRzXHJcbiAgICAgICAgICAgIHZhciBzcGFuID0gZGF0YS5zcGFuc1thcmNEcmFnT3JpZ2luXSB8fCB7fTtcclxuICAgICAgICAgICAgdmFyIHNwYW5EZXNjID0gc3BhblR5cGVzW3NwYW4udHlwZV0gfHwge307XHJcblxyXG4gICAgICAgICAgICAvLyBzZXBhcmF0ZSBvdXQgcG9zc2libGUgbnVtZXJpYyBzdWZmaXggZnJvbSB0eXBlIGZvciBoaWdoaWdodFxyXG4gICAgICAgICAgICAvLyAoaW5zdGVhZCBvZiBlLmcuIFwiVGhlbWUzXCIsIG5lZWQgdG8gbG9vayBmb3IgXCJUaGVtZVwiKVxyXG4gICAgICAgICAgICB2YXIgbm9OdW1BcmNUeXBlID0gc3RyaXBOdW1lcmljU3VmZml4KGFyY09wdGlvbnMgJiYgYXJjT3B0aW9ucy50eXBlKTtcclxuICAgICAgICAgICAgLy8gdmFyIHRhcmdldENsYXNzZXMgPSBbXTtcclxuICAgICAgICAgICAgdmFyICR0YXJnZXRzID0gJCgpO1xyXG4gICAgICAgICAgICAkLmVhY2goc3BhbkRlc2MuYXJjcyB8fCBbXSwgZnVuY3Rpb24ocG9zc2libGVBcmNObywgcG9zc2libGVBcmMpIHtcclxuICAgICAgICAgICAgICBpZiAoKGFyY09wdGlvbnMgJiYgcG9zc2libGVBcmMudHlwZSA9PSBub051bUFyY1R5cGUpIHx8ICEoYXJjT3B0aW9ucyAmJiBhcmNPcHRpb25zLm9sZF90YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAkLmVhY2gocG9zc2libGVBcmMudGFyZ2V0cyB8fCBbXSwgZnVuY3Rpb24ocG9zc2libGVUYXJnZXRObywgcG9zc2libGVUYXJnZXQpIHtcclxuICAgICAgICAgICAgICAgICAgLy8gc3BlZWR1cCBmb3IgIzY0MjogcmVsZXZhbnQgYnJvd3NlcnMgc2hvdWxkIHN1cHBvcnRcclxuICAgICAgICAgICAgICAgICAgLy8gdGhpcyBmdW5jdGlvbjogaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9kb20vdzNjX2NvcmUuaHRtbCN0MTFcclxuICAgICAgICAgICAgICAgICAgLy8gc28gd2UgZ2V0IG9mZiBqUXVlcnkgYW5kIGdldCBkb3duIHRvIHRoZSBtZXRhbDpcclxuICAgICAgICAgICAgICAgICAgLy8gdGFyZ2V0Q2xhc3Nlcy5wdXNoKCcuc3Bhbl8nICsgcG9zc2libGVUYXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgICAkdGFyZ2V0cyA9ICR0YXJnZXRzLmFkZChzdmdFbGVtZW50WzBdLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3NwYW5fJyArIHBvc3NpYmxlVGFyZ2V0KSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyQodGFyZ2V0Q2xhc3Nlcy5qb2luKCcsJykpLm5vdCgnW2RhdGEtc3Bhbi1pZD1cIicgKyBhcmNEcmFnT3JpZ2luICsgJ1wiXScpLmFkZENsYXNzKCdyZXNlbGVjdFRhcmdldCcpO1xyXG4gICAgICAgICAgICAvL1RPRE8gbmV4dCBvbmUgc2hvdWxkIGJlIHdvcmtpbmcgYnV0IGRvZXNuJ3QuIFJlbmF1ZCBvbiAyMDE2LTAzLTEwXHJcbiAgICAgICAgICAgICR0YXJnZXRzLm5vdCgnW2RhdGEtc3Bhbi1pZD1cIicgKyBhcmNEcmFnT3JpZ2luICsgJ1wiXScpLmFkZENsYXNzKCdyZXNlbGVjdFRhcmdldCcpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY2xlYXJTZWxlY3Rpb24oKTtcclxuICAgICAgICAgIHZhciBteCA9IGV2dC5wYWdlWCAtIHN2Z1Bvc2l0aW9uLmxlZnQ7XHJcbiAgICAgICAgICB2YXIgbXkgPSBldnQucGFnZVkgLSBzdmdQb3NpdGlvbi50b3AgKyA1OyAvLyBUT0RPIEZJWE1FIHdoeSArNT8hP1xyXG4gICAgICAgICAgdmFyIHkgPSBNYXRoLm1pbihhcmNEcmFnT3JpZ2luQm94LnksIG15KSAtIGRyYWdnZWRBcmNIZWlnaHQ7XHJcbiAgICAgICAgICB2YXIgZHggPSAoYXJjRHJhZ09yaWdpbkJveC5jZW50ZXIgLSBteCkgLyA0O1xyXG4gICAgICAgICAgdmFyIHBhdGggPSBzdmcuY3JlYXRlUGF0aCgpLlxyXG4gICAgICAgICAgICBtb3ZlKGFyY0RyYWdPcmlnaW5Cb3guY2VudGVyLCBhcmNEcmFnT3JpZ2luQm94LnkpLlxyXG4gICAgICAgICAgICBjdXJ2ZUMoYXJjRHJhZ09yaWdpbkJveC5jZW50ZXIgLSBkeCwgeSxcclxuICAgICAgICAgICAgICAgIG14ICsgZHgsIHksXHJcbiAgICAgICAgICAgICAgICBteCwgbXkpO1xyXG4gICAgICAgICAgYXJjRHJhZ0FyYy5zZXRBdHRyaWJ1dGUoJ2QnLCBwYXRoLnBhdGgoKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIEEuIFNjZXJyaSBGaXJlRm94IGNodW5rXHJcblxyXG4gICAgICAgICAgLy8gaWYgbm90LCB0aGVuIGlzIGl0IHNwYW4gc2VsZWN0aW9uPyAoY3RybCBrZXkgY2FuY2VscylcclxuICAgICAgICAgIHZhciBzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XHJcbiAgICAgICAgICB2YXIgY2h1bmtJbmRleEZyb20gPSBzZWwuYW5jaG9yTm9kZSAmJiAkKHNlbC5hbmNob3JOb2RlLnBhcmVudE5vZGUpLmF0dHIoJ2RhdGEtY2h1bmstaWQnKTtcclxuICAgICAgICAgIHZhciBjaHVua0luZGV4VG8gPSBzZWwuZm9jdXNOb2RlICYmICQoc2VsLmZvY3VzTm9kZS5wYXJlbnROb2RlKS5hdHRyKCdkYXRhLWNodW5rLWlkJyk7XHJcbiAgICAgICAgICAvLyBmYWxsYmFjayBmb3IgZmlyZWZveCAoYXQgbGVhc3QpOlxyXG4gICAgICAgICAgLy8gaXQncyB1bmNsZWFyIHdoeSwgYnV0IGZvciBmaXJlZm94IHRoZSBhbmNob3IgYW5kIGZvY3VzXHJcbiAgICAgICAgICAvLyBub2RlIHBhcmVudHMgYXJlIGFsd2F5cyB1bmRlZmluZWQsIHRoZSB0aGUgYW5jaG9yIGFuZFxyXG4gICAgICAgICAgLy8gZm9jdXMgbm9kZXMgdGhlbXNlbHZlcyBkbyAob2Z0ZW4pIGhhdmUgdGhlIG5lY2Vzc2FyeVxyXG4gICAgICAgICAgLy8gY2h1bmsgSUQuIEhvd2V2ZXIsIGFuY2hvciBvZmZzZXRzIGFyZSBhbG1vc3QgYWx3YXlzXHJcbiAgICAgICAgICAvLyB3cm9uZywgc28gd2UnbGwganVzdCBtYWtlIGEgZ3Vlc3MgYXQgd2hhdCB0aGUgdXNlciBtaWdodFxyXG4gICAgICAgICAgLy8gYmUgaW50ZXJlc3RlZCBpbiB0YWdnaW5nIGluc3RlYWQgb2YgdXNpbmcgd2hhdCdzIGdpdmVuLlxyXG4gICAgICAgICAgdmFyIGFuY2hvck9mZnNldCA9IG51bGw7XHJcbiAgICAgICAgICB2YXIgZm9jdXNPZmZzZXQgPSBudWxsO1xyXG4gICAgICAgICAgaWYgKGNodW5rSW5kZXhGcm9tID09PSB1bmRlZmluZWQgJiYgY2h1bmtJbmRleFRvID09PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgICAkKHNlbC5hbmNob3JOb2RlKS5hdHRyKCdkYXRhLWNodW5rLWlkJykgJiZcclxuICAgICAgICAgICAgICAkKHNlbC5mb2N1c05vZGUpLmF0dHIoJ2RhdGEtY2h1bmstaWQnKSkge1xyXG4gICAgICAgICAgICAvLyBMZXRzIHRha2UgdGhlIGFjdHVhbCBzZWxlY3Rpb24gcmFuZ2UgYW5kIHdvcmsgd2l0aCB0aGF0XHJcbiAgICAgICAgICAgIC8vIE5vdGUgZm9yIHZpc3VhbCBsaW5lIHVwIGFuZCBtb3JlIGFjY3VyYXRlIHBvc2l0aW9ucyBhIHZlcnRpY2FsIG9mZnNldCBvZiA4IGFuZCBob3Jpem9udGFsIG9mIDIgaGFzIGJlZW4gdXNlZCFcclxuICAgICAgICAgICAgdmFyIHJhbmdlID0gc2VsLmdldFJhbmdlQXQoMCk7XHJcbiAgICAgICAgICAgIHZhciBzdmdPZmZzZXQgPSAkKHN2Zy5fc3ZnKS5vZmZzZXQoKTtcclxuICAgICAgICAgICAgdmFyIGZsaXAgPSBmYWxzZTtcclxuICAgICAgICAgICAgdmFyIHRyaWVzID0gMDtcclxuICAgICAgICAgICAgLy8gRmlyc3QgdHJ5IGFuZCBtYXRjaCB0aGUgc3RhcnQgb2Zmc2V0IHdpdGggYSBwb3NpdGlvbiwgaWYgbm90IHRyeSBpdCBhZ2FpbnN0IHRoZSBvdGhlciBlbmRcclxuICAgICAgICAgICAgd2hpbGUgKHRyaWVzIDwgMikge1xyXG4gICAgICAgICAgICAgIHZhciBzcCA9IHN2Zy5fc3ZnLmNyZWF0ZVNWR1BvaW50KCk7XHJcbiAgICAgICAgICAgICAgc3AueCA9IChmbGlwID8gZXZ0LnBhZ2VYIDogZHJhZ1N0YXJ0ZWRBdC5wYWdlWCkgLSBzdmdPZmZzZXQubGVmdDtcclxuICAgICAgICAgICAgICBzcC55ID0gKGZsaXAgPyBldnQucGFnZVkgOiBkcmFnU3RhcnRlZEF0LnBhZ2VZKSAtIChzdmdPZmZzZXQudG9wICsgOCk7XHJcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0c0F0ID0gcmFuZ2Uuc3RhcnRDb250YWluZXI7XHJcbiAgICAgICAgICAgICAgYW5jaG9yT2Zmc2V0ID0gc3RhcnRzQXQuZ2V0Q2hhck51bUF0UG9zaXRpb24oc3ApO1xyXG4gICAgICAgICAgICAgIGNodW5rSW5kZXhGcm9tID0gc3RhcnRzQXQgJiYgJChzdGFydHNBdCkuYXR0cignZGF0YS1jaHVuay1pZCcpO1xyXG4gICAgICAgICAgICAgIGlmIChhbmNob3JPZmZzZXQgIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBmbGlwID0gdHJ1ZTtcclxuICAgICAgICAgICAgICB0cmllcysrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBOb3cgZ3JhYiB0aGUgZW5kIG9mZnNldFxyXG4gICAgICAgICAgICBzcC54ID0gKGZsaXAgPyBkcmFnU3RhcnRlZEF0LnBhZ2VYIDogZXZ0LnBhZ2VYKSAtIHN2Z09mZnNldC5sZWZ0O1xyXG4gICAgICAgICAgICBzcC55ID0gKGZsaXAgPyBkcmFnU3RhcnRlZEF0LnBhZ2VZIDogZXZ0LnBhZ2VZKSAtIChzdmdPZmZzZXQudG9wICsgOCk7XHJcbiAgICAgICAgICAgIHZhciBlbmRzQXQgPSByYW5nZS5lbmRDb250YWluZXI7XHJcbiAgICAgICAgICAgIGZvY3VzT2Zmc2V0ID0gZW5kc0F0LmdldENoYXJOdW1BdFBvc2l0aW9uKHNwKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHdlIGNhbm5vdCBnZXQgYSBzdGFydCBhbmQgZW5kIG9mZnNldCBzdG9wIGhlcmVcclxuICAgICAgICAgICAgaWYgKGFuY2hvck9mZnNldCA9PSAtMSB8fCBmb2N1c09mZnNldCA9PSAtMSkge1xyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBJZiB3ZSBhcmUgaW4gdGhlIHNhbWUgY29udGFpbmVyIGl0IGRvZXMgdGhlIHNlbGVjdGlvbiBiYWNrIHRvIGZyb250IHdoZW4gZHJhZ2dlZCByaWdodCB0byBsZWZ0LCBhY3Jvc3MgZGlmZmVyZW50IGNvbnRhaW5lcnMgdGhlIHN0YXJ0IGlzIHRoZSBzdGFydCBhbmQgdGhlIGVuZCBpZiB0aGUgZW5kIVxyXG4gICAgICAgICAgICBpZihyYW5nZS5zdGFydENvbnRhaW5lciA9PSByYW5nZS5lbmRDb250YWluZXIgJiYgYW5jaG9yT2Zmc2V0ID4gZm9jdXNPZmZzZXQpIHtcclxuICAgICAgICAgICAgICB2YXIgdCA9IGFuY2hvck9mZnNldDtcclxuICAgICAgICAgICAgICBhbmNob3JPZmZzZXQgPSBmb2N1c09mZnNldDtcclxuICAgICAgICAgICAgICBmb2N1c09mZnNldCA9IHQ7XHJcbiAgICAgICAgICAgICAgZmxpcCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNodW5rSW5kZXhUbyA9IGVuZHNBdCAmJiAkKGVuZHNBdCkuYXR0cignZGF0YS1jaHVuay1pZCcpO1xyXG5cclxuICAgICAgICAgICAgLy8gTm93IHRha2UgdGhlIHN0YXJ0IGFuZCBlbmQgY2hhcmFjdGVyIHJlY3RhbmdsZXNcclxuICAgICAgICAgICAgc3RhcnRSZWMgPSBzdGFydHNBdC5nZXRFeHRlbnRPZkNoYXIoYW5jaG9yT2Zmc2V0KTtcclxuICAgICAgICAgICAgc3RhcnRSZWMueSArPSAyO1xyXG4gICAgICAgICAgICBlbmRSZWMgPSBlbmRzQXQuZ2V0RXh0ZW50T2ZDaGFyKGZvY3VzT2Zmc2V0KTtcclxuICAgICAgICAgICAgZW5kUmVjLnkgKz0gMjtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIG5vdGhpbmcgaGFzIGNoYW5nZWQgdGhlbiBzdG9wIGhlcmVcclxuICAgICAgICAgICAgaWYgKGxhc3RTdGFydFJlYyAhPSBudWxsICYmIGxhc3RTdGFydFJlYy54ID09IHN0YXJ0UmVjLnggJiYgbGFzdFN0YXJ0UmVjLnkgPT0gc3RhcnRSZWMueSAmJiBsYXN0RW5kUmVjICE9IG51bGwgJiYgbGFzdEVuZFJlYy54ID09IGVuZFJlYy54ICYmIGxhc3RFbmRSZWMueSA9PSBlbmRSZWMueSkge1xyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHNlbFJlY3QgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgIHZhciByeCA9IHN0YXJ0UmVjLng7XHJcbiAgICAgICAgICAgICAgdmFyIHJ5ID0gc3RhcnRSZWMueTtcclxuICAgICAgICAgICAgICB2YXIgcncgPSAoZW5kUmVjLnggKyBlbmRSZWMud2lkdGgpIC0gc3RhcnRSZWMueDtcclxuICAgICAgICAgICAgICBpZiAocncgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICByeCArPSBydztcclxuICAgICAgICAgICAgICAgIHJ3ID0gLXJ3O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB2YXIgcmggPSBNYXRoLm1heChzdGFydFJlYy5oZWlnaHQsIGVuZFJlYy5oZWlnaHQpO1xyXG5cclxuICAgICAgICAgICAgICBzZWxSZWN0ID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgdmFyIGFjdGl2ZVNlbFJlY3QgPSBtYWtlU2VsUmVjdChyeCwgcnksIHJ3LCByaCk7XHJcbiAgICAgICAgICAgICAgc2VsUmVjdC5wdXNoKGFjdGl2ZVNlbFJlY3QpO1xyXG4gICAgICAgICAgICAgIHN0YXJ0c0F0LnBhcmVudE5vZGUucGFyZW50Tm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhY3RpdmVTZWxSZWN0LCBzdGFydHNBdC5wYXJlbnROb2RlLnBhcmVudE5vZGUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGlmIChzdGFydFJlYy54ICE9IGxhc3RTdGFydFJlYy54ICYmIGVuZFJlYy54ICE9IGxhc3RFbmRSZWMueCAmJiAoc3RhcnRSZWMueSAhPSBsYXN0U3RhcnRSZWMueSB8fCBlbmRSZWMueSAhPSBsYXN0RW5kUmVjLnkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRSZWMueSA8IGxhc3RTdGFydFJlYy55KSB7XHJcbiAgICAgICAgICAgICAgICAgIHNlbFJlY3RbMF0uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCBsYXN0U3RhcnRSZWMud2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgICBsYXN0RW5kUmVjID0gbGFzdFN0YXJ0UmVjO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbmRSZWMueSA+IGxhc3RFbmRSZWMueSkge1xyXG4gICAgICAgICAgICAgICAgICBzZWxSZWN0W3NlbFJlY3QubGVuZ3RoIC0gMV0uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHNlbFJlY3Rbc2VsUmVjdC5sZW5ndGggLSAxXS5nZXRBdHRyaWJ1dGVOUyhudWxsLCBcInhcIikpXHJcbiAgICAgICAgICAgICAgICAgICAgICArIHBhcnNlRmxvYXQoc2VsUmVjdFtzZWxSZWN0Lmxlbmd0aCAtIDFdLmdldEF0dHJpYnV0ZU5TKG51bGwsIFwid2lkdGhcIikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAtIGxhc3RFbmRSZWMud2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgICBzZWxSZWN0W3NlbFJlY3QubGVuZ3RoIC0gMV0uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCAwKTtcclxuICAgICAgICAgICAgICAgICAgbGFzdFN0YXJ0UmVjPWxhc3RFbmRSZWM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAvLyBTdGFydCBoYXMgbW92ZWRcclxuICAgICAgICAgICAgICB2YXIgZmxpcCA9ICEoc3RhcnRSZWMueCA9PSBsYXN0U3RhcnRSZWMueCAmJiBzdGFydFJlYy55ID09IGxhc3RTdGFydFJlYy55KTtcclxuICAgICAgICAgICAgICAvLyBJZiB0aGUgaGVpZ2h0IG9mIHRoZSBzdGFydCBvciBlbmQgY2hhbmdlZCB3ZSBuZWVkIHRvIGNoZWNrIHdoZXRoZXJcclxuICAgICAgICAgICAgICAvLyB0byByZW1vdmUgbXVsdGkgbGluZSBoaWdobGlnaHRzIG5vIGxvbmdlciBuZWVkZWQgaWYgdGhlIHVzZXIgd2VudCBiYWNrIHRvd2FyZHMgdGhlaXIgc3RhcnQgbGluZVxyXG4gICAgICAgICAgICAgIC8vIGFuZCB3aGV0aGVyIHRvIGNyZWF0ZSBuZXcgb25lcyBpZiB3ZSBtb3ZlZCB0byBhIG5ld2xpbmVcclxuICAgICAgICAgICAgICBpZiAoKChlbmRSZWMueSAhPSBsYXN0RW5kUmVjLnkpKSB8fCAoKHN0YXJ0UmVjLnkgIT0gbGFzdFN0YXJ0UmVjLnkpKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgd2UgaGF2ZSB0byByZW1vdmUgdGhlIGZpcnN0IGhpZ2hsaWdodHMgYmVjYXVzZSB3ZSBhcmUgbW92aW5nIHRvd2FyZHMgdGhlIGVuZCBvbiBhIGRpZmZlcmVudCBsaW5lXHJcbiAgICAgICAgICAgICAgICB2YXIgc3MgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yICg7IHNzICE9IHNlbFJlY3QubGVuZ3RoOyBzcysrKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChzdGFydFJlYy55IDw9IHBhcnNlRmxvYXQoc2VsUmVjdFtzc10uZ2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBOZXh0IGNoZWNrIGZvciBhbnkgZW5kIGhpZ2hsaWdodHMgaWYgd2UgYXJlIG1vdmluZyB0b3dhcmRzIHRoZSBzdGFydCBvbiBhIGRpZmZlcmVudCBsaW5lXHJcbiAgICAgICAgICAgICAgICB2YXIgZXMgPSBzZWxSZWN0Lmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgZXMgIT0gLTE7IGVzLS0pIHtcclxuICAgICAgICAgICAgICAgICAgaWYgKGVuZFJlYy55ID49IHBhcnNlRmxvYXQoc2VsUmVjdFtlc10uZ2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPIHB1dCB0aGlzIGluIGxvb3BzIGFib3ZlLCBmb3IgZWZmaWNpZW5jeSB0aGUgYXJyYXkgc2xpY2luZyBjb3VsZCBiZSBkb25lIHNlcGFyYXRlIHN0aWxsIGluIHNpbmdsZSBjYWxsXHJcbiAgICAgICAgICAgICAgICB2YXIgdHJ1bmMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmIChzcyA8IHNlbFJlY3QubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIHMyID0gMDsgczIgIT0gc3M7IHMyKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxSZWN0W3MyXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNlbFJlY3RbczJdKTtcclxuICAgICAgICAgICAgICAgICAgICBlcy0tO1xyXG4gICAgICAgICAgICAgICAgICAgIHRydW5jID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBzZWxSZWN0ID0gc2VsUmVjdC5zbGljZShzcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZXMgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBzMiA9IHNlbFJlY3QubGVuZ3RoIC0gMTsgczIgIT0gZXM7IHMyLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxSZWN0W3MyXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNlbFJlY3RbczJdKTtcclxuICAgICAgICAgICAgICAgICAgICB0cnVuYyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgc2VsUmVjdCA9IHNlbFJlY3Quc2xpY2UoMCwgZXMgKyAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIHRydW5jYXRlZCB0aGUgaGlnaGxpZ2h0cyB3ZSBuZWVkIHRvIHJlYWRqdXN0IHRoZSBsYXN0IG9uZVxyXG4gICAgICAgICAgICAgICAgaWYgKHRydW5jKSB7XHJcbiAgICAgICAgICAgICAgICAgIHZhciBhY3RpdmVTZWxSZWN0ID0gZmxpcCA/IHNlbFJlY3RbMF0gOiBzZWxSZWN0W3NlbFJlY3QubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgIGlmIChmbGlwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJ3ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRSZWMueSA9PSBlbmRSZWMueSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgcncgPSAoZW5kUmVjLnggKyBlbmRSZWMud2lkdGgpIC0gc3RhcnRSZWMueDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgcncgPSAocGFyc2VGbG9hdChhY3RpdmVTZWxSZWN0LmdldEF0dHJpYnV0ZU5TKG51bGwsIFwieFwiKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICArIHBhcnNlRmxvYXQoYWN0aXZlU2VsUmVjdC5nZXRBdHRyaWJ1dGVOUyhudWxsLCBcIndpZHRoXCIpKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAtIHN0YXJ0UmVjLng7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZVNlbFJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4XCIsIHN0YXJ0UmVjLngpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZVNlbFJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIHN0YXJ0UmVjLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZVNlbFJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCBydyk7XHJcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJ3ID0gKGVuZFJlYy54ICsgZW5kUmVjLndpZHRoKSAtIHBhcnNlRmxvYXQoYWN0aXZlU2VsUmVjdC5nZXRBdHRyaWJ1dGVOUyhudWxsLCBcInhcIikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZVNlbFJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCBydyk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIC8vIFdlIGRpZG50IHRydW5jYXRlIGFueXRoaW5nIGJ1dCB3ZSBoYXZlIG1vdmVkIHRvIGEgbmV3IGxpbmUgc28gd2UgbmVlZCB0byBjcmVhdGUgYSBuZXcgaGlnaGxpZ2h0XHJcbiAgICAgICAgICAgICAgICAgIHZhciBsYXN0U2VsID0gZmxpcCA/IHNlbFJlY3RbMF0gOiBzZWxSZWN0W3NlbFJlY3QubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgIHZhciBzdGFydEJveCA9IHN0YXJ0c0F0LnBhcmVudE5vZGUuZ2V0QkJveCgpO1xyXG4gICAgICAgICAgICAgICAgICB2YXIgZW5kQm94ID0gZW5kc0F0LnBhcmVudE5vZGUuZ2V0QkJveCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgaWYgKGZsaXApIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0U2VsLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwid2lkdGhcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHBhcnNlRmxvYXQobGFzdFNlbC5nZXRBdHRyaWJ1dGVOUyhudWxsLCBcInhcIikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgcGFyc2VGbG9hdChsYXN0U2VsLmdldEF0dHJpYnV0ZU5TKG51bGwsIFwid2lkdGhcIikpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAtIGVuZEJveC54KTtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0U2VsLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieFwiLCBlbmRCb3gueCk7XHJcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdFNlbC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIndpZHRoXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChzdGFydEJveC54ICsgc3RhcnRCb3gud2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC0gcGFyc2VGbG9hdChsYXN0U2VsLmdldEF0dHJpYnV0ZU5TKG51bGwsIFwieFwiKSkpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIHZhciByeCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgIHZhciByeSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgIHZhciBydyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgIHZhciByaCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChmbGlwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcnggPSBzdGFydFJlYy54O1xyXG4gICAgICAgICAgICAgICAgICAgIHJ5ID0gc3RhcnRSZWMueTtcclxuICAgICAgICAgICAgICAgICAgICBydyA9ICQoc3ZnLl9zdmcpLndpZHRoKCkgLSBzdGFydFJlYy54O1xyXG4gICAgICAgICAgICAgICAgICAgIHJoID0gc3RhcnRSZWMuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJ4ID0gZW5kQm94Lng7XHJcbiAgICAgICAgICAgICAgICAgICAgcnkgPSBlbmRSZWMueTtcclxuICAgICAgICAgICAgICAgICAgICBydyA9IChlbmRSZWMueCArIGVuZFJlYy53aWR0aCkgLSBlbmRCb3gueDtcclxuICAgICAgICAgICAgICAgICAgICByaCA9IGVuZFJlYy5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgdmFyIG5ld1JlY3QgPSBtYWtlU2VsUmVjdChyeCwgcnksIHJ3LCByaCk7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChmbGlwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsUmVjdC51bnNoaWZ0KG5ld1JlY3QpO1xyXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbFJlY3QucHVzaChuZXdSZWN0KTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gUGxhY2UgbmV3IGhpZ2hsaWdodCBpbiBhcHByb3ByaWF0ZSBzbG90IGluIFNWRyBncmFwaFxyXG4gICAgICAgICAgICAgICAgICBzdGFydHNBdC5wYXJlbnROb2RlLnBhcmVudE5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3UmVjdCwgc3RhcnRzQXQucGFyZW50Tm9kZS5wYXJlbnROb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIHVzZXIgc2ltcGx5IG1vdmVkIGxlZnQgb3IgcmlnaHQgYWxvbmcgdGhlIHNhbWUgbGluZSBzbyBqdXN0IGFkanVzdCB0aGUgY3VycmVudCBoaWdobGlnaHRcclxuICAgICAgICAgICAgICAgIHZhciBhY3RpdmVTZWxSZWN0ID0gZmxpcCA/IHNlbFJlY3RbMF0gOiBzZWxSZWN0W3NlbFJlY3QubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgc3RhcnQgbW92ZWQgc2hpZnQgdGhlIGhpZ2hsaWdodCBhbmQgYWRqdXN0IHdpZHRoXHJcbiAgICAgICAgICAgICAgICBpZiAoZmxpcCkge1xyXG4gICAgICAgICAgICAgICAgICB2YXIgcncgPSAocGFyc2VGbG9hdChhY3RpdmVTZWxSZWN0LmdldEF0dHJpYnV0ZU5TKG51bGwsIFwieFwiKSlcclxuICAgICAgICAgICAgICAgICAgICAgICsgcGFyc2VGbG9hdChhY3RpdmVTZWxSZWN0LmdldEF0dHJpYnV0ZU5TKG51bGwsIFwid2lkdGhcIikpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgLSBzdGFydFJlYy54O1xyXG4gICAgICAgICAgICAgICAgICBhY3RpdmVTZWxSZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieFwiLCBzdGFydFJlYy54KTtcclxuICAgICAgICAgICAgICAgICAgYWN0aXZlU2VsUmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgc3RhcnRSZWMueSk7XHJcbiAgICAgICAgICAgICAgICAgIGFjdGl2ZVNlbFJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCBydyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZW5kIG1vdmVkIHRoZW4gc2ltcGxlIGNoYW5nZSB0aGUgd2lkdGhcclxuICAgICAgICAgICAgICAgICAgdmFyIHJ3ID0gKGVuZFJlYy54ICsgZW5kUmVjLndpZHRoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgLSBwYXJzZUZsb2F0KGFjdGl2ZVNlbFJlY3QuZ2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4XCIpKTtcclxuICAgICAgICAgICAgICAgICAgYWN0aXZlU2VsUmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIndpZHRoXCIsIHJ3KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGFzdFN0YXJ0UmVjID0gc3RhcnRSZWM7XHJcbiAgICAgICAgICAgIGxhc3RFbmRSZWMgPSBlbmRSZWM7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFyY0RyYWdKdXN0U3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdmFyIGFkanVzdFRvQ3Vyc29yID0gZnVuY3Rpb24oZXZ0LCBlbGVtZW50LCBjZW50ZXJYLCBjZW50ZXJZKSB7XHJcbiAgICAgICAgdmFyIHNjcmVlbkhlaWdodCA9ICQod2luZG93KS5oZWlnaHQoKSAtIDg7IC8vIFRPRE8gSEFDSyAtIG5vIGlkZWEgd2h5IC04IGlzIG5lZWRlZFxyXG4gICAgICAgIHZhciBzY3JlZW5XaWR0aCA9ICQod2luZG93KS53aWR0aCgpIC0gODtcclxuICAgICAgICB2YXIgZWxlbWVudEhlaWdodCA9IGVsZW1lbnQuaGVpZ2h0KCk7XHJcbiAgICAgICAgdmFyIGVsZW1lbnRXaWR0aCA9IGVsZW1lbnQud2lkdGgoKTtcclxuICAgICAgICB2YXIgY3NzU2V0dGluZ3MgPSB7fTtcclxuICAgICAgICB2YXIgZUxlZnQ7XHJcbiAgICAgICAgdmFyIGVUb3A7XHJcbiAgICAgICAgaWYgKGNlbnRlclgpIHtcclxuICAgICAgICAgICAgZUxlZnQgPSBldnQuY2xpZW50WCAtIGVsZW1lbnRXaWR0aC8yO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGVMZWZ0ID0gZXZ0LmNsaWVudFg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjZW50ZXJZKSB7XHJcbiAgICAgICAgICAgIGVUb3AgPSBldnQuY2xpZW50WSAtIGVsZW1lbnRIZWlnaHQvMjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBlVG9wID0gZXZ0LmNsaWVudFk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRyeSB0byBtYWtlIHN1cmUgdGhlIGVsZW1lbnQgZG9lc24ndCBnbyBvZmYtc2NyZWVuLlxyXG4gICAgICAgIC8vIElmIHRoaXMgaXNuJ3QgcG9zc2libGUgKHRoZSBlbGVtZW50IGlzIGxhcmdlciB0aGFuIHRoZSBzY3JlZW4pLFxyXG4gICAgICAgIC8vIGFsaWdodCB0b3AtbGVmdCBjb3JuZXIgb2Ygc2NyZWVuIGFuZCBkaWFsb2cgYXMgYSBjb21wcm9taXNlLlxyXG4gICAgICAgIGlmIChzY3JlZW5XaWR0aCA+IGVsZW1lbnRXaWR0aCkge1xyXG4gICAgICAgICAgICBlTGVmdCA9IE1hdGgubWluKE1hdGgubWF4KGVMZWZ0LDApLCBzY3JlZW5XaWR0aCAtIGVsZW1lbnRXaWR0aCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZUxlZnQgPSAwO1xyXG4gICAgICAgIH0gXHJcbiAgICAgICAgaWYgKHNjcmVlbkhlaWdodCA+IGVsZW1lbnRIZWlnaHQpIHtcclxuICAgICAgICAgICAgZVRvcCAgPSBNYXRoLm1pbihNYXRoLm1heChlVG9wLDApLCBzY3JlZW5IZWlnaHQgLSBlbGVtZW50SGVpZ2h0KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBlVG9wICA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsZW1lbnQuY3NzKHsgdG9wOiBlVG9wLCBsZWZ0OiBlTGVmdCB9KTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciB1cGRhdGVDaGVja2JveCA9IGZ1bmN0aW9uKCRpbnB1dCkge1xyXG4gICAgICAgIHZhciAkd2lkZ2V0ID0gJGlucHV0LmJ1dHRvbignd2lkZ2V0Jyk7XHJcbiAgICAgICAgdmFyICR0ZXh0c3BhbiA9ICR3aWRnZXQuZmluZCgnLnVpLWJ1dHRvbi10ZXh0Jyk7XHJcbiAgICAgICAgJHRleHRzcGFuLmh0bWwoKCRpbnB1dFswXS5jaGVja2VkID8gJyYjeDI2MTE7ICcgOiAnJiN4MjYxMDsgJykgKyAkd2lkZ2V0LmF0dHIoJ2RhdGEtYmFyZScpKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciBmaWxsU3BhblR5cGVzQW5kRGlzcGxheUZvcm0gPSBmdW5jdGlvbihldnQsIHNwYW5UZXh0LCBzcGFuKSB7XHJcbiAgICAgICAga2V5bWFwID0gc3BhbktleW1hcDtcclxuXHJcbiAgICAgICAgLy8gRmlndXJlIG91dCB3aGV0aGVyIHdlIHNob3VsZCBzaG93IG9yIGhpZGUgb25lIG9mIHRoZSB0d29cclxuICAgICAgICAvLyBtYWluIGhhbHZlcyBvZiB0aGUgc2VsZWN0aW9uIGZyYW1lIChlbnRpdGllcyAvIGV2ZW50cykuXHJcbiAgICAgICAgLy8gVGhpcyBkZXBlbmRzIG9uIHRoZSB0eXBlIG9mIHRoZSBjdXJyZW50IHNwYW4sIGlmIGFueSwgYW5kXHJcbiAgICAgICAgLy8gdGhlIGF2YWlsYWJpbGl0eSBvZiB0eXBlcyB0byBzZWxlY3QuXHJcbiAgICAgICAgdmFyIGhpZGVGcmFtZTtcclxuICAgICAgICBpZiAoc3Bhbikge1xyXG4gICAgICAgICAgLy8gZXhpc3Rpbmcgc3Bhbjsgb25seSBzaG93IHJlbGV2YW50IGhhbGZcclxuICAgICAgICAgIGlmIChzcGFuLmdlbmVyYWxUeXBlID09ICdlbnRpdHknKSB7XHJcbiAgICAgICAgICAgIGhpZGVGcmFtZSA9ICdldmVudCc7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBoaWRlRnJhbWUgPSAnZW50aXR5JztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHNwYW5Gb3JtLmRpYWxvZygnb3B0aW9uJywgeyB0aXRsZTogJ0VkaXQgQW5ub3RhdGlvbicgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIG5ldyBzcGFuOyBzaG93IGV2ZXJ5dGhpbmcgdGhhdCdzIGF2YWlsYWJsZVxyXG4gICAgICAgICAgaWYgKCQoJyNldmVudF90eXBlcycpLmZpbmQoJ2lucHV0JykubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgaGlkZUZyYW1lID0gJ2V2ZW50JztcclxuICAgICAgICAgIH0gZWxzZSBpZiAoJCgnI2VudGl0eV90eXBlcycpLmZpbmQoJ2lucHV0JykubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgaGlkZUZyYW1lID0gJ2VudGl0eSc7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBoaWRlRnJhbWUgPSAnbm9uZSc7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBzcGFuRm9ybS5kaWFsb2coJ29wdGlvbicsIHsgdGl0bGU6ICdOZXcgQW5ub3RhdGlvbicgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChoaWRlRnJhbWUgPT0gJ2V2ZW50Jykge1xyXG4gICAgICAgICAgJCgnI3NwYW5fZXZlbnRfc2VjdGlvbicpLmhpZGUoKVxyXG4gICAgICAgICAgJCgnI3NwYW5fZW50aXR5X3NlY3Rpb24nKS5zaG93KCkuXHJcbiAgICAgICAgICAgIHJlbW92ZUNsYXNzKCd3cmFwcGVyX2hhbGZfbGVmdCcpLlxyXG4gICAgICAgICAgICBhZGRDbGFzcygnd3JhcHBlcl9mdWxsX3dpZHRoJyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChoaWRlRnJhbWUgPT0gJ2VudGl0eScpIHtcclxuICAgICAgICAgICQoJyNzcGFuX2VudGl0eV9zZWN0aW9uJykuaGlkZSgpXHJcbiAgICAgICAgICAkKCcjc3Bhbl9ldmVudF9zZWN0aW9uJykuc2hvdygpLlxyXG4gICAgICAgICAgICByZW1vdmVDbGFzcygnd3JhcHBlcl9oYWxmX3JpZ2h0JykuXHJcbiAgICAgICAgICAgIGFkZENsYXNzKCd3cmFwcGVyX2Z1bGxfd2lkdGgnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gc2hvdyBib3RoIGVudGl0eSBhbmQgZXZlbnQgaGFsdmVzXHJcbiAgICAgICAgICAkKCcjc3Bhbl9lbnRpdHlfc2VjdGlvbicpLnNob3coKS5cclxuICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoJ3dyYXBwZXJfZnVsbF93aWR0aCcpLlxyXG4gICAgICAgICAgICBhZGRDbGFzcygnd3JhcHBlcl9oYWxmX2xlZnQnKTtcclxuICAgICAgICAgICQoJyNzcGFuX2V2ZW50X3NlY3Rpb24nKS5zaG93KCkuXHJcbiAgICAgICAgICAgIHJlbW92ZUNsYXNzKCd3cmFwcGVyX2Z1bGxfd2lkdGgnKS5cclxuICAgICAgICAgICAgYWRkQ2xhc3MoJ3dyYXBwZXJfaGFsZl9yaWdodCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gb25seSBzaG93IFwiZGVsZXRlXCIgYnV0dG9uIGlmIHRoZXJlJ3MgYW4gZXhpc3RpbmcgYW5ub3RhdGlvbiB0byBkZWxldGVcclxuICAgICAgICBpZiAoc3Bhbikge1xyXG4gICAgICAgICAgJCgnI2RlbF9zcGFuX2J1dHRvbicpLnNob3coKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgJCgnI2RlbF9zcGFuX2J1dHRvbicpLmhpZGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICQoJyNzcGFuX3NlbGVjdGVkJykudGV4dChzcGFuVGV4dCk7XHJcbiAgICAgICAgdmFyIGVuY29kZWRUZXh0ID0gZW5jb2RlVVJJQ29tcG9uZW50KHNwYW5UZXh0KTsgICAgICAgXHJcbiAgICAgICAgJC5lYWNoKHNlYXJjaENvbmZpZywgZnVuY3Rpb24oc2VhcmNoTm8sIHNlYXJjaCkge1xyXG4gICAgICAgICAgJCgnI3NwYW5fJytzZWFyY2hbMF0pLmF0dHIoJ2hyZWYnLCBzZWFyY2hbMV0ucmVwbGFjZSgnJXMnLCBlbmNvZGVkVGV4dCkpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBlbmFibGUgYWxsIGlucHV0cyBieSBkZWZhdWx0IChzZWUgc2V0U3BhblR5cGVTZWxlY3RhYmlsaXR5KVxyXG4gICAgICAgICQoJyNzcGFuX2Zvcm0gaW5wdXQ6bm90KFt1bnVzZWRdKScpLnJlbW92ZUF0dHIoJ2Rpc2FibGVkJyk7XHJcblxyXG4gICAgICAgIC8vIGNsb3NlIHNwYW4gdHlwZXMgaWYgdGhlcmUncyBvdmVyIHNwYW5UeXBlc1RvU2hvd0JlZm9yZUNvbGxhcHNlXHJcbiAgICAgICAgaWYgKCQoJyNlbnRpdHlfdHlwZXMgLml0ZW0nKS5sZW5ndGggPiBzcGFuVHlwZXNUb1Nob3dCZWZvcmVDb2xsYXBzZSkge1xyXG4gICAgICAgICAgJCgnI2VudGl0eV90eXBlcyAub3BlbicpLnJlbW92ZUNsYXNzKCdvcGVuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgkKCcjZXZlbnRfdHlwZXMgLml0ZW0nKS5sZW5ndGggPiBzcGFuVHlwZXNUb1Nob3dCZWZvcmVDb2xsYXBzZSkge1xyXG4gICAgICAgICAgJCgnI2V2ZW50X3R5cGVzIC5vcGVuJykucmVtb3ZlQ2xhc3MoJ29wZW4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzaG93QWxsQXR0cmlidXRlcyA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChzcGFuKSB7XHJcbiAgICAgICAgICB2YXIgaGFzaCA9IG5ldyBVUkxIYXNoKGNvbGwsIGRvYywgeyBmb2N1czogW1tzcGFuLmlkXV0gfSkuZ2V0SGFzaCgpO1xyXG4gICAgICAgICAgJCgnI3NwYW5faGlnaGxpZ2h0X2xpbmsnKS5hdHRyKCdocmVmJywgaGFzaCkuc2hvdygpO1xyXG4gICAgICAgICAgdmFyIGVsID0gJCgnI3NwYW5fJyArIHNwYW4udHlwZSk7XHJcbiAgICAgICAgICBpZiAoZWwubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGVsWzBdLmNoZWNrZWQgPSB0cnVlO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgJCgnI3NwYW5fZm9ybSBpbnB1dDpyYWRpbzpjaGVja2VkJykuZWFjaChmdW5jdGlvbiAocmFkaW9ObywgcmFkaW8pIHtcclxuICAgICAgICAgICAgICByYWRpby5jaGVja2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIG9wZW4gdGhlIHNwYW4gdHlwZVxyXG4gICAgICAgICAgJCgnI3NwYW5fJyArIHNwYW4udHlwZSkucGFyZW50cygnLmNvbGxhcHNpYmxlJykuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdG9nZ2xlQ29sbGFwc2libGUoJCh0aGlzKS5wYXJlbnQoKS5wcmV2KCksIHRydWUpO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgLy8gY291bnQgdGhlIHJlcGVhdGluZyBhcmMgdHlwZXNcclxuICAgICAgICAgIHZhciBhcmNUeXBlQ291bnQgPSB7fTtcclxuICAgICAgICAgIHJlcGVhdGluZ0FyY1R5cGVzID0gW107XHJcbiAgICAgICAgICAkLmVhY2goc3Bhbi5vdXRnb2luZywgZnVuY3Rpb24oYXJjTm8sIGFyYykge1xyXG4gICAgICAgICAgICAvLyBwYXJzZSBvdXQgcG9zc2libGUgbnVtYmVyIHN1ZmZpeGVzIHRvIGFsbG93IGUuZy4gc3BsaXR0aW5nXHJcbiAgICAgICAgICAgIC8vIG9uIFwiVGhlbWVcIiBmb3IgYXJncyAoXCJUaGVtZTFcIiwgXCJUaGVtZTJcIikuXHJcbiAgICAgICAgICAgIHZhciBzcGxpdEFyY1R5cGUgPSBhcmMudHlwZS5tYXRjaCgvXiguKj8pKFxcZCopJC8pO1xyXG4gICAgICAgICAgICB2YXIgbm9OdW1BcmNUeXBlID0gc3BsaXRBcmNUeXBlWzFdO1xyXG4gICAgICAgICAgICBpZiAoKGFyY1R5cGVDb3VudFtub051bUFyY1R5cGVdID0gKGFyY1R5cGVDb3VudFtub051bUFyY1R5cGVdIHx8IDApICsgMSkgPT0gMikge1xyXG4gICAgICAgICAgICAgIHJlcGVhdGluZ0FyY1R5cGVzLnB1c2gobm9OdW1BcmNUeXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBpZiAocmVwZWF0aW5nQXJjVHlwZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICQoJyNzcGFuX2Zvcm1fc3BsaXQnKS5zaG93KCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAkKCcjc3Bhbl9mb3JtX3NwbGl0JykuaGlkZSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAkKCcjc3Bhbl9oaWdobGlnaHRfbGluaycpLmhpZGUoKTtcclxuICAgICAgICAgIHZhciBmaXJzdFJhZGlvID0gJCgnI3NwYW5fZm9ybSBpbnB1dDpyYWRpbzpub3QoW3VudXNlZF0pOmZpcnN0JylbMF07XHJcbiAgICAgICAgICBpZiAoZmlyc3RSYWRpbykge1xyXG4gICAgICAgICAgICBmaXJzdFJhZGlvLmNoZWNrZWQgPSB0cnVlO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdoaWRlRm9ybScpO1xyXG4gICAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ21lc3NhZ2VzJywgW1tbJ05vIHZhbGlkIHNwYW4gdHlwZXMgZGVmaW5lZCcsICdlcnJvciddXV0pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAkKCcjc3Bhbl9mb3JtX3NwbGl0JykuaGlkZSgpO1xyXG4gICAgICAgICAgJCgnI3NwYW5fbm90ZXMnKS52YWwoJycpO1xyXG4gICAgICAgICAgc2hvd0FsbEF0dHJpYnV0ZXMgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3BhbiAmJiAhcmVzZWxlY3RlZFNwYW4pIHtcclxuICAgICAgICAgICQoJyNzcGFuX2Zvcm1fcmVzZWxlY3QsICNzcGFuX2Zvcm1fZGVsZXRlLCAjc3Bhbl9mb3JtX2FkZF9mcmFnbWVudCcpLnNob3coKTtcclxuICAgICAgICAgIGtleW1hcFskLnVpLmtleUNvZGUuREVMRVRFXSA9ICdzcGFuX2Zvcm1fZGVsZXRlJztcclxuICAgICAgICAgIGtleW1hcFskLnVpLmtleUNvZGUuSU5TRVJUXSA9ICdzcGFuX2Zvcm1fcmVzZWxlY3QnO1xyXG4gICAgICAgICAga2V5bWFwWydTLScgKyAkLnVpLmtleUNvZGUuRU5URVJdID0gJ3NwYW5fZm9ybV9hZGRfZnJhZ21lbnQnO1xyXG4gICAgICAgICAgJCgnI3NwYW5fbm90ZXMnKS52YWwoc3Bhbi5hbm5vdGF0b3JOb3RlcyB8fCAnJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICQoJyNzcGFuX2Zvcm1fcmVzZWxlY3QsICNzcGFuX2Zvcm1fZGVsZXRlLCAjc3Bhbl9mb3JtX2FkZF9mcmFnbWVudCcpLmhpZGUoKTtcclxuICAgICAgICAgIGtleW1hcFskLnVpLmtleUNvZGUuREVMRVRFXSA9IG51bGw7XHJcbiAgICAgICAgICBrZXltYXBbJC51aS5rZXlDb2RlLklOU0VSVF0gPSBudWxsO1xyXG4gICAgICAgICAga2V5bWFwWydTLScgKyAkLnVpLmtleUNvZGUuRU5URVJdID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNwYW4gJiYgIXJlc2VsZWN0ZWRTcGFuICYmIHNwYW4ub2Zmc2V0cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAkKCcjc3Bhbl9mb3JtX3Jlc2VsZWN0X2ZyYWdtZW50LCAjc3Bhbl9mb3JtX2RlbGV0ZV9mcmFnbWVudCcpLnNob3coKTtcclxuICAgICAgICAgIGtleW1hcFsnUy0nICsgJC51aS5rZXlDb2RlLkRFTEVURV0gPSAnc3Bhbl9mb3JtX2RlbGV0ZV9mcmFnbWVudCc7XHJcbiAgICAgICAgICBrZXltYXBbJ1MtJyArICQudWkua2V5Q29kZS5JTlNFUlRdID0gJ3NwYW5fZm9ybV9yZXNlbGVjdF9mcmFnbWVudCc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICQoJyNzcGFuX2Zvcm1fcmVzZWxlY3RfZnJhZ21lbnQsICNzcGFuX2Zvcm1fZGVsZXRlX2ZyYWdtZW50JykuaGlkZSgpO1xyXG4gICAgICAgICAga2V5bWFwWydTLScgKyAkLnVpLmtleUNvZGUuREVMRVRFXSA9IG51bGw7XHJcbiAgICAgICAgICBrZXltYXBbJ1MtJyArICQudWkua2V5Q29kZS5JTlNFUlRdID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETzogbG90cyBvZiByZWR1bmRhbmN5IGluIHRoZSBuZXh0IHR3byBibG9ja3MsIGNsZWFuIHVwXHJcbiAgICAgICAgaWYgKCFzcGFuKSB7XHJcbiAgICAgICAgICAvLyBubyBleGlzdGluZyBhbm5vdGF0aW9uLCByZXNldCBhdHRyaWJ1dGVzXHJcbiAgICAgICAgICB2YXIgYXR0ckNhdGVnb3J5QW5kVHlwZXMgPSBbWydlbnRpdHknLCBlbnRpdHlBdHRyaWJ1dGVUeXBlc10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWydldmVudCcsIGV2ZW50QXR0cmlidXRlVHlwZXNdXTtcclxuICAgICAgICAgICQuZWFjaChhdHRyQ2F0ZWdvcnlBbmRUeXBlcywgZnVuY3Rpb24oY3RObywgY3QpIHtcclxuICAgICAgICAgICAgdmFyIGNhdGVnb3J5ID0gY3RbMF07XHJcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVUeXBlcyA9IGN0WzFdO1xyXG4gICAgICAgICAgICAkLmVhY2goYXR0cmlidXRlVHlwZXMsIGZ1bmN0aW9uKGF0dHJObywgYXR0cikge1xyXG4gICAgICAgICAgICAgICRpbnB1dCA9ICQoJyMnK2NhdGVnb3J5KydfYXR0cl8nK1V0aWwuZXNjYXBlUXVvdGVzKGF0dHIudHlwZSkpO1xyXG4gICAgICAgICAgICAgIGlmIChhdHRyLnVudXNlZCkge1xyXG4gICAgICAgICAgICAgICAgJGlucHV0LnZhbCgnJyk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChhdHRyLmJvb2wpIHtcclxuICAgICAgICAgICAgICAgICRpbnB1dFswXS5jaGVja2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVDaGVja2JveCgkaW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgJGlucHV0LmJ1dHRvbigncmVmcmVzaCcpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAkaW5wdXQudmFsKCcnKS5jaGFuZ2UoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICghcmVzZWxlY3RlZFNwYW4pIHtcclxuICAgICAgICAgIC8vIGV4aXN0aW5nIGFubm90YXRpb24sIGZpbGwgYXR0cmlidXRlIHZhbHVlcyBmcm9tIHNwYW5cclxuICAgICAgICAgIHZhciBhdHRyaWJ1dGVUeXBlcztcclxuICAgICAgICAgIHZhciBjYXRlZ29yeTtcclxuICAgICAgICAgIGlmIChzcGFuLmdlbmVyYWxUeXBlID09ICdlbnRpdHknKSB7XHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZVR5cGVzID0gZW50aXR5QXR0cmlidXRlVHlwZXM7XHJcbiAgICAgICAgICAgIGNhdGVnb3J5ID0gJ2VudGl0eSc7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHNwYW4uZ2VuZXJhbFR5cGUgPT0gJ3RyaWdnZXInKSB7XHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZVR5cGVzID0gZXZlbnRBdHRyaWJ1dGVUeXBlcztcclxuICAgICAgICAgICAgLy8gVE9ETzogdW5pZnkgY2F0ZWdvcnkvZ2VuZXJhbFR5cGUgdmFsdWVzICgndHJpZ2dlcicgdnMuICdldmVudCcpXHJcbiAgICAgICAgICAgIGNhdGVnb3J5ID0gJ2V2ZW50JztcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VucmVjb2duaXplZCBnZW5lcmFsVHlwZTonLCBzcGFuLmdlbmVyYWxUeXBlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgICQuZWFjaChhdHRyaWJ1dGVUeXBlcywgZnVuY3Rpb24oYXR0ck5vLCBhdHRyKSB7XHJcbiAgICAgICAgICAgICRpbnB1dCA9ICQoJyMnK2NhdGVnb3J5KydfYXR0cl8nK1V0aWwuZXNjYXBlUXVvdGVzKGF0dHIudHlwZSkpO1xyXG4gICAgICAgICAgICB2YXIgdmFsID0gc3Bhbi5hdHRyaWJ1dGVzW2F0dHIudHlwZV07XHJcbiAgICAgICAgICAgIGlmIChhdHRyLnVudXNlZCkge1xyXG4gICAgICAgICAgICAgICRpbnB1dC52YWwodmFsIHx8ICcnKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChhdHRyLmJvb2wpIHtcclxuICAgICAgICAgICAgICAkaW5wdXRbMF0uY2hlY2tlZCA9IHZhbDtcclxuICAgICAgICAgICAgICB1cGRhdGVDaGVja2JveCgkaW5wdXQpO1xyXG4gICAgICAgICAgICAgICRpbnB1dC5idXR0b24oJ3JlZnJlc2gnKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAkaW5wdXQudmFsKHZhbCB8fCAnJykuY2hhbmdlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHNob3dWYWxpZE5vcm1hbGl6YXRpb25zRm9yID0gZnVuY3Rpb24odHlwZSkge1xyXG4gICAgICAgICAgLy8gc2V0IERCIHNlbGVjdG9yIHRvIHRoZSBmaXJzdCBhcHByb3ByaWF0ZSBmb3IgdGhlIHR5cGUuXHJcbiAgICAgICAgICAvLyBUT0RPOiBhY3R1YWxseSBkaXNhYmxlIGluYXBwcm9wcmlhdGUgb25lcy5cclxuICAgICAgICAgIC8vIFRPRE86IHN1cHBvcnQgc3BlY2lmaWMgSURzLCBub3QganVzdCBEQiBzcGVjaWZpZXJzXHJcbiAgICAgICAgICB2YXIgZmlyc3REYiA9IHR5cGUgJiYgbm9ybURic0J5VHlwZVt0eXBlXSA/IG5vcm1EYnNCeVR5cGVbdHlwZV1bMF0gOiBudWxsO1xyXG4gICAgICAgICAgaWYgKGZpcnN0RGIpIHtcclxuICAgICAgICAgICAgJCgnI3NwYW5fbm9ybV9kYicpLnZhbChmaXJzdERiKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNob3dWYWxpZE5vcm1hbGl6YXRpb25zID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAvLyBzZXQgbm9ybSBEQiBzZWxlY3RvciBhY2NvcmRpbmcgdG8gdGhlIGZpcnN0IHNlbGVjdGVkIHR5cGVcclxuICAgICAgICAgIHZhciBmaXJzdFNlbGVjdGVkID0gJCgnI2VudGl0eV9hbmRfZXZlbnRfd3JhcHBlciBpbnB1dDpyYWRpbzpjaGVja2VkJylbMF07XHJcbiAgICAgICAgICB2YXIgc2VsZWN0ZWRUeXBlID0gZmlyc3RTZWxlY3RlZCA/IGZpcnN0U2VsZWN0ZWQudmFsdWUgOiBudWxsO1xyXG4gICAgICAgICAgc2hvd1ZhbGlkTm9ybWFsaXphdGlvbnNGb3Ioc2VsZWN0ZWRUeXBlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGZpbGwgbm9ybWFsaXphdGlvbnMgKGlmIGFueSlcclxuICAgICAgICBpZiAoIXJlc2VsZWN0ZWRTcGFuKSB7XHJcbiAgICAgICAgICAvLyBjbGVhciBmaXJzdFxyXG4gICAgICAgICAgY2xlYXJOb3JtYWxpemF0aW9uVUkoKTtcclxuXHJcbiAgICAgICAgICB2YXIgJG5vcm1EYiA9ICQoJyNzcGFuX25vcm1fZGInKTtcclxuICAgICAgICAgIHZhciAkbm9ybUlkID0gJCgnI3NwYW5fbm9ybV9pZCcpO1xyXG4gICAgICAgICAgdmFyICRub3JtVGV4dCA9ICQoJyNzcGFuX25vcm1fdHh0Jyk7XHJcblxyXG4gICAgICAgICAgLy8gZmlsbCBpZiBmb3VuZCAoTk9URTogb25seSBzaG93cyBsYXN0IG9uIG11bHRpcGxlKVxyXG4gICAgICAgICAgdmFyIG5vcm1GaWxsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICQuZWFjaChzcGFuID8gc3Bhbi5ub3JtYWxpemF0aW9ucyA6IFtdLCBmdW5jdGlvbihub3JtTm8sIG5vcm0pIHtcclxuICAgICAgICAgICAgdmFyIHJlZkRiID0gbm9ybVswXSwgcmVmSWQgPSBub3JtWzFdLCByZWZUZXh0ID0gbm9ybVsyXTtcclxuICAgICAgICAgICAgJG5vcm1EYi52YWwocmVmRGIpO1xyXG4gICAgICAgICAgICAvLyBjb3VsZCB0aGUgREIgc2VsZWN0b3IgYmUgc2V0PyAoaS5lLiBpcyByZWZEYiBjb25maWd1cmVkPylcclxuICAgICAgICAgICAgaWYgKCRub3JtRGIudmFsKCkgPT0gcmVmRGIpIHtcclxuICAgICAgICAgICAgICAvLyBEQiBpcyBPSywgc2V0IHRoZSByZXN0IGFsc29cclxuICAgICAgICAgICAgICAkbm9ybUlkLnZhbChyZWZJZCk7XHJcbiAgICAgICAgICAgICAgb2xkU3Bhbk5vcm1JZFZhbHVlID0gcmVmSWQ7XHJcbiAgICAgICAgICAgICAgJG5vcm1UZXh0LnZhbChyZWZUZXh0KTtcclxuICAgICAgICAgICAgICAvLyBUT0RPOiBjaGVjayBpZiBJRCBpcyB2YWxpZFxyXG4gICAgICAgICAgICAgICRub3JtSWQuYWRkQ2xhc3MoJ3ZhbGlkX3ZhbHVlJylcclxuICAgICAgICAgICAgICBub3JtRmlsbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAvLyBjYW4ndCBzZXQgdGhlIERCIHNlbGVjdG9yOyBhc3N1bWUgREIgaXMgbm90IGNvbmZpZ3VyZWQsXHJcbiAgICAgICAgICAgICAgLy8gd2FybiBhbmQgbGVhdmUgYmxhbmsgKHdpbGwgcmVtb3ZlIG5vcm0gd2hlbiBkaWFsb2cgaXMgT0snZClcclxuICAgICAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ21lc3NhZ2VzJywgW1tbJ1dhcm5pbmc6ICcrcmVmRGIrJyBub3QgY29uZmlndXJlZCwgcmVtb3Zpbmcgbm9ybWFsaXphdGlvbi4nLCAnd2FybmluZyddXV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBleGlzdGluZyBub3JtYWxpemF0aW9uLCBzaG93IHZhbGlkIG9uZXNcclxuICAgICAgICAgIGlmICghbm9ybUZpbGxlZCkge1xyXG4gICAgICAgICAgICBzaG93VmFsaWROb3JtYWxpemF0aW9ucygpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIHVwZGF0ZSBsaW5rc1xyXG4gICAgICAgICAgdXBkYXRlTm9ybWFsaXphdGlvblJlZkxpbmsoKTtcclxuICAgICAgICAgIHVwZGF0ZU5vcm1hbGl6YXRpb25EYkxpbmsoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzaG93QXR0cmlidXRlc0ZvciA9IGZ1bmN0aW9uKGF0dHJUeXBlcywgY2F0ZWdvcnksIHR5cGUpIHtcclxuICAgICAgICAgIHZhciB2YWxpZEF0dHJzID0gdHlwZSA/IHNwYW5UeXBlc1t0eXBlXS5hdHRyaWJ1dGVzIDogW107XHJcbiAgICAgICAgICB2YXIgc2hvd25Db3VudCA9IDA7XHJcbiAgICAgICAgICAkLmVhY2goYXR0clR5cGVzLCBmdW5jdGlvbihhdHRyTm8sIGF0dHIpIHtcclxuICAgICAgICAgICAgdmFyICRpbnB1dCA9ICQoJyMnK2NhdGVnb3J5KydfYXR0cl8nK1V0aWwuZXNjYXBlUXVvdGVzKGF0dHIudHlwZSkpO1xyXG4gICAgICAgICAgICB2YXIgc2hvd0F0dHIgPSBzaG93QWxsQXR0cmlidXRlcyB8fCAkLmluQXJyYXkoYXR0ci50eXBlLCB2YWxpZEF0dHJzKSAhPSAtMTtcclxuICAgICAgICAgICAgaWYgKHNob3dBdHRyKSB7XHJcbiAgICAgICAgICAgICAgJGlucHV0LmJ1dHRvbignd2lkZ2V0Jykuc2hvdygpO1xyXG4gICAgICAgICAgICAgIHNob3duQ291bnQrKztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAkaW5wdXQuYnV0dG9uKCd3aWRnZXQnKS5oaWRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgcmV0dXJuIHNob3duQ291bnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzaG93VmFsaWRBdHRyaWJ1dGVzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICB2YXIgdHlwZSA9ICQoJyNzcGFuX2Zvcm0gaW5wdXQ6cmFkaW86Y2hlY2tlZCcpLnZhbCgpO1xyXG4gICAgICAgICAgdmFyIGVudGl0eUF0dHJDb3VudCA9IHNob3dBdHRyaWJ1dGVzRm9yKGVudGl0eUF0dHJpYnV0ZVR5cGVzLCAnZW50aXR5JywgdHlwZSk7XHJcbiAgICAgICAgICB2YXIgZXZlbnRBdHRyQ291bnQgPSBzaG93QXR0cmlidXRlc0ZvcihldmVudEF0dHJpYnV0ZVR5cGVzLCAnZXZlbnQnLCB0eXBlKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgc2hvd0FsbEF0dHJpYnV0ZXMgPSBmYWxzZTtcclxuICAgICAgICAgIC8vIHNob3cgYXR0cmlidXRlIGZyYW1lcyBvbmx5IGlmIGF0IGxlYXN0IG9uZSBhdHRyaWJ1dGUgaXNcclxuICAgICAgICAgIC8vIHNob3duLCBhbmQgc2V0IHNpemUgY2xhc3NlcyBhcHByb3ByaWF0ZWx5XHJcbiAgICAgICAgICBpZiAoZXZlbnRBdHRyQ291bnQgPiAwKSB7XHJcbiAgICAgICAgICAgICQoJyNldmVudF9hdHRyaWJ1dGVzJykuc2hvdygpO1xyXG4gICAgICAgICAgICAkKCcjZXZlbnRfYXR0cmlidXRlX2xhYmVsJykuc2hvdygpO1xyXG4gICAgICAgICAgICAkKCcjZXZlbnRfdHlwZXMnKS5cclxuICAgICAgICAgICAgICByZW1vdmVDbGFzcygnc2Nyb2xsX3dyYXBwZXJfZnVsbCcpLlxyXG4gICAgICAgICAgICAgIGFkZENsYXNzKCdzY3JvbGxfd3JhcHBlcl91cHBlcicpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgJCgnI2V2ZW50X2F0dHJpYnV0ZXMnKS5oaWRlKCk7XHJcbiAgICAgICAgICAgICQoJyNldmVudF9hdHRyaWJ1dGVfbGFiZWwnKS5oaWRlKCk7XHJcbiAgICAgICAgICAgICQoJyNldmVudF90eXBlcycpLlxyXG4gICAgICAgICAgICAgIHJlbW92ZUNsYXNzKCdzY3JvbGxfd3JhcHBlcl91cHBlcicpLlxyXG4gICAgICAgICAgICAgIGFkZENsYXNzKCdzY3JvbGxfd3JhcHBlcl9mdWxsJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoZW50aXR5QXR0ckNvdW50ID4gMCkge1xyXG4gICAgICAgICAgICAkKCcjZW50aXR5X2F0dHJpYnV0ZXMnKS5zaG93KCk7XHJcbiAgICAgICAgICAgICQoJyNlbnRpdHlfYXR0cmlidXRlX2xhYmVsJykuc2hvdygpO1xyXG4gICAgICAgICAgICAkKCcjZW50aXR5X3R5cGVzJykuXHJcbiAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoJ3Njcm9sbF93cmFwcGVyX2Z1bGwnKS5cclxuICAgICAgICAgICAgICBhZGRDbGFzcygnc2Nyb2xsX3dyYXBwZXJfdXBwZXInKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICQoJyNlbnRpdHlfYXR0cmlidXRlcycpLmhpZGUoKTtcclxuICAgICAgICAgICAgJCgnI2VudGl0eV9hdHRyaWJ1dGVfbGFiZWwnKS5oaWRlKCk7XHJcbiAgICAgICAgICAgICQoJyNlbnRpdHlfdHlwZXMnKS5cclxuICAgICAgICAgICAgICByZW1vdmVDbGFzcygnc2Nyb2xsX3dyYXBwZXJfdXBwZXInKS5cclxuICAgICAgICAgICAgICBhZGRDbGFzcygnc2Nyb2xsX3dyYXBwZXJfZnVsbCcpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzaG93VmFsaWRBdHRyaWJ1dGVzKCk7XHJcblxyXG4gICAgICAgIC8vIFRPRE8gWFhYOiBpZiBzZWVtZWQgcXVpdGUgdW5leHBlY3RlZC91bmludHVpdGl2ZSB0aGF0IHRoZVxyXG4gICAgICAgIC8vIGZvcm0gd2FzIHJlLWRpc3BsYXllZCB3aGlsZSB0aGUgZG9jdW1lbnQgc3RpbGwgc2hvd3MgdGhlXHJcbiAgICAgICAgLy8gYW5ub3RhdGlvbiBpbiBpdHMgb2xkIGxvY2F0aW9uIGluIHRoZSBiYWNrZ3JvdW5kIChjaGVjayBpdCkuXHJcbiAgICAgICAgLy8gVGhlIGZpeCBvZiBza2lwcGluZyBjb25maXJtIGlzIG5vdCByZWFsbHkgZ29vZCBlaXRoZXIsIHRob3VnaC5cclxuICAgICAgICBpZiAocmVzZWxlY3RlZFNwYW4pIHsgLy8gJiYgIUNvbmZpZ3VyYXRpb24uY29uZmlybU1vZGVPbikge1xyXG4gICAgICAgICAgc3VibWl0UmVzZWxlY3QoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdzaG93Rm9ybScsIFtzcGFuRm9ybSwgc3Bhbk9wdGlvbnNdKTtcclxuICAgICAgICAgICQoJyNzcGFuX2Zvcm0tb2snKS5mb2N1cygpO1xyXG4gICAgICAgICAgYWRqdXN0VG9DdXJzb3IoZXZ0LCBzcGFuRm9ybS5wYXJlbnQoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgdmFyIHN1Ym1pdFJlc2VsZWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgJChyZXNlbGVjdGVkU3Bhbi5yZWN0KS5yZW1vdmVDbGFzcygncmVzZWxlY3QnKTtcclxuICAgICAgICByZXNlbGVjdGVkU3BhbiA9IG51bGw7XHJcbiAgICAgICAgc3BhbkZvcm0uc3VibWl0KCk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgcmFwaWRGaWxsU3BhblR5cGVzQW5kRGlzcGxheUZvcm0gPSBmdW5jdGlvbihzdGFydCwgZW5kLCB0ZXh0LCB0eXBlcykge1xyXG4gICAgICAgIC8vIHZhcmlhbnQgb2YgZmlsbFNwYW5UeXBlc0FuZERpc3BsYXlGb3JtIGZvciByYXBpZCBhbm5vdGF0aW9uIG1vZGVcclxuICAgICAgICBrZXltYXAgPSBzcGFuS2V5bWFwO1xyXG4gICAgICAgICQoJyNyYXBpZF9zcGFuX3NlbGVjdGVkJykudGV4dCh0ZXh0KTtcclxuXHJcbiAgICAgICAgLy8gZmlsbCB0eXBlc1xyXG4gICAgICAgIHZhciAkc3BhblR5cGVEaXYgPSAkKCcjcmFwaWRfc3Bhbl90eXBlc19kaXYnKTtcclxuICAgICAgICAvLyByZW1vdmUgcHJldmlvdXNseSBmaWxsZWQsIGlmIGFueVxyXG4gICAgICAgICRzcGFuVHlwZURpdi5lbXB0eSgpO1xyXG4gICAgICAgICQuZWFjaCh0eXBlcywgZnVuY3Rpb24odHlwZU5vLCB0eXBlQW5kUHJvYikge1xyXG4gICAgICAgICAgLy8gVE9ETzogdGhpcyBkdXBsaWNhdGVzIGEgcGFydCBvZiBhZGRTcGFuVHlwZXNUb0RpdklubmVyLCB1bmlmeVxyXG4gICAgICAgICAgdmFyIHR5cGUgPSB0eXBlQW5kUHJvYlswXTtcclxuICAgICAgICAgIHZhciBwcm9iID0gdHlwZUFuZFByb2JbMV07XHJcbiAgICAgICAgICB2YXIgJG51bWxhYmVsID0gJCgnPHNwYW4gY2xhc3M9XCJhY2Nlc3NrZXlcIj4nKyh0eXBlTm8rMSkrJzwvc3Bhbj48c3Bhbj46PC9zcGFuPicpO1xyXG4gICAgICAgICAgdmFyICRpbnB1dCA9ICQoJzxpbnB1dCB0eXBlPVwicmFkaW9cIiBuYW1lPVwicmFwaWRfc3Bhbl90eXBlXCIvPicpLlxyXG4gICAgICAgICAgICAgIGF0dHIoJ2lkJywgJ3JhcGlkX3NwYW5fJyArICh0eXBlTm8rMSkpLlxyXG4gICAgICAgICAgICAgIGF0dHIoJ3ZhbHVlJywgdHlwZSk7XHJcbiAgICAgICAgICB2YXIgc3BhbkJnQ29sb3IgPSBzcGFuVHlwZXNbdHlwZV0gJiYgc3BhblR5cGVzW3R5cGVdLmJnQ29sb3IgfHwgJyNmZmZmZmYnO1xyXG4gICAgICAgICAgc3BhbkJnQ29sb3IgPSBVdGlsLmFkanVzdENvbG9yTGlnaHRuZXNzKHNwYW5CZ0NvbG9yLCBzcGFuQm94VGV4dEJnQ29sb3JMaWdodGVuKTtcclxuICAgICAgICAgIC8vIHVzZSBwcmVmZXJyZWQgbGFiZWwgaW5zdGVhZCBvZiB0eXBlIG5hbWUgaWYgYXZhaWxhYmxlXHJcbiAgICAgICAgICB2YXIgbmFtZSA9IHNwYW5UeXBlc1t0eXBlXSAmJiBzcGFuVHlwZXNbdHlwZV0ubmFtZSB8fCB0eXBlO1xyXG4gICAgICAgICAgdmFyICRsYWJlbCA9ICQoJzxsYWJlbCBjbGFzcz1cInNwYW5fdHlwZV9sYWJlbFwiLz4nKS5cclxuICAgICAgICAgICAgYXR0cignZm9yJywgJ3JhcGlkX3NwYW5fJyArICh0eXBlTm8rMSkpLlxyXG4gICAgICAgICAgICB0ZXh0KG5hbWUrJyAoJyArICgxMDAuMCAqIHByb2IpLnRvRml4ZWQoMSkgKyAnJSknKTtcclxuICAgICAgICAgICRsYWJlbC5jc3MoJ2JhY2tncm91bmQtY29sb3InLCBzcGFuQmdDb2xvcik7ICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gVE9ETzogY2hlY2sgZm9yIHVubmVjZXNzYXJ5IGV4dHJhIHdyYXBwaW5nIGhlcmVcclxuICAgICAgICAgIHZhciAkY29udGVudCA9ICQoJzxkaXYgY2xhc3M9XCJpdGVtX2NvbnRlbnRcIi8+JykuXHJcbiAgICAgICAgICAgIGFwcGVuZCgkbnVtbGFiZWwpLlxyXG4gICAgICAgICAgICBhcHBlbmQoJGlucHV0KS5cclxuICAgICAgICAgICAgYXBwZW5kKCRsYWJlbCk7XHJcbiAgICAgICAgICAkc3BhblR5cGVEaXYuYXBwZW5kKCRjb250ZW50KTtcclxuICAgICAgICAgIC8vIGhpZ2hsaWdodCBjb25maWd1cmVkIGhvdGtleSAoaWYgYW55KSBpbiB0ZXh0LlxyXG4gICAgICAgICAgLy8gTk9URTogdGhpcyBiaXQgZG9lc24ndCBhY3R1YWxseSBzZXQgdXAgdGhlIGhvdGtleS5cclxuICAgICAgICAgIHZhciBob3RrZXlUeXBlID0gJ3NwYW5fJyArIHR5cGU7XHJcbiAgICAgICAgICAvLyBUT0RPOiB0aGlzIGlzIGNsdW1zeTsgdGhlcmUgc2hvdWxkIGJlIGEgYmV0dGVyIHdheVxyXG4gICAgICAgICAgdmFyIHR5cGVIb3RrZXkgPSBudWxsO1xyXG4gICAgICAgICAgJC5lYWNoKGtleW1hcCwgZnVuY3Rpb24oa2V5LCBrZXlUeXBlKSB7XHJcbiAgICAgICAgICAgIGlmIChrZXlUeXBlID09IGhvdGtleVR5cGUpIHtcclxuICAgICAgICAgICAgICB0eXBlSG90a2V5ID0ga2V5O1xyXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBpZiAodHlwZUhvdGtleSkge1xyXG4gICAgICAgICAgICB2YXIgbmFtZSA9ICRsYWJlbC5odG1sKCk7XHJcbiAgICAgICAgICAgIHZhciByZXBsYWNlID0gdHJ1ZTtcclxuICAgICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShuZXcgUmVnRXhwKFwiKCZbXjtdKj8pPyhcIiArIHR5cGVIb3RrZXkgKyBcIilcIiwgJ2dpJyksXHJcbiAgICAgICAgICAgICAgZnVuY3Rpb24oYWxsLCBlbnRpdHksIGxldHRlcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlcGxhY2UgJiYgIWVudGl0eSkge1xyXG4gICAgICAgICAgICAgICAgICByZXBsYWNlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgIHZhciBob3RrZXkgPSB0eXBlSG90a2V5LnRvTG93ZXJDYXNlKCkgPT0gbGV0dGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICA/IHR5cGVIb3RrZXkudG9Mb3dlckNhc2UoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgOiB0eXBlSG90a2V5LnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiAnPHNwYW4gY2xhc3M9XCJhY2Nlc3NrZXlcIj4nICsgVXRpbC5lc2NhcGVIVE1MKGhvdGtleSkgKyAnPC9zcGFuPic7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYWxsO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAkbGFiZWwuaHRtbChuYW1lKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIExpbWl0IHRoZSBudW1iZXIgb2Ygc3VnZ2VzdGlvbnMgdG8gdGhlIG51bWJlciBvZiBudW1lcmljIGtleXNcclxuICAgICAgICAgIGlmICh0eXBlTm8gPj0gOCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gZmlsbCBpbiBzb21lIHNwYWNlIGFuZCB0aGUgc3BlY2lhbCBcIk90aGVyXCIgb3B0aW9uLCB3aXRoIGtleSBcIjBcIiAoemVybylcclxuICAgICAgICAkc3BhblR5cGVEaXYuYXBwZW5kKCQoJzxkaXYgY2xhc3M9XCJpdGVtX2NvbnRlbnRcIj4mIzE2MDs8L2Rpdj4nKSk7IC8vIG5vbi1icmVha2luZyBzcGFjZVxyXG4gICAgICAgIHZhciAkbnVtbGFiZWwgPSAkKCc8c3BhbiBjbGFzcz1cImFjY2Vzc2tleVwiPjA8L3NwYW4+PHNwYW4+Ojwvc3Bhbj4nKTsgICAgICAgIFxyXG4gICAgICAgIHZhciAkaW5wdXQgPSAkKCc8aW5wdXQgdHlwZT1cInJhZGlvXCIgbmFtZT1cInJhcGlkX3NwYW5fdHlwZVwiIGlkPVwicmFwaWRfc3Bhbl8wXCIgdmFsdWU9XCJcIi8+Jyk7XHJcbiAgICAgICAgdmFyICRsYWJlbCA9ICQoJzxsYWJlbCBjbGFzcz1cInNwYW5fdHlwZV9sYWJlbFwiIGZvcj1cInJhcGlkX3NwYW5fMFwiIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjpsaWdodGdyYXlcIj5PdGhlci4uLjwvbGFiZWw+Jyk7XHJcbiAgICAgICAgdmFyICRjb250ZW50ID0gJCgnPGRpdiBjbGFzcz1cIml0ZW1fY29udGVudFwiLz4nKS5cclxuICAgICAgICAgIGFwcGVuZCgkbnVtbGFiZWwpLlxyXG4gICAgICAgICAgYXBwZW5kKCRpbnB1dCkuXHJcbiAgICAgICAgICBhcHBlbmQoJGxhYmVsKTtcclxuICAgICAgICAkc3BhblR5cGVEaXYuYXBwZW5kKCRjb250ZW50KTtcclxuXHJcbiAgICAgICAgLy8gc2V0IHVwIGNsaWNrIGV2ZW50IGhhbmRsZXJzXHJcbiAgICAgICAgcmFwaWRTcGFuRm9ybS5maW5kKCcjcmFwaWRfc3Bhbl90eXBlcyBpbnB1dDpyYWRpbycpLmNsaWNrKHJhcGlkU3BhbkZvcm1TdWJtaXRSYWRpbyk7XHJcblxyXG4gICAgICAgIHZhciBmaXJzdFJhZGlvID0gJCgnI3JhcGlkX3NwYW5fZm9ybSBpbnB1dDpyYWRpbzpmaXJzdCcpWzBdO1xyXG4gICAgICAgIGlmIChmaXJzdFJhZGlvKSB7XHJcbiAgICAgICAgICBmaXJzdFJhZGlvLmNoZWNrZWQgPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ2hpZGVGb3JtJyk7XHJcbiAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ21lc3NhZ2VzJywgW1tbJ05vIHZhbGlkIHNwYW4gdHlwZXMgZGVmaW5lZCcsICdlcnJvciddXV0pO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ3Nob3dGb3JtJywgW3JhcGlkU3BhbkZvcm1dKTtcclxuICAgICAgICByYXBpZEFubm90YXRpb25EaWFsb2dWaXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAkKCcjcmFwaWRfc3Bhbl9mb3JtLW9rJykuZm9jdXMoKTtcclxuICAgICAgICAvLyBUT0RPOiBhdm9pZCB1c2luZyBnbG9iYWwgZm9yIHN0b3JlZCBjbGljayBldmVudFxyXG4vLyAgICAgICAgIGFkanVzdFRvQ3Vyc29yKGxhc3RSYXBpZEFubm90YXRpb25FdmVudCwgcmFwaWRTcGFuRm9ybS5wYXJlbnQoKSxcclxuLy8gICAgICAgICAgICAgICAgICAgICAgICB0cnVlLCB0cnVlKTtcclxuICAgICAgICAvLyBUT0RPOiBhdm9pZCBjb29yZGluYXRlIGhhY2sgdG8gcG9zaXRpb24gcm91Z2hseSBhdCBmaXJzdFxyXG4gICAgICAgIC8vIGF2YWlsYWJsZSBzZWxlY3Rpb25cclxuICAgICAgICBsYXN0UmFwaWRBbm5vdGF0aW9uRXZlbnQuY2xpZW50WCAtPSA1NTtcclxuICAgICAgICBsYXN0UmFwaWRBbm5vdGF0aW9uRXZlbnQuY2xpZW50WSAtPSAxMTU7XHJcbiAgICAgICAgYWRqdXN0VG9DdXJzb3IobGFzdFJhcGlkQW5ub3RhdGlvbkV2ZW50LCByYXBpZFNwYW5Gb3JtLnBhcmVudCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLCBmYWxzZSk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgY2xlYXJTcGFuTm90ZXMgPSBmdW5jdGlvbihldnQpIHtcclxuICAgICAgICAkKCcjc3Bhbl9ub3RlcycpLnZhbCgnJyk7XHJcbiAgICAgIH1cclxuICAgICAgJCgnI2NsZWFyX25vdGVzX2J1dHRvbicpLmJ1dHRvbigpO1xyXG4gICAgICAkKCcjY2xlYXJfbm90ZXNfYnV0dG9uJykuY2xpY2soY2xlYXJTcGFuTm90ZXMpO1xyXG5cclxuICAgICAgdmFyIGNsZWFyU3Bhbk5vcm0gPSBmdW5jdGlvbihldnQpIHtcclxuICAgICAgICBjbGVhck5vcm1hbGl6YXRpb25VSSgpO1xyXG4gICAgICB9XHJcbiAgICAgICQoJyNjbGVhcl9ub3JtX2J1dHRvbicpLmJ1dHRvbigpO1xyXG4gICAgICAkKCcjY2xlYXJfbm9ybV9idXR0b24nKS5jbGljayhjbGVhclNwYW5Ob3JtKTtcclxuXHJcbiAgICAgIC8vIGludm9rZWQgb24gcmVzcG9uc2UgdG8gYWpheCByZXF1ZXN0IGZvciBpZCBsb29rdXBcclxuICAgICAgdmFyIHNldFNwYW5Ob3JtVGV4dCA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgaWYgKHJlc3BvbnNlLmV4Y2VwdGlvbikge1xyXG4gICAgICAgICAgLy8gVE9ETzogYmV0dGVyIHJlc3BvbnNlIHRvIGZhaWx1cmVcclxuICAgICAgICAgIGRpc3BhdGNoZXIucG9zdCgnbWVzc2FnZXMnLCBbW1snTG9va3VwIGVycm9yJywgJ3dhcm5pbmcnLCAtMV1dXSk7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSAgICAgICAgXHJcbiAgICAgICAgLy8gc2V0IGlucHV0IHN0eWxlIGFjY29yZGluZyB0byB3aGV0aGVyIHdlIGhhdmUgYSB2YWxpZCB2YWx1ZVxyXG4gICAgICAgIHZhciAkaWRpbnB1dCA9ICQoJyNzcGFuX25vcm1faWQnKTtcclxuICAgICAgICAvLyBUT0RPOiBtYWtlIHN1cmUgdGhlIGtleSBlY2hvIGluIHRoZSByZXNwb25zZSBtYXRjaGVzIHRoZVxyXG4gICAgICAgIC8vIGN1cnJlbnQgdmFsdWUgb2YgdGhlICRpZGlucHV0XHJcbiAgICAgICAgJGlkaW5wdXQucmVtb3ZlQ2xhc3MoJ3ZhbGlkX3ZhbHVlJykucmVtb3ZlQ2xhc3MoJ2ludmFsaWRfdmFsdWUnKTtcclxuICAgICAgICBpZiAocmVzcG9uc2UudmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgICAgICRpZGlucHV0LmFkZENsYXNzKCdpbnZhbGlkX3ZhbHVlJyk7XHJcbiAgICAgICAgICBoaWRlTm9ybWFsaXphdGlvblJlZkxpbmsoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgJGlkaW5wdXQuYWRkQ2xhc3MoJ3ZhbGlkX3ZhbHVlJyk7XHJcbiAgICAgICAgICB1cGRhdGVOb3JtYWxpemF0aW9uUmVmTGluaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAkKCcjc3Bhbl9ub3JtX3R4dCcpLnZhbChyZXNwb25zZS52YWx1ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIG9uIGFueSBjaGFuZ2UgdG8gdGhlIG5vcm1hbGl6YXRpb24gREIsIGNsZWFyIGV2ZXJ5dGhpbmcgYW5kXHJcbiAgICAgIC8vIHVwZGF0ZSBsaW5rXHJcbiAgICAgIHZhciBzcGFuTm9ybURiVXBkYXRlID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgY2xlYXJOb3JtYWxpemF0aW9uVUkoKTtcclxuICAgICAgICB1cGRhdGVOb3JtYWxpemF0aW9uRGJMaW5rKCk7XHJcbiAgICAgIH1cclxuICAgICAgJCgnI3NwYW5fbm9ybV9kYicpLmNoYW5nZShzcGFuTm9ybURiVXBkYXRlKTtcclxuXHJcbiAgICAgIC8vIG9uIGFueSBjaGFuZ2UgdG8gdGhlIG5vcm1hbGl6YXRpb24gSUQsIHVwZGF0ZSB0aGUgdGV4dCBvZiB0aGVcclxuICAgICAgLy8gcmVmZXJlbmNlXHJcbiAgICAgIHZhciBzcGFuTm9ybUlkVXBkYXRlID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgdmFyIGtleSA9ICQodGhpcykudmFsKCk7XHJcbiAgICAgICAgdmFyIGRiID0gJCgnI3NwYW5fbm9ybV9kYicpLnZhbCgpO1xyXG4gICAgICAgIGlmIChrZXkgIT0gb2xkU3Bhbk5vcm1JZFZhbHVlKSB7XHJcbiAgICAgICAgICBpZiAoa2V5Lm1hdGNoKC9eXFxzKiQvKSkge1xyXG4gICAgICAgICAgICAvLyBkb24ndCBxdWVyeSBlbXB0aWVzLCBqdXN0IGNsZWFyIGluc3RlYWRcclxuICAgICAgICAgICAgY2xlYXJOb3JtYWxpemF0aW9uVUkoKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGRpc3BhdGNoZXIucG9zdCgnYWpheCcsIFsge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAnbm9ybUdldE5hbWUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YWJhc2U6IGRiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBrZXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uOiBjb2xsfSwgJ25vcm1HZXROYW1lUmVzdWx0J10pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgb2xkU3Bhbk5vcm1JZFZhbHVlID0ga2V5O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvLyBzZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xOTQ4MzMyL2RldGVjdC1hbGwtY2hhbmdlcy10by1hLWlucHV0LXR5cGUtdGV4dC1pbW1lZGlhdGVseS11c2luZy1qcXVlcnlcclxuICAgICAgJCgnI3NwYW5fbm9ybV9pZCcpLmJpbmQoJ3Byb3BlcnR5Y2hhbmdlIGtleXVwIGlucHV0IHBhc3RlJywgc3Bhbk5vcm1JZFVwZGF0ZSk7XHJcbiAgICAgIC8vIG5pY2UtbG9va2luZyBzZWxlY3QgZm9yIG5vcm1hbGl6YXRpb25cclxuICAgICAgJCgnI3NwYW5fbm9ybV9kYicpLmFkZENsYXNzKCd1aS13aWRnZXQgdWktc3RhdGUtZGVmYXVsdCB1aS1idXR0b24tdGV4dCcpO1xyXG5cclxuICAgICAgdmFyIG5vcm1TZWFyY2hEaWFsb2cgPSAkKCcjbm9ybV9zZWFyY2hfZGlhbG9nJyk7XHJcbiAgICAgIGluaXRGb3JtKG5vcm1TZWFyY2hEaWFsb2csIHtcclxuICAgICAgICAgIHdpZHRoOiA4MDAsXHJcbiAgICAgICAgICB3aWR0aDogNjAwLFxyXG4gICAgICAgICAgcmVzaXphYmxlOiB0cnVlLFxyXG4gICAgICAgICAgYWxzb1Jlc2l6ZTogJyNub3JtX3NlYXJjaF9yZXN1bHRfc2VsZWN0JyxcclxuICAgICAgICAgIG9wZW46IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgICAgICBrZXltYXAgPSB7fTtcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBjbG9zZTogZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgICAgIC8vIGFzc3VtZSB0aGF0IHdlIGFsd2F5cyB3YW50IHRvIHJldHVybiB0byB0aGUgc3BhbiBkaWFsb2dcclxuICAgICAgICAgICAgLy8gb24gbm9ybWFsaXphdGlvbiBkaWFsb2cgY2xvc2VcclxuICAgICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdzaG93Rm9ybScsIFtzcGFuRm9ybV0pO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgfSk7XHJcblxyXG4vLyBCUkFUIFNUQU5EIEFMT05FIExJQlJBUlkgQkVHSU5cclxuLypcclxuICAgICAgJCgnI25vcm1fc2VhcmNoX3F1ZXJ5JykuYXV0b2NvbXBsZXRlKHtcclxuICAgICAgICBzb3VyY2U6IGZ1bmN0aW9uKHJlcXVlc3QsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICB2YXIgcXVlcnkgPSAkLnVpLmF1dG9jb21wbGV0ZS5lc2NhcGVSZWdleChyZXF1ZXN0LnRlcm0pO1xyXG4gICAgICAgICAgdmFyIHBhdHRlcm4gPSBuZXcgUmVnRXhwKCdcXFxcYicgKyBxdWVyeSwgJ2knKTtcclxuICAgICAgICAgIGNhbGxiYWNrKCQuZ3JlcChsYXN0Tm9ybVNlYXJjaGVzLCBmdW5jdGlvbihzZWFyY2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdChzZWFyY2gudmFsdWUpIHx8IHBhdHRlcm4udGVzdChzZWFyY2guaWQpO1xyXG4gICAgICAgICAgfSkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbWluTGVuZ3RoOiAwLFxyXG4gICAgICAgIHNlbGVjdDogZnVuY3Rpb24oZXZ0LCB1aSkge1xyXG4gICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgbm9ybVN1Ym1pdCh1aS5pdGVtLmlkLCB1aS5pdGVtLnZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZvY3VzOiBmdW5jdGlvbihldnQsIHVpKSB7XHJcbiAgICAgICAgICAvLyBkbyBub3RoaW5nXHJcbiAgICAgICAgfSxcclxuICAgICAgfSkuZGF0YSgnYXV0b2NvbXBsZXRlJykuX3JlbmRlckl0ZW0gPSBmdW5jdGlvbigkdWwsIGl0ZW0pIHtcclxuICAgICAgICByZXR1cm4gJCgnPGxpPjwvbGk+JykuXHJcbiAgICAgICAgICBkYXRhKCdpdGVtLmF1dG9jb21wbGV0ZScsIGl0ZW0pLlxyXG4gICAgICAgICAgYXBwZW5kKCc8YT4nICsgVXRpbC5lc2NhcGVIVE1MKGl0ZW0udmFsdWUpICsgJzxkaXYgY2xhc3M9XCJhdXRvY29tcGxldGUtaWRcIj4nICsgVXRpbC5lc2NhcGVIVE1MKGl0ZW0uaWQpICsgXCI8L2Rpdj48L2E+XCIpLlxyXG4gICAgICAgICAgYXBwZW5kVG8oJHVsKTtcclxuICAgICAgfTtcclxuKi9cclxuLy8gQlJBVCBTVEFORCBBTE9ORSBMSUJSQVJZIEVORFxyXG5cclxuICAgICAgdmFyIG5vcm1TdWJtaXQgPSBmdW5jdGlvbihzZWxlY3RlZElkLCBzZWxlY3RlZFR4dCkge1xyXG4gICAgICAgIC8vIHdlIGdvdCBhIHZhbHVlOyBhY3QgaWYgaXQgd2FzIGEgc3VibWl0XHJcbiAgICAgICAgJCgnI3NwYW5fbm9ybV9pZCcpLnZhbChzZWxlY3RlZElkKTtcclxuICAgICAgICAvLyBkb24ndCBmb3JnZXQgdG8gdXBkYXRlIHRoaXMgcmVmZXJlbmNlIHZhbHVlXHJcbiAgICAgICAgb2xkU3Bhbk5vcm1JZFZhbHVlID0gc2VsZWN0ZWRJZDtcclxuICAgICAgICAkKCcjc3Bhbl9ub3JtX3R4dCcpLnZhbChzZWxlY3RlZFR4dCk7XHJcbiAgICAgICAgdXBkYXRlTm9ybWFsaXphdGlvblJlZkxpbmsoKTtcclxuICAgICAgICAvLyB1cGRhdGUgaGlzdG9yeVxyXG4gICAgICAgIHZhciBuZXh0TGFzdE5vcm1TZWFyY2hlcyA9IFtcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgdmFsdWU6IHNlbGVjdGVkVHh0LFxyXG4gICAgICAgICAgICBpZDogc2VsZWN0ZWRJZCxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgXTtcclxuICAgICAgICAkLmVhY2gobGFzdE5vcm1TZWFyY2hlcywgZnVuY3Rpb24oc2VhcmNoTm8sIHNlYXJjaCkge1xyXG4gICAgICAgICAgaWYgKHNlYXJjaC5pZCAhPSBzZWxlY3RlZElkIHx8IHNlYXJjaC52YWx1ZSAhPSBzZWxlY3RlZFR4dCkge1xyXG4gICAgICAgICAgICBuZXh0TGFzdE5vcm1TZWFyY2hlcy5wdXNoKHNlYXJjaCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGFzdE5vcm1TZWFyY2hlcyA9IG5leHRMYXN0Tm9ybVNlYXJjaGVzO1xyXG4gICAgICAgIGxhc3ROb3JtU2VhcmNoZXMuc2xpY2UoMCwgbWF4Tm9ybVNlYXJjaEhpc3RvcnkpO1xyXG4gICAgICAgIC8vIFN3aXRjaCBkaWFsb2dzLiBOT1RFOiBhc3N1bWluZyB3ZSBjbG9zZWQgdGhlIHNwYW5Gb3JtIHdoZW5cclxuICAgICAgICAvLyBicmluZ2luZyB1cCB0aGUgbm9ybVNlYXJjaERpYWxvZy5cclxuICAgICAgICBub3JtU2VhcmNoRGlhbG9nLmRpYWxvZygnY2xvc2UnKTtcclxuICAgICAgfTtcclxuICAgICAgdmFyIG5vcm1TZWFyY2hTdWJtaXQgPSBmdW5jdGlvbihldnQpIHtcclxuICAgICAgICBpZiAobm9ybVNlYXJjaFN1Ym1pdHRhYmxlKSB7XHJcbiAgICAgICAgICB2YXIgc2VsZWN0ZWRJZCA9ICQoJyNub3JtX3NlYXJjaF9pZCcpLnZhbCgpOyBcclxuICAgICAgICAgIHZhciBzZWxlY3RlZFR4dCA9ICQoJyNub3JtX3NlYXJjaF9xdWVyeScpLnZhbCgpO1xyXG5cclxuICAgICAgICAgIG5vcm1TdWJtaXQoc2VsZWN0ZWRJZCwgc2VsZWN0ZWRUeHQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBwZXJmb3JtTm9ybVNlYXJjaCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIG5vcm1TZWFyY2hTdWJtaXR0YWJsZSA9IGZhbHNlO1xyXG4gICAgICB2YXIgc2V0Tm9ybVNlYXJjaFN1Ym1pdCA9IGZ1bmN0aW9uKGVuYWJsZSkge1xyXG4gICAgICAgICQoJyNub3JtX3NlYXJjaF9kaWFsb2ctb2snKS5idXR0b24oZW5hYmxlID8gJ2VuYWJsZScgOiAnZGlzYWJsZScpO1xyXG4gICAgICAgIG5vcm1TZWFyY2hTdWJtaXR0YWJsZSA9IGVuYWJsZTtcclxuICAgICAgfTtcclxuICAgICAgbm9ybVNlYXJjaERpYWxvZy5zdWJtaXQobm9ybVNlYXJjaFN1Ym1pdCk7XHJcbiAgICAgIHZhciBjaG9vc2VOb3JtSWQgPSBmdW5jdGlvbihldnQpIHtcclxuICAgICAgICB2YXIgJGVsZW1lbnQgPSAkKGV2dC50YXJnZXQpLmNsb3Nlc3QoJ3RyJyk7XHJcbiAgICAgICAgJCgnI25vcm1fc2VhcmNoX3Jlc3VsdF9zZWxlY3QgdHInKS5yZW1vdmVDbGFzcygnc2VsZWN0ZWQnKTtcclxuICAgICAgICAkZWxlbWVudC5hZGRDbGFzcygnc2VsZWN0ZWQnKTtcclxuICAgICAgICAkKCcjbm9ybV9zZWFyY2hfcXVlcnknKS52YWwoJGVsZW1lbnQuYXR0cignZGF0YS10eHQnKSk7XHJcbiAgICAgICAgJCgnI25vcm1fc2VhcmNoX2lkJykudmFsKCRlbGVtZW50LmF0dHIoJ2RhdGEtaWQnKSk7XHJcbiAgICAgICAgc2V0Tm9ybVNlYXJjaFN1Ym1pdCh0cnVlKTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgY2hvb3NlTm9ybUlkQW5kU3VibWl0ID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgY2hvb3NlTm9ybUlkKGV2dCk7XHJcbiAgICAgICAgbm9ybVNlYXJjaFN1Ym1pdChldnQpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBzZXRTcGFuTm9ybVNlYXJjaFJlc3VsdHMgPSBmdW5jdGlvbihyZXNwb25zZSkge1xyXG4gICAgICAgIGlmIChyZXNwb25zZS5leGNlcHRpb24pIHtcclxuICAgICAgICAgIC8vIFRPRE86IGJldHRlciByZXNwb25zZSB0byBmYWlsdXJlXHJcbiAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ21lc3NhZ2VzJywgW1tbJ0xvb2t1cCBlcnJvcicsICd3YXJuaW5nJywgLTFdXV0pO1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHJlc3BvbnNlLml0ZW1zLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAvLyBubyByZXN1bHRzXHJcbiAgICAgICAgICAkKCcjbm9ybV9zZWFyY2hfcmVzdWx0X3NlbGVjdCB0aGVhZCcpLmVtcHR5KCk7XHJcbiAgICAgICAgICAkKCcjbm9ybV9zZWFyY2hfcmVzdWx0X3NlbGVjdCB0Ym9keScpLmVtcHR5KCk7XHJcbiAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ21lc3NhZ2VzJywgW1tbJ05vIG1hdGNoZXMgdG8gc2VhcmNoLicsICdjb21tZW50J11dXSk7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUT0RPOiBhdm9pZCBjb2RlIGR1cGxpY2F0aW9uIHdpdGggc2hvd0ZpbGVCcm93c2VyKClcclxuXHJcbiAgICAgICAgdmFyIGh0bWwgPSBbJzx0cj4nXTtcclxuICAgICAgICAkLmVhY2gocmVzcG9uc2UuaGVhZGVyLCBmdW5jdGlvbihoZWFkTm8sIGhlYWQpIHtcclxuICAgICAgICAgIGh0bWwucHVzaCgnPHRoPicgKyBVdGlsLmVzY2FwZUhUTUwoaGVhZFswXSkgKyAnPC90aD4nKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBodG1sLnB1c2goJzwvdHI+Jyk7XHJcbiAgICAgICAgJCgnI25vcm1fc2VhcmNoX3Jlc3VsdF9zZWxlY3QgdGhlYWQnKS5odG1sKGh0bWwuam9pbignJykpO1xyXG5cclxuICAgICAgICBodG1sID0gW107XHJcbiAgICAgICAgdmFyIGxlbiA9IHJlc3BvbnNlLmhlYWRlci5sZW5ndGg7XHJcbiAgICAgICAgJC5lYWNoKHJlc3BvbnNlLml0ZW1zLCBmdW5jdGlvbihpdGVtTm8sIGl0ZW0pIHtcclxuICAgICAgICAgIC8vIE5PVEU6IGFzc3VtaW5nIElEIGlzIGFsd2F5cyB0aGUgZmlyc3QgZGF0dW0gaW4gdGhlIGl0ZW1cclxuICAgICAgICAgIC8vIGFuZCB0aGF0IHRoZSBwcmVmZXJyZWQgdGV4dCBpcyBhbHdheXMgdGhlIHNlY29uZFxyXG4gICAgICAgICAgLy8gVE9ETzogVXRpbC5lc2NhcGVRdW90ZXMgd291bGQgYmUgZXhwZWN0ZWQgdG8gYmVcclxuICAgICAgICAgIC8vIHN1ZmZpY2llbnQgaGVyZSwgYnV0IHRoYXQgYXBwZWFycyB0byBnaXZlIFwiRE9NIEV4Y2VwdGlvblxyXG4gICAgICAgICAgLy8gMTFcIiBpbiBjYXNlcyAodHJ5IGUuZy4gJHguaHRtbCgnPHAgYT1cIkEmQlwiLz4nKS4gV2h5PyBJc1xyXG4gICAgICAgICAgLy8gdGhpcyB3b3JrYXJvdW5kIE9LP1xyXG4gICAgICAgICAgaHRtbC5wdXNoKCc8dHInK1xyXG4gICAgICAgICAgICAgICAgICAgICcgZGF0YS1pZD1cIicrVXRpbC5lc2NhcGVIVE1MYW5kUXVvdGVzKGl0ZW1bMF0pKydcIicrXHJcbiAgICAgICAgICAgICAgICAgICAgJyBkYXRhLXR4dD1cIicrVXRpbC5lc2NhcGVIVE1MYW5kUXVvdGVzKGl0ZW1bMV0pKydcIicrXHJcbiAgICAgICAgICAgICAgICAgICAgJz4nKTtcclxuICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxsZW47IGkrKykge1xyXG4gICAgICAgICAgICBodG1sLnB1c2goJzx0ZD4nICsgVXRpbC5lc2NhcGVIVE1MKGl0ZW1baV0pICsgJzwvdGQ+Jyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBodG1sLnB1c2goJzwvdHI+Jyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgJCgnI25vcm1fc2VhcmNoX3Jlc3VsdF9zZWxlY3QgdGJvZHknKS5odG1sKGh0bWwuam9pbignJykpO1xyXG5cclxuICAgICAgICAkKCcjbm9ybV9zZWFyY2hfcmVzdWx0X3NlbGVjdCB0Ym9keScpLmZpbmQoJ3RyJykuXHJcbiAgICAgICAgICAgIGNsaWNrKGNob29zZU5vcm1JZCkuXHJcbiAgICAgICAgICAgIGRibGNsaWNrKGNob29zZU5vcm1JZEFuZFN1Ym1pdCk7XHJcblxyXG4gICAgICAgIC8vIFRPRE86IHNvcnRpbmcgb24gY2xpY2sgb24gaGVhZGVyIChzZWUgc2hvd0ZpbGVCcm93c2VyKCkpXHJcbiAgICAgIH1cclxuICAgICAgdmFyIHBlcmZvcm1Ob3JtU2VhcmNoID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHZhbCA9ICQoJyNub3JtX3NlYXJjaF9xdWVyeScpLnZhbCgpO1xyXG4gICAgICAgIHZhciBkYiA9ICQoJyNzcGFuX25vcm1fZGInKS52YWwoKTtcclxuICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ2FqYXgnLCBbIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAnbm9ybVNlYXJjaCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFiYXNlOiBkYixcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdmFsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uOiBjb2xsfSwgJ25vcm1TZWFyY2hSZXN1bHQnXSk7XHJcbiAgICAgIH1cclxuICAgICAgJCgnI25vcm1fc2VhcmNoX2J1dHRvbicpLmNsaWNrKHBlcmZvcm1Ob3JtU2VhcmNoKTtcclxuICAgICAgJCgnI25vcm1fc2VhcmNoX3F1ZXJ5JykuZm9jdXMoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgc2V0Tm9ybVNlYXJjaFN1Ym1pdChmYWxzZSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICB2YXIgc2hvd05vcm1TZWFyY2hEaWFsb2cgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAvLyBpZiB3ZSBhbHJlYWR5IGhhdmUgbm9uLWVtcHR5IElEIGFuZCBub3JtYWxpemVkIHN0cmluZyxcclxuICAgICAgICAvLyB1c2UgdGhlc2UgYXMgZGVmYXVsdDsgb3RoZXJ3aXNlIHRha2UgZGVmYXVsdCBzZWFyY2ggc3RyaW5nXHJcbiAgICAgICAgLy8gZnJvbSBhbm5vdGF0ZWQgc3BhbiBhbmQgY2xlYXIgSUQgZW50cnlcclxuICAgICAgICBpZiAoISQoJyNzcGFuX25vcm1faWQnKS52YWwoKS5tYXRjaCgvXlxccyokLykgJiZcclxuICAgICAgICAgICAgISQoJyNzcGFuX25vcm1fdHh0JykudmFsKCkubWF0Y2goL15cXHMqJC8pKSB7XHJcbiAgICAgICAgICAkKCcjbm9ybV9zZWFyY2hfaWQnKS52YWwoJCgnI3NwYW5fbm9ybV9pZCcpLnZhbCgpKTtcclxuICAgICAgICAgICQoJyNub3JtX3NlYXJjaF9xdWVyeScpLnZhbCgkKCcjc3Bhbl9ub3JtX3R4dCcpLnZhbCgpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgJCgnI25vcm1fc2VhcmNoX2lkJykudmFsKCcnKTtcclxuICAgICAgICAgICQoJyNub3JtX3NlYXJjaF9xdWVyeScpLnZhbCgkKCcjc3Bhbl9zZWxlY3RlZCcpLnRleHQoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGJsYW5rIHRoZSB0YWJsZVxyXG4gICAgICAgICQoJyNub3JtX3NlYXJjaF9yZXN1bHRfc2VsZWN0IHRoZWFkJykuZW1wdHkoKTtcclxuICAgICAgICAkKCcjbm9ybV9zZWFyY2hfcmVzdWx0X3NlbGVjdCB0Ym9keScpLmVtcHR5KCk7ICAgICAgICBcclxuICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGZvciB0d28gKG9yIG1vcmUpIGRpYWxvZ3Mgb3BlbiBhdCB0aGUgc2FtZSB0aW1lXHJcbiAgICAgICAgLy8gc28gd2UgZG9uJ3QgbmVlZCB0byBoaWRlIHRoaXMgYmVmb3JlIHNob3dpbmcgbm9ybVNlYXJjaERpYWxvZ1xyXG4gICAgICAgIGRpc3BhdGNoZXIucG9zdCgnaGlkZUZvcm0nKTtcclxuICAgICAgICAkKCcjbm9ybV9zZWFyY2hfYnV0dG9uJykudmFsKCdTZWFyY2ggJyArICQoJyNzcGFuX25vcm1fZGInKS52YWwoKSk7XHJcbiAgICAgICAgc2V0Tm9ybVNlYXJjaFN1Ym1pdChmYWxzZSk7XHJcbiAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdzaG93Rm9ybScsIFtub3JtU2VhcmNoRGlhbG9nXSk7XHJcbiAgICAgICAgJCgnI25vcm1fc2VhcmNoX3F1ZXJ5JykuZm9jdXMoKS5zZWxlY3QoKTtcclxuICAgICAgfVxyXG4gICAgICAkKCcjc3Bhbl9ub3JtX3R4dCcpLmNsaWNrKHNob3dOb3JtU2VhcmNoRGlhbG9nKTtcclxuICAgICAgJCgnI25vcm1fc2VhcmNoX2J1dHRvbicpLmJ1dHRvbigpO1xyXG5cclxuICAgICAgdmFyIGFyY0Zvcm1TdWJtaXRSYWRpbyA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgIC8vIFRPRE86IGNoZWNrIGZvciBjb25maXJtX21vZGU/XHJcbiAgICAgICAgYXJjRm9ybVN1Ym1pdChldnQsICQoZXZ0LnRhcmdldCkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgYXJjRm9ybVN1Ym1pdCA9IGZ1bmN0aW9uKGV2dCwgdHlwZVJhZGlvKSB7XHJcbiAgICAgICAgdHlwZVJhZGlvID0gdHlwZVJhZGlvIHx8ICQoJyNhcmNfZm9ybSBpbnB1dDpyYWRpbzpjaGVja2VkJyk7XHJcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlUmFkaW8udmFsKCk7XHJcbiAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdoaWRlRm9ybScsIFthcmNGb3JtXSk7XHJcblxyXG4gICAgICAgIGFyY09wdGlvbnMudHlwZSA9IHR5cGU7XHJcbiAgICAgICAgYXJjT3B0aW9ucy5jb21tZW50ID0gJCgnI2FyY19ub3RlcycpLnZhbCgpO1xyXG4gICAgICAgIGRpc3BhdGNoZXIucG9zdCgnYWpheCcsIFthcmNPcHRpb25zLCAnZWRpdGVkJ10pO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciBmaWxsQXJjVHlwZXNBbmREaXNwbGF5Rm9ybSA9IGZ1bmN0aW9uKGV2dCwgb3JpZ2luVHlwZSwgdGFyZ2V0VHlwZSwgYXJjVHlwZSwgYXJjSWQpIHtcclxuICAgICAgICB2YXIgbm9BcmNzID0gdHJ1ZTtcclxuICAgICAgICBrZXltYXAgPSB7fTtcclxuXHJcbiAgICAgICAgLy8gc2VwYXJhdGUgb3V0IHBvc3NpYmxlIG51bWVyaWMgc3VmZml4IGZyb20gdHlwZVxyXG4gICAgICAgIHZhciBub051bUFyY1R5cGU7XHJcbiAgICAgICAgaWYgKGFyY1R5cGUpIHtcclxuICAgICAgICAgICAgdmFyIHNwbGl0VHlwZSA9IGFyY1R5cGUubWF0Y2goL14oLio/KShcXGQqKSQvKTtcclxuICAgICAgICAgICAgbm9OdW1BcmNUeXBlID0gc3BsaXRUeXBlWzFdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGlzRXF1aXYgPVxyXG4gICAgICAgICAgcmVsYXRpb25UeXBlc0hhc2ggJiZcclxuICAgICAgICAgIHJlbGF0aW9uVHlwZXNIYXNoW25vTnVtQXJjVHlwZV0gJiZcclxuICAgICAgICAgIHJlbGF0aW9uVHlwZXNIYXNoW25vTnVtQXJjVHlwZV0ucHJvcGVydGllcyAmJlxyXG4gICAgICAgICAgcmVsYXRpb25UeXBlc0hhc2hbbm9OdW1BcmNUeXBlXS5wcm9wZXJ0aWVzLnN5bW1ldHJpYyAmJlxyXG4gICAgICAgICAgcmVsYXRpb25UeXBlc0hhc2hbbm9OdW1BcmNUeXBlXS5wcm9wZXJ0aWVzLnRyYW5zaXRpdmU7XHJcblxyXG4gICAgICAgIHZhciAkc2Nyb2xsZXIgPSAkKCk7XHJcbiAgICAgICAgaWYgKHNwYW5UeXBlc1tvcmlnaW5UeXBlXSkge1xyXG4gICAgICAgICAgdmFyIGFyY1R5cGVzID0gc3BhblR5cGVzW29yaWdpblR5cGVdLmFyY3M7XHJcbiAgICAgICAgICAkc2Nyb2xsZXIgPSAkKCcjYXJjX3JvbGVzIC5zY3JvbGxlcicpLmVtcHR5KCk7XHJcblxyXG4gICAgICAgICAgLy8gbGF5IHRoZW0gb3V0IGludG8gdGhlIGZvcm1cclxuICAgICAgICAgICQuZWFjaChhcmNUeXBlcyB8fCBbXSwgZnVuY3Rpb24oYXJjVHlwZU5vLCBhcmNEZXNjKSB7XHJcbiAgICAgICAgICAgIGlmIChhcmNEZXNjLnRhcmdldHMgJiYgYXJjRGVzYy50YXJnZXRzLmluZGV4T2YodGFyZ2V0VHlwZSkgIT0gLTEpIHtcclxuICAgICAgICAgICAgICB2YXIgYXJjVHlwZU5hbWUgPSBhcmNEZXNjLnR5cGU7XHJcblxyXG4gICAgICAgICAgICAgIHZhciBpc1RoaXNFcXVpdiA9XHJcbiAgICAgICAgICAgICAgICByZWxhdGlvblR5cGVzSGFzaCAmJlxyXG4gICAgICAgICAgICAgICAgcmVsYXRpb25UeXBlc0hhc2hbYXJjVHlwZU5hbWVdICYmXHJcbiAgICAgICAgICAgICAgICByZWxhdGlvblR5cGVzSGFzaFthcmNUeXBlTmFtZV0ucHJvcGVydGllcyAmJlxyXG4gICAgICAgICAgICAgICAgcmVsYXRpb25UeXBlc0hhc2hbYXJjVHlwZU5hbWVdLnByb3BlcnRpZXMuc3ltbWV0cmljICYmXHJcbiAgICAgICAgICAgICAgICByZWxhdGlvblR5cGVzSGFzaFthcmNUeXBlTmFtZV0ucHJvcGVydGllcy50cmFuc2l0aXZlO1xyXG5cclxuICAgICAgICAgICAgICAvLyBkbyBub3QgYWxsb3cgZXF1aXY8LT5ub24tZXF1aXYgY2hhbmdlIG9wdGlvbnNcclxuICAgICAgICAgICAgICBpZiAoYXJjVHlwZSAmJiBpc0VxdWl2ICE9IGlzVGhpc0VxdWl2KSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgIHZhciBkaXNwbGF5TmFtZSA9ICgoYXJjRGVzYy5sYWJlbHMgJiYgYXJjRGVzYy5sYWJlbHNbMF0pIHx8IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmNUeXBlTmFtZSk7XHJcbiAgICAgICAgICAgICAgdmFyICRjaGVja2JveCA9ICQoJzxpbnB1dCBpZD1cImFyY18nICsgYXJjVHlwZU5hbWUgKyAnXCIgdHlwZT1cInJhZGlvXCIgbmFtZT1cImFyY190eXBlXCIgdmFsdWU9XCInICsgYXJjVHlwZU5hbWUgKyAnXCIvPicpO1xyXG4gICAgICAgICAgICAgIHZhciAkbGFiZWwgPSAkKCc8bGFiZWwgY2xhc3M9XCJhcmNfdHlwZV9sYWJlbFwiIGZvcj1cImFyY18nICsgYXJjVHlwZU5hbWUgKyAnXCIvPicpLnRleHQoZGlzcGxheU5hbWUpO1xyXG4gICAgICAgICAgICAgIHZhciAkZGl2ID0gJCgnPGRpdi8+JykuYXBwZW5kKCRjaGVja2JveCkuYXBwZW5kKCRsYWJlbCk7XHJcbiAgICAgICAgICAgICAgJHNjcm9sbGVyLmFwcGVuZCgkZGl2KTtcclxuICAgICAgICAgICAgICBpZiAoYXJjRGVzYy5ob3RrZXkpIHtcclxuICAgICAgICAgICAgICAgIGtleW1hcFthcmNEZXNjLmhvdGtleV0gPSAnI2FyY18nICsgYXJjVHlwZU5hbWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9ICRsYWJlbC5odG1sKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVwbGFjZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAoXCIoJlteO10qPyk/KFwiICsgYXJjRGVzYy5ob3RrZXkgKyBcIilcIiwgJ2dpJyksXHJcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGFsbCwgZW50aXR5LCBsZXR0ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVwbGFjZSAmJiAhZW50aXR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgaG90a2V5ID0gYXJjRGVzYy5ob3RrZXkudG9Mb3dlckNhc2UoKSA9PSBsZXR0ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICA/IGFyY0Rlc2MuaG90a2V5LnRvTG93ZXJDYXNlKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IGFyY0Rlc2MuaG90a2V5LnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzxzcGFuIGNsYXNzPVwiYWNjZXNza2V5XCI+JyArIFV0aWwuZXNjYXBlSFRNTChob3RrZXkpICsgJzwvc3Bhbj4nO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWxsO1xyXG4gICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICRsYWJlbC5odG1sKG5hbWUpO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgbm9BcmNzID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG5vQXJjcykge1xyXG4gICAgICAgICAgaWYgKGFyY0lkKSB7XHJcbiAgICAgICAgICAgIC8vIGxldCB0aGUgdXNlciBkZWxldGUgb3Igd2hhdGV2ZXIsIGV2ZW4gb24gYmFkIGNvbmZpZ1xyXG4gICAgICAgICAgICAvLyAobm90ZSB0aGF0IHdoYXQncyBzaG93biB0byB0aGUgdXNlciBpcyB3L28gcG9zc2libGUgbnVtIHN1ZmZpeClcclxuICAgICAgICAgICAgdmFyICRjaGVja2JveCA9ICQoJzxpbnB1dCBpZD1cImFyY18nICsgYXJjVHlwZSArICdcIiB0eXBlPVwiaGlkZGVuXCIgbmFtZT1cImFyY190eXBlXCIgdmFsdWU9XCInICsgbm9OdW1BcmNUeXBlICsgJ1wiLz4nKTtcclxuICAgICAgICAgICAgJHNjcm9sbGVyLmFwcGVuZCgkY2hlY2tib3gpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gY2FuJ3QgbWFrZSBhIG5ldyBhcmNcclxuICAgICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdtZXNzYWdlcycsXHJcbiAgICAgICAgICAgICAgW1tbXCJObyBjaG9pY2VzIGZvciBcIiArXHJcbiAgICAgICAgICAgICAgICAgVXRpbC5zcGFuRGlzcGxheUZvcm0oc3BhblR5cGVzLCBvcmlnaW5UeXBlKSArXHJcbiAgICAgICAgICAgICAgICAgXCIgLT4gXCIgK1xyXG4gICAgICAgICAgICAgICAgIFV0aWwuc3BhbkRpc3BsYXlGb3JtKHNwYW5UeXBlcywgdGFyZ2V0VHlwZSksXHJcbiAgICAgICAgICAgICAgICAgJ3dhcm5pbmcnXV1dKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHJldmVyc2FsUG9zc2libGUgPSBmYWxzZTtcclxuICAgICAgICBpZiAoYXJjSWQpIHtcclxuICAgICAgICAgIC8vIHNvbWV0aGluZyB3YXMgc2VsZWN0ZWRcclxuICAgICAgICAgIHZhciBmb2N1cyA9IGFyY0lkIGluc3RhbmNlb2YgQXJyYXkgPyBhcmNJZCA6IFthcmNJZF07XHJcbiAgICAgICAgICB2YXIgaGFzaCA9IG5ldyBVUkxIYXNoKGNvbGwsIGRvYywgeyBmb2N1czogW2ZvY3VzXSB9KS5nZXRIYXNoKCk7XHJcbiAgICAgICAgICAkKCcjYXJjX2hpZ2hsaWdodF9saW5rJykuYXR0cignaHJlZicsIGhhc2gpLnNob3coKTsgLy8gVE9ETyBpbmNvcnJlY3RcclxuICAgICAgICAgIHZhciBlbCA9ICQoJyNhcmNfJyArIGFyY1R5cGUpWzBdO1xyXG4gICAgICAgICAgaWYgKGVsKSB7XHJcbiAgICAgICAgICAgIGVsLmNoZWNrZWQgPSB0cnVlO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAvLyB0cnkgdy9vIG51bWVyaWMgc3VmZml4XHJcbiAgICAgICAgICAgICAgZWwgPSAkKCcjYXJjXycgKyBub051bUFyY1R5cGUpWzBdO1xyXG4gICAgICAgICAgICAgIGlmIChlbCkge1xyXG4gICAgICAgICAgICAgICAgICBlbC5jaGVja2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgJCgnI2FyY19mb3JtX3Jlc2VsZWN0LCAjYXJjX2Zvcm1fZGVsZXRlJykuc2hvdygpO1xyXG4gICAgICAgICAga2V5bWFwWyQudWkua2V5Q29kZS5ERUxFVEVdID0gJ2FyY19mb3JtX2RlbGV0ZSc7XHJcbiAgICAgICAgICBrZXltYXBbJC51aS5rZXlDb2RlLklOU0VSVF0gPSAnYXJjX2Zvcm1fcmVzZWxlY3QnO1xyXG5cclxuICAgICAgICAgIHZhciBiYWNrVGFyZ2V0VHlwZSA9IHNwYW5UeXBlc1t0YXJnZXRUeXBlXTtcclxuICAgICAgICAgIGlmIChiYWNrVGFyZ2V0VHlwZSkge1xyXG4gICAgICAgICAgICAkLmVhY2goYmFja1RhcmdldFR5cGUuYXJjcyB8fCBbXSwgZnVuY3Rpb24oYmFja0FyY1R5cGVObywgYmFja0FyY0Rlc2MpIHtcclxuICAgICAgICAgICAgICBpZiAoJC5pbkFycmF5KG9yaWdpblR5cGUsIGJhY2tBcmNEZXNjLnRhcmdldHMgfHwgW10pICE9IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXZlcnNhbFBvc3NpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gdGVybWluYXRlIHRoZSBsb29wXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBhcmNGb3JtLmRpYWxvZygnb3B0aW9uJywgeyB0aXRsZTogJ0VkaXQgQW5ub3RhdGlvbicgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIG5ldyBhcmNcclxuICAgICAgICAgICQoJyNhcmNfaGlnaGxpZ2h0X2xpbmsnKS5oaWRlKCk7XHJcbiAgICAgICAgICBlbCA9ICQoJyNhcmNfZm9ybSBpbnB1dDpyYWRpbzpmaXJzdCcpWzBdO1xyXG4gICAgICAgICAgaWYgKGVsKSB7XHJcbiAgICAgICAgICAgIGVsLmNoZWNrZWQgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICQoJyNhcmNfZm9ybV9yZXNlbGVjdCwgI2FyY19mb3JtX2RlbGV0ZSwgI2FyY19mb3JtX3JldmVyc2UnKS5oaWRlKCk7XHJcblxyXG4gICAgICAgICAgYXJjRm9ybS5kaWFsb2coJ29wdGlvbicsIHsgdGl0bGU6ICdOZXcgQW5ub3RhdGlvbicgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXZlcnNhbFBvc3NpYmxlKSB7XHJcbiAgICAgICAgICAkKCcjYXJjX2Zvcm1fcmV2ZXJzZScpLnNob3coKTtcclxuICAgICAgICAgIGtleW1hcFsnUy0nICsgJC51aS5rZXlDb2RlLklOU0VSVF0gPSAnYXJjX2Zvcm1fcmV2ZXJzZSc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICQoJyNhcmNfZm9ybV9yZXZlcnNlJykuaGlkZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFDb25maWd1cmF0aW9uLmNvbmZpcm1Nb2RlT24pIHtcclxuICAgICAgICAgIGFyY0Zvcm0uZmluZCgnI2FyY19yb2xlcyBpbnB1dDpyYWRpbycpLmNsaWNrKGFyY0Zvcm1TdWJtaXRSYWRpbyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYXJjQW5ub3RhdG9yTm90ZXM7XHJcbiAgICAgICAgdmFyIGlzQmluYXJ5UmVsYXRpb24gPSBhcmNJZCAmJiAhKGFyY0lkIGluc3RhbmNlb2YgQXJyYXkpO1xyXG4gICAgICAgIGlmIChpc0JpbmFyeVJlbGF0aW9uKSB7XHJcbiAgICAgICAgICAvLyBvbmx5IGZvciByZWxhdGlvbiBhcmNzXHJcbiAgICAgICAgICB2YXIgZWQgPSBkYXRhLmV2ZW50RGVzY3NbYXJjSWRdO1xyXG4gICAgICAgICAgYXJjQW5ub3RhdG9yTm90ZXMgPSBlZCAmJiBlZC5hbm5vdGF0b3JOb3RlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFyY0Fubm90YXRvck5vdGVzKSB7XHJcbiAgICAgICAgICAkKCcjYXJjX25vdGVzJykudmFsKGFyY0Fubm90YXRvck5vdGVzKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgJCgnI2FyY19ub3RlcycpLnZhbCgnJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBkaXNhYmxlIG5vdGVzIGZvciBhcmMgdHlwZXMgdGhhdCBkb24ndCBzdXBwb3J0IHN0b3JhZ2UgKCM5NDUpXHJcbiAgICAgICAgaWYoIWlzQmluYXJ5UmVsYXRpb24gfHwgaXNFcXVpdikge1xyXG4gICAgICAgICAgLy8gZGlzYWJsZSB0aGUgYWN0dWFsIGlucHV0XHJcbiAgICAgICAgICAkKCcjYXJjX25vdGVzJykuYXR0cignZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcclxuICAgICAgICAgIC8vIGFkZCB0byBmaWVsZHNldCBmb3Igc3R5bGVcclxuICAgICAgICAgICQoJyNhcmNfbm90ZXNfZmllbGRzZXQnKS5hdHRyKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAkKCcjYXJjX25vdGVzJykucmVtb3ZlQXR0cignZGlzYWJsZWQnKVxyXG4gICAgICAgICAgJCgnI2FyY19ub3Rlc19maWVsZHNldCcpLnJlbW92ZUF0dHIoJ2Rpc2FibGVkJylcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRpc3BhdGNoZXIucG9zdCgnc2hvd0Zvcm0nLCBbYXJjRm9ybV0pO1xyXG4gICAgICAgICQoJyNhcmNfZm9ybS1vaycpLmZvY3VzKCk7XHJcbiAgICAgICAgYWRqdXN0VG9DdXJzb3IoZXZ0LCBhcmNGb3JtLnBhcmVudCgpKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciByZXZlcnNlQXJjID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgdmFyIGV2ZW50RGF0YUlkID0gJChldnQudGFyZ2V0KS5hdHRyKCdkYXRhLWFyYy1lZCcpO1xyXG4gICAgICAgIGRpc3BhdGNoZXIucG9zdCgnaGlkZUZvcm0nKTtcclxuICAgICAgICBhcmNPcHRpb25zLmFjdGlvbiA9ICdyZXZlcnNlQXJjJztcclxuICAgICAgICBkZWxldGUgYXJjT3B0aW9ucy5vbGRfdGFyZ2V0O1xyXG4gICAgICAgIGRlbGV0ZSBhcmNPcHRpb25zLm9sZF90eXBlO1xyXG4gICAgICAgIGRpc3BhdGNoZXIucG9zdCgnYWpheCcsIFthcmNPcHRpb25zLCAnZWRpdGVkJ10pO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdmFyIGRlbGV0ZUFyYyA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgIGlmIChDb25maWd1cmF0aW9uLmNvbmZpcm1Nb2RlT24gJiYgIWNvbmZpcm0oXCJBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZGVsZXRlIHRoaXMgYW5ub3RhdGlvbj9cIikpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGV2ZW50RGF0YUlkID0gJChldnQudGFyZ2V0KS5hdHRyKCdkYXRhLWFyYy1lZCcpO1xyXG4gICAgICAgIGRpc3BhdGNoZXIucG9zdCgnaGlkZUZvcm0nKTtcclxuICAgICAgICBhcmNPcHRpb25zLmFjdGlvbiA9ICdkZWxldGVBcmMnO1xyXG4gICAgICAgIGRpc3BhdGNoZXIucG9zdCgnYWpheCcsIFthcmNPcHRpb25zLCAnZWRpdGVkJ10pO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdmFyIHJlc2VsZWN0QXJjID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdoaWRlRm9ybScpO1xyXG4gICAgICAgIHN2Z0VsZW1lbnQuYWRkQ2xhc3MoJ3Jlc2VsZWN0Jyk7XHJcbiAgICAgICAgJCgnZ1tkYXRhLWZyb209XCInICsgYXJjT3B0aW9ucy5vcmlnaW4gKyAnXCJdW2RhdGEtdG89XCInICsgYXJjT3B0aW9ucy50YXJnZXQgKyAnXCJdJykuYWRkQ2xhc3MoJ3Jlc2VsZWN0Jyk7XHJcbiAgICAgICAgc3RhcnRBcmNEcmFnKGFyY09wdGlvbnMub3JpZ2luKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciBhcmNGb3JtID0gJCgnI2FyY19mb3JtJyk7XHJcbiAgICAgIGRpc3BhdGNoZXIucG9zdCgnaW5pdEZvcm0nLCBbYXJjRm9ybSwge1xyXG4gICAgICAgICAgd2lkdGg6IDUwMCxcclxuICAgICAgICAgIGJ1dHRvbnM6IFt7XHJcbiAgICAgICAgICAgICAgaWQ6ICdhcmNfZm9ybV9yZXZlcnNlJyxcclxuICAgICAgICAgICAgICB0ZXh0OiBcIlJldmVyc2VcIixcclxuICAgICAgICAgICAgICBjbGljazogcmV2ZXJzZUFyY1xyXG4gICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgaWQ6ICdhcmNfZm9ybV9kZWxldGUnLFxyXG4gICAgICAgICAgICAgIHRleHQ6IFwiRGVsZXRlXCIsXHJcbiAgICAgICAgICAgICAgY2xpY2s6IGRlbGV0ZUFyY1xyXG4gICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgaWQ6ICdhcmNfZm9ybV9yZXNlbGVjdCcsXHJcbiAgICAgICAgICAgICAgdGV4dDogJ1Jlc2VsZWN0JyxcclxuICAgICAgICAgICAgICBjbGljazogcmVzZWxlY3RBcmNcclxuICAgICAgICAgICAgfV0sXHJcbiAgICAgICAgICBhbHNvUmVzaXplOiAnI2FyY19yb2xlcycsXHJcbiAgICAgICAgICBjbG9zZTogZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgICAgIGtleW1hcCA9IG51bGw7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfV0pO1xyXG4gICAgICBhcmNGb3JtLnN1Ym1pdChhcmNGb3JtU3VibWl0KTtcclxuICAgICAgLy8gc2V0IGJ1dHRvbiB0b29sdGlwcyAoQGFtYWRhbm1hdGg6IGNhbiB0aGlzIGJlIGRvbmUgaW4gaW5pdD8pXHJcbiAgICAgICQoJyNhcmNfZm9ybV9yZXNlbGVjdCcpLmF0dHIoJ3RpdGxlJywgJ1JlLXNlbGVjdCB0aGUgYW5ub3RhdGlvbiB0aGlzIGNvbm5lY3RzIGludG8uJyk7XHJcbiAgICAgICQoJyNhcmNfZm9ybV9kZWxldGUnKS5hdHRyKCd0aXRsZScsICdEZWxldGUgdGhpcyBhbm5vdGF0aW9uLicpO1xyXG5cclxuICAgICAgdmFyIHN0b3BBcmNEcmFnID0gZnVuY3Rpb24odGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKGFyY0RyYWdPcmlnaW4pIHtcclxuICAgICAgICAgIGlmICghdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHRhcmdldCA9ICQoJy5iYWRUYXJnZXQnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRhcmdldC5yZW1vdmVDbGFzcygnYmFkVGFyZ2V0Jyk7XHJcbiAgICAgICAgICBhcmNEcmFnT3JpZ2luR3JvdXAucmVtb3ZlQ2xhc3MoJ2hpZ2hsaWdodCcpO1xyXG4gICAgICAgICAgaWYgKHRhcmdldCkge1xyXG4gICAgICAgICAgICB0YXJnZXQucGFyZW50KCkucmVtb3ZlQ2xhc3MoJ2hpZ2hsaWdodCcpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGFyY0RyYWdBcmMpIHtcclxuICAgICAgICAgICAgc3ZnLnJlbW92ZShhcmNEcmFnQXJjKTtcclxuICAgICAgICAgICAgYXJjRHJhZyA9IG51bGw7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBhcmNEcmFnT3JpZ2luID0gbnVsbDtcclxuICAgICAgICAgIGlmIChhcmNPcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgJCgnZ1tkYXRhLWZyb209XCInICsgYXJjT3B0aW9ucy5vcmlnaW4gKyAnXCJdW2RhdGEtdG89XCInICsgYXJjT3B0aW9ucy50YXJnZXQgKyAnXCJdJykucmVtb3ZlQ2xhc3MoJ3Jlc2VsZWN0Jyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBzdmdFbGVtZW50LnJlbW92ZUNsYXNzKCdyZXNlbGVjdCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdmdFbGVtZW50LnJlbW92ZUNsYXNzKCd1bnNlbGVjdGFibGUnKTtcclxuICAgICAgICAkKCcucmVzZWxlY3RUYXJnZXQnKS5yZW1vdmVDbGFzcygncmVzZWxlY3RUYXJnZXQnKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciBvbk1vdXNlVXAgPSBmdW5jdGlvbihldnQpIHtcclxuICAgICAgICAvL1JlbW92ZWQgYnkgUmVuYXVkIG9uIDIwMTYtMDMtMTBcclxuICAgICAgICAvL2lmICh0aGF0LnVzZXIgPT09IG51bGwpIHJldHVybjtcclxuXHJcbiAgICAgICAgdmFyIHRhcmdldCA9ICQoZXZ0LnRhcmdldCk7XHJcblxyXG4gICAgICAgIC8vIHRocmVlIHRoaW5ncyB0aGF0IGFyZSBjbGlja2FibGUgaW4gU1ZHXHJcbiAgICAgICAgdmFyIHRhcmdldFNwYW5JZCA9IHRhcmdldC5kYXRhKCdzcGFuLWlkJyk7XHJcbiAgICAgICAgdmFyIHRhcmdldENodW5rSWQgPSB0YXJnZXQuZGF0YSgnY2h1bmstaWQnKTtcclxuICAgICAgICB2YXIgdGFyZ2V0QXJjUm9sZSA9IHRhcmdldC5kYXRhKCdhcmMtcm9sZScpO1xyXG4gICAgICAgIGlmICghKHRhcmdldFNwYW5JZCAhPT0gdW5kZWZpbmVkIHx8IHRhcmdldENodW5rSWQgIT09IHVuZGVmaW5lZCB8fCB0YXJnZXRBcmNSb2xlICE9PSB1bmRlZmluZWQpKSB7XHJcbiAgICAgICAgICAvLyBtaXNjbGlja1xyXG4gICAgICAgICAgY2xlYXJTZWxlY3Rpb24oKTtcclxuICAgICAgICAgIHN0b3BBcmNEcmFnKHRhcmdldCk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBpcyBpdCBhcmMgZHJhZyBlbmQ/XHJcbiAgICAgICAgaWYgKGFyY0RyYWdPcmlnaW4pIHtcclxuICAgICAgICAgIHZhciBvcmlnaW4gPSBhcmNEcmFnT3JpZ2luO1xyXG4gICAgICAgICAgdmFyIHRhcmdldFZhbGlkID0gdGFyZ2V0Lmhhc0NsYXNzKCdyZXNlbGVjdFRhcmdldCcpO1xyXG4gICAgICAgICAgc3RvcEFyY0RyYWcodGFyZ2V0KTtcclxuICAgICAgICAgIGlmICgoaWQgPSB0YXJnZXQuYXR0cignZGF0YS1zcGFuLWlkJykpICYmIG9yaWdpbiAhPSBpZCAmJiB0YXJnZXRWYWxpZCkge1xyXG4gICAgICAgICAgICB2YXIgb3JpZ2luU3BhbiA9IGRhdGEuc3BhbnNbb3JpZ2luXTtcclxuICAgICAgICAgICAgdmFyIHRhcmdldFNwYW4gPSBkYXRhLnNwYW5zW2lkXTtcclxuICAgICAgICAgICAgaWYgKGFyY09wdGlvbnMgJiYgYXJjT3B0aW9ucy5vbGRfdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgYXJjT3B0aW9ucy50YXJnZXQgPSB0YXJnZXRTcGFuLmlkO1xyXG4gICAgICAgICAgICAgIGRpc3BhdGNoZXIucG9zdCgnYWpheCcsIFthcmNPcHRpb25zLCAnZWRpdGVkJ10pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGFyY09wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdjcmVhdGVBcmMnLFxyXG4gICAgICAgICAgICAgICAgb3JpZ2luOiBvcmlnaW5TcGFuLmlkLFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXRTcGFuLmlkLFxyXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbjogY29sbCxcclxuICAgICAgICAgICAgICAgICdkb2N1bWVudCc6IGRvY1xyXG4gICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgJCgnI2FyY19vcmlnaW4nKS50ZXh0KFV0aWwuc3BhbkRpc3BsYXlGb3JtKHNwYW5UeXBlcywgb3JpZ2luU3Bhbi50eXBlKSsnIChcIicrb3JpZ2luU3Bhbi50ZXh0KydcIiknKTtcclxuICAgICAgICAgICAgICAkKCcjYXJjX3RhcmdldCcpLnRleHQoVXRpbC5zcGFuRGlzcGxheUZvcm0oc3BhblR5cGVzLCB0YXJnZXRTcGFuLnR5cGUpKycgKFwiJyt0YXJnZXRTcGFuLnRleHQrJ1wiKScpO1xyXG4gICAgICAgICAgICAgIGZpbGxBcmNUeXBlc0FuZERpc3BsYXlGb3JtKGV2dCwgb3JpZ2luU3Bhbi50eXBlLCB0YXJnZXRTcGFuLnR5cGUpO1xyXG4gICAgICAgICAgICAgIC8vIGZvciBwcmVjaXNlIHRpbWluZywgbG9nIGRpYWxvZyBkaXNwbGF5IHRvIHVzZXIuXHJcbiAgICAgICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdsb2dBY3Rpb24nLCBbJ2FyY1NlbGVjdGVkJ10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmICghZXZ0LmN0cmxLZXkpIHtcclxuICAgICAgICAgIC8vIGlmIG5vdCwgdGhlbiBpcyBpdCBzcGFuIHNlbGVjdGlvbj8gKGN0cmwga2V5IGNhbmNlbHMpXHJcbiAgICAgICAgICB2YXIgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xyXG4gICAgICAgICAgdmFyIGNodW5rSW5kZXhGcm9tID0gc2VsLmFuY2hvck5vZGUgJiYgJChzZWwuYW5jaG9yTm9kZS5wYXJlbnROb2RlKS5hdHRyKCdkYXRhLWNodW5rLWlkJyk7XHJcbiAgICAgICAgICB2YXIgY2h1bmtJbmRleFRvID0gc2VsLmZvY3VzTm9kZSAmJiAkKHNlbC5mb2N1c05vZGUucGFyZW50Tm9kZSkuYXR0cignZGF0YS1jaHVuay1pZCcpO1xyXG5cclxuICAgICAgICAgIC8vIGZhbGxiYWNrIGZvciBmaXJlZm94IChhdCBsZWFzdCk6XHJcbiAgICAgICAgICAvLyBpdCdzIHVuY2xlYXIgd2h5LCBidXQgZm9yIGZpcmVmb3ggdGhlIGFuY2hvciBhbmQgZm9jdXNcclxuICAgICAgICAgIC8vIG5vZGUgcGFyZW50cyBhcmUgYWx3YXlzIHVuZGVmaW5lZCwgdGhlIHRoZSBhbmNob3IgYW5kXHJcbiAgICAgICAgICAvLyBmb2N1cyBub2RlcyB0aGVtc2VsdmVzIGRvIChvZnRlbikgaGF2ZSB0aGUgbmVjZXNzYXJ5XHJcbiAgICAgICAgICAvLyBjaHVuayBJRC4gSG93ZXZlciwgYW5jaG9yIG9mZnNldHMgYXJlIGFsbW9zdCBhbHdheXNcclxuICAgICAgICAgIC8vIHdyb25nLCBzbyB3ZSdsbCBqdXN0IG1ha2UgYSBndWVzcyBhdCB3aGF0IHRoZSB1c2VyIG1pZ2h0XHJcbiAgICAgICAgICAvLyBiZSBpbnRlcmVzdGVkIGluIHRhZ2dpbmcgaW5zdGVhZCBvZiB1c2luZyB3aGF0J3MgZ2l2ZW4uXHJcbiAgICAgICAgICB2YXIgYW5jaG9yT2Zmc2V0ID0gbnVsbDtcclxuICAgICAgICAgIHZhciBmb2N1c09mZnNldCA9IG51bGw7XHJcbiAgICAgICAgICBpZiAoY2h1bmtJbmRleEZyb20gPT09IHVuZGVmaW5lZCAmJiBjaHVua0luZGV4VG8gPT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgICAgICAgICQoc2VsLmFuY2hvck5vZGUpLmF0dHIoJ2RhdGEtY2h1bmstaWQnKSAmJlxyXG4gICAgICAgICAgICAgICQoc2VsLmZvY3VzTm9kZSkuYXR0cignZGF0YS1jaHVuay1pZCcpKSB7XHJcbiAgICAgICAgICAgIC8vIEEuIFNjZXJyaSBGaXJlRm94IGNodW5rXHJcblxyXG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBzZWwuZ2V0UmFuZ2VBdCgwKTtcclxuICAgICAgICAgICAgdmFyIHN2Z09mZnNldCA9ICQoc3ZnLl9zdmcpLm9mZnNldCgpO1xyXG4gICAgICAgICAgICB2YXIgZmxpcCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB2YXIgdHJpZXMgPSAwO1xyXG4gICAgICAgICAgICB3aGlsZSAodHJpZXMgPCAyKSB7XHJcbiAgICAgICAgICAgICAgdmFyIHNwID0gc3ZnLl9zdmcuY3JlYXRlU1ZHUG9pbnQoKTtcclxuICAgICAgICAgICAgICBzcC54ID0gKGZsaXAgPyBldnQucGFnZVggOiBkcmFnU3RhcnRlZEF0LnBhZ2VYKSAtIHN2Z09mZnNldC5sZWZ0O1xyXG4gICAgICAgICAgICAgIHNwLnkgPSAoZmxpcCA/IGV2dC5wYWdlWSA6IGRyYWdTdGFydGVkQXQucGFnZVkpIC0gKHN2Z09mZnNldC50b3AgKyA4KTtcclxuICAgICAgICAgICAgICB2YXIgc3RhcnRzQXQgPSByYW5nZS5zdGFydENvbnRhaW5lcjtcclxuICAgICAgICAgICAgICBhbmNob3JPZmZzZXQgPSBzdGFydHNBdC5nZXRDaGFyTnVtQXRQb3NpdGlvbihzcCk7XHJcbiAgICAgICAgICAgICAgY2h1bmtJbmRleEZyb20gPSBzdGFydHNBdCAmJiAkKHN0YXJ0c0F0KS5hdHRyKCdkYXRhLWNodW5rLWlkJyk7XHJcbiAgICAgICAgICAgICAgaWYgKGFuY2hvck9mZnNldCAhPSAtMSkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGZsaXAgPSB0cnVlO1xyXG4gICAgICAgICAgICAgIHRyaWVzKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3AueCA9IChmbGlwID8gZHJhZ1N0YXJ0ZWRBdC5wYWdlWCA6IGV2dC5wYWdlWCkgLSBzdmdPZmZzZXQubGVmdDtcclxuICAgICAgICAgICAgc3AueSA9IChmbGlwID8gZHJhZ1N0YXJ0ZWRBdC5wYWdlWSA6IGV2dC5wYWdlWSkgLSAoc3ZnT2Zmc2V0LnRvcCArIDgpO1xyXG4gICAgICAgICAgICB2YXIgZW5kc0F0ID0gcmFuZ2UuZW5kQ29udGFpbmVyO1xyXG4gICAgICAgICAgICBmb2N1c09mZnNldCA9IGVuZHNBdC5nZXRDaGFyTnVtQXRQb3NpdGlvbihzcCk7XHJcblxyXG4gICAgICAgICAgICBpZiAocmFuZ2Uuc3RhcnRDb250YWluZXIgPT0gcmFuZ2UuZW5kQ29udGFpbmVyICYmIGFuY2hvck9mZnNldCA+IGZvY3VzT2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgdmFyIHQgPSBhbmNob3JPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgYW5jaG9yT2Zmc2V0ID0gZm9jdXNPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgZm9jdXNPZmZzZXQgPSB0O1xyXG4gICAgICAgICAgICAgIGZsaXAgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZm9jdXNPZmZzZXQgIT0gLTEpIHtcclxuICAgICAgICAgICAgICBmb2N1c09mZnNldCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNodW5rSW5kZXhUbyA9IGVuZHNBdCAmJiAkKGVuZHNBdCkuYXR0cignZGF0YS1jaHVuay1pZCcpO1xyXG5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZmFsbGJhY2sgZnJvbScsIGRhdGEuY2h1bmtzW2NodW5rSW5kZXhGcm9tXSwgYW5jaG9yT2Zmc2V0KTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZmFsbGJhY2sgdG8nLCBkYXRhLmNodW5rc1tjaHVua0luZGV4VG9dLCBmb2N1c09mZnNldCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBub3JtYWwgY2FzZSwgYXNzdW1lIHRoZSBleGFjdCBvZmZzZXRzIGFyZSB1c2FibGVcclxuICAgICAgICAgICAgYW5jaG9yT2Zmc2V0ID0gc2VsLmFuY2hvck9mZnNldDtcclxuICAgICAgICAgICAgZm9jdXNPZmZzZXQgPSBzZWwuZm9jdXNPZmZzZXQ7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKGNodW5rSW5kZXhGcm9tICE9PSB1bmRlZmluZWQgJiYgY2h1bmtJbmRleFRvICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdmFyIGNodW5rRnJvbSA9IGRhdGEuY2h1bmtzW2NodW5rSW5kZXhGcm9tXTtcclxuICAgICAgICAgICAgdmFyIGNodW5rVG8gPSBkYXRhLmNodW5rc1tjaHVua0luZGV4VG9dO1xyXG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWRGcm9tID0gY2h1bmtGcm9tLmZyb20gKyBhbmNob3JPZmZzZXQ7XHJcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZFRvID0gY2h1bmtUby5mcm9tICsgZm9jdXNPZmZzZXQ7XHJcbiAgICAgICAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZEZyb20gPiBzZWxlY3RlZFRvKSB7XHJcbiAgICAgICAgICAgICAgdmFyIHRtcCA9IHNlbGVjdGVkRnJvbTsgc2VsZWN0ZWRGcm9tID0gc2VsZWN0ZWRUbzsgc2VsZWN0ZWRUbyA9IHRtcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB0cmltXHJcbiAgICAgICAgICAgIHdoaWxlIChzZWxlY3RlZEZyb20gPCBzZWxlY3RlZFRvICYmIFwiIFxcblxcdFwiLmluZGV4T2YoZGF0YS50ZXh0LnN1YnN0cihzZWxlY3RlZEZyb20sIDEpKSAhPT0gLTEpIHNlbGVjdGVkRnJvbSsrO1xyXG4gICAgICAgICAgICB3aGlsZSAoc2VsZWN0ZWRGcm9tIDwgc2VsZWN0ZWRUbyAmJiBcIiBcXG5cXHRcIi5pbmRleE9mKGRhdGEudGV4dC5zdWJzdHIoc2VsZWN0ZWRUbyAtIDEsIDEpKSAhPT0gLTEpIHNlbGVjdGVkVG8tLTtcclxuXHJcbiAgICAgICAgICAgIC8vIHNoaWZ0K2NsaWNrIGFsbG93cyB6ZXJvLXdpZHRoIHNwYW5zXHJcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZEZyb20gPT09IHNlbGVjdGVkVG8gJiYgIWV2dC5zaGlmdEtleSkge1xyXG4gICAgICAgICAgICAgIC8vIHNpbXBsZSBjbGljayAoemVyby13aWR0aCBzcGFuKVxyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIG5ld09mZnNldCA9IFtzZWxlY3RlZEZyb20sIHNlbGVjdGVkVG9dO1xyXG4gICAgICAgICAgICBpZiAocmVzZWxlY3RlZFNwYW4pIHtcclxuICAgICAgICAgICAgICB2YXIgbmV3T2Zmc2V0cyA9IHJlc2VsZWN0ZWRTcGFuLm9mZnNldHMuc2xpY2UoMCk7IC8vIGNsb25lXHJcbiAgICAgICAgICAgICAgc3Bhbk9wdGlvbnMub2xkX29mZnNldHMgPSBKU09OLnN0cmluZ2lmeShyZXNlbGVjdGVkU3Bhbi5vZmZzZXRzKTtcclxuICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRGcmFnbWVudCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkRnJhZ21lbnQgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgIG5ld09mZnNldHMuc3BsaWNlKHNlbGVjdGVkRnJhZ21lbnQsIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbmV3T2Zmc2V0cy5wdXNoKG5ld09mZnNldCk7XHJcbiAgICAgICAgICAgICAgICBuZXdPZmZzZXRzLnNvcnQoVXRpbC5jbXBBcnJheU9uRmlyc3RFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIHNwYW5PcHRpb25zLm9mZnNldHMgPSBuZXdPZmZzZXRzO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzcGFuT3B0aW9ucy5vZmZzZXRzID0gW25ld09mZnNldF07XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHNwYW5PcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnY3JlYXRlU3BhbicsXHJcbiAgICAgICAgICAgICAgICBvZmZzZXRzOiBbbmV3T2Zmc2V0XVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuLyogSW4gcmVsYXRpb24gdG8gIzc4NiwgcmVtb3ZlZCB0aGUgY3Jvc3Mtc2VudGVuY2UgY2hlY2tpbmcgY29kZVxyXG4gICAgICAgICAgICB2YXIgY3Jvc3NTZW50ZW5jZSA9IHRydWU7XHJcbiAgICAgICAgICAgICQuZWFjaChzb3VyY2VEYXRhLnNlbnRlbmNlX29mZnNldHMsIGZ1bmN0aW9uKHNlbnRObywgc3RhcnRFbmQpIHtcclxuICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRUbyA8PSBzdGFydEVuZFsxXSkge1xyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgc2VudGVuY2VcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRGcm9tID49IHN0YXJ0RW5kWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNyb3NzU2VudGVuY2UgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNyb3NzU2VudGVuY2UpIHtcclxuICAgICAgICAgICAgICAvLyBhdHRlbXB0IHRvIGFubm90YXRlIGFjcm9zcyBzZW50ZW5jZSBib3VuZGFyaWVzOyBub3Qgc3VwcG9ydGVkXHJcbiAgICAgICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdtZXNzYWdlcycsIFtbWydFcnJvcjogY2Fubm90IGFubm90YXRlIGFjcm9zcyBhIHNlbnRlbmNlIGJyZWFrJywgJ2Vycm9yJ11dXSk7XHJcbiAgICAgICAgICAgICAgaWYgKHJlc2VsZWN0ZWRTcGFuKSB7XHJcbiAgICAgICAgICAgICAgICAkKHJlc2VsZWN0ZWRTcGFuLnJlY3QpLnJlbW92ZUNsYXNzKCdyZXNlbGVjdCcpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICByZXNlbGVjdGVkU3BhbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgc3ZnRWxlbWVudC5yZW1vdmVDbGFzcygncmVzZWxlY3QnKTtcclxuICAgICAgICAgICAgfSBlbHNlXHJcbiovXHJcbiAgICAgICAgICAgIGlmICghQ29uZmlndXJhdGlvbi5yYXBpZE1vZGVPbiB8fCByZXNlbGVjdGVkU3BhbiAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgLy8gbm9ybWFsIHNwYW4gc2VsZWN0IGluIHN0YW5kYXJkIGFubm90YXRpb24gbW9kZVxyXG4gICAgICAgICAgICAgIC8vIG9yIHJlc2VsZWN0OiBzaG93IHNlbGVjdG9yXHJcbiAgICAgICAgICAgICAgdmFyIHNwYW5UZXh0ID0gZGF0YS50ZXh0LnN1YnN0cmluZyhzZWxlY3RlZEZyb20sIHNlbGVjdGVkVG8pO1xyXG4gICAgICAgICAgICAgIGZpbGxTcGFuVHlwZXNBbmREaXNwbGF5Rm9ybShldnQsIHNwYW5UZXh0LCByZXNlbGVjdGVkU3Bhbik7XHJcbiAgICAgICAgICAgICAgLy8gZm9yIHByZWNpc2UgdGltaW5nLCBsb2cgYW5ub3RhdGlvbiBkaXNwbGF5IHRvIHVzZXIuXHJcbiAgICAgICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdsb2dBY3Rpb24nLCBbJ3NwYW5TZWxlY3RlZCddKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAvLyBub3JtYWwgc3BhbiBzZWxlY3QgaW4gcmFwaWQgYW5ub3RhdGlvbiBtb2RlOiBjYWxsXHJcbiAgICAgICAgICAgICAgLy8gc2VydmVyIGZvciBzcGFuIHR5cGUgY2FuZGlkYXRlc1xyXG4gICAgICAgICAgICAgIHZhciBzcGFuVGV4dCA9IGRhdGEudGV4dC5zdWJzdHJpbmcoc2VsZWN0ZWRGcm9tLCBzZWxlY3RlZFRvKTtcclxuICAgICAgICAgICAgICAvLyBUT0RPOiB3ZSdyZSBjdXJyZW50bHkgc3RvcmluZyB0aGUgZXZlbnQgdG8gcG9zaXRpb24gdGhlXHJcbiAgICAgICAgICAgICAgLy8gc3BhbiBmb3JtIHVzaW5nIGFkanVzdFRvQ3Vyc29yKCkgKHdoaWNoIHRha2VzIGFuIGV2ZW50KSxcclxuICAgICAgICAgICAgICAvLyBidXQgdGhpcyBpcyBjbHVtc3kgYW5kIHN1Ym9wdGltYWwgKHVzZXIgbWF5IGhhdmUgc2Nyb2xsZWRcclxuICAgICAgICAgICAgICAvLyBkdXJpbmcgdGhlIGFqYXggaW52b2NhdGlvbik7IHRoaW5rIG9mIGEgYmV0dGVyIHdheS5cclxuICAgICAgICAgICAgICBsYXN0UmFwaWRBbm5vdGF0aW9uRXZlbnQgPSBldnQ7XHJcbiAgICAgICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdhamF4JywgWyB7IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICdzdWdnZXN0U3BhblR5cGVzJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbjogY29sbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RvY3VtZW50JzogZG9jLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc2VsZWN0ZWRGcm9tLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHNlbGVjdGVkVG8sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHNwYW5UZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbDogJCgnI3JhcGlkX21vZGVsJykudmFsKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sICdzdWdnZXN0ZWRTcGFuVHlwZXMnXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgcmVjZWl2ZWRTdWdnZXN0ZWRTcGFuVHlwZXMgPSBmdW5jdGlvbihzdWdnKSB7XHJcbiAgICAgICAgaWYgKHN1Z2cuZXhjZXB0aW9uKSB7XHJcbiAgICAgICAgICAvLyBmYWlsZWQgaW4gb25lIHdheSBvciBhbm90aGVyOyBhc3N1bWUgcmFwaWQgbW9kZSBjYW5ub3QgYmVcclxuICAgICAgICAgIC8vIHVzZWQuXHJcbiAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ21lc3NhZ2VzJywgW1tbJ1JhcGlkIGFubm90YXRpb24gbW9kZSBlcnJvcjsgcmV0dXJuaW5nIHRvIG5vcm1hbCBtb2RlLicsICd3YXJuaW5nJywgLTFdXV0pO1xyXG4gICAgICAgICAgc2V0QW5ub3RhdGlvblNwZWVkKDIpO1xyXG4gICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdjb25maWd1cmF0aW9uVXBkYXRlZCcpO1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBzdWdnZXN0aW9ucyBhcmUgZm9yIHRoZSBjdXJyZW50IGNvbGxlY3Rpb24gYW5kIGRvY3VtZW50XHJcbiAgICAgICAgaWYgKHN1Z2cuY29sbGVjdGlvbiAhPSBjb2xsIHx8IHN1Z2cuZG9jdW1lbnQgIT0gZG9jKSB7XHJcbiAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ21lc3NhZ2VzJywgW1tbJ0Vycm9yOiBjb2xsZWN0aW9uL2RvY3VtZW50IG1pc21hdGNoIGZvciBzcGFuIHN1Z2dlc3Rpb25zJywgJ2Vycm9yJ11dXSk7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGluaXRpYWxpemUgZm9yIHN1Ym1pc3Npb25cclxuICAgICAgICAvLyBUT0RPOiBpcyB0aGlzIGEgcmVhc29uYWJsZSBwbGFjZSB0byBkbyB0aGlzP1xyXG4gICAgICAgIHJhcGlkU3Bhbk9wdGlvbnMgPSB7XHJcbiAgICAgICAgICBvZmZzZXRzOiBbW3N1Z2cuc3RhcnQsIHN1Z2cuZW5kXV0sXHJcbiAgICAgICAgfTtcclxuICAgICAgICByYXBpZEZpbGxTcGFuVHlwZXNBbmREaXNwbGF5Rm9ybShzdWdnLnN0YXJ0LCBzdWdnLmVuZCwgc3VnZy50ZXh0LCBzdWdnLnR5cGVzKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciB0b2dnbGVDb2xsYXBzaWJsZSA9IGZ1bmN0aW9uKCRlbCwgc3RhdGUpIHtcclxuICAgICAgICB2YXIgb3BlbmluZyA9IHN0YXRlICE9PSB1bmRlZmluZWQgPyBzdGF0ZSA6ICEkZWwuaGFzQ2xhc3MoJ29wZW4nKTtcclxuICAgICAgICB2YXIgJGNvbGxhcHNpYmxlID0gJGVsLnBhcmVudCgpLmZpbmQoJy5jb2xsYXBzaWJsZTpmaXJzdCcpO1xyXG4gICAgICAgIGlmIChvcGVuaW5nKSB7XHJcbiAgICAgICAgICAkY29sbGFwc2libGUuYWRkQ2xhc3MoJ29wZW4nKTtcclxuICAgICAgICAgICRlbC5hZGRDbGFzcygnb3BlbicpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAkY29sbGFwc2libGUucmVtb3ZlQ2xhc3MoJ29wZW4nKTtcclxuICAgICAgICAgICRlbC5yZW1vdmVDbGFzcygnb3BlbicpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciBjb2xsYXBzZUhhbmRsZXIgPSBmdW5jdGlvbihldnQpIHtcclxuICAgICAgICB0b2dnbGVDb2xsYXBzaWJsZSgkKGV2dC50YXJnZXQpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHNwYW5Gb3JtU3VibWl0UmFkaW8gPSBmdW5jdGlvbihldnQpIHtcclxuICAgICAgICBpZiAoQ29uZmlndXJhdGlvbi5jb25maXJtTW9kZU9uKSB7XHJcbiAgICAgICAgICBzaG93VmFsaWRBdHRyaWJ1dGVzKCk7XHJcbiAgICAgICAgICBzaG93VmFsaWROb3JtYWxpemF0aW9ucygpO1xyXG4gICAgICAgICAgJCgnI3NwYW5fZm9ybS1vaycpLmZvY3VzKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHNwYW5Gb3JtU3VibWl0KGV2dCwgJChldnQudGFyZ2V0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgcmFwaWRTcGFuRm9ybVN1Ym1pdFJhZGlvID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgcmFwaWRTcGFuRm9ybVN1Ym1pdChldnQsICQoZXZ0LnRhcmdldCkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgcmVtZW1iZXJEYXRhID0gZnVuY3Rpb24oX2RhdGEpIHtcclxuICAgICAgICBpZiAoX2RhdGEgJiYgIV9kYXRhLmV4Y2VwdGlvbikge1xyXG4gICAgICAgICAgZGF0YSA9IF9kYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciBhZGRTcGFuVHlwZXNUb0RpdklubmVyID0gZnVuY3Rpb24oJHBhcmVudCwgdHlwZXMsIGNhdGVnb3J5KSB7XHJcbiAgICAgICAgaWYgKCF0eXBlcykgcmV0dXJuO1xyXG5cclxuICAgICAgICAkLmVhY2godHlwZXMsIGZ1bmN0aW9uKHR5cGVObywgdHlwZSkge1xyXG4gICAgICAgICAgaWYgKHR5cGUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgJHBhcmVudC5hcHBlbmQoJzxoci8+Jyk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbmFtZSA9IHR5cGUubmFtZTtcclxuICAgICAgICAgICAgdmFyICRpbnB1dCA9ICQoJzxpbnB1dCB0eXBlPVwicmFkaW9cIiBuYW1lPVwic3Bhbl90eXBlXCIvPicpLlxyXG4gICAgICAgICAgICAgIGF0dHIoJ2lkJywgJ3NwYW5fJyArIHR5cGUudHlwZSkuXHJcbiAgICAgICAgICAgICAgYXR0cigndmFsdWUnLCB0eXBlLnR5cGUpO1xyXG4gICAgICAgICAgICBpZiAoY2F0ZWdvcnkpIHtcclxuICAgICAgICAgICAgICAkaW5wdXQuYXR0cignY2F0ZWdvcnknLCBjYXRlZ29yeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdXNlIGEgbGlnaHQgdmVyc2lvbiBvZiB0aGUgc3BhbiBjb2xvciBhcyBCR1xyXG4gICAgICAgICAgICB2YXIgc3BhbkJnQ29sb3IgPSBzcGFuVHlwZXNbdHlwZS50eXBlXSAmJiBzcGFuVHlwZXNbdHlwZS50eXBlXS5iZ0NvbG9yIHx8ICcjZmZmZmZmJztcclxuICAgICAgICAgICAgc3BhbkJnQ29sb3IgPSBVdGlsLmFkanVzdENvbG9yTGlnaHRuZXNzKHNwYW5CZ0NvbG9yLCBzcGFuQm94VGV4dEJnQ29sb3JMaWdodGVuKTtcclxuICAgICAgICAgICAgdmFyICRsYWJlbCA9ICQoJzxsYWJlbCBjbGFzcz1cInNwYW5fdHlwZV9sYWJlbFwiLz4nKS5cclxuICAgICAgICAgICAgICBhdHRyKCdmb3InLCAnc3Bhbl8nICsgdHlwZS50eXBlKS5cclxuICAgICAgICAgICAgICB0ZXh0KG5hbWUpO1xyXG4gICAgICAgICAgICBpZiAodHlwZS51bnVzZWQpIHtcclxuICAgICAgICAgICAgICAkaW5wdXQuYXR0cih7XHJcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogJ2Rpc2FibGVkJyxcclxuICAgICAgICAgICAgICAgIHVudXNlZDogJ3VudXNlZCdcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAkbGFiZWwuY3NzKCdmb250LXdlaWdodCcsICdib2xkJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgJGxhYmVsLmNzcygnYmFja2dyb3VuZC1jb2xvcicsIHNwYW5CZ0NvbG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgJGNvbGxhcHNpYmxlID0gJCgnPGRpdiBjbGFzcz1cImNvbGxhcHNpYmxlIG9wZW5cIi8+Jyk7XHJcbiAgICAgICAgICAgIHZhciAkY29udGVudCA9ICQoJzxkaXYgY2xhc3M9XCJpdGVtX2NvbnRlbnRcIi8+JykuXHJcbiAgICAgICAgICAgICAgYXBwZW5kKCRpbnB1dCkuXHJcbiAgICAgICAgICAgICAgYXBwZW5kKCRsYWJlbCkuXHJcbiAgICAgICAgICAgICAgYXBwZW5kKCRjb2xsYXBzaWJsZSk7XHJcbiAgICAgICAgICAgIHZhciAkY29sbGFwc2VyID0gJCgnPGRpdiBjbGFzcz1cImNvbGxhcHNlciBvcGVuXCIvPicpO1xyXG4gICAgICAgICAgICB2YXIgJGRpdiA9ICQoJzxkaXYgY2xhc3M9XCJpdGVtXCIvPicpO1xyXG4gICAgICAgICAgICBpZiAodHlwZS5jaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAkZGl2LmFwcGVuZCgkY29sbGFwc2VyKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICRkaXYuYXBwZW5kKCRjb250ZW50KTtcclxuICAgICAgICAgICAgYWRkU3BhblR5cGVzVG9EaXZJbm5lcigkY29sbGFwc2libGUsIHR5cGUuY2hpbGRyZW4sIGNhdGVnb3J5KTtcclxuICAgICAgICAgICAgJHBhcmVudC5hcHBlbmQoJGRpdik7XHJcbiAgICAgICAgICAgIGlmICh0eXBlLmhvdGtleSkge1xyXG4gICAgICAgICAgICAgIHNwYW5LZXltYXBbdHlwZS5ob3RrZXldID0gJ3NwYW5fJyArIHR5cGUudHlwZTtcclxuICAgICAgICAgICAgICB2YXIgbmFtZSA9ICRsYWJlbC5odG1sKCk7XHJcbiAgICAgICAgICAgICAgdmFyIHJlcGxhY2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobmV3IFJlZ0V4cChcIigmW147XSo/KT8oXCIgKyB0eXBlLmhvdGtleSArIFwiKVwiLCAnZ2knKSxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGFsbCwgZW50aXR5LCBsZXR0ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgaWYgKHJlcGxhY2UgJiYgIWVudGl0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2UgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaG90a2V5ID0gdHlwZS5ob3RrZXkudG9Mb3dlckNhc2UoKSA9PSBsZXR0ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0eXBlLmhvdGtleS50b0xvd2VyQ2FzZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdHlwZS5ob3RrZXkudG9VcHBlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzxzcGFuIGNsYXNzPVwiYWNjZXNza2V5XCI+JyArIFV0aWwuZXNjYXBlSFRNTChob3RrZXkpICsgJzwvc3Bhbj4nO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBhbGw7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAkbGFiZWwuaHRtbChuYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9O1xyXG4gICAgICB2YXIgYWRkU3BhblR5cGVzVG9EaXYgPSBmdW5jdGlvbigkdG9wLCB0eXBlcywgaGVhZGluZykge1xyXG4gICAgICAgICRzY3JvbGxlciA9ICQoJzxkaXYgY2xhc3M9XCJzY3JvbGxlclwiLz4nKTtcclxuICAgICAgICAkbGVnZW5kID0gJCgnPGxlZ2VuZC8+JykudGV4dChoZWFkaW5nKTtcclxuICAgICAgICAkZmllbGRzZXQgPSAkKCc8ZmllbGRzZXQvPicpLmFwcGVuZCgkbGVnZW5kKS5hcHBlbmQoJHNjcm9sbGVyKTtcclxuICAgICAgICAkdG9wLmFwcGVuZCgkZmllbGRzZXQpO1xyXG4gICAgICAgIGFkZFNwYW5UeXBlc1RvRGl2SW5uZXIoJHNjcm9sbGVyLCB0eXBlcyk7XHJcbiAgICAgIH07XHJcbiAgICAgIHZhciBhZGRBdHRyaWJ1dGVUeXBlc1RvRGl2ID0gZnVuY3Rpb24oJHRvcCwgdHlwZXMsIGNhdGVnb3J5KSB7XHJcbiAgICAgICAgJC5lYWNoKHR5cGVzLCBmdW5jdGlvbihhdHRyTm8sIGF0dHIpIHtcclxuICAgICAgICAgIHZhciBlc2NhcGVkVHlwZSA9IFV0aWwuZXNjYXBlUXVvdGVzKGF0dHIudHlwZSk7XHJcbiAgICAgICAgICB2YXIgYXR0cklkID0gY2F0ZWdvcnkrJ19hdHRyXycrZXNjYXBlZFR5cGU7XHJcbiAgICAgICAgICBpZiAoYXR0ci51bnVzZWQpIHtcclxuICAgICAgICAgICAgdmFyICRpbnB1dCA9ICQoJzxpbnB1dCB0eXBlPVwiaGlkZGVuXCIgaWQ9XCInK2F0dHJJZCsnXCIgdmFsdWU9XCJcIi8+Jyk7XHJcbiAgICAgICAgICAgICR0b3AuYXBwZW5kKCRpbnB1dCk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGF0dHIuYm9vbCkge1xyXG4gICAgICAgICAgICB2YXIgZXNjYXBlZE5hbWUgPSBVdGlsLmVzY2FwZVF1b3RlcyhhdHRyLm5hbWUpO1xyXG4gICAgICAgICAgICB2YXIgJGlucHV0ID0gJCgnPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGlkPVwiJythdHRySWQrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICdcIiB2YWx1ZT1cIicgKyBlc2NhcGVkVHlwZSArIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAnXCIgY2F0ZWdvcnk9XCInICsgY2F0ZWdvcnkgKyAnXCIvPicpO1xyXG4gICAgICAgICAgICB2YXIgJGxhYmVsID0gJCgnPGxhYmVsIGNsYXNzPVwiYXR0cmlidXRlX3R5cGVfbGFiZWxcIiBmb3I9XCInK2F0dHJJZCtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1wiIGRhdGEtYmFyZT1cIicgKyBlc2NhcGVkTmFtZSArICdcIj4mI3gyNjEwOyAnICsgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZWROYW1lICsgJzwvbGFiZWw+Jyk7XHJcbiAgICAgICAgICAgICR0b3AuYXBwZW5kKCRpbnB1dCkuYXBwZW5kKCRsYWJlbCk7XHJcbiAgICAgICAgICAgICRpbnB1dC5idXR0b24oKTtcclxuICAgICAgICAgICAgJGlucHV0LmNoYW5nZShvbkJvb2xlYW5BdHRyQ2hhbmdlKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciAkZGl2ID0gJCgnPGRpdiBjbGFzcz1cInVpLWJ1dHRvbiB1aS1idXR0b24tdGV4dC1vbmx5IGF0dHJpYnV0ZV90eXBlX2xhYmVsXCIvPicpO1xyXG4gICAgICAgICAgICB2YXIgJHNlbGVjdCA9ICQoJzxzZWxlY3QgaWQ9XCInK2F0dHJJZCsnXCIgY2xhc3M9XCJ1aS13aWRnZXQgdWktc3RhdGUtZGVmYXVsdCB1aS1idXR0b24tdGV4dFwiIGNhdGVnb3J5PVwiJyArIGNhdGVnb3J5ICsgJ1wiLz4nKTtcclxuICAgICAgICAgICAgdmFyICRvcHRpb24gPSAkKCc8b3B0aW9uIGNsYXNzPVwidWktc3RhdGUtZGVmYXVsdFwiIHZhbHVlPVwiXCIvPicpLnRleHQoYXR0ci5uYW1lICsgJzogPycpO1xyXG4gICAgICAgICAgICAkc2VsZWN0LmFwcGVuZCgkb3B0aW9uKTtcclxuICAgICAgICAgICAgJC5lYWNoKGF0dHIudmFsdWVzLCBmdW5jdGlvbih2YWxUeXBlLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICRvcHRpb24gPSAkKCc8b3B0aW9uIGNsYXNzPVwidWktc3RhdGUtYWN0aXZlXCIgdmFsdWU9XCInICsgVXRpbC5lc2NhcGVRdW90ZXModmFsVHlwZSkgKyAnXCIvPicpLnRleHQoYXR0ci5uYW1lICsgJzogJyArICh2YWx1ZS5uYW1lIHx8IHZhbFR5cGUpKTtcclxuICAgICAgICAgICAgICAkc2VsZWN0LmFwcGVuZCgkb3B0aW9uKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICRkaXYuYXBwZW5kKCRzZWxlY3QpO1xyXG4gICAgICAgICAgICAkdG9wLmFwcGVuZCgkZGl2KTtcclxuICAgICAgICAgICAgJHNlbGVjdC5jaGFuZ2Uob25NdWx0aUF0dHJDaGFuZ2UpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgc2V0U3BhblR5cGVTZWxlY3RhYmlsaXR5ID0gZnVuY3Rpb24oY2F0ZWdvcnkpIHtcclxuICAgICAgICAvLyBUT0RPOiB0aGlzIGltcGxlbWVudGF0aW9uIGlzIGluY29tcGxldGU6IHdlIHNob3VsZCBpZGVhbGx5XHJcbiAgICAgICAgLy8gZGlzYWJsZSBub3Qgb25seSBjYXRlZ29yaWVzIG9mIHR5cGVzIChldmVudHMgb3IgZW50aXRpZXMpLFxyXG4gICAgICAgIC8vIGJ1dCB0aGUgc3BlY2lmaWMgc2V0IG9mIHR5cGVzIHRoYXQgYXJlIGluY29tcGF0aWJsZSB3aXRoXHJcbiAgICAgICAgLy8gdGhlIGN1cnJlbnQgYXR0cmlidXRlIHNldHRpbmdzLlxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIGp1c3QgYXNzdW1lIGFsbCBhdHRyaWJ1dGVzIGFyZSBldmVudCBhdHRyaWJ1dGVzXHJcbiAgICAgICAgLy8gVE9ETzogc3VwcG9ydCBmb3IgZW50aXR5IGF0dHJpYnV0ZXNcclxuICAgICAgICAvLyBUT0RPMjogdGhlIGFib3ZlIGNvbW1lbnQgaXMgYWxtb3N0IGNlcnRhaW5seSBmYWxzZSwgY2hlY2sgYW5kIHJlbW92ZVxyXG4gICAgICAgICQoJyNzcGFuX2Zvcm0gaW5wdXQ6bm90KFt1bnVzZWRdKScpLnJlbW92ZUF0dHIoJ2Rpc2FibGVkJyk7XHJcbiAgICAgICAgdmFyICR0b0Rpc2FibGU7XHJcbiAgICAgICAgaWYgKGNhdGVnb3J5ID09IFwiZXZlbnRcIikge1xyXG4gICAgICAgICAgJHRvRGlzYWJsZSA9ICQoJyNzcGFuX2Zvcm0gaW5wdXRbY2F0ZWdvcnk9XCJlbnRpdHlcIl0nKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGNhdGVnb3J5ID09IFwiZW50aXR5XCIpIHtcclxuICAgICAgICAgICR0b0Rpc2FibGUgPSAkKCcjc3Bhbl9mb3JtIGlucHV0W2NhdGVnb3J5PVwiZXZlbnRcIl0nKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5yZWNvZ25pemVkIGF0dHJpYnV0ZSBjYXRlZ29yeTonLCBjYXRlZ29yeSk7XHJcbiAgICAgICAgICAkdG9EaXNhYmxlID0gJCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgJGNoZWNrZWRUb0Rpc2FibGUgPSAkdG9EaXNhYmxlLmZpbHRlcignOmNoZWNrZWQnKTtcclxuICAgICAgICAkdG9EaXNhYmxlLmF0dHIoJ2Rpc2FibGVkJywgdHJ1ZSk7XHJcbiAgICAgICAgLy8gdGhlIGRpc2FibGUgbWF5IGxlYXZlIHRoZSBkaWFsb2cgaW4gYSBzdGF0ZSB3aGVyZSBub3RoaW5nXHJcbiAgICAgICAgLy8gaXMgY2hlY2tlZCwgd2hpY2ggd291bGQgY2F1c2UgZXJyb3Igb24gXCJPS1wiLiBJbiB0aGlzIGNhc2UsXHJcbiAgICAgICAgLy8gY2hlY2sgdGhlIGZpcnN0IHZhbGlkIGNob2ljZS5cclxuICAgICAgICBpZiAoJGNoZWNrZWRUb0Rpc2FibGUubGVuZ3RoKSB7XHJcbiAgICAgICAgICB2YXIgJHRvQ2hlY2sgPSAkKCcjc3Bhbl9mb3JtIGlucHV0W2NhdGVnb3J5PVwiJyArIGNhdGVnb3J5ICsgJ1wiXTpmaXJzdCcpO1xyXG4gICAgICAgICAgLy8gc28gd2VpcmQsIGF0dHIoJ2NoZWNrZWQnLCAnY2hlY2tlZCcpIGZhaWxzIHNvbWV0aW1lcywgc29cclxuICAgICAgICAgIC8vIHJlcGxhY2VkIHdpdGggbW9yZSBcIm1ldGFsXCIgdmVyc2lvblxyXG4gICAgICAgICAgJHRvQ2hlY2tbMF0uY2hlY2tlZCA9IHRydWVcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBvbk11bHRpQXR0ckNoYW5nZSA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgIGlmICgkKHRoaXMpLnZhbCgpID09ICcnKSB7XHJcbiAgICAgICAgICAkKCcjc3Bhbl9mb3JtIGlucHV0Om5vdChbdW51c2VkXSknKS5yZW1vdmVBdHRyKCdkaXNhYmxlZCcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB2YXIgYXR0ckNhdGVnb3J5ID0gZXZ0LnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2NhdGVnb3J5Jyk7XHJcbiAgICAgICAgICBzZXRTcGFuVHlwZVNlbGVjdGFiaWxpdHkoYXR0ckNhdGVnb3J5KTtcclxuICAgICAgICAgIGlmIChldnQudGFyZ2V0LnNlbGVjdGVkSW5kZXgpIHtcclxuICAgICAgICAgICAgJChldnQudGFyZ2V0KS5hZGRDbGFzcygndWktc3RhdGUtYWN0aXZlJyk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAkKGV2dC50YXJnZXQpLnJlbW92ZUNsYXNzKCd1aS1zdGF0ZS1hY3RpdmUnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBvbkJvb2xlYW5BdHRyQ2hhbmdlID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgdmFyIGF0dHJDYXRlZ29yeSA9IGV2dC50YXJnZXQuZ2V0QXR0cmlidXRlKCdjYXRlZ29yeScpO1xyXG4gICAgICAgIHNldFNwYW5UeXBlU2VsZWN0YWJpbGl0eShhdHRyQ2F0ZWdvcnkpO1xyXG4gICAgICAgIHVwZGF0ZUNoZWNrYm94KCQoZXZ0LnRhcmdldCkpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdmFyIHJlbWVtYmVyU3BhblNldHRpbmdzID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcclxuICAgICAgICBzcGFuS2V5bWFwID0ge307XHJcblxyXG4gICAgICAgIC8vIFRPRE86IGNoZWNrIGZvciBleGNlcHRpb25zIGluIHJlc3BvbnNlXHJcblxyXG4gICAgICAgIC8vIGZpbGwgaW4gZW50aXR5IGFuZCBldmVudCB0eXBlc1xyXG4gICAgICAgIHZhciAkZW50aXR5U2Nyb2xsZXIgPSAkKCcjZW50aXR5X3R5cGVzIGRpdi5zY3JvbGxlcicpLmVtcHR5KCk7XHJcbiAgICAgICAgYWRkU3BhblR5cGVzVG9EaXZJbm5lcigkZW50aXR5U2Nyb2xsZXIsIHJlc3BvbnNlLmVudGl0eV90eXBlcywgJ2VudGl0eScpO1xyXG4gICAgICAgIHZhciAkZXZlbnRTY3JvbGxlciA9ICQoJyNldmVudF90eXBlcyBkaXYuc2Nyb2xsZXInKS5lbXB0eSgpO1xyXG4gICAgICAgIGFkZFNwYW5UeXBlc1RvRGl2SW5uZXIoJGV2ZW50U2Nyb2xsZXIsIHJlc3BvbnNlLmV2ZW50X3R5cGVzLCAnZXZlbnQnKTtcclxuXHJcbiAgICAgICAgLy8gZmlsbCBpbiBhdHRyaWJ1dGVzXHJcbiAgICAgICAgdmFyICRlbnRhdHRycyA9ICQoJyNlbnRpdHlfYXR0cmlidXRlcyBkaXYuc2Nyb2xsZXInKS5lbXB0eSgpO1xyXG4gICAgICAgIGFkZEF0dHJpYnV0ZVR5cGVzVG9EaXYoJGVudGF0dHJzLCBlbnRpdHlBdHRyaWJ1dGVUeXBlcywgJ2VudGl0eScpO1xyXG5cclxuICAgICAgICB2YXIgJGV2ZWF0dHJzID0gJCgnI2V2ZW50X2F0dHJpYnV0ZXMgZGl2LnNjcm9sbGVyJykuZW1wdHkoKTtcclxuICAgICAgICBhZGRBdHRyaWJ1dGVUeXBlc1RvRGl2KCRldmVhdHRycywgZXZlbnRBdHRyaWJ1dGVUeXBlcywgJ2V2ZW50Jyk7XHJcblxyXG4gICAgICAgIC8vIGZpbGwgc2VhcmNoIG9wdGlvbnMgaW4gc3BhbiBkaWFsb2dcclxuICAgICAgICBzZWFyY2hDb25maWcgPSByZXNwb25zZS5zZWFyY2hfY29uZmlnO1xyXG4gICAgICAgIHZhciAkc2VhcmNobGlua3MgID0gJCgnI3NwYW5fc2VhcmNoX2xpbmtzJykuZW1wdHkoKTtcclxuICAgICAgICB2YXIgJHNlYXJjaGxpbmtzMiA9ICQoJyN2aWV3c3Bhbl9zZWFyY2hfbGlua3MnKS5lbXB0eSgpO1xyXG4gICAgICAgIHZhciBmaXJzdExpbms9dHJ1ZTtcclxuICAgICAgICB2YXIgbGlua0ZpbGxlZD1mYWxzZTtcclxuICAgICAgICBpZiAoc2VhcmNoQ29uZmlnKSB7XHJcbiAgICAgICAgICAkLmVhY2goc2VhcmNoQ29uZmlnLCBmdW5jdGlvbihzZWFyY2hObywgc2VhcmNoKSB7XHJcbiAgICAgICAgICAgIGlmICghZmlyc3RMaW5rKSB7XHJcbiAgICAgICAgICAgICAgJHNlYXJjaGxpbmtzLmFwcGVuZCgnLFxcbicpXHJcbiAgICAgICAgICAgICAgJHNlYXJjaGxpbmtzMi5hcHBlbmQoJyxcXG4nKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpcnN0TGluaz1mYWxzZTtcclxuICAgICAgICAgICAgJHNlYXJjaGxpbmtzLmFwcGVuZCgnPGEgdGFyZ2V0PVwiX2JsYW5rXCIgaWQ9XCJzcGFuXycrc2VhcmNoWzBdKydcIiBocmVmPVwiI1wiPicrc2VhcmNoWzBdKyc8L2E+Jyk7XHJcbiAgICAgICAgICAgICRzZWFyY2hsaW5rczIuYXBwZW5kKCc8YSB0YXJnZXQ9XCJfYmxhbmtcIiBpZD1cInZpZXdzcGFuXycrc2VhcmNoWzBdKydcIiBocmVmPVwiI1wiPicrc2VhcmNoWzBdKyc8L2E+Jyk7XHJcbiAgICAgICAgICAgIGxpbmtGaWxsZWQ9dHJ1ZTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGlua0ZpbGxlZCkge1xyXG4gICAgICAgICAgJCgnI3NwYW5fc2VhcmNoX2ZpZWxkc2V0Jykuc2hvdygpO1xyXG4gICAgICAgICAgJCgnI3ZpZXdzcGFuX3NlYXJjaF9maWVsZHNldCcpLnNob3coKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgJCgnI3NwYW5fc2VhcmNoX2ZpZWxkc2V0JykuaGlkZSgpO1xyXG4gICAgICAgICAgJCgnI3ZpZXdzcGFuX3NlYXJjaF9maWVsZHNldCcpLmhpZGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNwYW5Gb3JtLmZpbmQoJyNlbnRpdHlfdHlwZXMgaW5wdXQ6cmFkaW8nKS5jbGljayhzcGFuRm9ybVN1Ym1pdFJhZGlvKTtcclxuICAgICAgICBzcGFuRm9ybS5maW5kKCcjZXZlbnRfdHlwZXMgaW5wdXQ6cmFkaW8nKS5jbGljayhzcGFuRm9ybVN1Ym1pdFJhZGlvKTtcclxuICAgICAgICBzcGFuRm9ybS5maW5kKCcuY29sbGFwc2VyJykuY2xpY2soY29sbGFwc2VIYW5kbGVyKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciB0YWdDdXJyZW50RG9jdW1lbnQgPSBmdW5jdGlvbih0YWdnZXJJZCkge1xyXG4gICAgICAgIHZhciB0YWdPcHRpb25zID0ge1xyXG4gICAgICAgICAgYWN0aW9uOiAndGFnJyxcclxuICAgICAgICAgIGNvbGxlY3Rpb246IGNvbGwsXHJcbiAgICAgICAgICAnZG9jdW1lbnQnOiBkb2MsXHJcbiAgICAgICAgICB0YWdnZXI6IHRhZ2dlcklkLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdhamF4JywgW3RhZ09wdGlvbnMsICdlZGl0ZWQnXSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBzZXR1cFRhZ2dlclVJID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcclxuICAgICAgICB2YXIgdGFnZ2VycyA9IHJlc3BvbnNlLm5lcl90YWdnZXJzIHx8IFtdO1xyXG4gICAgICAgICR0YWdnZXJCdXR0b25zID0gJCgnI3RhZ2dlcl9idXR0b25zJykuZW1wdHkoKTtcclxuICAgICAgICAkLmVhY2godGFnZ2VycywgZnVuY3Rpb24odGFnZ2VyTm8sIHRhZ2dlcikge1xyXG4gICAgICAgICAgLy8gZXhwZWN0IGEgdHVwbGUgd2l0aCBJRCwgbmFtZSwgbW9kZWwsIGFuZCBVUkxcclxuICAgICAgICAgIHZhciB0YWdnZXJJZCA9IHRhZ2dlclswXTtcclxuICAgICAgICAgIHZhciB0YWdnZXJOYW1lID0gdGFnZ2VyWzFdO1xyXG4gICAgICAgICAgdmFyIHRhZ2dlck1vZGVsID0gdGFnZ2VyWzJdO1xyXG4gICAgICAgICAgaWYgKCF0YWdnZXJJZCB8fCAhdGFnZ2VyTmFtZSB8fCAhdGFnZ2VyTW9kZWwpIHtcclxuICAgICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdtZXNzYWdlcycsIFtbWydJbnZhbGlkIHRhZ2dlciBzcGVjaWZpY2F0aW9uIHJlY2VpdmVkIGZyb20gc2VydmVyJywgJ2Vycm9yJ11dXSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBjb250aW51ZVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdmFyICRyb3cgPSAkKCc8ZGl2IGNsYXNzPVwib3B0aW9uUm93XCIvPicpO1xyXG4gICAgICAgICAgdmFyICRsYWJlbCA9ICQoJzxzcGFuIGNsYXNzPVwib3B0aW9uTGFiZWxcIj4nK1V0aWwuZXNjYXBlSFRNTCh0YWdnZXJOYW1lKSsnPC9zcGFuPicpO1xyXG4gICAgICAgICAgdmFyICRidXR0b24gPSAkKCc8aW5wdXQgaWQ9XCJ0YWdfJytVdGlsLmVzY2FwZUhUTUwodGFnZ2VySWQpKydfYnV0dG9uXCIgdHlwZT1cImJ1dHRvblwiIHZhbHVlPVwiJytVdGlsLmVzY2FwZUhUTUwodGFnZ2VyTW9kZWwpKydcIiB0YWJpbmRleD1cIi0xXCIgdGl0bGU9XCJBdXRvbWF0aWNhbGx5IHRhZyB0aGUgY3VycmVudCBkb2N1bWVudC5cIi8+Jyk7XHJcbiAgICAgICAgICAkcm93LmFwcGVuZCgkbGFiZWwpLmFwcGVuZCgkYnV0dG9uKTtcclxuICAgICAgICAgICR0YWdnZXJCdXR0b25zLmFwcGVuZCgkcm93KTtcclxuICAgICAgICAgICRidXR0b24uY2xpY2soZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgICAgIHRhZ0N1cnJlbnREb2N1bWVudCh0YWdnZXJJZCk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAkdGFnZ2VyQnV0dG9ucy5maW5kKCdpbnB1dCcpLmJ1dHRvbigpO1xyXG4gICAgICAgIC8vIGlmIG5vdGhpbmcgd2FzIHNldCB1cCwgaGlkZSB0aGUgd2hvbGUgZmllbGRzZXQgYW5kIHNob3dcclxuICAgICAgICAvLyBhIG1lc3NhZ2UgdG8gdGhpcyBlZmZlY3QsIGVsc2UgdGhlIG90aGVyIHdheSBhcm91bmRcclxuICAgICAgICBpZiAoJHRhZ2dlckJ1dHRvbnMuZmluZCgnaW5wdXQnKS5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgJCgnI2F1dG9fdGFnZ2luZ19maWVsZHNldCcpLmhpZGUoKTtcclxuICAgICAgICAgICQoJyNub190YWdnZXJfbWVzc2FnZScpLnNob3coKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgJCgnI2F1dG9fdGFnZ2luZ19maWVsZHNldCcpLnNob3coKTtcclxuICAgICAgICAgICQoJyNub190YWdnZXJfbWVzc2FnZScpLmhpZGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHJlY3Vyc2l2ZWx5IHRyYXZlcnNlcyB0eXBlIGhpZXJhcmNoeSAoZW50aXR5X3R5cGVzIG9yXHJcbiAgICAgIC8vIGV2ZW50X3R5cGVzKSBhbmQgc3RvcmVzIG5vcm1hbGl6YXRpb25zIGluIG5vcm1EYnNCeVR5cGUuXHJcbiAgICAgIHZhciByZW1lbWJlck5vcm1EYnNGb3JUeXBlID0gZnVuY3Rpb24odHlwZXMpIHtcclxuICAgICAgICBpZiAoIXR5cGVzKSByZXR1cm47XHJcblxyXG4gICAgICAgICQuZWFjaCh0eXBlcywgZnVuY3Rpb24odHlwZU5vLCB0eXBlKSB7XHJcbiAgICAgICAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBzcGFjZXIsIG5vLW9wXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBub3JtRGJzQnlUeXBlW3R5cGUudHlwZV0gPSB0eXBlLm5vcm1hbGl6YXRpb25zIHx8IFtdO1xyXG4gICAgICAgICAgICBpZiAodHlwZS5jaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICByZW1lbWJlck5vcm1EYnNGb3JUeXBlKHR5cGUuY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgc2V0dXBOb3JtYWxpemF0aW9uVUkgPSBmdW5jdGlvbihyZXNwb25zZSkge1xyXG4gICAgICAgIHZhciBub3JtX3Jlc291cmNlcyA9IHJlc3BvbnNlLm5vcm1hbGl6YXRpb25fY29uZmlnIHx8IFtdO1xyXG4gICAgICAgIHZhciAkbm9ybV9zZWxlY3QgPSAkKCcjc3Bhbl9ub3JtX2RiJyk7XHJcbiAgICAgICAgLy8gY2xlYXIgcG9zc2libGUgZXhpc3RpbmdcclxuICAgICAgICAkbm9ybV9zZWxlY3QuZW1wdHkoKTtcclxuICAgICAgICAvLyBmaWxsIGluIG5ld1xyXG4gICAgICAgIGh0bWwgPSBbXTtcclxuICAgICAgICAkLmVhY2gobm9ybV9yZXNvdXJjZXMsIGZ1bmN0aW9uKG5vcm1Obywgbm9ybSkge1xyXG4gICAgICAgICAgdmFyIG5vcm1OYW1lID0gbm9ybVswXSwgbm9ybVVybCA9IG5vcm1bMV0sIG5vcm1VcmxCYXNlID0gbm9ybVsyXTtcclxuICAgICAgICAgIHZhciBzZXJ2ZXJEYiA9IG5vcm1bM107XHJcbiAgICAgICAgICBodG1sLnB1c2goJzxvcHRpb24gdmFsdWU9XCInK1V0aWwuZXNjYXBlSFRNTChub3JtTmFtZSkrJ1wiPicrXHJcbiAgICAgICAgICAgICAgICAgICAgVXRpbC5lc2NhcGVIVE1MKG5vcm1OYW1lKSsnPC9vcHRpb24+Jyk7XHJcbiAgICAgICAgICAvLyByZW1lbWJlciB0aGUgdXJscyBmb3IgdXBkYXRlc1xyXG4gICAgICAgICAgbm9ybURiVXJsQnlEYk5hbWVbbm9ybU5hbWVdID0gbm9ybVVybDtcclxuICAgICAgICAgIG5vcm1EYlVybEJhc2VCeURiTmFtZVtub3JtTmFtZV0gPSBub3JtVXJsQmFzZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyByZW1lbWJlciBwZXItdHlwZSBhcHByb3ByaWF0ZSBEQnNcclxuICAgICAgICBub3JtRGJzQnlUeXBlID0ge307XHJcbiAgICAgICAgcmVtZW1iZXJOb3JtRGJzRm9yVHlwZShyZXNwb25zZS5lbnRpdHlfdHlwZXMpO1xyXG4gICAgICAgIHJlbWVtYmVyTm9ybURic0ZvclR5cGUocmVzcG9uc2UuZXZlbnRfdHlwZXMpO1xyXG4gICAgICAgIC8vIHNldCB1cCBIVE1MXHJcbiAgICAgICAgJG5vcm1fc2VsZWN0Lmh0bWwoaHRtbC5qb2luKCcnKSk7XHJcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBub3RoaW5nLCBqdXN0IGhpZGUgdGhlIHdob2xlIHRoaW5nXHJcbiAgICAgICAgaWYgKCFub3JtX3Jlc291cmNlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICQoJyNub3JtX2ZpZWxkc2V0JykuaGlkZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAkKCcjbm9ybV9maWVsZHNldCcpLnNob3coKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGhpZGVzIHRoZSByZWZlcmVuY2UgbGluayBpbiB0aGUgbm9ybWFsaXphdGlvbiBVSVxyXG4gICAgICB2YXIgaGlkZU5vcm1hbGl6YXRpb25SZWZMaW5rID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgJCgnI3NwYW5fbm9ybV9yZWZfbGluaycpLmhpZGUoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gdXBkYXRlcyB0aGUgcmVmZXJlbmNlIGxpbmsgaW4gdGhlIG5vcm1hbGl6YXRpb24gVUkgYWNjb3JkaW5nXHJcbiAgICAgIC8vIHRvIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBub3JtYWxpemF0aW9uIERCIGFuZCBJRC5cclxuICAgICAgdmFyIHVwZGF0ZU5vcm1hbGl6YXRpb25SZWZMaW5rID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyICRub3JtSWQgPSAkKCcjc3Bhbl9ub3JtX2lkJyk7XHJcbiAgICAgICAgdmFyICRub3JtTGluayA9ICQoJyNzcGFuX25vcm1fcmVmX2xpbmsnKTtcclxuICAgICAgICB2YXIgbm9ybUlkID0gJG5vcm1JZC52YWwoKTtcclxuICAgICAgICB2YXIgJG5vcm1EYiA9ICQoJyNzcGFuX25vcm1fZGInKTtcclxuICAgICAgICB2YXIgbm9ybURiID0gJG5vcm1EYi52YWwoKTtcclxuICAgICAgICBpZiAoIW5vcm1JZCB8fCAhbm9ybURiIHx8IG5vcm1JZC5tYXRjaCgvXlxccyokLykpIHtcclxuICAgICAgICAgICRub3JtTGluay5oaWRlKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHZhciBiYXNlID0gbm9ybURiVXJsQmFzZUJ5RGJOYW1lW25vcm1EYl07XHJcbiAgICAgICAgICAvLyBhc3N1bWUgaGlkZGVuIHVubGVzcyBldmVyeXRoaW5nIGdvZXMgdGhyb3VnaFxyXG4gICAgICAgICAgJG5vcm1MaW5rLmhpZGUoKTtcclxuICAgICAgICAgIGlmICghYmFzZSkge1xyXG4gICAgICAgICAgICAvLyBiYXNlIFVSTCBpcyBub3cgb3B0aW9uYWwsIGp1c3Qgc2tpcCBsaW5rIGdlbmVyYXRpb24gaWYgbm90IHNldFxyXG4gICAgICAgICAgICA7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGJhc2UuaW5kZXhPZignJXMnKSA9PSAtMSkge1xyXG4gICAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ21lc3NhZ2VzJywgW1tbJ0Jhc2UgVVJMIFwiJytiYXNlKydcIiBmb3IgJytub3JtRGIrJyBkb2VzIG5vdCBjb250YWluIFwiJXNcIicsICdlcnJvciddXV0pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVE9ETzogcHJvdGVjdCBhZ2FpbnN0IHN0cmFuZ2UgY2hhcnMgaW4gSURcclxuICAgICAgICAgICAgbGluayA9IGJhc2UucmVwbGFjZSgnJXMnLCBub3JtSWQpO1xyXG4gICAgICAgICAgICAkbm9ybUxpbmsuYXR0cignaHJlZicsIGxpbmspO1xyXG4gICAgICAgICAgICAkbm9ybUxpbmsuc2hvdygpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gdXBkYXRlcyB0aGUgREIgc2VhcmNoIGxpbmsgaW4gdGhlIG5vcm1hbGl6YXRpb24gVUkgYWNjb3JkaW5nXHJcbiAgICAgIC8vIHRvIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBub3JtYWxpemF0aW9uIERCLlxyXG4gICAgICB2YXIgdXBkYXRlTm9ybWFsaXphdGlvbkRiTGluayA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciAkZGJMaW5rID0gJCgnI3NwYW5fbm9ybV9kYl9saW5rJyk7XHJcbiAgICAgICAgdmFyICRub3JtRGIgPSAkKCcjc3Bhbl9ub3JtX2RiJyk7XHJcbiAgICAgICAgdmFyIG5vcm1EYiA9ICRub3JtRGIudmFsKCk7XHJcbiAgICAgICAgaWYgKCFub3JtRGIpIHJldHVybjsgLy8gbm8gbm9ybWFsaXNhdGlvbiBjb25maWd1cmVkXHJcbiAgICAgICAgdmFyIGxpbmsgPSBub3JtRGJVcmxCeURiTmFtZVtub3JtRGJdO1xyXG4gICAgICAgIGlmICghbGluayB8fCBsaW5rLm1hdGNoKC9eXFxzKiQvKSkge1xyXG4gICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdtZXNzYWdlcycsIFtbWydObyBVUkwgZm9yICcrbm9ybURiLCAnZXJyb3InXV1dKTtcclxuICAgICAgICAgICRkYkxpbmsuaGlkZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBUT0RPOiBwcm90ZWN0IGFnYWluc3Qgd2VpcmRuZXNzIGluIERCIGxpbmtcclxuICAgICAgICAgICRkYkxpbmsuYXR0cignaHJlZicsIGxpbmspO1xyXG4gICAgICAgICAgJGRiTGluay5zaG93KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyByZXNldHMgdXNlci1zZXR0YWJsZSBub3JtYWxpemF0aW9uLXJlbGF0ZWQgVUkgZWxlbWVudHMgdG8gYVxyXG4gICAgICAvLyBibGFuayBzdGF0ZSAoZG9lcyBub3QgYmxhbmsgI3NwYW5fbm9ybV9kYiA8c2VsZWN0PikuXHJcbiAgICAgIHZhciBjbGVhck5vcm1hbGl6YXRpb25VSSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciAkbm9ybUlkID0gJCgnI3NwYW5fbm9ybV9pZCcpO1xyXG4gICAgICAgIHZhciAkbm9ybVRleHQgPSAkKCcjc3Bhbl9ub3JtX3R4dCcpO1xyXG4gICAgICAgICRub3JtSWQudmFsKCcnKTtcclxuICAgICAgICBvbGRTcGFuTm9ybUlkVmFsdWUgPSAnJztcclxuICAgICAgICAkbm9ybUlkLnJlbW92ZUNsYXNzKCd2YWxpZF92YWx1ZScpLnJlbW92ZUNsYXNzKCdpbnZhbGlkX3ZhbHVlJyk7XHJcbiAgICAgICAgJG5vcm1UZXh0LnZhbCgnJyk7XHJcbiAgICAgICAgdXBkYXRlTm9ybWFsaXphdGlvblJlZkxpbmsoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gcmV0dXJucyB0aGUgbm9ybWFsaXphdGlvbnMgY3VycmVudGx5IGZpbGxlZCBpbiB0aGUgc3BhblxyXG4gICAgICAvLyBkaWFsb2csIG9yIGVtcHR5IGxpc3QgaWYgdGhlcmUgYXJlIG5vbmVcclxuICAgICAgdmFyIHNwYW5Ob3JtYWxpemF0aW9ucyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vIE5vdGUgdGhhdCBvbmx5IG5vIG9yIG9uZSBub3JtYWxpemF0aW9uIGlzIHN1cHBvcnRlZCBpbiB0aGVcclxuICAgICAgICAvLyBVSSBhdCB0aGUgbW9tZW50LlxyXG4gICAgICAgIHZhciBub3JtYWxpemF0aW9ucyA9IFtdO1xyXG4gICAgICAgIHZhciBub3JtRGIgPSAkKCcjc3Bhbl9ub3JtX2RiJykudmFsKCk7XHJcbiAgICAgICAgdmFyIG5vcm1JZCA9ICQoJyNzcGFuX25vcm1faWQnKS52YWwoKTtcclxuICAgICAgICB2YXIgbm9ybVRleHQgPSAkKCcjc3Bhbl9ub3JtX3R4dCcpLnZhbCgpO1xyXG4gICAgICAgIC8vIGVtcHR5IElEIC0+IG5vIG5vcm1hbGl6YXRpb25cclxuICAgICAgICBpZiAoIW5vcm1JZC5tYXRjaCgvXlxccyokLykpIHtcclxuICAgICAgICAgIG5vcm1hbGl6YXRpb25zLnB1c2goW25vcm1EYiwgbm9ybUlkLCBub3JtVGV4dF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9ybWFsaXphdGlvbnM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHJldHVybnMgYXR0cmlidXRlcyB0aGF0IGFyZSB2YWxpZCBmb3IgdGhlIHNlbGVjdGVkIHR5cGUgaW5cclxuICAgICAgLy8gdGhlIHNwYW4gZGlhbG9nXHJcbiAgICAgIHZhciBzcGFuQXR0cmlidXRlcyA9IGZ1bmN0aW9uKHR5cGVSYWRpbykge1xyXG4gICAgICAgIHR5cGVSYWRpbyA9IHR5cGVSYWRpbyB8fCAkKCcjc3Bhbl9mb3JtIGlucHV0OnJhZGlvOmNoZWNrZWQnKTtcclxuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHt9O1xyXG4gICAgICAgIHZhciBhdHRyaWJ1dGVUeXBlcztcclxuICAgICAgICB2YXIgY2F0ZWdvcnkgPSB0eXBlUmFkaW8uYXR0cignY2F0ZWdvcnknKTtcclxuICAgICAgICBpZiAoY2F0ZWdvcnkgPT0gJ2VudGl0eScpIHtcclxuICAgICAgICAgIGF0dHJpYnV0ZVR5cGVzID0gZW50aXR5QXR0cmlidXRlVHlwZXM7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjYXRlZ29yeSA9PSAnZXZlbnQnKSB7XHJcbiAgICAgICAgICBhdHRyaWJ1dGVUeXBlcyA9IGV2ZW50QXR0cmlidXRlVHlwZXM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VucmVjb2duaXplZCB0eXBlIGNhdGVnb3J5OicsIGNhdGVnb3J5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgJC5lYWNoKGF0dHJpYnV0ZVR5cGVzLCBmdW5jdGlvbihhdHRyTm8sIGF0dHIpIHtcclxuICAgICAgICAgIHZhciAkaW5wdXQgPSAkKCcjJytjYXRlZ29yeSsnX2F0dHJfJytVdGlsLmVzY2FwZVF1b3RlcyhhdHRyLnR5cGUpKTtcclxuICAgICAgICAgIGlmIChhdHRyLmJvb2wpIHtcclxuICAgICAgICAgICAgYXR0cmlidXRlc1thdHRyLnR5cGVdID0gJGlucHV0WzBdLmNoZWNrZWQ7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKCRpbnB1dFswXS5zZWxlY3RlZEluZGV4KSB7XHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNbYXR0ci50eXBlXSA9ICRpbnB1dC52YWwoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gYXR0cmlidXRlcztcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHNwYW5BbmRBdHRyaWJ1dGVUeXBlc0xvYWRlZCA9IGZ1bmN0aW9uKF9zcGFuVHlwZXMsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2VudGl0eUF0dHJpYnV0ZVR5cGVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2V2ZW50QXR0cmlidXRlVHlwZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVsYXRpb25UeXBlc0hhc2gpIHtcclxuICAgICAgICBzcGFuVHlwZXMgPSBfc3BhblR5cGVzO1xyXG4gICAgICAgIGVudGl0eUF0dHJpYnV0ZVR5cGVzID0gX2VudGl0eUF0dHJpYnV0ZVR5cGVzO1xyXG4gICAgICAgIGV2ZW50QXR0cmlidXRlVHlwZXMgPSBfZXZlbnRBdHRyaWJ1dGVUeXBlcztcclxuICAgICAgICByZWxhdGlvblR5cGVzSGFzaCA9IF9yZWxhdGlvblR5cGVzSGFzaDtcclxuICAgICAgICAvLyBmb3IgZWFzaWVyIGFjY2Vzc1xyXG4gICAgICAgIGFsbEF0dHJpYnV0ZVR5cGVzID0gJC5leHRlbmQoe30sIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50aXR5QXR0cmlidXRlVHlwZXMsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRBdHRyaWJ1dGVUeXBlcyk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgZ290Q3VycmVudCA9IGZ1bmN0aW9uKF9jb2xsLCBfZG9jLCBfYXJncykge1xyXG4gICAgICAgIGNvbGwgPSBfY29sbDtcclxuICAgICAgICBkb2MgPSBfZG9jO1xyXG4gICAgICAgIGFyZ3MgPSBfYXJncztcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciB1bmRvU3RhY2sgPSBbXTtcclxuICAgICAgdmFyIGVkaXRlZCA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgdmFyIHggPSByZXNwb25zZS5leGNlcHRpb247XHJcbiAgICAgICAgaWYgKHgpIHtcclxuICAgICAgICAgIGlmICh4ID09ICdhbm5vdGF0aW9uSXNSZWFkT25seScpIHtcclxuICAgICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdtZXNzYWdlcycsIFtbW1wiVGhpcyBkb2N1bWVudCBpcyByZWFkLW9ubHkgYW5kIGNhbid0IGJlIGVkaXRlZC5cIiwgJ2Vycm9yJ11dXSk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHggPT0gJ3NwYW5PZmZzZXRPdmVybGFwRXJyb3InKSB7XHJcbiAgICAgICAgICAgIC8vIGNyZWF0ZVNwYW4gd2l0aCBvdmVybGFwcGluZyBmcmFnIG9mZnNldHM7IHJlc2V0IG9mZnNldHNcclxuICAgICAgICAgICAgLy8gQGFtYWRhbm1hdGg6IHdobyBob2xkcyB0aGUgbGlzdCBvZiBvZmZzZXRzIGZvciBhIHNwYW4/XHJcbiAgICAgICAgICAgIC8vIGhvdyB0byByZXNldCB0aGlzP1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdtZXNzYWdlcycsIFtbWydVbmtub3duIGVycm9yICcreCwgJ2Vycm9yJ11dXSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAocmVzZWxlY3RlZFNwYW4pIHtcclxuICAgICAgICAgICAgJChyZXNlbGVjdGVkU3Bhbi5yZWN0KS5yZW1vdmVDbGFzcygncmVzZWxlY3QnKTtcclxuICAgICAgICAgICAgcmVzZWxlY3RlZFNwYW4gPSBudWxsO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgc3ZnRWxlbWVudC5yZW1vdmVDbGFzcygncmVzZWxlY3QnKTtcclxuICAgICAgICAgICQoJyN3YWl0ZXInKS5kaWFsb2coJ2Nsb3NlJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmIChyZXNwb25zZS5lZGl0ZWQgPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignV2FybmluZzogc2VydmVyIHJlc3BvbnNlIHRvIGVkaXQgaGFzJywgcmVzcG9uc2UuZWRpdGVkLCAndmFsdWUgZm9yIFwiZWRpdGVkXCInKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGFyZ3MuZWRpdGVkID0gcmVzcG9uc2UuZWRpdGVkO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdmFyIHNvdXJjZURhdGEgPSByZXNwb25zZS5hbm5vdGF0aW9ucztcclxuICAgICAgICAgIHNvdXJjZURhdGEuZG9jdW1lbnQgPSBkb2M7XHJcbiAgICAgICAgICBzb3VyY2VEYXRhLmNvbGxlY3Rpb24gPSBjb2xsO1xyXG4gICAgICAgICAgLy8gdGhpcyBcInByZXZlbnRcIiBpcyB0byBwcm90ZWN0IGFnYWluc3QgcmVsb2FkaW5nIChmcm9tIHRoZVxyXG4gICAgICAgICAgLy8gc2VydmVyKSB0aGUgdmVyeSBkYXRhIHRoYXQgd2UganVzdCByZWNlaXZlZCBhcyBwYXJ0IG9mIHRoZVxyXG4gICAgICAgICAgLy8gcmVzcG9uc2UgdG8gdGhlIGVkaXQuXHJcbiAgICAgICAgICBpZiAocmVzcG9uc2UudW5kbyAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdW5kb1N0YWNrLnB1c2goW2NvbGwsIHNvdXJjZURhdGEuZG9jdW1lbnQsIHJlc3BvbnNlLnVuZG9dKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGRpc3BhdGNoZXIucG9zdCgncHJldmVudFJlbG9hZEJ5VVJMJyk7XHJcbiAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ3NldEFyZ3VtZW50cycsIFthcmdzXSk7XHJcbiAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ3JlbmRlckRhdGEnLCBbc291cmNlRGF0YV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcblxyXG4gICAgICAvLyBUT0RPOiB3aHkgYXJlIHRoZXNlIGdsb2JhbHMgZGVmaW5lZCBoZXJlIGluc3RlYWQgb2YgYXQgdGhlIHRvcD9cclxuICAgICAgdmFyIHNwYW5Gb3JtID0gJCgnI3NwYW5fZm9ybScpO1xyXG4gICAgICB2YXIgcmFwaWRTcGFuRm9ybSA9ICQoJyNyYXBpZF9zcGFuX2Zvcm0nKTtcclxuICAgIFxyXG4gICAgICB2YXIgZGVsZXRlU3BhbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmIChDb25maWd1cmF0aW9uLmNvbmZpcm1Nb2RlT24gJiYgIWNvbmZpcm0oXCJBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZGVsZXRlIHRoaXMgYW5ub3RhdGlvbj9cIikpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgJC5leHRlbmQoc3Bhbk9wdGlvbnMsIHtcclxuICAgICAgICAgIGFjdGlvbjogJ2RlbGV0ZVNwYW4nLFxyXG4gICAgICAgICAgY29sbGVjdGlvbjogY29sbCxcclxuICAgICAgICAgICdkb2N1bWVudCc6IGRvYyxcclxuICAgICAgICB9KTtcclxuICAgICAgICBzcGFuT3B0aW9ucy5vZmZzZXRzID0gSlNPTi5zdHJpbmdpZnkoc3Bhbk9wdGlvbnMub2Zmc2V0cyk7XHJcbiAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdhamF4JywgW3NwYW5PcHRpb25zLCAnZWRpdGVkJ10pO1xyXG4gICAgICAgIGRpc3BhdGNoZXIucG9zdCgnaGlkZUZvcm0nKTtcclxuICAgICAgICAkKCcjd2FpdGVyJykuZGlhbG9nKCdvcGVuJyk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgcmVzZWxlY3RTcGFuID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdoaWRlRm9ybScpO1xyXG4gICAgICAgIHN2Z0VsZW1lbnQuYWRkQ2xhc3MoJ3Jlc2VsZWN0Jyk7XHJcbiAgICAgICAgJChlZGl0ZWRTcGFuLnJlY3QpLmFkZENsYXNzKCdyZXNlbGVjdCcpO1xyXG4gICAgICAgIHJlc2VsZWN0ZWRTcGFuID0gZWRpdGVkU3BhbjtcclxuICAgICAgICBzZWxlY3RlZEZyYWdtZW50ID0gbnVsbDtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciBzcGxpdEZvcm0gPSAkKCcjc3BsaXRfZm9ybScpO1xyXG4gICAgICBzcGxpdEZvcm0uc3VibWl0KGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgIHZhciBzcGxpdFJvbGVzID0gW107XHJcbiAgICAgICAgJCgnI3NwbGl0X3JvbGVzIGlucHV0OmNoZWNrZWQnKS5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgc3BsaXRSb2xlcy5wdXNoKCQodGhpcykudmFsKCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgICQuZXh0ZW5kKHNwYW5PcHRpb25zLCB7XHJcbiAgICAgICAgICAgIGFjdGlvbjogJ3NwbGl0U3BhbicsXHJcbiAgICAgICAgICAgICdhcmdzJzogJC50b0pTT04oc3BsaXRSb2xlcyksXHJcbiAgICAgICAgICAgIGNvbGxlY3Rpb246IGNvbGwsXHJcbiAgICAgICAgICAgICdkb2N1bWVudCc6IGRvYyxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIHNwYW5PcHRpb25zLm9mZnNldHMgPSBKU09OLnN0cmluZ2lmeShzcGFuT3B0aW9ucy5vZmZzZXRzKTtcclxuICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ2hpZGVGb3JtJyk7XHJcbiAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdhamF4JywgW3NwYW5PcHRpb25zLCAnZWRpdGVkJ10pO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfSk7XHJcbiAgICAgIGRpc3BhdGNoZXIucG9zdCgnaW5pdEZvcm0nLCBbc3BsaXRGb3JtLCB7XHJcbiAgICAgICAgICBhbHNvUmVzaXplOiAnLnNjcm9sbF9mc2V0JyxcclxuICAgICAgICAgIHdpZHRoOiA0MDBcclxuICAgICAgICB9XSk7XHJcbiAgICAgIHZhciBzcGxpdFNwYW4gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ2hpZGVGb3JtJyk7XHJcbiAgICAgICAgdmFyICRyb2xlcyA9ICQoJyNzcGxpdF9yb2xlcycpLmVtcHR5KCk7XHJcbiAgICAgICAgdmFyIG51bVJvbGVzID0gcmVwZWF0aW5nQXJjVHlwZXMubGVuZ3RoO1xyXG4gICAgICAgIHZhciByb2xlcyA9ICQuZWFjaChyZXBlYXRpbmdBcmNUeXBlcywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICB2YXIgJHJvbGUgPSAkKCc8aW5wdXQgaWQ9XCJzcGxpdF9vbl8nICsgVXRpbC5lc2NhcGVRdW90ZXModGhpcykgK1xyXG4gICAgICAgICAgICAnXCIgdHlwZT1cImNoZWNrYm94XCIgbmFtZT1cIicgKyBVdGlsLmVzY2FwZVF1b3Rlcyh0aGlzKSArXHJcbiAgICAgICAgICAgICdcIiB2YWx1ZT1cIicgKyBVdGlsLmVzY2FwZVF1b3Rlcyh0aGlzKSArICdcIi8+Jyk7XHJcbiAgICAgICAgICBpZiAobnVtUm9sZXMgPT0gMSkge1xyXG4gICAgICAgICAgICAvLyBhIHNpbmdsZSByb2xlIHdpbGwgYmUgc2VsZWN0ZWQgYXV0b21hdGljYWxseVxyXG4gICAgICAgICAgICAkcm9sZS5jbGljaygpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdmFyICRsYWJlbCA9ICQoJzxsYWJlbCBmb3I9XCJzcGxpdF9vbl8nICsgVXRpbC5lc2NhcGVRdW90ZXModGhpcykgK1xyXG4gICAgICAgICAgICAnXCI+JyArIFV0aWwuZXNjYXBlUXVvdGVzKHRoaXMpICsgJzwvbGFiZWw+Jyk7XHJcbiAgICAgICAgICAkcm9sZXMuYXBwZW5kKCRyb2xlKS5hcHBlbmQoJGxhYmVsKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgJHJvbGVCdXR0b25zID0gJHJvbGVzLmZpbmQoJ2lucHV0JykuYnV0dG9uKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdzaG93Rm9ybScsIFtzcGxpdEZvcm1dKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciBhZGRGcmFnbWVudCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGRpc3BhdGNoZXIucG9zdCgnaGlkZUZvcm0nKTtcclxuICAgICAgICBzdmdFbGVtZW50LmFkZENsYXNzKCdyZXNlbGVjdCcpO1xyXG4gICAgICAgICQoZWRpdGVkU3Bhbi5yZWN0KS5hZGRDbGFzcygncmVzZWxlY3QnKTtcclxuICAgICAgICByZXNlbGVjdGVkU3BhbiA9IGVkaXRlZFNwYW47XHJcbiAgICAgICAgc2VsZWN0ZWRGcmFnbWVudCA9IGZhbHNlO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdmFyIHJlc2VsZWN0RnJhZ21lbnQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBhZGRGcmFnbWVudCgpO1xyXG4gICAgICAgIHNlbGVjdGVkRnJhZ21lbnQgPSBlZGl0ZWRGcmFnbWVudDtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciBkZWxldGVGcmFnbWVudCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmIChDb25maWd1cmF0aW9uLmNvbmZpcm1Nb2RlT24gJiYgIWNvbmZpcm0oXCJBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZGVsZXRlIHRoaXMgZnJhZ21lbnQ/XCIpKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvZmZzZXRzID0gZWRpdGVkU3Bhbi5vZmZzZXRzO1xyXG4gICAgICAgIHNwYW5PcHRpb25zLm9sZF9vZmZzZXRzID0gSlNPTi5zdHJpbmdpZnkob2Zmc2V0cyk7XHJcbiAgICAgICAgb2Zmc2V0cy5zcGxpY2UoZWRpdGVkRnJhZ21lbnQsIDEpO1xyXG5cclxuICAgICAgICAkLmV4dGVuZChzcGFuT3B0aW9ucywge1xyXG4gICAgICAgICAgY29sbGVjdGlvbjogY29sbCxcclxuICAgICAgICAgICdkb2N1bWVudCc6IGRvYyxcclxuICAgICAgICAgIG9mZnNldHM6IEpTT04uc3RyaW5naWZ5KG9mZnNldHMpLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBzcGFuT3B0aW9ucy5hdHRyaWJ1dGVzID0gJC50b0pTT04oc3BhbkF0dHJpYnV0ZXMoKSk7XHJcblxyXG4gICAgICAgIHNwYW5PcHRpb25zLm5vcm1hbGl6YXRpb25zID0gJC50b0pTT04oc3Bhbk5vcm1hbGl6YXRpb25zKCkpO1xyXG5cclxuICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ2FqYXgnLCBbc3Bhbk9wdGlvbnMsICdlZGl0ZWQnXSk7XHJcbiAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdoaWRlRm9ybScpO1xyXG4gICAgICAgICQoJyN3YWl0ZXInKS5kaWFsb2coJ29wZW4nKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGRpc3BhdGNoZXIucG9zdCgnaW5pdEZvcm0nLCBbc3BhbkZvcm0sIHtcclxuICAgICAgICAgIGFsc29SZXNpemU6ICcjZW50aXR5X2FuZF9ldmVudF93cmFwcGVyJyxcclxuICAgICAgICAgIHdpZHRoOiA3NjAsXHJcbiAgICAgICAgICBidXR0b25zOiBbe1xyXG4gICAgICAgICAgICAgIGlkOiAnc3Bhbl9mb3JtX2FkZF9mcmFnbWVudCcsXHJcbiAgICAgICAgICAgICAgdGV4dDogXCJBZGQgRnJhZy5cIixcclxuICAgICAgICAgICAgICBjbGljazogYWRkRnJhZ21lbnRcclxuICAgICAgICAgICAgfSwge1xyXG4gICAgICAgICAgICAgIGlkOiAnc3Bhbl9mb3JtX2RlbGV0ZScsXHJcbiAgICAgICAgICAgICAgdGV4dDogXCJEZWxldGVcIixcclxuICAgICAgICAgICAgICBjbGljazogZGVsZXRlU3BhblxyXG4gICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgaWQ6ICdzcGFuX2Zvcm1fZGVsZXRlX2ZyYWdtZW50JyxcclxuICAgICAgICAgICAgICB0ZXh0OiBcIkRlbGV0ZSBGcmFnLlwiLFxyXG4gICAgICAgICAgICAgIGNsaWNrOiBkZWxldGVGcmFnbWVudFxyXG4gICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgaWQ6ICdzcGFuX2Zvcm1fcmVzZWxlY3QnLFxyXG4gICAgICAgICAgICAgIHRleHQ6ICdNb3ZlJyxcclxuICAgICAgICAgICAgICBjbGljazogcmVzZWxlY3RTcGFuXHJcbiAgICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgICBpZDogJ3NwYW5fZm9ybV9yZXNlbGVjdF9mcmFnbWVudCcsXHJcbiAgICAgICAgICAgICAgdGV4dDogJ01vdmUgRnJhZy4nLFxyXG4gICAgICAgICAgICAgIGNsaWNrOiByZXNlbGVjdEZyYWdtZW50XHJcbiAgICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgICBpZDogJ3NwYW5fZm9ybV9zcGxpdCcsXHJcbiAgICAgICAgICAgICAgdGV4dDogJ1NwbGl0JyxcclxuICAgICAgICAgICAgICBjbGljazogc3BsaXRTcGFuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIF0sXHJcbiAgICAgICAgICBjbG9zZTogZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgICAgIGtleW1hcCA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChyZXNlbGVjdGVkU3Bhbikge1xyXG4gICAgICAgICAgICAgICQocmVzZWxlY3RlZFNwYW4ucmVjdCkucmVtb3ZlQ2xhc3MoJ3Jlc2VsZWN0Jyk7XHJcbiAgICAgICAgICAgICAgcmVzZWxlY3RlZFNwYW4gPSBudWxsO1xyXG4gICAgICAgICAgICAgIHN2Z0VsZW1lbnQucmVtb3ZlQ2xhc3MoJ3Jlc2VsZWN0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XSk7XHJcbiAgICAgIC8vIHNldCBidXR0b24gdG9vbHRpcHMgKEBhbWFkYW5tYXRoOiBjYW4gdGhpcyBiZSBkb25lIGluIGluaXQ/KVxyXG4gICAgICAkKCcjc3Bhbl9mb3JtX3Jlc2VsZWN0JykuYXR0cigndGl0bGUnLCAnUmUtc2VsZWN0IHRoZSB0ZXh0IHNwYW4gdGhhdCB0aGlzIGFubm90YXRpb24gbWFya3MuJyk7XHJcbiAgICAgICQoJyNzcGFuX2Zvcm1fZGVsZXRlJykuYXR0cigndGl0bGUnLCAnRGVsZXRlIHRoaXMgYW5ub3RhdGlvbi4nKTtcclxuICAgICAgJCgnI3NwYW5fZm9ybV9zcGxpdCcpLmF0dHIoJ3RpdGxlJywgJ1NwbGl0IHRoaXMgYW5ub3RhdGlvbiBpbnRvIG11bHRpcGxlIHNpbWlsYXIgYW5ub3RhdGlvbnMsIGRpc3RyaWJ1dGluZyBpdHMgYXJndW1lbnRzLicpO1xyXG5cclxuICAgICAgZGlzcGF0Y2hlci5wb3N0KCdpbml0Rm9ybScsIFtyYXBpZFNwYW5Gb3JtLCB7XHJcbiAgICAgICAgICBhbHNvUmVzaXplOiAnI3JhcGlkX3NwYW5fdHlwZXMnLFxyXG4gICAgICAgICAgd2lkdGg6IDQwMCwgICAgICAgICAgICAgXHJcbiAgICAgICAgICBjbG9zZTogZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgICAgIGtleW1hcCA9IG51bGw7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfV0pO1xyXG5cclxuICAgICAgdmFyIHNwYW5Gb3JtU3VibWl0ID0gZnVuY3Rpb24oZXZ0LCB0eXBlUmFkaW8pIHtcclxuICAgICAgICB0eXBlUmFkaW8gPSB0eXBlUmFkaW8gfHwgJCgnI3NwYW5fZm9ybSBpbnB1dDpyYWRpbzpjaGVja2VkJyk7XHJcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlUmFkaW8udmFsKCk7XHJcbiAgICAgICAgJCgnI3NwYW5fZm9ybS1vaycpLmJsdXIoKTtcclxuICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ2hpZGVGb3JtJyk7XHJcbiAgICAgICAgJC5leHRlbmQoc3Bhbk9wdGlvbnMsIHtcclxuICAgICAgICAgIGFjdGlvbjogJ2NyZWF0ZVNwYW4nLFxyXG4gICAgICAgICAgY29sbGVjdGlvbjogY29sbCxcclxuICAgICAgICAgICdkb2N1bWVudCc6IGRvYyxcclxuICAgICAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgICAgICBjb21tZW50OiAkKCcjc3Bhbl9ub3RlcycpLnZhbCgpXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHNwYW5PcHRpb25zLmF0dHJpYnV0ZXMgPSAkLnRvSlNPTihzcGFuQXR0cmlidXRlcygpKTtcclxuXHJcbiAgICAgICAgc3Bhbk9wdGlvbnMubm9ybWFsaXphdGlvbnMgPSAkLnRvSlNPTihzcGFuTm9ybWFsaXphdGlvbnMoKSk7XHJcblxyXG4gICAgICAgIGlmIChzcGFuT3B0aW9ucy5vZmZzZXRzKSB7XHJcbiAgICAgICAgICBzcGFuT3B0aW9ucy5vZmZzZXRzID0gJC50b0pTT04oc3Bhbk9wdGlvbnMub2Zmc2V0cyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB1bmZvY3VzIGFsbCBlbGVtZW50cyB0byBwcmV2ZW50IGZvY3VzIGJlaW5nIGtlcHQgYWZ0ZXJcclxuICAgICAgICAvLyBoaWRpbmcgdGhlbVxyXG4gICAgICAgIHNwYW5Gb3JtLnBhcmVudCgpLmZpbmQoJyonKS5ibHVyKCk7XHJcblxyXG4gICAgICAgICQoJyN3YWl0ZXInKS5kaWFsb2coJ29wZW4nKTtcclxuICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ2FqYXgnLCBbc3Bhbk9wdGlvbnMsICdlZGl0ZWQnXSk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9O1xyXG4gICAgICAkKCcjc3Bhbl9ub3RlcycpLmZvY3VzKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGtleW1hcCA9IG51bGw7XHJcbiAgICAgICAgfSkuYmx1cihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBrZXltYXAgPSBzcGFuS2V5bWFwO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICBzcGFuRm9ybS5zdWJtaXQoc3BhbkZvcm1TdWJtaXQpO1xyXG5cclxuICAgICAgdmFyIHJhcGlkU3BhbkZvcm1TdWJtaXQgPSBmdW5jdGlvbihldnQsIHR5cGVSYWRpbykge1xyXG4gICAgICAgIHR5cGVSYWRpbyA9IHR5cGVSYWRpbyB8fCAkKCcjcmFwaWRfc3Bhbl9mb3JtIGlucHV0OnJhZGlvOmNoZWNrZWQnKTtcclxuICAgICAgICB2YXIgdHlwZSA9IHR5cGVSYWRpby52YWwoKTtcclxuXHJcbiAgICAgICAgLy8gdW5mb2N1cyBhbGwgZWxlbWVudHMgdG8gcHJldmVudCBmb2N1cyBiZWluZyBrZXB0IGFmdGVyXHJcbiAgICAgICAgLy8gaGlkaW5nIHRoZW1cclxuICAgICAgICByYXBpZFNwYW5Gb3JtLnBhcmVudCgpLmZpbmQoJyonKS5ibHVyKCk7XHJcbiAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdoaWRlRm9ybScpO1xyXG5cclxuICAgICAgICBpZiAodHlwZSA9PSBcIlwiKSB7XHJcbiAgICAgICAgICAvLyBlbXB0eSB0eXBlIHZhbHVlIHNpZ25hbHMgdGhlIHNwZWNpYWwgY2FzZSB3aGVyZSB0aGUgdXNlclxyXG4gICAgICAgICAgLy8gc2VsZWN0ZWQgXCJub25lIG9mIHRoZSBhYm92ZVwiIG9mIHRoZSBwcm9wb3NlZCB0eXBlcyBhbmRcclxuICAgICAgICAgIC8vIHRoZSBub3JtYWwgZGlhbG9nIHNob3VsZCBiZSBicm91Z2h0IHVwIGZvciB0aGUgc2FtZSBzcGFuLlxyXG4gICAgICAgICAgc3Bhbk9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGFjdGlvbjogJ2NyZWF0ZVNwYW4nLFxyXG4gICAgICAgICAgICBvZmZzZXRzOiByYXBpZFNwYW5PcHRpb25zLm9mZnNldHMsXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgLy8gVE9ETzogYXZvaWQgdXNpbmcgdGhlIHN0b3JlZCBtb3VzZSBldmVudFxyXG4gICAgICAgICAgZmlsbFNwYW5UeXBlc0FuZERpc3BsYXlGb3JtKGxhc3RSYXBpZEFubm90YXRpb25FdmVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCcjcmFwaWRfc3Bhbl9zZWxlY3RlZCcpLnRleHQoKSk7XHJcbiAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ2xvZ0FjdGlvbicsIFsnbm9ybWFsU3BhblNlbGVjdGVkJ10pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBub3JtYWwgdHlwZSBzZWxlY3Rpb247IHN1Ym1pdCBjcmVhdGVTcGFuIHdpdGggdGhlIHNlbGVjdGVkIHR5cGUuXHJcbiAgICAgICAgICAkLmV4dGVuZChyYXBpZFNwYW5PcHRpb25zLCB7XHJcbiAgICAgICAgICAgIGFjdGlvbjogJ2NyZWF0ZVNwYW4nLFxyXG4gICAgICAgICAgICBjb2xsZWN0aW9uOiBjb2xsLFxyXG4gICAgICAgICAgICAnZG9jdW1lbnQnOiBkb2MsXHJcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgICQoJyN3YWl0ZXInKS5kaWFsb2coJ29wZW4nKTtcclxuICAgICAgICAgIHJhcGlkU3Bhbk9wdGlvbnMub2Zmc2V0cyA9IEpTT04uc3RyaW5naWZ5KHJhcGlkU3Bhbk9wdGlvbnMub2Zmc2V0cyk7XHJcbiAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ2FqYXgnLCBbcmFwaWRTcGFuT3B0aW9ucywgJ2VkaXRlZCddKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9O1xyXG4gICAgICByYXBpZFNwYW5Gb3JtLnN1Ym1pdChyYXBpZFNwYW5Gb3JtU3VibWl0KTtcclxuXHJcbiAgICAgIHZhciBpbXBvcnRGb3JtID0gJCgnI2ltcG9ydF9mb3JtJyk7XHJcbiAgICAgIHZhciBpbXBvcnRGb3JtU3VibWl0ID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgdmFyIF9kb2NpZCA9ICQoJyNpbXBvcnRfZG9jaWQnKS52YWwoKTtcclxuICAgICAgICB2YXIgX2RvY3RpdGxlID0gJCgnI2ltcG9ydF90aXRsZScpLnZhbCgpO1xyXG4gICAgICAgIHZhciBfZG9jdGV4dCA9ICQoJyNpbXBvcnRfdGV4dCcpLnZhbCgpO1xyXG4gICAgICAgIHZhciBvcHRzID0ge1xyXG4gICAgICAgICAgYWN0aW9uIDogJ2ltcG9ydERvY3VtZW50JyxcclxuICAgICAgICAgIGNvbGxlY3Rpb24gOiBjb2xsLFxyXG4gICAgICAgICAgZG9jaWQgIDogX2RvY2lkLFxyXG4gICAgICAgICAgdGl0bGUgOiBfZG9jdGl0bGUsXHJcbiAgICAgICAgICB0ZXh0ICA6IF9kb2N0ZXh0LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdhamF4JywgW29wdHMsIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICB2YXIgeCA9IHJlc3BvbnNlLmV4Y2VwdGlvbjtcclxuICAgICAgICAgIGlmICh4KSB7XHJcbiAgICAgICAgICAgIGlmICh4ID09ICdmaWxlRXhpc3RzRXJyb3InKSB7XHJcbiAgICAgICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdtZXNzYWdlcycsIFtbW1wiQSBmaWxlIHdpdGggdGhlIGdpdmVuIG5hbWUgZXhpc3RzLiBQbGVhc2UgZ2l2ZSBhIGRpZmZlcmVudCBuYW1lIHRvIHRoZSBmaWxlIHRvIGltcG9ydC5cIiwgJ2Vycm9yJ11dXSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdtZXNzYWdlcycsIFtbWydVbmtub3duIGVycm9yOiAnICsgcmVzcG9uc2UuZXhjZXB0aW9uLCAnZXJyb3InXV1dKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdoaWRlRm9ybScpO1xyXG4gICAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ3NldERvY3VtZW50JywgW3Jlc3BvbnNlLmRvY3VtZW50XSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfV0pO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfTtcclxuICAgICAgaW1wb3J0Rm9ybS5zdWJtaXQoaW1wb3J0Rm9ybVN1Ym1pdCk7XHJcbiAgICAgIGRpc3BhdGNoZXIucG9zdCgnaW5pdEZvcm0nLCBbaW1wb3J0Rm9ybSwge1xyXG4gICAgICAgICAgd2lkdGg6IDUwMCxcclxuICAgICAgICAgIGFsc29SZXNpemU6ICcjaW1wb3J0X3RleHQnLFxyXG4gICAgICAgICAgb3BlbjogZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgICAgIGtleW1hcCA9IHt9O1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9XSk7XHJcbiAgICAgICQoJyNpbXBvcnRfYnV0dG9uJykuY2xpY2soZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdoaWRlRm9ybScpO1xyXG4gICAgICAgIGRpc3BhdGNoZXIucG9zdCgnc2hvd0Zvcm0nLCBbaW1wb3J0Rm9ybV0pO1xyXG4gICAgICAgIGltcG9ydEZvcm0uZmluZCgnaW5wdXQsIHRleHRhcmVhJykudmFsKCcnKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvKiBCRUdJTiBkZWxldGUgYnV0dG9uIC0gcmVsYXRlZCAqL1xyXG5cclxuICAgICAgJCgnI2RlbGV0ZV9kb2N1bWVudF9idXR0b24nKS5jbGljayhmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoIWRvYykge1xyXG4gICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdtZXNzYWdlcycsIFtbWydObyBkb2N1bWVudCBzZWxlY3RlZCcsICdlcnJvciddXV0pO1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWNvbmZpcm0oJ0FyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBwZXJtYW5lbnRseSByZW1vdmUgdGhpcyBkb2N1bWVudCBhbmQgaXRzIGFubm90YXRpb25zIGZyb20gdGhlIGNvbGxlY3Rpb24/IFRoaXMgYWN0aW9uIGNhbm5vdCBiZSB1bmRvbmUuJykpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRlbE9wdGlvbnMgPSB7XHJcbiAgICAgICAgICBhY3Rpb246ICdkZWxldGVEb2N1bWVudCcsXHJcbiAgICAgICAgICBjb2xsZWN0aW9uOiBjb2xsLFxyXG4gICAgICAgICAgJ2RvY3VtZW50JzogZG9jXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRpc3BhdGNoZXIucG9zdCgnYWpheCcsIFtkZWxPcHRpb25zLCAnZG9jRGVsZXRlZCddKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAkKCcjZGVsZXRlX2NvbGxlY3Rpb25fYnV0dG9uJykuY2xpY2soZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKCFjb2xsKSB7XHJcbiAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ21lc3NhZ2VzJywgW1tbJ05vIGNvbGxlY3Rpb24gc2VsZWN0ZWQnLCAnZXJyb3InXV1dKTtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFjb25maXJtKCdBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gcGVybWFuZW50bHkgUkVNT1ZFIHRoZSBFTlRJUkUgQ09MTEVDVElPTiAnK2NvbGwrJywgaW5jbHVkaW5nIGFsbCBpdHMgZG9jdW1lbnRzIGFuZCB0aGVpciBhbm5vdGF0aW9ucz8gIFRoaXMgYWN0aW9uIENBTk5PVCBCRSBVTkRPTkUuJykpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRlbE9wdGlvbnMgPSB7XHJcbiAgICAgICAgICBhY3Rpb246ICdkZWxldGVDb2xsZWN0aW9uJyxcclxuICAgICAgICAgIGNvbGxlY3Rpb246IGNvbGwsXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRpc3BhdGNoZXIucG9zdCgnYWpheCcsIFtkZWxPcHRpb25zLCAnY29sbERlbGV0ZWQnXSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLyogRU5EIGRlbGV0ZSBidXR0b24gLSByZWxhdGVkICovXHJcblxyXG4gICAgICAkKCcjdW5kb19idXR0b24nKS5jbGljayhmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoY29sbCAmJiBkb2MpIHtcclxuICAgICAgICAgIGlmICh1bmRvU3RhY2subGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB2YXIgc3RvcmVkVW5kbyA9IHVuZG9TdGFjay5wb3AoKTtcclxuICAgICAgICAgICAgdmFyIGNvbGxlY3Rpb24gPSBzdG9yZWRVbmRvWzBdO1xyXG4gICAgICAgICAgICB2YXIgZG9rID0gc3RvcmVkVW5kb1sxXTtcclxuICAgICAgICAgICAgdmFyIHRva2VuID0gc3RvcmVkVW5kb1syXTtcclxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgJ2FjdGlvbic6ICd1bmRvJyxcclxuICAgICAgICAgICAgICAnY29sbGVjdGlvbic6IGNvbGxlY3Rpb24sXHJcbiAgICAgICAgICAgICAgJ2RvY3VtZW50JzogZG9rLFxyXG4gICAgICAgICAgICAgICd0b2tlbic6IHRva2VuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdhamF4JywgW29wdGlvbnMsICdlZGl0ZWQnXSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ21lc3NhZ2VzJywgW1tbJ05vIGFjdGlvbiB0byBiZSB1bmRvbmUnLCAnZXJyb3InXV1dKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdtZXNzYWdlcycsIFtbWydObyBkb2N1bWVudCBsb2FkZWQsIGNhbiBub3QgdW5kbyBjaGFuZ2VzJywgJ2Vycm9yJ11dXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcblxyXG4gICAgICB2YXIgcHJldmVudERlZmF1bHQgPSBmdW5jdGlvbihldnQpIHtcclxuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyICR3YWl0ZXIgPSAkKCcjd2FpdGVyJyk7XHJcbiAgICAgICR3YWl0ZXIuZGlhbG9nKHtcclxuICAgICAgICBjbG9zZU9uRXNjYXBlOiBmYWxzZSxcclxuICAgICAgICBidXR0b25zOiB7fSxcclxuICAgICAgICBtb2RhbDogdHJ1ZSxcclxuICAgICAgICBvcGVuOiBmdW5jdGlvbihldnQsIHVpKSB7XHJcbiAgICAgICAgICAkKGV2dC50YXJnZXQpLnBhcmVudCgpLmZpbmQoXCIudWktZGlhbG9nLXRpdGxlYmFyLWNsb3NlXCIpLmhpZGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICAvLyBoaWRlIHRoZSB3YWl0ZXIgKFNhbXBvIHNhaWQgaXQncyBhbm5veWluZylcclxuICAgICAgLy8gd2UgZG9uJ3QgZWxsaW1pbmF0ZSBpdCBhbHRvZ2V0aGVyIGJlY2F1c2UgaXQgc3RpbGwgcHJvdmlkZXMgdGhlXHJcbiAgICAgIC8vIG92ZXJsYXkgdG8gcHJldmVudCBpbnRlcmFjdGlvblxyXG4gICAgICAvLyAkd2FpdGVyLnBhcmVudCgpLmNzcygnb3BhY2l0eScsICcwJyk7XHJcblxyXG4gICAgICB2YXIgaXNSZWxvYWRPa2F5ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy8gZG8gbm90IHJlbG9hZCB3aGlsZSB0aGUgdXNlciBpcyBpbiB0aGUgbWlkZGxlIG9mIGVkaXRpbmdcclxuICAgICAgICByZXR1cm4gYXJjRHJhZ09yaWdpbiA9PSBudWxsICYmIHJlc2VsZWN0ZWRTcGFuID09IG51bGw7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgdXNlclJlY2VpdmVkID0gZnVuY3Rpb24oX3VzZXIpIHtcclxuICAgICAgICB0aGF0LnVzZXIgPSBfdXNlcjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHNldEFubm90YXRpb25TcGVlZCA9IGZ1bmN0aW9uKHNwZWVkKSB7XHJcbiAgICAgICAgaWYgKHNwZWVkID09IDEpIHtcclxuICAgICAgICAgIENvbmZpZ3VyYXRpb24uY29uZmlybU1vZGVPbiA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIENvbmZpZ3VyYXRpb24uY29uZmlybU1vZGVPbiA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3BlZWQgPT0gMykge1xyXG4gICAgICAgICAgQ29uZmlndXJhdGlvbi5yYXBpZE1vZGVPbiA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIENvbmZpZ3VyYXRpb24ucmFwaWRNb2RlT24gPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdjb25maWd1cmF0aW9uQ2hhbmdlZCcpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdmFyIG9uTmV3U291cmNlRGF0YSA9IGZ1bmN0aW9uKF9zb3VyY2VEYXRhKSB7XHJcbiAgICAgICAgc291cmNlRGF0YSA9IF9zb3VyY2VEYXRhO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgaW5pdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGRpc3BhdGNoZXIucG9zdCgnYW5ub3RhdGlvbklzQXZhaWxhYmxlJyk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgY29sbGVjdGlvbkxvYWRlZCA9IGZ1bmN0aW9uKGNvbGxEYXRhKXtcclxuICAgICAgICBjb2xsID0gY29sbERhdGE7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgcmVxdWVzdFJlbmRlckRhdGEgPSBmdW5jdGlvbihkb2NEYXRhKSB7XHJcbiAgICAgICAgZG9jID0gZG9jRGF0YTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGRpc3BhdGNoZXIuXHJcbiAgICAgICAgICBvbignaW5pdCcsIGluaXQpLlxyXG4gICAgICAgICAgb24oJ2dldFZhbGlkQXJjVHlwZXNGb3JEcmFnJywgZ2V0VmFsaWRBcmNUeXBlc0ZvckRyYWcpLlxyXG4gICAgICAgICAgb24oJ2RhdGFSZWFkeScsIHJlbWVtYmVyRGF0YSkuXHJcbiAgICAgICAgICBvbigncmVxdWVzdFJlbmRlckRhdGEnLCByZXF1ZXN0UmVuZGVyRGF0YSkuXHJcbiAgICAgICAgICBvbignY29sbGVjdGlvbkxvYWRlZCcsIGNvbGxlY3Rpb25Mb2FkZWQpLlxyXG4gICAgICAgICAgb24oJ2NvbGxlY3Rpb25Mb2FkZWQnLCByZW1lbWJlclNwYW5TZXR0aW5ncykuXHJcbiAgICAgICAgICBvbignY29sbGVjdGlvbkxvYWRlZCcsIHNldHVwVGFnZ2VyVUkpLlxyXG4gICAgICAgICAgb24oJ2NvbGxlY3Rpb25Mb2FkZWQnLCBzZXR1cE5vcm1hbGl6YXRpb25VSSkuXHJcbiAgICAgICAgICBvbignc3BhbkFuZEF0dHJpYnV0ZVR5cGVzTG9hZGVkJywgc3BhbkFuZEF0dHJpYnV0ZVR5cGVzTG9hZGVkKS5cclxuICAgICAgICAgIG9uKCduZXdTb3VyY2VEYXRhJywgb25OZXdTb3VyY2VEYXRhKS5cclxuICAgICAgICAgIG9uKCdoaWRlRm9ybScsIGhpZGVGb3JtKS5cclxuICAgICAgICAgIG9uKCd1c2VyJywgdXNlclJlY2VpdmVkKS5cclxuICAgICAgICAgIG9uKCdlZGl0ZWQnLCBlZGl0ZWQpLlxyXG4gICAgICAgICAgb24oJ2N1cnJlbnQnLCBnb3RDdXJyZW50KS5cclxuICAgICAgICAgIG9uKCdpc1JlbG9hZE9rYXknLCBpc1JlbG9hZE9rYXkpLlxyXG4gICAgICAgICAgb24oJ2tleWRvd24nLCBvbktleURvd24pLlxyXG4gICAgICAgICAgb24oJ2RibGNsaWNrJywgb25EYmxDbGljaykuXHJcbiAgICAgICAgICBvbignZHJhZ3N0YXJ0JywgcHJldmVudERlZmF1bHQpLlxyXG4gICAgICAgICAgb24oJ21vdXNlZG93bicsIG9uTW91c2VEb3duKS5cclxuICAgICAgICAgIG9uKCdtb3VzZXVwJywgb25Nb3VzZVVwKS5cclxuICAgICAgICAgIG9uKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSkuXHJcbiAgICAgICAgICBvbignYW5ub3RhdGlvblNwZWVkJywgc2V0QW5ub3RhdGlvblNwZWVkKS5cclxuICAgICAgICAgIG9uKCdzdWdnZXN0ZWRTcGFuVHlwZXMnLCByZWNlaXZlZFN1Z2dlc3RlZFNwYW5UeXBlcykuXHJcbiAgICAgICAgICBvbignbm9ybUdldE5hbWVSZXN1bHQnLCBzZXRTcGFuTm9ybVRleHQpLlxyXG4gICAgICAgICAgb24oJ25vcm1TZWFyY2hSZXN1bHQnLCBzZXRTcGFuTm9ybVNlYXJjaFJlc3VsdHMpO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gQW5ub3RhdG9yVUk7XHJcbn0pKGpRdWVyeSwgd2luZG93KTtcclxuXHJcbi8vIEJSQVQgU1RBTkRBTE9ORSBMSUJSQVJZIEJFR0lOXHJcbi8vIEJyb3dzZXJpZnkgZXhwb3J0XHJcbm1vZHVsZS5leHBvcnRzID0gQW5ub3RhdG9yVUk7XHJcbi8vIEJSQVQgU1RBTkRBTE9ORSBMSUJSQVJZIEVORFxyXG4iLCIvLyAtKi0gTW9kZTogSmF2YVNjcmlwdDsgdGFiLXdpZHRoOiAyOyBpbmRlbnQtdGFicy1tb2RlOiBuaWw7IC0qLVxyXG4vLyB2aW06c2V0IGZ0PWphdmFzY3JpcHQgdHM9MiBzdz0yIHN0cz0yIGNpbmRlbnQ6XHJcbnZhciBDb25maWd1cmF0aW9uID0gKGZ1bmN0aW9uKHdpbmRvdywgdW5kZWZpbmVkKSB7XHJcbiAgICB2YXIgQ29uZmlndXJhdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB0aGF0LmFiYnJldnNPbiA9IHRydWU7XHJcbiAgICAgICAgdGhhdC50ZXh0QmFja2dyb3VuZHMgPSBcInN0cmlwZWRcIjtcclxuICAgICAgICB0aGF0LnN2Z1dpZHRoID0gJzEwMCUnO1xyXG4gICAgICAgIHRoYXQucmFwaWRNb2RlT24gPSBmYWxzZTtcclxuICAgICAgICB0aGF0LmNvbmZpcm1Nb2RlT24gPSB0cnVlO1xyXG4gICAgICAgIHRoYXQuYXV0b3JlZnJlc2hPbiA9IGZhbHNlO1xyXG4gICAgICAgIHRoYXQudmlzdWFsID0ge1xyXG4gICAgICAgICAgICBtYXJnaW46IHsgeDogMiwgeTogMSB9LFxyXG4gICAgICAgICAgICBhcmNUZXh0TWFyZ2luOiAxLFxyXG4gICAgICAgICAgICBib3hTcGFjaW5nOiAxLFxyXG4gICAgICAgICAgICBjdXJseUhlaWdodDogNCxcclxuICAgICAgICAgICAgYXJjU3BhY2luZzogOSwgLy8xMDtcclxuICAgICAgICAgICAgYXJjU3RhcnRIZWlnaHQ6IDE5LCAvLzIzOyAvLzI1O1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBDb25maWd1cmF0aW9uO1xyXG59KSh3aW5kb3cpO1xyXG5cclxuLy8gQlJBVCBTVEFOREFMT05FIExJQlJBUlkgQkVHSU5cclxuLy8gQnJvd3NlcmlmeSBleHBvcnRcclxubW9kdWxlLmV4cG9ydHMgPSBDb25maWd1cmF0aW9uO1xyXG4vLyBCUkFUIFNUQU5EQUxPTkUgTElCUkFSWSBFTkQiLCIvLyAtKi0gTW9kZTogSmF2YVNjcmlwdDsgdGFiLXdpZHRoOiAyOyBpbmRlbnQtdGFicy1tb2RlOiBuaWw7IC0qLVxyXG4vLyB2aW06c2V0IGZ0PWphdmFzY3JpcHQgdHM9MiBzdz0yIHN0cz0yIGNpbmRlbnQ6XHJcbi8vIFRPRE86IGRvZXMgJ2FyZ3VtZW50cy5jYWxsZWUuY2FsbGVyJyB3b3JrP1xyXG5cclxudmFyIERpc3BhdGNoZXIgPSAoZnVuY3Rpb24oJCwgd2luZG93LCB1bmRlZmluZWQpIHtcclxuICAgIHZhciBEaXNwYXRjaGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuXHJcbiAgICAgIHZhciB0YWJsZSA9IHt9O1xyXG5cclxuICAgICAgdmFyIG9uID0gZnVuY3Rpb24obWVzc2FnZSwgaG9zdCwgaGFuZGxlcikge1xyXG4gICAgICAgIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIGhhbmRsZXIgPSBob3N0O1xyXG4gICAgICAgICAgaG9zdCA9IGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGFibGVbbWVzc2FnZV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgdGFibGVbbWVzc2FnZV0gPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGFibGVbbWVzc2FnZV0ucHVzaChbaG9zdCwgaGFuZGxlcl0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gTm90aWZ5IGxpc3RlbmVycyB0aGF0IHdlIGVuY291bnRlcmVkIGFuIGVycm9yIGluIGFuIGFzeW5jaCBjYWxsXHJcbiAgICAgIHZhciBpbkFzeW5jaEVycm9yID0gZmFsc2U7IC8vIFRvIGF2b2lkIGVycm9yIGF2YWxhbmNoZXNcclxuICAgICAgdmFyIGhhbmRsZUFzeW5jaEVycm9yID0gZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIGlmICghaW5Bc3luY2hFcnJvcikge1xyXG4gICAgICAgICAgaW5Bc3luY2hFcnJvciA9IHRydWU7XHJcbiAgICAgICAgICAvLyBUT0RPOiBIb29rIHByaW50b3V0IGludG8gZGlzcGF0Y2ggZWxzZXdoZXJlP1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKCdIYW5kbGVkIGFzeW5jIGVycm9yOicsIGUpO1xyXG4gICAgICAgICAgdGhhdC5wb3N0KCdkaXNwYXRjaEFzeW5jaEVycm9yJywgW2VdKTtcclxuICAgICAgICAgIGluQXN5bmNoRXJyb3IgPSBmYWxzZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKCdEcm9wcGVkIGFzeW5jaCBlcnJvcjonLCBlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgcG9zdCA9IGZ1bmN0aW9uKGFzeW5jaCwgbWVzc2FnZSwgYXJncywgcmV0dXJuVHlwZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YoYXN5bmNoKSAhPT0gJ251bWJlcicpIHtcclxuICAgICAgICAgIC8vIG5vIGFzeW5jaCBwYXJhbWV0ZXJcclxuICAgICAgICAgIHJldHVyblR5cGUgPSBhcmdzO1xyXG4gICAgICAgICAgYXJncyA9IG1lc3NhZ2U7XHJcbiAgICAgICAgICBtZXNzYWdlID0gYXN5bmNoO1xyXG4gICAgICAgICAgYXN5bmNoID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFyZ3MgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgYXJncyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xyXG4gICAgICAgIC8vIERFQlVHOiBpZiAodHlwZW9mKG1lc3NhZ2UpICE9IFwic3RyaW5nXCIgfHwgIShtZXNzYWdlLm1hdGNoKC9tb3VzZS8pIHx8IG1lc3NhZ2UgPT0gXCJoaWRlQ29tbWVudFwiKSkgY29uc29sZS5sb2cobWVzc2FnZSwgYXJncyk7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YobWVzc2FnZSkgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgIC8vIHNvbWVvbmUgd2FzIGxhenkgYW5kIHNlbnQgYSBzaW1wbGUgZnVuY3Rpb25cclxuICAgICAgICAgIHZhciBob3N0ID0gYXJndW1lbnRzLmNhbGxlZS5jYWxsZXI7XHJcbiAgICAgICAgICBpZiAoYXN5bmNoICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgLyp0cnkgeyovXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmFwcGx5KGhvc3QsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgIC8qfSBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0LmhhbmRsZUFzeW5jaEVycm9yKGUpO1xyXG4gICAgICAgICAgICAgIH0qL1xyXG4gICAgICAgICAgICB9LCBhc3luY2gpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gbWVzc2FnZS5hcHBseShob3N0LCBhcmdzKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBhIHByb3BlciBtZXNzYWdlLCBwcm9wYWdhdGUgdG8gYWxsIGludGVyZXN0ZWQgcGFydGllc1xyXG4gICAgICAgICAgdmFyIHRvZG8gPSB0YWJsZVttZXNzYWdlXTtcclxuICAgICAgICAgIGlmICh0b2RvICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgJC5lYWNoKHRvZG8sIGZ1bmN0aW9uKGl0ZW1ObywgaXRlbSkge1xyXG4gICAgICAgICAgICAgIHZhciByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgaWYgKGFzeW5jaCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgLyp0cnkgeyovXHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbVsxXS5hcHBseShpdGVtWzBdLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgLyp9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5oYW5kbGVBc3luY2hFcnJvcihlKTtcclxuICAgICAgICAgICAgICAgICAgfSovXHJcbiAgICAgICAgICAgICAgICB9LCBhc3luY2gpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpdGVtWzFdLmFwcGx5KGl0ZW1bMF0sIGFyZ3MpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcclxuICAgICAgICAgICAgfSk7XHJcbi8qIERFQlVHXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ01lc3NhZ2UgJyArIG1lc3NhZ2UgKyAnIGhhcyBubyBzdWJzY3JpYmVycy4nKTsgLy8gREVCVUdcclxuKi9cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJldHVyblR5cGUgPT0gJ2FueScpIHtcclxuICAgICAgICAgIHZhciBpID0gcmVzdWx0cy5sZW5ndGg7XHJcbiAgICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHRzW2ldICE9PSBmYWxzZSkgcmV0dXJuIHJlc3VsdHNbaV07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXR1cm5UeXBlID09ICdhbGwnKSB7XHJcbiAgICAgICAgICB2YXIgaSA9IHJlc3VsdHMubGVuZ3RoO1xyXG4gICAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0c1tpXSA9PT0gZmFsc2UpIHJldHVybiByZXN1bHRzW2ldO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciBwcm94eSA9IGZ1bmN0aW9uKGRlc3RpbmF0aW9uLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgdGhpcy5vbihtZXNzYWdlLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGRlc3RpbmF0aW9uLnBvc3QobWVzc2FnZSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IHtcclxuICAgICAgICBvbjogb24sXHJcbiAgICAgICAgcG9zdDogcG9zdCxcclxuICAgICAgICBwcm94eTogcHJveHksXHJcbiAgICAgIH07XHJcbiAgICAgIERpc3BhdGNoZXIuZGlzcGF0Y2hlcnMucHVzaChkaXNwYXRjaGVyKTtcclxuICAgICAgcmV0dXJuIGRpc3BhdGNoZXI7XHJcbiAgICB9O1xyXG5cclxuICAgIERpc3BhdGNoZXIuZGlzcGF0Y2hlcnMgPSBbXTtcclxuICAgIERpc3BhdGNoZXIucG9zdCA9IGZ1bmN0aW9uKGFzeW5jaCwgbWVzc2FnZSwgYXJncywgcmV0dXJuVHlwZSkge1xyXG4gICAgICAkLmVhY2goRGlzcGF0Y2hlci5kaXNwYXRjaGVycywgZnVuY3Rpb24oZGlzcGF0Y2hlck5vLCBkaXNwYXRjaGVyKSB7XHJcbiAgICAgICAgZGlzcGF0Y2hlci5wb3N0KGFzeW5jaCwgbWVzc2FnZSwgYXJncywgcmV0dXJuVHlwZSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gRGlzcGF0Y2hlcjtcclxufSkoalF1ZXJ5LCB3aW5kb3cpO1xyXG5cclxuLy8gQlJBVCBTVEFOREFMT05FIExJQlJBUlkgQkVHSU5cclxuLy8gQnJvd3NlcmlmeSBleHBvcnRcclxubW9kdWxlLmV4cG9ydHMgPSBEaXNwYXRjaGVyO1xyXG4vLyBCUkFUIFNUQU5EQUxPTkUgTElCUkFSWSBFTkRcclxuIiwidmFyIExvY2FsQWpheCA9IChmdW5jdGlvbigkLCB3aW5kb3csIHVuZGVmaW5lZCkge1xyXG4gICAgdmFyIExvY2FsQWpheCA9IGZ1bmN0aW9uKGRpc3BhdGNoZXIsIG1heEZyYWdtZW50TGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuICAgICAgICB2YXIgZmluZFR5cGUgPSBmdW5jdGlvbiAoZW50aXR5VHlwZXMsIHR5cGUpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRpdHlUeXBlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVudGl0eVR5cGUgPSBlbnRpdHlUeXBlc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChlbnRpdHlUeXBlLnR5cGUgPT09IHR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW50aXR5VHlwZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudGl0eVR5cGUuY2hpbGRyZW4gJiYgZW50aXR5VHlwZS5jaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGZpbmRUeXBlKGVudGl0eVR5cGUuY2hpbGRyZW4sIHR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdmFyIGNyZWF0ZUFubm90YXRpb24gPSBmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgdmFyIGF0dHJzID0gSlNPTi5wYXJzZShkYXRhLmF0dHJpYnV0ZXMpLFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0cyA9IEpTT04ucGFyc2UoZGF0YS5vZmZzZXRzKSxcclxuICAgICAgICAgICAgICAgIGVfdHlwZSA9IGZpbmRUeXBlKGRhdGEuY29sbGVjdGlvbi5lbnRpdHlfdHlwZXMsIGRhdGEudHlwZSk7XHJcbiAgICAgICAgICAgICAgICBlX2lkID0gXCJcIjsvL0VudGl0eSBvciBUcmlnZ2VyXHJcbiAgICAgICAgICAgIGlmKCFlX3R5cGUpe1xyXG4gICAgICAgICAgICAgICAgLy9UcmlnZ2VyXHJcbiAgICAgICAgICAgICAgICBlX3R5cGUgPSBkYXRhLmNvbGxlY3Rpb24uZXZlbnRfdHlwZXMuZmluZCggeCA9PiB4LnR5cGUgPT09IGRhdGEudHlwZSApO1xyXG4gICAgICAgICAgICAgICAgaWYoZV90eXBlKXtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHJpZ2dlcl9pZCA9IFwiVFwiICsgKHRoYXQuZG9jdW1lbnQudHJpZ2dlcnMubGVuZ3RoICsgMSk7IC8vVE9ETzogbXVzdCBhYnNvbHV0ZWx5IGJlIHVuaXF1ZVxyXG4gICAgICAgICAgICAgICAgICAgIGVfaWQgPSBcIkVcIiArICh0aGF0LmRvY3VtZW50LnRyaWdnZXJzLmxlbmd0aCArIDEpOyAvL1RPRE86IG11c3QgYWJzb2x1dGVseSBiZSB1bmlxdWVcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLmRvY3VtZW50LnRyaWdnZXJzLnB1c2goW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyX2lkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldHNcclxuICAgICAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLmRvY3VtZW50LmV2ZW50cy5wdXNoKFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZV9pZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcl9pZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgW11cclxuICAgICAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICB2YXIgZV9pZCA9IFwiTlwiICsgKHRoYXQuZG9jdW1lbnQuZW50aXRpZXMubGVuZ3RoICsgMSksIC8vVE9ETzogbXVzdCBhYnNvbHV0ZWx5IGJlIHVuaXF1ZVxyXG4gICAgICAgICAgICAgICAgICAgIG5ld19vZmZzZXRzID0gc3BsaXRUb29Mb25nRnJhZ21lbnQob2Zmc2V0cywgZGF0YSwgZV9pZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9FbnRpdHlcclxuICAgICAgICAgICAgICAgIGRhdGEuZG9jdW1lbnQuZW50aXRpZXMucHVzaChbXHJcbiAgICAgICAgICAgICAgICAgICAgZV9pZCxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3X29mZnNldHNcclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcclxuICAgICAgICAgICAgICAgIGlmKGF0dHJzLmhhc093blByb3BlcnR5KGtleSkgJiYgYXR0cnNba2V5XSl7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5kb2N1bWVudC5hdHRyaWJ1dGVzLnB1c2goW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkFcIiArICh0aGF0LmRvY3VtZW50LmF0dHJpYnV0ZXMubGVuZ3RoICsgMSksIC8vVE9ETzogbXVzdCBhYnNvbHV0ZWx5IGJlIHVuaXF1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlX2lkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyc1trZXldXHJcbiAgICAgICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoZGF0YS5jb21tZW50Lmxlbmd0aCl7XHJcbiAgICAgICAgICAgICAgICBkYXRhLmRvY3VtZW50LmNvbW1lbnRzLnB1c2goW1xyXG4gICAgICAgICAgICAgICAgICAgIGVfaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJBbm5vdGF0b3JOb3Rlc1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuY29tbWVudFxyXG4gICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXHJcbiAgICAgICAgICAgICAgICBhY3Rpb246IGRhdGEuYWN0aW9uLFxyXG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICBcInNvdXJjZV9maWxlc1wiOiBkYXRhLmRvY3VtZW50LnNvdXJjZV9maWxlcyxcclxuICAgICAgICAgICAgICAgICAgICBcIm1vZGlmaWNhdGlvbnNcIjogZGF0YS5kb2N1bWVudC5tb2RpZmljYXRpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgIFwibm9ybWFsaXphdGlvbnNcIjogZGF0YS5kb2N1bWVudC5ub3JtYWxpemF0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogZGF0YS5kb2N1bWVudC50ZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgIFwiZW50aXRpZXNcIiA6IGRhdGEuZG9jdW1lbnQuZW50aXRpZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJhdHRyaWJ1dGVzXCI6IGRhdGEuZG9jdW1lbnQuYXR0cmlidXRlcyxcclxuICAgICAgICAgICAgICAgICAgICBcInJlbGF0aW9uc1wiOiBkYXRhLmRvY3VtZW50LnJlbGF0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICBcInRyaWdnZXJzXCI6IGRhdGEuZG9jdW1lbnQudHJpZ2dlcnMsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJldmVudHNcIjogZGF0YS5kb2N1bWVudC5ldmVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJjb21tZW50c1wiOiBkYXRhLmRvY3VtZW50LmNvbW1lbnRzXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWRpdGVkOiBbW2VfaWRdXSxcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzOiBbXSxcclxuICAgICAgICAgICAgICAgIHByb3RvY29sOiAxXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gVmFsaWRhdGUgbWF4IGZyYWdtZW50IGxlbmd0aCBiYXNlZCBvbiBvcHRpb25zLm1heEZyYWdtZW50TGVuZ3RoXHJcbiAgICAgICAgLy8gVXNlIGRpc2NvbnRpbmd1aXR5IHRvIGZpeCBsb25nIGFubm90YXRpb25zIGdsaXRjaGVzIGJlZm9yZSBjYWxsaW5nIEJSQVQgcmVuZGVyaW5nIGVuZ2luZS5cclxuICAgICAgICB2YXIgc3BsaXRUb29Mb25nRnJhZ21lbnQgPSBmdW5jdGlvbihvZmZzZXRzLCBkYXRhLCBlX2lkKXtcclxuICAgICAgICAgICAgdmFyIG5ld19vZmZzZXRzID0gW107XHJcblxyXG4gICAgICAgICAgICBpZihtYXhGcmFnbWVudExlbmd0aCA+IDAgJiYgb2Zmc2V0cy5maW5kKCB4ID0+ICh4WzFdIC0geFswXSkgPiBtYXhGcmFnbWVudExlbmd0aCkpe1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0cy5mb3JFYWNoKGZ1bmN0aW9uKGZyYWdtZW50KXtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZnJvbSA9IGZyYWdtZW50WzBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0byA9IGZyYWdtZW50WzFdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJ0ZXh0ID0gZGF0YS5kb2N1bWVudC50ZXh0LnN1YnN0cmluZyhmcm9tLCB0byk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHRvIC0gZnJvbSA+IG1heEZyYWdtZW50TGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcm9tX2VuZCA9IGZyb20gKyAoc3VidGV4dC5pbmRleE9mKCcgJykpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9fc3RhcnQgPSB0byAtIChzdWJ0ZXh0Lmxlbmd0aCAtIChzdWJ0ZXh0Lmxhc3RJbmRleE9mKCcgJykgKyAxKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld19vZmZzZXRzLnB1c2goW2Zyb20sIGZyb21fZW5kIF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdfb2Zmc2V0cy5wdXNoKFt0b19zdGFydCwgdG9dKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBzcGVjaWFsIGF0dHJpYnV0ZSBmb3Igc3ltYm9saWMgcmVwcmVzZW50YXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5kb2N1bWVudC5hdHRyaWJ1dGVzLnB1c2goW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJBXCIgKyAodGhhdC5kb2N1bWVudC5hdHRyaWJ1dGVzLmxlbmd0aCArIDEpLCAvL1RPRE86IG11c3QgYWJzb2x1dGVseSBiZSB1bmlxdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMT05HX0FOTk9UQVRJT05fQ09OU1QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlX2lkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2Zyb20sdG9dXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdfb2Zmc2V0cy5wdXNoKFtmcm9tLCB0byBdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICBuZXdfb2Zmc2V0cyA9IG9mZnNldHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ld19vZmZzZXRzO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciBlZGl0QW5ub3RhdGlvbiA9IGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICB2YXIgZV90eXBlID0ge30sIC8vRW50aXR5IG9yIFRyaWdnZXJcclxuICAgICAgICAgICAgICAgIGF0dHJzID0gSlNPTi5wYXJzZShkYXRhLmF0dHJpYnV0ZXMpLFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0cyA9IEpTT04ucGFyc2UoZGF0YS5vZmZzZXRzKTtcclxuXHJcbiAgICAgICAgICAgIC8vRWRpdCBhbm5vdGF0aW9uIFRPRE86IFZhbGlkYXRpb24gaXMgYmFzZWQgb24gaWQsIGZpeCB0aGlzXHJcbiAgICAgICAgICAgIGlmKGRhdGEuaWQuc3Vic3RyaW5nKDAsIDEpID09IFwiRVwiKXtcclxuICAgICAgICAgICAgICAgIC8vRXZlbnQgYW5ub3RhdGlvblxyXG4gICAgICAgICAgICAgICAgLy9kYXRhLm5vcm1hbGlzYXRpb25zID8/XHJcbiAgICAgICAgICAgICAgICB2YXIgYW5ub3RhdGlvbiA9IGRhdGEuZG9jdW1lbnQuZXZlbnRzLmZpbmQoIHggPT4geFswXSA9PT0gZGF0YS5pZCApO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRyaWdnZXJfaWQgPSBhbm5vdGF0aW9uWzFdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRyaWdnZXIgPSBkYXRhLmRvY3VtZW50LnRyaWdnZXJzLmZpbmQoIHggPT4geFswXSA9PT0gdHJpZ2dlcl9pZCApO1xyXG4gICAgICAgICAgICAgICAgdHJpZ2dlclsxXSA9IGRhdGEudHlwZTtcclxuICAgICAgICAgICAgICAgIHRyaWdnZXJbMl0gPSBvZmZzZXRzO1xyXG4gICAgICAgICAgICAgICAgZV90eXBlID0gZGF0YS5jb2xsZWN0aW9uLmV2ZW50X3R5cGVzLmZpbmQoIHggPT4geC50eXBlID09PSBkYXRhLnR5cGUgKTtcclxuICAgICAgICAgICAgfWVsc2UgaWYoZGF0YS5pZC5zdWJzdHJpbmcoMCwgMSkgPT0gXCJOXCIpe1xyXG4gICAgICAgICAgICAgICAgLy9FbnRpdHkgYW5ub3RhdGlvblxyXG4gICAgICAgICAgICAgICAgdmFyIGVudGl0eSA9IGRhdGEuZG9jdW1lbnQuZW50aXRpZXMuZmluZCggeCA9PiB4WzBdID09PSBkYXRhLmlkICk7XHJcbiAgICAgICAgICAgICAgICBlbnRpdHlbMV0gPSBkYXRhLnR5cGU7XHJcbiAgICAgICAgICAgICAgICBlbnRpdHlbMl0gPSBzcGxpdFRvb0xvbmdGcmFnbWVudChvZmZzZXRzLCBkYXRhLCBkYXRhLmlkKTtcclxuICAgICAgICAgICAgICAgIGVfdHlwZSA9IGZpbmRUeXBlKGRhdGEuY29sbGVjdGlvbi5lbnRpdHlfdHlwZXMsIGRhdGEudHlwZSk7XHJcblxyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIC8vVE9ETzogRXJyb3JcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihlX3R5cGUpe1xyXG4gICAgICAgICAgICAgICAgLy9SZW1vdmVkIGFsbCBhdHRyaWJ1dGVzIGZvciB0aGlzIHBhcnRpY3VsYXIgYW5ub3RhdGlvbiBpZFxyXG4gICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nX2F0dHJzID0gZGF0YS5kb2N1bWVudC5hdHRyaWJ1dGVzLmZpbHRlciggeCA9PiB4WzJdID09PSBkYXRhLmlkKTtcclxuICAgICAgICAgICAgICAgIGV4aXN0aW5nX2F0dHJzLmZvckVhY2goZnVuY3Rpb24oYXR0cil7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gZGF0YS5kb2N1bWVudC5hdHRyaWJ1dGVzLmluZGV4T2YoIHggPT4geFswXSA9PT0gYXR0clswXSk7IC8vVE9ETzogdGhpcyBhbHdheXMgcmV0dXJucyAtMVxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZG9jdW1lbnQuYXR0cmlidXRlcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9SZS1hZGQgYWxsIGF0dHJpYnV0ZXNcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBhdHRycykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGF0dHJzLmhhc093blByb3BlcnR5KGtleSkgJiYgYXR0cnNba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ19hdHRycy5maW5kKHggPT4geFsxXSA9PT0ga2V5KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuZG9jdW1lbnQuYXR0cmlidXRlcy5wdXNoKFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQVwiICsgKHRoYXQuZG9jdW1lbnQuYXR0cmlidXRlcy5sZW5ndGggKyAxKSwgLy9UT0RPOiBtdXN0IGFic29sdXRlbHkgYmUgdW5pcXVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5pZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzW2tleV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vQWRkL0VkaXQgY29tbWVudCBjb250ZW50XHJcbiAgICAgICAgICAgICAgICBpZihkYXRhLmNvbW1lbnQubGVuZ3RoKXtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWVudCA9IGRhdGEuZG9jdW1lbnQuY29tbWVudHMuZmluZCggeCA9PiB4WzBdID09PSBkYXRhLmlkKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihjb21tZW50KXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9FZGl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRbMl0gPSBkYXRhLmNvbW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vQWRkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuZG9jdW1lbnQuY29tbWVudHMucHVzaChbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJBbm5vdGF0b3JOb3Rlc1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5jb21tZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vQ29tbWVudHMgJiYgQXR0cmlidXRlcyBhcmUgZGVhY3RpdmF0ZWQgZm9yIHJlbGF0aW9ucyBhdCB0aGlzIHBvaW50XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogZGF0YS5hY3Rpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJzb3VyY2VfZmlsZXNcIjogZGF0YS5kb2N1bWVudC5zb3VyY2VfZmlsZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibW9kaWZpY2F0aW9uc1wiOiBkYXRhLmRvY3VtZW50Lm1vZGlmaWNhdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibm9ybWFsaXphdGlvbnNcIjogZGF0YS5kb2N1bWVudC5ub3JtYWxpemF0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IGRhdGEuZG9jdW1lbnQudGV4dCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJlbnRpdGllc1wiIDogZGF0YS5kb2N1bWVudC5lbnRpdGllcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJhdHRyaWJ1dGVzXCI6IGRhdGEuZG9jdW1lbnQuYXR0cmlidXRlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJyZWxhdGlvbnNcIjogZGF0YS5kb2N1bWVudC5yZWxhdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHJpZ2dlcnNcIjogZGF0YS5kb2N1bWVudC50cmlnZ2VycyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJldmVudHNcIjogZGF0YS5kb2N1bWVudC5ldmVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiY29tbWVudHNcIjogZGF0YS5kb2N1bWVudC5jb21tZW50c1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgZWRpdGVkOiBbW2RhdGEuaWRdXSxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2w6IDFcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9OyAvL1RPRE86IEVycm9yIGhhbmRsaW5nXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdmFyIGRlbGV0ZUFubm90YXRpb24gPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICAvLyBkZWxldGUgdGhlIGVudGl0eS4gVE9ETzogYWxzbyBkZWxldGUgZXZlbnRzIGV0Y1xyXG4gICAgICAgICAgICB2YXIgZW50aXRpZXMgPSBkYXRhLmRvY3VtZW50LmVudGl0aWVzO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVudGl0aWVzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgICAgIGlmIChlbnRpdGllc1tpXVswXSA9PT0gZGF0YS5pZCl7ICAvLyBlbnRpdHkgZm9ybWF0IFtpZCwgdHlwZSwgb2Zmc2V0c10sIGUuZy4gW1wiTjFcIiwgXCJQZXJzb25cIiwgQXJyYXlbMl1dXHJcbiAgICAgICAgICAgICAgICAgICAgZW50aXRpZXMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGRlbGV0ZSByZWxhdGlvbnMgY29udGFpbmluZyB0aGUgZW50aXR5IFRPRE86IGF0dHJpYnV0ZXMgZXRjP1xyXG4gICAgICAgICAgICB2YXIgcmVsYXRpb25zID0gZGF0YS5kb2N1bWVudC5yZWxhdGlvbnM7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSByZWxhdGlvbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pe1xyXG4gICAgICAgICAgICAgICAgLy8gcmVsYXRpb24gZm9ybWF0OiBbXCJSMVwiLCBcIkZyaWVuZFwiLCBBcnJheVsyXV1cclxuICAgICAgICAgICAgICAgIHZhciByZWxhdGlvbiA9IHJlbGF0aW9uc1tpXVsyXTsgIC8vIGUuZy4gW1snRnJvbScsIFwiTjFcIl0sIFsnVG8nLCAnTjInXV1cclxuICAgICAgICAgICAgICAgIGlmIChyZWxhdGlvblswXVsxXSA9PT0gZGF0YS5pZCB8fCByZWxhdGlvblsxXVsxXSA9PT0gZGF0YS5pZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRpb25zLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IGRhdGEuYWN0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIGFubm90YXRpb25zOiBkYXRhLmRvY3VtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIGVkaXRlZDogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIHByb3RvY29sOiAxXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciBjcmVhdGVSZWxhdGlvbiA9IGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICB2YXIgZV90eXBlID0gZGF0YS5jb2xsZWN0aW9uLnJlbGF0aW9uX3R5cGVzLmZpbmQoIHggPT4geC50eXBlID09PSBkYXRhLnR5cGUgKTsgLy9FbnRpdHkgb3IgRXZlbnRcclxuXHJcbiAgICAgICAgICAgIGlmKCFlX3R5cGUpe1xyXG4gICAgICAgICAgICAgICAgLy9FdmVudCByZWxhdGlvblxyXG4gICAgICAgICAgICAgICAgLypkYXRhLmNvbGxlY3Rpb24uZXZlbnRfdHlwZXMuZm9yRWFjaChmdW5jdGlvbihldmVudCl7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGVSZWxhdGlvbil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGVSZWxhdGlvbi50eXBlID09PSBkYXRhLnR5cGUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZV90eXBlID0gZXZlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE86IEV4aXQgbG9vcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIH0pOyovXHJcbiAgICAgICAgICAgICAgICBlX3R5cGUgPSBkYXRhLmRvY3VtZW50LmV2ZW50cy5maW5kKCB4ID0+IHhbMF0gPT09IGRhdGEub3JpZ2luICk7XHJcbiAgICAgICAgICAgICAgICBpZihlX3R5cGUpe1xyXG4gICAgICAgICAgICAgICAgICAgIGVfdHlwZVsyXS5wdXNoKFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnRhcmdldFxyXG4gICAgICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIC8vRW50aXR5IHJlbGF0aW9uXHJcbiAgICAgICAgICAgICAgICB2YXIgb2JqID1cclxuICAgICAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgICAgICBcIlJcIiArICh0aGF0LmRvY3VtZW50LnJlbGF0aW9ucy5sZW5ndGggKyAxKSwgLy9UT0RPOiBtdXN0IGFic29sdXRlbHkgbWUgdW5pcXVlXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS50eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgW2VfdHlwZS5hcmdzWzBdLnJvbGUsIGRhdGEub3JpZ2luXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgW2VfdHlwZS5hcmdzWzFdLnJvbGUsIGRhdGEudGFyZ2V0XV1cclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICBkYXRhLmRvY3VtZW50LnJlbGF0aW9ucy5wdXNoKG9iaik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGFjdGlvbjogZGF0YS5hY3Rpb24sXHJcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgICAgIFwic291cmNlX2ZpbGVzXCI6IGRhdGEuZG9jdW1lbnQuc291cmNlX2ZpbGVzLFxyXG4gICAgICAgICAgICAgICAgICAgIFwibW9kaWZpY2F0aW9uc1wiOiBkYXRhLmRvY3VtZW50Lm1vZGlmaWNhdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJub3JtYWxpemF0aW9uc1wiOiBkYXRhLmRvY3VtZW50Lm5vcm1hbGl6YXRpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBkYXRhLmRvY3VtZW50LnRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJlbnRpdGllc1wiIDogZGF0YS5kb2N1bWVudC5lbnRpdGllcyxcclxuICAgICAgICAgICAgICAgICAgICBcImF0dHJpYnV0ZXNcIjogZGF0YS5kb2N1bWVudC5hdHRyaWJ1dGVzLFxyXG4gICAgICAgICAgICAgICAgICAgIFwicmVsYXRpb25zXCI6IGRhdGEuZG9jdW1lbnQucmVsYXRpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidHJpZ2dlcnNcIjogZGF0YS5kb2N1bWVudC50cmlnZ2VycyxcclxuICAgICAgICAgICAgICAgICAgICBcImV2ZW50c1wiOiBkYXRhLmRvY3VtZW50LmV2ZW50c1xyXG4gICAgICAgICAgICAgICAgICAgIC8vXCJjdGltZVwiOiAxLjAsXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cImNvbGxlY3Rpb25cIjogXCJcIixcclxuICAgICAgICAgICAgICAgICAgICAvL1wiZG9jdW1lbnRcIjogXCJcIixcclxuICAgICAgICAgICAgICAgICAgICAvL1wiZXF1aXZzXCI6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vXCJtdGltZVwiOiAxLjAsXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cInNlbnRlbmNlc19vZmZzZXRzXCI6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vXCJ0b2tlbl9vZmZzZXRzXCI6IFtdLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVkaXRlZDogW1tkYXRhLm9yaWdpbl0sIFtkYXRhLnRhcmdldF1dLFxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgcHJvdG9jb2w6IDFcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB2YXIgZWRpdFJlbGF0aW9uID0gZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIHZhciBlX3R5cGUgPSBkYXRhLmNvbGxlY3Rpb24ucmVsYXRpb25fdHlwZXMuZmluZCggeCA9PiB4LnR5cGUgPT09IGRhdGEudHlwZSApOyAvL0VudGl0eSBvciBFdmVudFxyXG5cclxuICAgICAgICAgICAgaWYoIWVfdHlwZSl7XHJcbiAgICAgICAgICAgICAgICAvL0V2ZW50IHJlbGF0aW9uXHJcbiAgICAgICAgICAgICAgICBlX3R5cGUgPSBkYXRhLmRvY3VtZW50LmV2ZW50cy5maW5kKCB4ID0+IHhbMF0gPT09IGRhdGEub3JpZ2luICk7XHJcbiAgICAgICAgICAgICAgICBpZihlX3R5cGUpe1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAvL0VudGl0eSByZWxhdGlvblxyXG4gICAgICAgICAgICAgICAgdmFyIHJlbGF0aW9uID0gZGF0YS5kb2N1bWVudC5yZWxhdGlvbnMuZmluZCggeCA9PiB4WzFdID09PSBkYXRhLm9sZF90eXBlICYmIHhbMl1bMF1bMV0gPT09IGRhdGEub3JpZ2luICYmIHhbMl1bMV1bMV0gPT09IGRhdGEub2xkX3RhcmdldCApO1xyXG4gICAgICAgICAgICAgICAgcmVsYXRpb25bMV0gPSBkYXRhLnR5cGU7XHJcbiAgICAgICAgICAgICAgICByZWxhdGlvblsyXSA9IFtcclxuICAgICAgICAgICAgICAgICAgICBbZV90eXBlLmFyZ3NbMF0ucm9sZSwgZGF0YS5vcmlnaW5dLFxyXG4gICAgICAgICAgICAgICAgICAgIFtlX3R5cGUuYXJnc1sxXS5yb2xlLCBkYXRhLnRhcmdldF1cclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBhY3Rpb246IGRhdGEuYWN0aW9uLFxyXG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICBcInNvdXJjZV9maWxlc1wiOiBkYXRhLmRvY3VtZW50LnNvdXJjZV9maWxlcyxcclxuICAgICAgICAgICAgICAgICAgICBcIm1vZGlmaWNhdGlvbnNcIjogZGF0YS5kb2N1bWVudC5tb2RpZmljYXRpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgIFwibm9ybWFsaXphdGlvbnNcIjogZGF0YS5kb2N1bWVudC5ub3JtYWxpemF0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogZGF0YS5kb2N1bWVudC50ZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgIFwiZW50aXRpZXNcIiA6IGRhdGEuZG9jdW1lbnQuZW50aXRpZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJhdHRyaWJ1dGVzXCI6IGRhdGEuZG9jdW1lbnQuYXR0cmlidXRlcyxcclxuICAgICAgICAgICAgICAgICAgICBcInJlbGF0aW9uc1wiOiBkYXRhLmRvY3VtZW50LnJlbGF0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICBcInRyaWdnZXJzXCI6IGRhdGEuZG9jdW1lbnQudHJpZ2dlcnMsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJldmVudHNcIjogZGF0YS5kb2N1bWVudC5ldmVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJjb21tZW50c1wiOiBkYXRhLmRvY3VtZW50LmNvbW1lbnRzXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWRpdGVkOiBbW2RhdGEub3JpZ2luXSwgW2RhdGEudGFyZ2V0XV0sXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlczogW10sXHJcbiAgICAgICAgICAgICAgICBwcm90b2NvbDogMVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB2YXIgbG9jYWxFeGVjdXRpb24gPSBmdW5jdGlvbihkYXRhLCBjYWxsYmFjaywgbWVyZ2UpIHtcclxuICAgICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdzcGluJyk7XHJcbiAgICAgICAgICAgIGRpc3BhdGNoZXIucG9zdCgnbG9jYWwtYWpheC1iZWdpbicsIFtkYXRhXSk7XHJcbiAgICAgICAgICAgIHRoYXQuY29sbGVjdGlvbiA9IGRhdGEuY29sbGVjdGlvbjtcclxuICAgICAgICAgICAgdGhhdC5kb2N1bWVudCA9IGRhdGEuZG9jdW1lbnQ7XHJcbiAgICAgICAgICAgIHZhciByZXNwb25zZSA9IHt9O1xyXG5cclxuICAgICAgICAgICAgc3dpdGNoKGRhdGEuYWN0aW9uKXtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJnZXREb2N1bWVudFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vVE9ET1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImxvYWRDb25mXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0Q29sbGVjdGlvbkluZm9ybWF0aW9uXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiY3JlYXRlQXJjXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPOiBWYWxpZGF0ZSBtb2RlbCB3aXRoIGlucHV0c1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGRhdGEub2xkX3RhcmdldCB8fCBkYXRhLm9sZF90eXBlKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBlZGl0UmVsYXRpb24oZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gY3JlYXRlUmVsYXRpb24oZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImRlbGV0ZUFyY1wiOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vVE9ET1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInJldmVyc2VBcmNcIjpcclxuICAgICAgICAgICAgICAgICAgICAvL1RPRE9cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJjcmVhdGVTcGFuXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgLy9FZGl0IGFuZCBDcmVhdGVkIGFjdGlvbnMgb24gRW50aXRpZXMgYXMgd2VsbCBhcyBUcmlnZ2VycyhFdmVudHMpXHJcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPOiBWYWxpZGF0ZSBtb2RlbCB3aXRoIGlucHV0c1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGRhdGEuaWQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGVkaXRBbm5vdGF0aW9uKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGNyZWF0ZUFubm90YXRpb24oZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImRlbGV0ZVNwYW5cIjpcclxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGRlbGV0ZUFubm90YXRpb24oZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiZGVsZXRlRnJhZ21lbnR4eXo/XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwic3BsaXRTcGFuXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwidGFnXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPID8/XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbjogZGF0YS5jb2xsZWN0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudDogZGF0YS5kb2N1bWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnZ2VyOiBkYXRhLnRhZ2dlclxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwibG9naW5cIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJsb2dvdXRcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJ3aG9hbWlcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJub3JtR2V0TmFtZVwiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcIm5vcm1TZWFyY2hcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJzdWdnZXN0U3BhblR5cGVzXCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiaW1wb3J0RG9jdW1lbnRcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJkZWxldGVEb2N1bWVudFwiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcImRlbGV0ZUNvbGxlY3Rpb25cIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJ1bmRvXCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwibm9ybURhdGFcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJJbkRvY3VtZW50XCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiSW5Db2xsZWN0aW9uXCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwic3RvcmVTVkdcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJnZXREb2N1bWVudFRpbWVzdGFtcFwiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcInNhdmVDb25mXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIC8vVE9ET1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoMCwgY2FsbGJhY2ssIFtyZXNwb25zZV0pO1xyXG4gICAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ2xvY2FsLWFqYXgtZG9uZScsIFtyZXNwb25zZV0pO1xyXG4gICAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ3Vuc3BpbicpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGRpc3BhdGNoZXIuXHJcbiAgICAgICAgb24oJ2FqYXgnLCBsb2NhbEV4ZWN1dGlvbik7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBMb2NhbEFqYXg7XHJcbn0pKGpRdWVyeSwgd2luZG93KTtcclxuXHJcbi8vIEJSQVQgU1RBTkRBTE9ORSBMSUJSQVJZIEJFR0lOXHJcbi8vIEJyb3dzZXJpZnkgZXhwb3J0XHJcbm1vZHVsZS5leHBvcnRzID0gTG9jYWxBamF4O1xyXG4vLyBCUkFUIFNUQU5EQUxPTkUgTElCUkFSWSBFTkRcclxuIiwiLy8gLSotIE1vZGU6IEphdmFTY3JpcHQ7IHRhYi13aWR0aDogMjsgaW5kZW50LXRhYnMtbW9kZTogbmlsOyAtKi1cclxuLy8gdmltOnNldCBmdD1qYXZhc2NyaXB0IHRzPTIgc3c9MiBzdHM9MiBjaW5kZW50OlxyXG52YXIgU3Bpbm5lciA9IChmdW5jdGlvbigkLCB3aW5kb3csIHVuZGVmaW5lZCkge1xyXG4gICAgdmFyIFNwaW5uZXIgPSBmdW5jdGlvbihkaXNwYXRjaGVyLCBzcGluRWxlbWVudCkge1xyXG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgIHZhciBzcGluRWxlbWVudCA9ICQoc3BpbkVsZW1lbnQpO1xyXG5cclxuICAgICAgdmFyIGNvdW50ID0gMDtcclxuICAgICAgdmFyIHNwaW4gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoY291bnQgPT09IDApIHtcclxuICAgICAgICAgIHNwaW5FbGVtZW50LmNzcygnZGlzcGxheScsICdibG9jaycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb3VudCsrO1xyXG4gICAgICB9O1xyXG4gICAgICB2YXIgdW5zcGluID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgY291bnQtLTtcclxuICAgICAgICBpZiAoY291bnQgPT09IDApIHtcclxuICAgICAgICAgIHNwaW5FbGVtZW50LmNzcygnZGlzcGxheScsICdub25lJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgZGlzcGF0Y2hlci5cclxuICAgICAgICAgIG9uKCdzcGluJywgc3BpbikuXHJcbiAgICAgICAgICBvbigndW5zcGluJywgdW5zcGluKTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIFNwaW5uZXI7XHJcbn0pKGpRdWVyeSwgd2luZG93KTtcclxuXHJcbi8vIEJSQVQgU1RBTkRBTE9ORSBMSUJSQVJZIEJFR0lOXHJcbi8vIEJyb3dzZXJpZnkgZXhwb3J0XHJcbm1vZHVsZS5leHBvcnRzID0gU3Bpbm5lcjtcclxuLy8gQlJBVCBTVEFOREFMT05FIExJQlJBUlkgRU5EXHJcbiIsInZhciBVUkxIYXNoID0gKGZ1bmN0aW9uKCQsIHdpbmRvdywgdW5kZWZpbmVkKSB7XHJcbiAgICB2YXIgVVJMSGFzaCA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIF9kb2N1bWVudCwgX2FyZ3VtZW50cykge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB0aGF0LmNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xyXG4gICAgICAgIHRoYXQuZG9jdW1lbnQgPSBfZG9jdW1lbnQgfHwgJyc7XHJcbiAgICAgICAgdGhhdC5hcmd1bWVudHMgPSBfYXJndW1lbnRzIHx8IHt9O1xyXG4gICAgICAgIHRoYXQuY2FsY0FyZ3MoKTtcclxuICAgIH1cclxuXHJcbiAgICBVUkxIYXNoLnByb3RvdHlwZSA9IHtcclxuICAgICAgICBjYWxjQXJnczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gVVJMSGFzaC5zcGxpdEFyZ3ModGhpcy5hcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLmludEFyZ3VtZW50cyA9IGFyZ3NbMF07XHJcbiAgICAgICAgICAgIHRoaXMuZXh0QXJndW1lbnRzID0gYXJnc1sxXTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXRBcmd1bWVudDogZnVuY3Rpb24oYXJndW1lbnQsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5hcmd1bWVudHMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXJndW1lbnRzID0ge307XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5hcmd1bWVudHNbYXJndW1lbnRdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsY0FyZ3MoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0QXJndW1lbnRzOiBmdW5jdGlvbihfYXJndW1lbnRzKSB7XHJcbiAgICAgICAgICAgIC8vIHRoZSAkLmV4dGVuZCBoZXJlIGJhc2ljYWxseSB0YWtlcyBhIGNvcHk7IHJhdyBhc3NpZ25tZW50XHJcbiAgICAgICAgICAgIC8vIHdvdWxkIGFsbG93IGNoYW5nZXMgb2YgdGhlIGFyZ3MgdG8gYWx0ZXIgb3JpZ2luYWwsIHdoaWNoXHJcbiAgICAgICAgICAgIC8vIGNvdWxkIGJlIGUuZy4gdGhlIFwiYXJnc1wiIG9mIHNlYXJjaCByZXN1bHRzXHJcbiAgICAgICAgICAgIHRoaXMuYXJndW1lbnRzID0gJC5leHRlbmQoe30sIF9hcmd1bWVudHMgfHwge30pO1xyXG4gICAgICAgICAgICB0aGlzLmNhbGNBcmdzKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldERvY3VtZW50OiBmdW5jdGlvbihfZG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5kb2N1bWVudCA9IF9kb2N1bWVudDtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0Q29sbGVjdGlvbjogZnVuY3Rpb24oY29sbGVjdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLmNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBnZXRIYXNoOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHVybF9oYXNoID0gdGhpcy5jb2xsZWN0aW9uICsgdGhpcy5kb2N1bWVudDtcclxuXHJcbiAgICAgICAgICAgIHZhciB1cmxfYXJncyA9IFV0aWwucGFyYW0odGhpcy5leHRBcmd1bWVudHMpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHVybF9hcmdzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdXJsX2hhc2ggKz0gJz8nICsgdXJsX2FyZ3M7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh1cmxfaGFzaC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHVybF9oYXNoID0gJyMnICsgdXJsX2hhc2g7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB1cmxfaGFzaDtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBhcmd1bWVudHMgdGhhdCBkbyBub3QgYXBwZWFyIGluIHRoZSBVUkxcclxuICAgIHZhciBJTlRfQVJHUyA9IFsnbWF0Y2gnLCAnbWF0Y2hmb2N1cycsICdlZGl0ZWQnXTtcclxuXHJcbiAgICBVUkxIYXNoLnNwbGl0QXJncyA9IGZ1bmN0aW9uKGFyZ3MpIHtcclxuICAgICAgICB2YXIgaW50QXJncyA9IHt9O1xyXG4gICAgICAgIHZhciBleHRBcmdzID0gJC5leHRlbmQoe30sIGFyZ3MpO1xyXG4gICAgICAgIHZhciBpbnRBcmdOYW1lTGVuID0gSU5UX0FSR1MubGVuZ3RoO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW50QXJnTmFtZUxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGludEFyZ3NbSU5UX0FSR1NbaV1dID0gZXh0QXJnc1tJTlRfQVJHU1tpXV07XHJcbiAgICAgICAgICAgIGRlbGV0ZSBleHRBcmdzW0lOVF9BUkdTW2ldXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtpbnRBcmdzLCBleHRBcmdzXTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gVE9ETzogRG9jdW1lbnQgYW5kIGNvbmZvcm0gdmFyaWFibGVzIHRvIHRoZSByZXN0IG9mIHRoZSBvYmplY3RcclxuICAgIFVSTEhhc2gucGFyc2UgPSBmdW5jdGlvbihoYXNoKSB7XHJcbiAgICAgICAgaWYgKGhhc2gubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbGVhZGluZyBoYXNoICgjKVxyXG4gICAgICAgICAgICBoYXNoID0gaGFzaC5zdWJzdHIoMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcGF0aEFuZEFyZ3MgPSBoYXNoLnNwbGl0KCc/Jyk7XHJcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoQW5kQXJnc1swXSB8fCAnJztcclxuICAgICAgICB2YXIgYXJnc1N0ciA9IHBhdGhBbmRBcmdzWzFdIHx8ICcnO1xyXG4gICAgICAgIHZhciBjb2xsO1xyXG4gICAgICAgIHZhciBzbGFzaFBvcyA9IHBhdGgubGFzdEluZGV4T2YoJy8nKTtcclxuICAgICAgICBpZiAoc2xhc2hQb3MgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIGNvbGwgPSAnLyc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29sbCA9IHBhdGguc3Vic3RyKDAsIHNsYXNoUG9zICsgMSk7XHJcbiAgICAgICAgICAgIGlmIChjb2xsW2NvbGwubGVuZ3RoIC0gMV0gIT09ICcvJykge1xyXG4gICAgICAgICAgICAgICAgY29sbCArPSAnLyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNvbGxbMF0gIT09ICcvJykge1xyXG4gICAgICAgICAgICAgICAgY29sbCA9ICcvJyArIGNvbGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRvYyA9IHBhdGguc3Vic3RyKHNsYXNoUG9zICsgMSk7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBVdGlsLmRlcGFyYW0oYXJnc1N0cik7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVUkxIYXNoKGNvbGwsIGRvYywgYXJncyk7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBVUkxIYXNoO1xyXG59KShqUXVlcnksIHdpbmRvdyk7XHJcblxyXG4vLyBCUkFUIFNUQU5EQUxPTkUgTElCUkFSWSBCRUdJTlxyXG4vLyBCcm93c2VyaWZ5IGV4cG9ydFxyXG5tb2R1bGUuZXhwb3J0cyA9IFVSTEhhc2g7XHJcbi8vIEJSQVQgU1RBTkRBTE9ORSBMSUJSQVJZIEVORFxyXG4iLCIvLyAtKi0gTW9kZTogSmF2YVNjcmlwdDsgdGFiLXdpZHRoOiAyOyBpbmRlbnQtdGFicy1tb2RlOiBuaWw7IC0qLVxyXG4vLyB2aW06c2V0IGZ0PWphdmFzY3JpcHQgdHM9MiBzdz0yIHN0cz0yIGNpbmRlbnQ6XHJcbnZhciBVdGlsID0gKGZ1bmN0aW9uKHdpbmRvdywgdW5kZWZpbmVkKSB7XHJcblxyXG4gICAgdmFyIG1vbnRoTmFtZXMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsICdOb3YnLCAnRGVjJ107XHJcblxyXG4gICAgdmFyIGNtcCA9IGZ1bmN0aW9uKGEsYikge1xyXG4gICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDA7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNtcEFycmF5T25GaXJzdEVsZW1lbnQgPSBmdW5jdGlvbihhLGIpIHtcclxuICAgICAgYSA9IGFbMF07XHJcbiAgICAgIGIgPSBiWzBdO1xyXG4gICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDA7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHVuaXRBZ28gPSBmdW5jdGlvbihuLCB1bml0KSB7XHJcbiAgICAgIGlmIChuID09IDEpIHJldHVybiBcIlwiICsgbiArIFwiIFwiICsgdW5pdCArIFwiIGFnb1wiO1xyXG4gICAgICByZXR1cm4gXCJcIiArIG4gKyBcIiBcIiArIHVuaXQgKyBcInMgYWdvXCI7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBmb3JtYXRUaW1lQWdvID0gZnVuY3Rpb24odGltZSkge1xyXG4gICAgICBpZiAodGltZSA9PSAtMTAwMCkge1xyXG4gICAgICAgIHJldHVybiBcIm5ldmVyXCI7IC8vIEZJWE1FIG1ha2UgdGhlIHNlcnZlciByZXR1cm4gdGhlIHNlcnZlciB0aW1lIVxyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgbm93RGF0ZSA9IG5ldyBEYXRlKCk7XHJcbiAgICAgIHZhciBub3cgPSBub3dEYXRlLmdldFRpbWUoKTtcclxuICAgICAgdmFyIGRpZmYgPSBNYXRoLmZsb29yKChub3cgLSB0aW1lKSAvIDEwMDApO1xyXG4gICAgICBpZiAoIWRpZmYpIHJldHVybiBcImp1c3Qgbm93XCI7XHJcbiAgICAgIGlmIChkaWZmIDwgNjApIHJldHVybiB1bml0QWdvKGRpZmYsIFwic2Vjb25kXCIpO1xyXG4gICAgICBkaWZmID0gTWF0aC5mbG9vcihkaWZmIC8gNjApO1xyXG4gICAgICBpZiAoZGlmZiA8IDYwKSByZXR1cm4gdW5pdEFnbyhkaWZmLCBcIm1pbnV0ZVwiKTtcclxuICAgICAgZGlmZiA9IE1hdGguZmxvb3IoZGlmZiAvIDYwKTtcclxuICAgICAgaWYgKGRpZmYgPCAyNCkgcmV0dXJuIHVuaXRBZ28oZGlmZiwgXCJob3VyXCIpO1xyXG4gICAgICBkaWZmID0gTWF0aC5mbG9vcihkaWZmIC8gMjQpO1xyXG4gICAgICBpZiAoZGlmZiA8IDcpIHJldHVybiB1bml0QWdvKGRpZmYsIFwiZGF5XCIpO1xyXG4gICAgICBpZiAoZGlmZiA8IDI4KSByZXR1cm4gdW5pdEFnbyhNYXRoLmZsb29yKGRpZmYgLyA3KSwgXCJ3ZWVrXCIpO1xyXG4gICAgICB2YXIgdGhlbkRhdGUgPSBuZXcgRGF0ZSh0aW1lKTtcclxuICAgICAgdmFyIHJlc3VsdCA9IHRoZW5EYXRlLmdldERhdGUoKSArICcgJyArIG1vbnRoTmFtZXNbdGhlbkRhdGUuZ2V0TW9udGgoKV07XHJcbiAgICAgIGlmICh0aGVuRGF0ZS5nZXRZZWFyKCkgIT0gbm93RGF0ZS5nZXRZZWFyKCkpIHtcclxuICAgICAgICByZXN1bHQgKz0gJyAnICsgdGhlbkRhdGUuZ2V0RnVsbFllYXIoKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciByZWFsQkJveCA9IGZ1bmN0aW9uKHNwYW4pIHtcclxuICAgICAgdmFyIGJveCA9IHNwYW4ucmVjdC5nZXRCQm94KCk7XHJcbiAgICAgIHZhciBjaHVua1RyYW5zbGF0aW9uID0gc3Bhbi5jaHVuay50cmFuc2xhdGlvbjtcclxuICAgICAgdmFyIHJvd1RyYW5zbGF0aW9uID0gc3Bhbi5jaHVuay5yb3cudHJhbnNsYXRpb247XHJcbiAgICAgIGJveC54ICs9IGNodW5rVHJhbnNsYXRpb24ueCArIHJvd1RyYW5zbGF0aW9uLng7XHJcbiAgICAgIGJveC55ICs9IGNodW5rVHJhbnNsYXRpb24ueSArIHJvd1RyYW5zbGF0aW9uLnk7XHJcbiAgICAgIHJldHVybiBib3g7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGVzY2FwZUhUTUwgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mL2csJyZhbXA7JykucmVwbGFjZSgvPC9nLCcmbHQ7JykucmVwbGFjZSgvPi9nLCcmZ3Q7Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGVzY2FwZUhUTUxhbmRRdW90ZXMgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mL2csJyZhbXA7JykucmVwbGFjZSgvPC9nLCcmbHQ7JykucmVwbGFjZSgvPi9nLCcmZ3Q7JykucmVwbGFjZSgvXFxcIi9nLCcmcXVvdDsnKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZXNjYXBlSFRNTHdpdGhOZXdsaW5lcyA9IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyYvZywnJmFtcDsnKS5yZXBsYWNlKC88L2csJyZsdDsnKS5yZXBsYWNlKC8+L2csJyZndDsnKS5yZXBsYWNlKC9cXG4vZywnPGJyLz4nKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZXNjYXBlUXVvdGVzID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgICAgIC8vIHdlIG9ubHkgdXNlIGRvdWJsZSBxdW90ZXMgZm9yIEhUTUwgYXR0cmlidXRlc1xyXG4gICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcXCIvZywnJnF1b3Q7Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGdldFNwYW5MYWJlbHMgPSBmdW5jdGlvbihzcGFuVHlwZXMsIHNwYW5UeXBlKSB7XHJcbiAgICAgIHZhciB0eXBlID0gc3BhblR5cGVzW3NwYW5UeXBlXTtcclxuICAgICAgcmV0dXJuIHR5cGUgJiYgdHlwZS5sYWJlbHMgfHwgW107XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHNwYW5EaXNwbGF5Rm9ybSA9IGZ1bmN0aW9uKHNwYW5UeXBlcywgc3BhblR5cGUpIHtcclxuICAgICAgdmFyIGxhYmVscyA9IGdldFNwYW5MYWJlbHMoc3BhblR5cGVzLCBzcGFuVHlwZSk7XHJcbiAgICAgIHJldHVybiBsYWJlbHNbMF0gfHwgc3BhblR5cGU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGdldEFyY0xhYmVscyA9IGZ1bmN0aW9uKHNwYW5UeXBlcywgc3BhblR5cGUsIGFyY1R5cGUsIHJlbGF0aW9uVHlwZXNIYXNoKSB7XHJcbiAgICAgIHZhciB0eXBlID0gc3BhblR5cGVzW3NwYW5UeXBlXTtcclxuICAgICAgdmFyIGFyY1R5cGVzID0gdHlwZSAmJiB0eXBlLmFyY3MgfHwgW107XHJcbiAgICAgIHZhciBhcmNEZXNjID0gbnVsbDtcclxuICAgICAgLy8gYWxzbyBjb25zaWRlciBtYXRjaGVzIHdpdGhvdXQgc3VmZml4IG51bWJlciwgaWYgYW55XHJcbiAgICAgIHZhciBub051bUFyY1R5cGU7XHJcbiAgICAgIGlmIChhcmNUeXBlKSB7XHJcbiAgICAgICAgICB2YXIgc3BsaXRUeXBlID0gYXJjVHlwZS5tYXRjaCgvXiguKj8pKFxcZCopJC8pO1xyXG4gICAgICAgICAgbm9OdW1BcmNUeXBlID0gc3BsaXRUeXBlWzFdO1xyXG4gICAgICB9XHJcbiAgICAgICQuZWFjaChhcmNUeXBlcywgZnVuY3Rpb24oYXJjbm8sIGFyY0Rlc2NJKSB7XHJcbiAgICAgICAgaWYgKGFyY0Rlc2NJLnR5cGUgPT0gYXJjVHlwZSB8fCBhcmNEZXNjSS50eXBlID09IG5vTnVtQXJjVHlwZSkge1xyXG4gICAgICAgICAgYXJjRGVzYyA9IGFyY0Rlc2NJO1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIC8vIGZhbGwgYmFjayB0byByZWxhdGlvbiB0eXBlcyBmb3IgdW5jb25maWd1cmVkIG9yIG1pc3NpbmcgZGVmXHJcbiAgICAgIGlmICghYXJjRGVzYykge1xyXG4gICAgICAgIGFyY0Rlc2MgPSAkLmV4dGVuZCh7fSwgcmVsYXRpb25UeXBlc0hhc2hbYXJjVHlwZV0gfHwgcmVsYXRpb25UeXBlc0hhc2hbbm9OdW1BcmNUeXBlXSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGFyY0Rlc2MgJiYgYXJjRGVzYy5sYWJlbHMgfHwgW107XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGFyY0Rpc3BsYXlGb3JtID0gZnVuY3Rpb24oc3BhblR5cGVzLCBzcGFuVHlwZSwgYXJjVHlwZSwgcmVsYXRpb25UeXBlc0hhc2gpIHtcclxuICAgICAgdmFyIGxhYmVscyA9IGdldEFyY0xhYmVscyhzcGFuVHlwZXMsIHNwYW5UeXBlLCBhcmNUeXBlLCByZWxhdGlvblR5cGVzSGFzaCk7XHJcbiAgICAgIHJldHVybiBsYWJlbHNbMF0gfHwgYXJjVHlwZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPOiBzd2l0Y2hpbmcgdG8gdXNlIG9mICQucGFyYW0oKSwgdGhpcyBmdW5jdGlvbiBzaG91bGRcclxuICAgIC8vIGJlIGRlcHJlY2F0ZWQgYW5kIHJlbW92ZWQuXHJcbiAgICB2YXIgb2JqZWN0VG9VcmxTdHIgPSBmdW5jdGlvbihvKSB7XHJcbiAgICAgIGEgPSBbXTtcclxuICAgICAgJC5lYWNoKG8sIGZ1bmN0aW9uKGtleSx2YWx1ZSkge1xyXG4gICAgICAgIGEucHVzaChrZXkrXCI9XCIrZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gYS5qb2luKFwiJlwiKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjb2xvciBuYW1lIFJHQiBsaXN0LCBjb252ZXJ0ZWQgZnJvbVxyXG4gICAgLy8gaHR0cDovL3d3dy53M3NjaG9vbHMuY29tL2h0bWwvaHRtbF9jb2xvcm5hbWVzLmFzcFxyXG4gICAgLy8gd2l0aCBwZXJsIGFzXHJcbiAgICAvLyAgICAgcGVybCAtZSAncHJpbnQgXCJ2YXIgY29sb3JzID0ge1xcblwiOyB3aGlsZSg8PikgeyAvKFxcUyspXFxzK1xcIyhbMC05YS16XXsyfSkoWzAtOWEtel17Mn0pKFswLTlhLXpdezJ9KVxccyovaSBvciBkaWUgXCJGYWlsZWQgdG8gcGFyc2UgJF9cIjsgKCRyLCRnLCRiKT0oaGV4KCQyKSxoZXgoJDMpLGhleCgkNCkpOyBwcmludCBcIiAgICAnXFwnJ1wiLGxjKCQxKSxcIidcXCcnOlxcWyRyLCRnLCRiXFxdLFxcblwiIH0gcHJpbnQgXCJ9O1xcblwiICdcclxuICAgIHZhciBjb2xvcnMgPSB7XHJcbiAgICAgICAgJ2FsaWNlYmx1ZSc6WzI0MCwyNDgsMjU1XSxcclxuICAgICAgICAnYW50aXF1ZXdoaXRlJzpbMjUwLDIzNSwyMTVdLFxyXG4gICAgICAgICdhcXVhJzpbMCwyNTUsMjU1XSxcclxuICAgICAgICAnYXF1YW1hcmluZSc6WzEyNywyNTUsMjEyXSxcclxuICAgICAgICAnYXp1cmUnOlsyNDAsMjU1LDI1NV0sXHJcbiAgICAgICAgJ2JlaWdlJzpbMjQ1LDI0NSwyMjBdLFxyXG4gICAgICAgICdiaXNxdWUnOlsyNTUsMjI4LDE5Nl0sXHJcbiAgICAgICAgJ2JsYWNrJzpbMCwwLDBdLFxyXG4gICAgICAgICdibGFuY2hlZGFsbW9uZCc6WzI1NSwyMzUsMjA1XSxcclxuICAgICAgICAnYmx1ZSc6WzAsMCwyNTVdLFxyXG4gICAgICAgICdibHVldmlvbGV0JzpbMTM4LDQzLDIyNl0sXHJcbiAgICAgICAgJ2Jyb3duJzpbMTY1LDQyLDQyXSxcclxuICAgICAgICAnYnVybHl3b29kJzpbMjIyLDE4NCwxMzVdLFxyXG4gICAgICAgICdjYWRldGJsdWUnOls5NSwxNTgsMTYwXSxcclxuICAgICAgICAnY2hhcnRyZXVzZSc6WzEyNywyNTUsMF0sXHJcbiAgICAgICAgJ2Nob2NvbGF0ZSc6WzIxMCwxMDUsMzBdLFxyXG4gICAgICAgICdjb3JhbCc6WzI1NSwxMjcsODBdLFxyXG4gICAgICAgICdjb3JuZmxvd2VyYmx1ZSc6WzEwMCwxNDksMjM3XSxcclxuICAgICAgICAnY29ybnNpbGsnOlsyNTUsMjQ4LDIyMF0sXHJcbiAgICAgICAgJ2NyaW1zb24nOlsyMjAsMjAsNjBdLFxyXG4gICAgICAgICdjeWFuJzpbMCwyNTUsMjU1XSxcclxuICAgICAgICAnZGFya2JsdWUnOlswLDAsMTM5XSxcclxuICAgICAgICAnZGFya2N5YW4nOlswLDEzOSwxMzldLFxyXG4gICAgICAgICdkYXJrZ29sZGVucm9kJzpbMTg0LDEzNCwxMV0sXHJcbiAgICAgICAgJ2RhcmtncmF5JzpbMTY5LDE2OSwxNjldLFxyXG4gICAgICAgICdkYXJrZ3JleSc6WzE2OSwxNjksMTY5XSxcclxuICAgICAgICAnZGFya2dyZWVuJzpbMCwxMDAsMF0sXHJcbiAgICAgICAgJ2RhcmtraGFraSc6WzE4OSwxODMsMTA3XSxcclxuICAgICAgICAnZGFya21hZ2VudGEnOlsxMzksMCwxMzldLFxyXG4gICAgICAgICdkYXJrb2xpdmVncmVlbic6Wzg1LDEwNyw0N10sXHJcbiAgICAgICAgJ2RhcmtvcmFuZ2UnOlsyNTUsMTQwLDBdLFxyXG4gICAgICAgICdkYXJrb3JjaGlkJzpbMTUzLDUwLDIwNF0sXHJcbiAgICAgICAgJ2RhcmtyZWQnOlsxMzksMCwwXSxcclxuICAgICAgICAnZGFya3NhbG1vbic6WzIzMywxNTAsMTIyXSxcclxuICAgICAgICAnZGFya3NlYWdyZWVuJzpbMTQzLDE4OCwxNDNdLFxyXG4gICAgICAgICdkYXJrc2xhdGVibHVlJzpbNzIsNjEsMTM5XSxcclxuICAgICAgICAnZGFya3NsYXRlZ3JheSc6WzQ3LDc5LDc5XSxcclxuICAgICAgICAnZGFya3NsYXRlZ3JleSc6WzQ3LDc5LDc5XSxcclxuICAgICAgICAnZGFya3R1cnF1b2lzZSc6WzAsMjA2LDIwOV0sXHJcbiAgICAgICAgJ2Rhcmt2aW9sZXQnOlsxNDgsMCwyMTFdLFxyXG4gICAgICAgICdkZWVwcGluayc6WzI1NSwyMCwxNDddLFxyXG4gICAgICAgICdkZWVwc2t5Ymx1ZSc6WzAsMTkxLDI1NV0sXHJcbiAgICAgICAgJ2RpbWdyYXknOlsxMDUsMTA1LDEwNV0sXHJcbiAgICAgICAgJ2RpbWdyZXknOlsxMDUsMTA1LDEwNV0sXHJcbiAgICAgICAgJ2RvZGdlcmJsdWUnOlszMCwxNDQsMjU1XSxcclxuICAgICAgICAnZmlyZWJyaWNrJzpbMTc4LDM0LDM0XSxcclxuICAgICAgICAnZmxvcmFsd2hpdGUnOlsyNTUsMjUwLDI0MF0sXHJcbiAgICAgICAgJ2ZvcmVzdGdyZWVuJzpbMzQsMTM5LDM0XSxcclxuICAgICAgICAnZnVjaHNpYSc6WzI1NSwwLDI1NV0sXHJcbiAgICAgICAgJ2dhaW5zYm9ybyc6WzIyMCwyMjAsMjIwXSxcclxuICAgICAgICAnZ2hvc3R3aGl0ZSc6WzI0OCwyNDgsMjU1XSxcclxuICAgICAgICAnZ29sZCc6WzI1NSwyMTUsMF0sXHJcbiAgICAgICAgJ2dvbGRlbnJvZCc6WzIxOCwxNjUsMzJdLFxyXG4gICAgICAgICdncmF5JzpbMTI4LDEyOCwxMjhdLFxyXG4gICAgICAgICdncmV5JzpbMTI4LDEyOCwxMjhdLFxyXG4gICAgICAgICdncmVlbic6WzAsMTI4LDBdLFxyXG4gICAgICAgICdncmVlbnllbGxvdyc6WzE3MywyNTUsNDddLFxyXG4gICAgICAgICdob25leWRldyc6WzI0MCwyNTUsMjQwXSxcclxuICAgICAgICAnaG90cGluayc6WzI1NSwxMDUsMTgwXSxcclxuICAgICAgICAnaW5kaWFucmVkJzpbMjA1LDkyLDkyXSxcclxuICAgICAgICAnaW5kaWdvJzpbNzUsMCwxMzBdLFxyXG4gICAgICAgICdpdm9yeSc6WzI1NSwyNTUsMjQwXSxcclxuICAgICAgICAna2hha2knOlsyNDAsMjMwLDE0MF0sXHJcbiAgICAgICAgJ2xhdmVuZGVyJzpbMjMwLDIzMCwyNTBdLFxyXG4gICAgICAgICdsYXZlbmRlcmJsdXNoJzpbMjU1LDI0MCwyNDVdLFxyXG4gICAgICAgICdsYXduZ3JlZW4nOlsxMjQsMjUyLDBdLFxyXG4gICAgICAgICdsZW1vbmNoaWZmb24nOlsyNTUsMjUwLDIwNV0sXHJcbiAgICAgICAgJ2xpZ2h0Ymx1ZSc6WzE3MywyMTYsMjMwXSxcclxuICAgICAgICAnbGlnaHRjb3JhbCc6WzI0MCwxMjgsMTI4XSxcclxuICAgICAgICAnbGlnaHRjeWFuJzpbMjI0LDI1NSwyNTVdLFxyXG4gICAgICAgICdsaWdodGdvbGRlbnJvZHllbGxvdyc6WzI1MCwyNTAsMjEwXSxcclxuICAgICAgICAnbGlnaHRncmF5JzpbMjExLDIxMSwyMTFdLFxyXG4gICAgICAgICdsaWdodGdyZXknOlsyMTEsMjExLDIxMV0sXHJcbiAgICAgICAgJ2xpZ2h0Z3JlZW4nOlsxNDQsMjM4LDE0NF0sXHJcbiAgICAgICAgJ2xpZ2h0cGluayc6WzI1NSwxODIsMTkzXSxcclxuICAgICAgICAnbGlnaHRzYWxtb24nOlsyNTUsMTYwLDEyMl0sXHJcbiAgICAgICAgJ2xpZ2h0c2VhZ3JlZW4nOlszMiwxNzgsMTcwXSxcclxuICAgICAgICAnbGlnaHRza3libHVlJzpbMTM1LDIwNiwyNTBdLFxyXG4gICAgICAgICdsaWdodHNsYXRlZ3JheSc6WzExOSwxMzYsMTUzXSxcclxuICAgICAgICAnbGlnaHRzbGF0ZWdyZXknOlsxMTksMTM2LDE1M10sXHJcbiAgICAgICAgJ2xpZ2h0c3RlZWxibHVlJzpbMTc2LDE5NiwyMjJdLFxyXG4gICAgICAgICdsaWdodHllbGxvdyc6WzI1NSwyNTUsMjI0XSxcclxuICAgICAgICAnbGltZSc6WzAsMjU1LDBdLFxyXG4gICAgICAgICdsaW1lZ3JlZW4nOls1MCwyMDUsNTBdLFxyXG4gICAgICAgICdsaW5lbic6WzI1MCwyNDAsMjMwXSxcclxuICAgICAgICAnbWFnZW50YSc6WzI1NSwwLDI1NV0sXHJcbiAgICAgICAgJ21hcm9vbic6WzEyOCwwLDBdLFxyXG4gICAgICAgICdtZWRpdW1hcXVhbWFyaW5lJzpbMTAyLDIwNSwxNzBdLFxyXG4gICAgICAgICdtZWRpdW1ibHVlJzpbMCwwLDIwNV0sXHJcbiAgICAgICAgJ21lZGl1bW9yY2hpZCc6WzE4Niw4NSwyMTFdLFxyXG4gICAgICAgICdtZWRpdW1wdXJwbGUnOlsxNDcsMTEyLDIxNl0sXHJcbiAgICAgICAgJ21lZGl1bXNlYWdyZWVuJzpbNjAsMTc5LDExM10sXHJcbiAgICAgICAgJ21lZGl1bXNsYXRlYmx1ZSc6WzEyMywxMDQsMjM4XSxcclxuICAgICAgICAnbWVkaXVtc3ByaW5nZ3JlZW4nOlswLDI1MCwxNTRdLFxyXG4gICAgICAgICdtZWRpdW10dXJxdW9pc2UnOls3MiwyMDksMjA0XSxcclxuICAgICAgICAnbWVkaXVtdmlvbGV0cmVkJzpbMTk5LDIxLDEzM10sXHJcbiAgICAgICAgJ21pZG5pZ2h0Ymx1ZSc6WzI1LDI1LDExMl0sXHJcbiAgICAgICAgJ21pbnRjcmVhbSc6WzI0NSwyNTUsMjUwXSxcclxuICAgICAgICAnbWlzdHlyb3NlJzpbMjU1LDIyOCwyMjVdLFxyXG4gICAgICAgICdtb2NjYXNpbic6WzI1NSwyMjgsMTgxXSxcclxuICAgICAgICAnbmF2YWpvd2hpdGUnOlsyNTUsMjIyLDE3M10sXHJcbiAgICAgICAgJ25hdnknOlswLDAsMTI4XSxcclxuICAgICAgICAnb2xkbGFjZSc6WzI1MywyNDUsMjMwXSxcclxuICAgICAgICAnb2xpdmUnOlsxMjgsMTI4LDBdLFxyXG4gICAgICAgICdvbGl2ZWRyYWInOlsxMDcsMTQyLDM1XSxcclxuICAgICAgICAnb3JhbmdlJzpbMjU1LDE2NSwwXSxcclxuICAgICAgICAnb3JhbmdlcmVkJzpbMjU1LDY5LDBdLFxyXG4gICAgICAgICdvcmNoaWQnOlsyMTgsMTEyLDIxNF0sXHJcbiAgICAgICAgJ3BhbGVnb2xkZW5yb2QnOlsyMzgsMjMyLDE3MF0sXHJcbiAgICAgICAgJ3BhbGVncmVlbic6WzE1MiwyNTEsMTUyXSxcclxuICAgICAgICAncGFsZXR1cnF1b2lzZSc6WzE3NSwyMzgsMjM4XSxcclxuICAgICAgICAncGFsZXZpb2xldHJlZCc6WzIxNiwxMTIsMTQ3XSxcclxuICAgICAgICAncGFwYXlhd2hpcCc6WzI1NSwyMzksMjEzXSxcclxuICAgICAgICAncGVhY2hwdWZmJzpbMjU1LDIxOCwxODVdLFxyXG4gICAgICAgICdwZXJ1JzpbMjA1LDEzMyw2M10sXHJcbiAgICAgICAgJ3BpbmsnOlsyNTUsMTkyLDIwM10sXHJcbiAgICAgICAgJ3BsdW0nOlsyMjEsMTYwLDIyMV0sXHJcbiAgICAgICAgJ3Bvd2RlcmJsdWUnOlsxNzYsMjI0LDIzMF0sXHJcbiAgICAgICAgJ3B1cnBsZSc6WzEyOCwwLDEyOF0sXHJcbiAgICAgICAgJ3JlZCc6WzI1NSwwLDBdLFxyXG4gICAgICAgICdyb3N5YnJvd24nOlsxODgsMTQzLDE0M10sXHJcbiAgICAgICAgJ3JveWFsYmx1ZSc6WzY1LDEwNSwyMjVdLFxyXG4gICAgICAgICdzYWRkbGVicm93bic6WzEzOSw2OSwxOV0sXHJcbiAgICAgICAgJ3NhbG1vbic6WzI1MCwxMjgsMTE0XSxcclxuICAgICAgICAnc2FuZHlicm93bic6WzI0NCwxNjQsOTZdLFxyXG4gICAgICAgICdzZWFncmVlbic6WzQ2LDEzOSw4N10sXHJcbiAgICAgICAgJ3NlYXNoZWxsJzpbMjU1LDI0NSwyMzhdLFxyXG4gICAgICAgICdzaWVubmEnOlsxNjAsODIsNDVdLFxyXG4gICAgICAgICdzaWx2ZXInOlsxOTIsMTkyLDE5Ml0sXHJcbiAgICAgICAgJ3NreWJsdWUnOlsxMzUsMjA2LDIzNV0sXHJcbiAgICAgICAgJ3NsYXRlYmx1ZSc6WzEwNiw5MCwyMDVdLFxyXG4gICAgICAgICdzbGF0ZWdyYXknOlsxMTIsMTI4LDE0NF0sXHJcbiAgICAgICAgJ3NsYXRlZ3JleSc6WzExMiwxMjgsMTQ0XSxcclxuICAgICAgICAnc25vdyc6WzI1NSwyNTAsMjUwXSxcclxuICAgICAgICAnc3ByaW5nZ3JlZW4nOlswLDI1NSwxMjddLFxyXG4gICAgICAgICdzdGVlbGJsdWUnOls3MCwxMzAsMTgwXSxcclxuICAgICAgICAndGFuJzpbMjEwLDE4MCwxNDBdLFxyXG4gICAgICAgICd0ZWFsJzpbMCwxMjgsMTI4XSxcclxuICAgICAgICAndGhpc3RsZSc6WzIxNiwxOTEsMjE2XSxcclxuICAgICAgICAndG9tYXRvJzpbMjU1LDk5LDcxXSxcclxuICAgICAgICAndHVycXVvaXNlJzpbNjQsMjI0LDIwOF0sXHJcbiAgICAgICAgJ3Zpb2xldCc6WzIzOCwxMzAsMjM4XSxcclxuICAgICAgICAnd2hlYXQnOlsyNDUsMjIyLDE3OV0sXHJcbiAgICAgICAgJ3doaXRlJzpbMjU1LDI1NSwyNTVdLFxyXG4gICAgICAgICd3aGl0ZXNtb2tlJzpbMjQ1LDI0NSwyNDVdLFxyXG4gICAgICAgICd5ZWxsb3cnOlsyNTUsMjU1LDBdLFxyXG4gICAgICAgICd5ZWxsb3dncmVlbic6WzE1NCwyMDUsNTBdLFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBjb2xvciBwYXJzaW5nIGZ1bmN0aW9uIG9yaWdpbmFsbHkgZnJvbVxyXG4gICAgLy8gaHR0cDovL3BsdWdpbnMuanF1ZXJ5LmNvbS9maWxlcy9qcXVlcnkuY29sb3IuanMudHh0XHJcbiAgICAvLyAod2l0aCBzbGlnaHQgbW9kaWZpY2F0aW9ucylcclxuXHJcbiAgICAvLyBQYXJzZSBzdHJpbmdzIGxvb2tpbmcgZm9yIGNvbG9yIHR1cGxlcyBbMjU1LDI1NSwyNTVdXHJcbiAgICB2YXIgcmdiTnVtUkUgPSAvcmdiXFwoXFxzKihbMC05XXsxLDN9KVxccyosXFxzKihbMC05XXsxLDN9KVxccyosXFxzKihbMC05XXsxLDN9KVxccypcXCkvO1xyXG4gICAgdmFyIHJnYlBlcmNSRSA9IC9yZ2JcXChcXHMqKFswLTldKyg/OlxcLlswLTldKyk/KVxcJVxccyosXFxzKihbMC05XSsoPzpcXC5bMC05XSspPylcXCVcXHMqLFxccyooWzAtOV0rKD86XFwuWzAtOV0rKT8pXFwlXFxzKlxcKS87XHJcbiAgICB2YXIgcmdiSGFzaDZSRSA9IC8jKFthLWZBLUYwLTldezJ9KShbYS1mQS1GMC05XXsyfSkoW2EtZkEtRjAtOV17Mn0pLztcclxuICAgIHZhciByZ2JIYXNoM1JFID0gLyMoW2EtZkEtRjAtOV0pKFthLWZBLUYwLTldKShbYS1mQS1GMC05XSkvO1xyXG5cclxuICAgIHZhciBzdHJUb1JnYiA9IGZ1bmN0aW9uKGNvbG9yKSB7XHJcbiAgICAgIHZhciByZXN1bHQ7XHJcblxyXG4gICAgICAvLyBDaGVjayBpZiB3ZSdyZSBhbHJlYWR5IGRlYWxpbmcgd2l0aCBhbiBhcnJheSBvZiBjb2xvcnNcclxuLy8gICAgICAgICBpZiAoIGNvbG9yICYmIGNvbG9yLmNvbnN0cnVjdG9yID09IEFycmF5ICYmIGNvbG9yLmxlbmd0aCA9PSAzIClcclxuLy8gICAgICAgICAgICAgcmV0dXJuIGNvbG9yO1xyXG4gICAgICBcclxuICAgICAgLy8gTG9vayBmb3IgcmdiKG51bSxudW0sbnVtKVxyXG4gICAgICBpZiAocmVzdWx0ID0gcmdiTnVtUkUuZXhlYyhjb2xvcikpXHJcbiAgICAgICAgcmV0dXJuIFtwYXJzZUludChyZXN1bHRbMV0pLCBwYXJzZUludChyZXN1bHRbMl0pLCBwYXJzZUludChyZXN1bHRbM10pXTtcclxuICAgICAgXHJcbiAgICAgIC8vIExvb2sgZm9yIHJnYihudW0lLG51bSUsbnVtJSlcclxuICAgICAgaWYgKHJlc3VsdCA9IHJnYlBlcmNSRS5leGVjKGNvbG9yKSlcclxuICAgICAgICByZXR1cm4gW3BhcnNlRmxvYXQocmVzdWx0WzFdKSoyLjU1LCBwYXJzZUZsb2F0KHJlc3VsdFsyXSkqMi41NSwgcGFyc2VGbG9hdChyZXN1bHRbM10pKjIuNTVdO1xyXG4gICAgICBcclxuICAgICAgLy8gTG9vayBmb3IgI2EwYjFjMlxyXG4gICAgICBpZiAocmVzdWx0ID0gcmdiSGFzaDZSRS5leGVjKGNvbG9yKSlcclxuICAgICAgICByZXR1cm4gW3BhcnNlSW50KHJlc3VsdFsxXSwxNiksIHBhcnNlSW50KHJlc3VsdFsyXSwxNiksIHBhcnNlSW50KHJlc3VsdFszXSwxNildO1xyXG4gICAgICBcclxuICAgICAgLy8gTG9vayBmb3IgI2ZmZlxyXG4gICAgICBpZiAocmVzdWx0ID0gcmdiSGFzaDNSRS5leGVjKGNvbG9yKSlcclxuICAgICAgICByZXR1cm4gW3BhcnNlSW50KHJlc3VsdFsxXStyZXN1bHRbMV0sMTYpLCBwYXJzZUludChyZXN1bHRbMl0rcmVzdWx0WzJdLDE2KSwgcGFyc2VJbnQocmVzdWx0WzNdK3Jlc3VsdFszXSwxNildO1xyXG4gICAgICBcclxuICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSdyZSBtb3N0IGxpa2VseSBkZWFsaW5nIHdpdGggYSBuYW1lZCBjb2xvclxyXG4gICAgICByZXR1cm4gY29sb3JzWyQudHJpbShjb2xvcikudG9Mb3dlckNhc2UoKV07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJnYlRvU3RyID0gZnVuY3Rpb24ocmdiKSB7XHJcbiAgICAgIC8vIFRPRE86IHRoZXJlIGhhcyB0byBiZSBhIGJldHRlciB3YXksIGV2ZW4gaW4gSlNcclxuICAgICAgdmFyIHIgPSBNYXRoLmZsb29yKHJnYlswXSkudG9TdHJpbmcoMTYpO1xyXG4gICAgICB2YXIgZyA9IE1hdGguZmxvb3IocmdiWzFdKS50b1N0cmluZygxNik7XHJcbiAgICAgIHZhciBiID0gTWF0aC5mbG9vcihyZ2JbMl0pLnRvU3RyaW5nKDE2KTtcclxuICAgICAgLy8gcGFkXHJcbiAgICAgIHIgPSByLmxlbmd0aCA8IDIgPyAnMCcgKyByIDogcjtcclxuICAgICAgZyA9IGcubGVuZ3RoIDwgMiA/ICcwJyArIGcgOiBnO1xyXG4gICAgICBiID0gYi5sZW5ndGggPCAyID8gJzAnICsgYiA6IGI7ICAgICAgICBcclxuICAgICAgcmV0dXJuICgnIycrcitnK2IpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBGdW5jdGlvbnMgcmdiVG9Ic2wgYW5kIGhzbFRvUmdiIG9yaWdpbmFsbHkgZnJvbSBcclxuICAgIC8vIGh0dHA6Ly9tamlqYWNrc29uLmNvbS8yMDA4LzAyL3JnYi10by1oc2wtYW5kLXJnYi10by1oc3YtY29sb3ItbW9kZWwtY29udmVyc2lvbi1hbGdvcml0aG1zLWluLWphdmFzY3JpcHRcclxuICAgIC8vIGltcGxlbWVudGF0aW9uIG9mIGZ1bmN0aW9ucyBpbiBXaWtpcGVkaWFcclxuICAgIC8vICh3aXRoIHNsaWdodCBtb2RpZmljYXRpb25zKVxyXG5cclxuICAgIC8vIFJHQiB0byBIU0wgY29sb3IgY29udmVyc2lvblxyXG4gICAgdmFyIHJnYlRvSHNsID0gZnVuY3Rpb24ocmdiKSB7XHJcbiAgICAgIHZhciByID0gcmdiWzBdLzI1NSwgZyA9IHJnYlsxXS8yNTUsIGIgPSByZ2JbMl0vMjU1O1xyXG4gICAgICB2YXIgbWF4ID0gTWF0aC5tYXgociwgZywgYiksIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xyXG4gICAgICB2YXIgaCwgcywgbCA9IChtYXggKyBtaW4pIC8gMjtcclxuXHJcbiAgICAgIGlmIChtYXggPT0gbWluKSB7XHJcbiAgICAgICAgaCA9IHMgPSAwOyAvLyBhY2hyb21hdGljXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIGQgPSBtYXggLSBtaW47XHJcbiAgICAgICAgcyA9IGwgPiAwLjUgPyBkIC8gKDIgLSBtYXggLSBtaW4pIDogZCAvIChtYXggKyBtaW4pO1xyXG4gICAgICAgIHN3aXRjaCAobWF4KSB7XHJcbiAgICAgICAgICBjYXNlIHI6IGggPSAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKTsgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIGc6IGggPSAoYiAtIHIpIC8gZCArIDI7IGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBiOiBoID0gKHIgLSBnKSAvIGQgKyA0OyBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgaCAvPSA2O1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gW2gsIHMsIGxdO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBodWUycmdiID0gZnVuY3Rpb24ocCwgcSwgdCkge1xyXG4gICAgICBpZiAodCA8IDApIHQgKz0gMTtcclxuICAgICAgaWYgKHQgPiAxKSB0IC09IDE7XHJcbiAgICAgIGlmICh0IDwgMS82KSByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcclxuICAgICAgaWYgKHQgPCAxLzIpIHJldHVybiBxO1xyXG4gICAgICBpZiAodCA8IDIvMykgcmV0dXJuIHAgKyAocSAtIHApICogKDIvMyAtIHQpICogNjtcclxuICAgICAgcmV0dXJuIHA7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGhzbFRvUmdiID0gZnVuY3Rpb24oaHNsKSB7XHJcbiAgICAgIHZhciBoID0gaHNsWzBdLCBzID0gaHNsWzFdLCBsID0gaHNsWzJdO1xyXG5cclxuICAgICAgdmFyIHIsIGcsIGI7XHJcblxyXG4gICAgICBpZiAocyA9PSAwKSB7XHJcbiAgICAgICAgciA9IGcgPSBiID0gbDsgLy8gYWNocm9tYXRpY1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciBxID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcclxuICAgICAgICB2YXIgcCA9IDIgKiBsIC0gcTtcclxuICAgICAgICByID0gaHVlMnJnYihwLCBxLCBoICsgMS8zKTtcclxuICAgICAgICBnID0gaHVlMnJnYihwLCBxLCBoKTtcclxuICAgICAgICBiID0gaHVlMnJnYihwLCBxLCBoIC0gMS8zKTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIFtyICogMjU1LCBnICogMjU1LCBiICogMjU1XTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYWRqdXN0TGlnaHRuZXNzQ2FjaGUgPSB7fTtcclxuXHJcbiAgICAvLyBnaXZlbiBjb2xvciBzdHJpbmcgYW5kIC0xPD1hZGp1c3Q8PTEsIHJldHVybnMgY29sb3Igc3RyaW5nXHJcbiAgICAvLyB3aGVyZSBsaWdodG5lc3MgKGluIHRoZSBIU0wgc2Vuc2UpIGlzIGFkanVzdGVkIGJ5IHRoZSBnaXZlblxyXG4gICAgLy8gYW1vdW50LCB0aGUgbGFyZ2VyIHRoZSBsaWdodGVyOiAtMSBnaXZlcyBibGFjaywgMSB3aGl0ZSwgYW5kIDBcclxuICAgIC8vIHRoZSBnaXZlbiBjb2xvci5cclxuICAgIHZhciBhZGp1c3RDb2xvckxpZ2h0bmVzcyA9IGZ1bmN0aW9uKGNvbG9yc3RyLCBhZGp1c3QpIHtcclxuICAgICAgaWYgKCEoY29sb3JzdHIgaW4gYWRqdXN0TGlnaHRuZXNzQ2FjaGUpKSB7XHJcbiAgICAgICAgYWRqdXN0TGlnaHRuZXNzQ2FjaGVbY29sb3JzdHJdID0ge31cclxuICAgICAgfVxyXG4gICAgICBpZiAoIShhZGp1c3QgaW4gYWRqdXN0TGlnaHRuZXNzQ2FjaGVbY29sb3JzdHJdKSkge1xyXG4gICAgICAgIHZhciByZ2IgPSBzdHJUb1JnYihjb2xvcnN0cik7XHJcbiAgICAgICAgaWYgKHJnYiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAvLyBmYWlsZWQgY29sb3Igc3RyaW5nIGNvbnZlcnNpb247IGp1c3QgcmV0dXJuIHRoZSBpbnB1dFxyXG4gICAgICAgICAgYWRqdXN0TGlnaHRuZXNzQ2FjaGVbY29sb3JzdHJdW2FkanVzdF0gPSBjb2xvcnN0cjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdmFyIGhzbCA9IHJnYlRvSHNsKHJnYik7XHJcbiAgICAgICAgICBpZiAoYWRqdXN0ID4gMC4wKSB7XHJcbiAgICAgICAgICAgIGhzbFsyXSA9IDEuMCAtICgoMS4wLWhzbFsyXSkqKDEuMC1hZGp1c3QpKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGhzbFsyXSA9ICgxLjArYWRqdXN0KSpoc2xbMl07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB2YXIgbGlnaHRSZ2IgPSBoc2xUb1JnYihoc2wpO1xyXG4gICAgICAgICAgYWRqdXN0TGlnaHRuZXNzQ2FjaGVbY29sb3JzdHJdW2FkanVzdF0gPSByZ2JUb1N0cihsaWdodFJnYik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBhZGp1c3RMaWdodG5lc3NDYWNoZVtjb2xvcnN0cl1bYWRqdXN0XTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQYXJ0aWFsbHkgc3RvbGVuIGZyb206IGh0dHA6Ly9kb2N1bWVudGNsb3VkLmdpdGh1Yi5jb20vdW5kZXJzY29yZS9cclxuICAgIC8vIE1JVC1MaWNlbnNlXHJcbiAgICAvLyBUT0RPOiBNZW50aW9uIGluIExJQ0VOU0UubWRcclxuICAgIHZhciBpc0VxdWFsID0gZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAvLyBDaGVjayBvYmplY3QgaWRlbnRpdHkuXHJcbiAgICAgIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgLy8gRGlmZmVyZW50IHR5cGVzP1xyXG4gICAgICB2YXIgYXR5cGUgPSB0eXBlb2YoYSksIGJ0eXBlID0gdHlwZW9mKGIpO1xyXG4gICAgICBpZiAoYXR5cGUgIT0gYnR5cGUpIHJldHVybiBmYWxzZTtcclxuICAgICAgLy8gQmFzaWMgZXF1YWxpdHkgdGVzdCAod2F0Y2ggb3V0IGZvciBjb2VyY2lvbnMpLlxyXG4gICAgICBpZiAoYSA9PSBiKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgLy8gT25lIGlzIGZhbHN5IGFuZCB0aGUgb3RoZXIgdHJ1dGh5LlxyXG4gICAgICBpZiAoKCFhICYmIGIpIHx8IChhICYmICFiKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAvLyBJZiBhIGlzIG5vdCBhbiBvYmplY3QgYnkgdGhpcyBwb2ludCwgd2UgY2FuJ3QgaGFuZGxlIGl0LlxyXG4gICAgICBpZiAoYXR5cGUgIT09ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIC8vIENoZWNrIGZvciBkaWZmZXJlbnQgYXJyYXkgbGVuZ3RocyBiZWZvcmUgY29tcGFyaW5nIGNvbnRlbnRzLlxyXG4gICAgICBpZiAoYS5sZW5ndGggJiYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkpIHJldHVybiBmYWxzZTtcclxuICAgICAgLy8gTm90aGluZyBlbHNlIHdvcmtlZCwgZGVlcCBjb21wYXJlIHRoZSBjb250ZW50cy5cclxuICAgICAgZm9yICh2YXIga2V5IGluIGIpIGlmICghKGtleSBpbiBhKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAvLyBSZWN1cnNpdmUgY29tcGFyaXNvbiBvZiBjb250ZW50cy5cclxuICAgICAgZm9yICh2YXIga2V5IGluIGEpIGlmICghKGtleSBpbiBiKSB8fCAhaXNFcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBrZXlWYWxSRSA9IC9eKFtePV0rKT0oLiopJC87IC8vIGtleT12YWx1ZVxyXG4gICAgdmFyIGlzRGlnaXRzUkUgPSAvXlswLTldKyQvO1xyXG5cclxuICAgIHZhciBkZXBhcmFtID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgICAgIHZhciBhcmdzID0gc3RyLnNwbGl0KCcmJyk7XHJcbiAgICAgIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcclxuICAgICAgaWYgKCFsZW4pIHJldHVybiBudWxsO1xyXG4gICAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICB2YXIgcGFydHMgPSBhcmdzW2ldLm1hdGNoKGtleVZhbFJFKTtcclxuICAgICAgICBpZiAoIXBhcnRzIHx8IHBhcnRzLmxlbmd0aCAhPSAzKSBicmVhaztcclxuICAgICAgICB2YXIgdmFsID0gW107XHJcbiAgICAgICAgdmFyIGFyciA9IHBhcnRzWzJdLnNwbGl0KCcsJyk7XHJcbiAgICAgICAgdmFyIHN1YmxlbiA9IGFyci5sZW5ndGg7XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdWJsZW47IGorKykge1xyXG4gICAgICAgICAgdmFyIGlubmVybW9zdCA9IFtdO1xyXG4gICAgICAgICAgLy8gbWFwIGVtcHR5IGFyZ3VtZW50cyAoXCJcIiBpbiBVUkwpIHRvIGVtcHR5IGFycmF5c1xyXG4gICAgICAgICAgLy8gKGlubmVybW9zdCByZW1haW5zIFtdKVxyXG4gICAgICAgICAgaWYgKGFycltqXS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdmFyIGFycnNwbGl0ID0gYXJyW2pdLnNwbGl0KCd+Jyk7XHJcbiAgICAgICAgICAgIHZhciBzdWJzdWJsZW4gPSBhcnJzcGxpdC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgc3Vic3VibGVuOyBrKyspIHtcclxuICAgICAgICAgICAgICBpZihhcnJzcGxpdFtrXS5tYXRjaChpc0RpZ2l0c1JFKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gY29udmVydCBkaWdpdHMgaW50byBpbnRzIC4uLlxyXG4gICAgICAgICAgICAgICAgaW5uZXJtb3N0LnB1c2gocGFyc2VJbnQoYXJyc3BsaXRba10sIDEwKSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gLi4uIGFueXRoaW5nIGVsc2UgcmVtYWlucyBhIHN0cmluZy5cclxuICAgICAgICAgICAgICAgIGlubmVybW9zdC5wdXNoKGFycnNwbGl0W2tdKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHZhbC5wdXNoKGlubmVybW9zdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdFtwYXJ0c1sxXV0gPSB2YWw7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIHBhcmFtQXJyYXkgPSBmdW5jdGlvbih2YWwpIHtcclxuICAgICAgdmFsID0gdmFsIHx8IFtdO1xyXG4gICAgICB2YXIgbGVuID0gdmFsLmxlbmd0aDtcclxuICAgICAgdmFyIGFyciA9IFtdO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgaWYgKCQuaXNBcnJheSh2YWxbaV0pKSB7XHJcbiAgICAgICAgICBhcnIucHVzaCh2YWxbaV0uam9pbignficpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gbm9uLWFycmF5IGFyZ3VtZW50OyB0aGlzIGlzIGFuIGVycm9yIGZyb20gdGhlIGNhbGxlclxyXG4gICAgICAgICAgY29uc29sZS5lcnJvcigncGFyYW06IEVycm9yOiByZWNlaXZlZCBub24tYXJyYXktaW4tYXJyYXkgYXJndW1lbnQgWycsIGksICddJywgJzonLCB2YWxbaV0sICcoZml4IGNhbGxlciknKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGFycjtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIHBhcmFtID0gZnVuY3Rpb24oYXJncykge1xyXG4gICAgICBpZiAoIWFyZ3MpIHJldHVybiAnJztcclxuICAgICAgdmFyIHZhbHMgPSBbXTtcclxuICAgICAgZm9yICh2YXIga2V5IGluIGFyZ3MpIHtcclxuICAgICAgICBpZiAoYXJncy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICB2YXIgdmFsID0gYXJnc1trZXldO1xyXG4gICAgICAgICAgaWYgKHZhbCA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3I6IHJlY2VpdmVkIGFyZ3VtZW50Jywga2V5LCAnd2l0aCB2YWx1ZScsIHZhbCk7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gdmFsdWVzIG5vcm1hbGx5IGV4cGVjdGVkIHRvIGJlIGFycmF5cywgYnV0IHNvbWUgY2FsbGVycyBzY3Jld1xyXG4gICAgICAgICAgLy8gdXAsIHNvIGNoZWNrXHJcbiAgICAgICAgICBpZiAoJC5pc0FycmF5KHZhbCkpIHtcclxuICAgICAgICAgICAgdmFyIGFyciA9IHBhcmFtQXJyYXkodmFsKTtcclxuICAgICAgICAgICAgdmFscy5wdXNoKGtleSArICc9JyArIGFyci5qb2luKCcsJykpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gbm9uLWFycmF5IGFyZ3VtZW50OyB0aGlzIGlzIGFuIGVycm9yIGZyb20gdGhlIGNhbGxlclxyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdwYXJhbTogRXJyb3I6IHJlY2VpdmVkIG5vbi1hcnJheSBhcmd1bWVudCcsIGtleSwgJzonLCB2YWwsICcoZml4IGNhbGxlciknKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHZhbHMuam9pbignJicpO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgcHJvZmlsZXMgPSB7fTtcclxuICAgIHZhciBwcm9maWxlU3RhcnRzID0ge307XHJcbiAgICB2YXIgcHJvZmlsZU9uID0gZmFsc2U7XHJcbiAgICB2YXIgcHJvZmlsZUVuYWJsZSA9IGZ1bmN0aW9uKG9uKSB7XHJcbiAgICAgIGlmIChvbiA9PT0gdW5kZWZpbmVkKSBvbiA9IHRydWU7XHJcbiAgICAgIHByb2ZpbGVPbiA9IG9uO1xyXG4gICAgfTsgLy8gcHJvZmlsZUVuYWJsZVxyXG4gICAgdmFyIHByb2ZpbGVDbGVhciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICBpZiAoIXByb2ZpbGVPbikgcmV0dXJuO1xyXG4gICAgICBwcm9maWxlcyA9IHt9O1xyXG4gICAgICBwcm9maWxlU3RhcnRzID0ge307XHJcbiAgICB9OyAvLyBwcm9maWxlQ2xlYXJcclxuICAgIHZhciBwcm9maWxlU3RhcnQgPSBmdW5jdGlvbihsYWJlbCkge1xyXG4gICAgICBpZiAoIXByb2ZpbGVPbikgcmV0dXJuO1xyXG4gICAgICBwcm9maWxlU3RhcnRzW2xhYmVsXSA9IG5ldyBEYXRlKCk7XHJcbiAgICB9OyAvLyBwcm9maWxlU3RhcnRcclxuICAgIHZhciBwcm9maWxlRW5kID0gZnVuY3Rpb24obGFiZWwpIHtcclxuICAgICAgaWYgKCFwcm9maWxlT24pIHJldHVybjtcclxuICAgICAgdmFyIHByb2ZpbGVFbGFwc2VkID0gbmV3IERhdGUoKSAtIHByb2ZpbGVTdGFydHNbbGFiZWxdXHJcbiAgICAgIGlmICghcHJvZmlsZXNbbGFiZWxdKSBwcm9maWxlc1tsYWJlbF0gPSAwO1xyXG4gICAgICBwcm9maWxlc1tsYWJlbF0gKz0gcHJvZmlsZUVsYXBzZWQ7XHJcbiAgICB9OyAvLyBwcm9maWxlRW5kXHJcbiAgICB2YXIgcHJvZmlsZVJlcG9ydCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICBpZiAoIXByb2ZpbGVPbikgcmV0dXJuO1xyXG4gICAgICBpZiAod2luZG93LmNvbnNvbGUpIHtcclxuICAgICAgICAkLmVhY2gocHJvZmlsZXMsIGZ1bmN0aW9uKGxhYmVsLCB0aW1lKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhcInByb2ZpbGUgXCIgKyBsYWJlbCwgdGltZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCItLS0tLS0tXCIpO1xyXG4gICAgICB9XHJcbiAgICB9OyAvLyBwcm9maWxlUmVwb3J0XHJcblxyXG4gICAgLy8gY29udGFpbmVyOiBJRCBvciBqUXVlcnkgZWxlbWVudFxyXG4gICAgLy8gY29sbERhdGE6IHRoZSBjb2xsZWN0aW9uIGRhdGEgKGluIHRoZSBmb3JtYXQgb2YgdGhlIHJlc3VsdCBvZlxyXG4gICAgLy8gICBodHRwOi8vLi4uL2JyYXQvYWpheC5jZ2k/YWN0aW9uPWdldENvbGxlY3Rpb25JbmZvcm1hdGlvbiZjb2xsZWN0aW9uPS4uLlxyXG4gICAgLy8gZG9jRGF0YTogdGhlIGRvY3VtZW50IGRhdGEgKGluIHRoZSBmb3JtYXQgb2YgdGhlIHJlc3VsdCBvZlxyXG4gICAgLy8gICBodHRwOi8vLi4uL2JyYXQvYWpheC5jZ2k/YWN0aW9uPWdldERvY3VtZW50JmNvbGxlY3Rpb249Li4uJmRvY3VtZW50PS4uLlxyXG4gICAgLy8gcmV0dXJucyB0aGUgZW1iZWRkZWQgdmlzdWFsaXplcidzIGRpc3BhdGNoZXIgb2JqZWN0XHJcbiAgICB2YXIgZW1iZWQgPSBmdW5jdGlvbihjb250YWluZXIsIGNvbGxEYXRhLCBkb2NEYXRhLCB3ZWJGb250VVJMcykge1xyXG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IG5ldyBEaXNwYXRjaGVyKCk7XHJcbiAgICAgIHZhciB2aXN1YWxpemVyID0gbmV3IFZpc3VhbGl6ZXIoZGlzcGF0Y2hlciwgY29udGFpbmVyLCB3ZWJGb250VVJMcyk7XHJcbiAgICAgIGRvY0RhdGEuY29sbGVjdGlvbiA9IG51bGw7XHJcbiAgICAgIGRpc3BhdGNoZXIucG9zdCgnY29sbGVjdGlvbkxvYWRlZCcsIFtjb2xsRGF0YV0pO1xyXG4gICAgICBkaXNwYXRjaGVyLnBvc3QoJ3JlcXVlc3RSZW5kZXJEYXRhJywgW2RvY0RhdGFdKTtcclxuICAgICAgcmV0dXJuIGRpc3BhdGNoZXI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGNvbnRhaW5lcjogSUQgb3IgalF1ZXJ5IGVsZW1lbnRcclxuICAgIC8vIGNvbGxEYXRhVVJMOiB0aGUgVVJMIG9mIHRoZSBjb2xsZWN0aW9uIGRhdGEsIG9yIGNvbGxlY3Rpb24gZGF0YVxyXG4gICAgLy8gICBvYmplY3QgKGlmIHByZS1mZXRjaGVkKVxyXG4gICAgLy8gZG9jRGF0YVVSTDogdGhlIHVybCBvZiB0aGUgZG9jdW1lbnQgZGF0YSAoaWYgcHJlLWZldGNoZWQsIHVzZVxyXG4gICAgLy8gICBzaW1wbGUgYGVtYmVkYCBpbnN0ZWFkKVxyXG4gICAgLy8gY2FsbGJhY2s6IG9wdGlvbmFsOyB0aGUgY2FsbGJhY2sgdG8gY2FsbCBhZnRlcndhcmRzOyBpdCB3aWxsIGJlXHJcbiAgICAvLyAgIHBhc3NlZCB0aGUgZW1iZWRkZWQgdmlzdWFsaXplcidzIGRpc3BhdGNoZXIgb2JqZWN0XHJcbiAgICB2YXIgZW1iZWRCeVVSTCA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgY29sbERhdGFVUkwsIGRvY0RhdGFVUkwsIGNhbGxiYWNrKSB7XHJcbiAgICAgIHZhciBjb2xsRGF0YSwgZG9jRGF0YTtcclxuICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoY29sbERhdGEgJiYgZG9jRGF0YSkge1xyXG4gICAgICAgICAgdmFyIGRpc3BhdGNoZXIgPSBlbWJlZChjb250YWluZXIsIGNvbGxEYXRhLCBkb2NEYXRhKTtcclxuICAgICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soZGlzcGF0Y2hlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgICBpZiAodHlwZW9mKGNvbnRhaW5lcikgPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAkLmdldEpTT04oY29sbERhdGFVUkwsIGZ1bmN0aW9uKGRhdGEpIHsgY29sbERhdGEgPSBkYXRhOyBoYW5kbGVyKCk7IH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbGxEYXRhID0gY29sbERhdGFVUkw7XHJcbiAgICAgIH1cclxuICAgICAgJC5nZXRKU09OKGRvY0RhdGFVUkwsIGZ1bmN0aW9uKGRhdGEpIHsgZG9jRGF0YSA9IGRhdGE7IGhhbmRsZXIoKTsgfSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBwcm9maWxlRW5hYmxlOiBwcm9maWxlRW5hYmxlLFxyXG4gICAgICBwcm9maWxlQ2xlYXI6IHByb2ZpbGVDbGVhcixcclxuICAgICAgcHJvZmlsZVN0YXJ0OiBwcm9maWxlU3RhcnQsXHJcbiAgICAgIHByb2ZpbGVFbmQ6IHByb2ZpbGVFbmQsXHJcbiAgICAgIHByb2ZpbGVSZXBvcnQ6IHByb2ZpbGVSZXBvcnQsXHJcbiAgICAgIGZvcm1hdFRpbWVBZ286IGZvcm1hdFRpbWVBZ28sXHJcbiAgICAgIHJlYWxCQm94OiByZWFsQkJveCxcclxuICAgICAgZ2V0U3BhbkxhYmVsczogZ2V0U3BhbkxhYmVscyxcclxuICAgICAgc3BhbkRpc3BsYXlGb3JtOiBzcGFuRGlzcGxheUZvcm0sXHJcbiAgICAgIGdldEFyY0xhYmVsczogZ2V0QXJjTGFiZWxzLFxyXG4gICAgICBhcmNEaXNwbGF5Rm9ybTogYXJjRGlzcGxheUZvcm0sXHJcbiAgICAgIGVzY2FwZVF1b3RlczogZXNjYXBlUXVvdGVzLFxyXG4gICAgICBlc2NhcGVIVE1MOiBlc2NhcGVIVE1MLFxyXG4gICAgICBlc2NhcGVIVE1MYW5kUXVvdGVzOiBlc2NhcGVIVE1MYW5kUXVvdGVzLFxyXG4gICAgICBlc2NhcGVIVE1Md2l0aE5ld2xpbmVzOiBlc2NhcGVIVE1Md2l0aE5ld2xpbmVzLFxyXG4gICAgICBjbXA6IGNtcCxcclxuICAgICAgcmdiVG9Ic2w6IHJnYlRvSHNsLFxyXG4gICAgICBoc2xUb1JnYjogaHNsVG9SZ2IsXHJcbiAgICAgIGFkanVzdENvbG9yTGlnaHRuZXNzOiBhZGp1c3RDb2xvckxpZ2h0bmVzcyxcclxuICAgICAgb2JqZWN0VG9VcmxTdHI6IG9iamVjdFRvVXJsU3RyLFxyXG4gICAgICBpc0VxdWFsOiBpc0VxdWFsLFxyXG4gICAgICBwYXJhbUFycmF5OiBwYXJhbUFycmF5LFxyXG4gICAgICBwYXJhbTogcGFyYW0sXHJcbiAgICAgIGRlcGFyYW06IGRlcGFyYW0sXHJcbiAgICAgIGVtYmVkOiBlbWJlZCxcclxuICAgICAgZW1iZWRCeVVSTDogZW1iZWRCeVVSTCxcclxuICAgIH07XHJcblxyXG59KSh3aW5kb3cpO1xyXG5cclxuLy8gQlJBVCBTVEFOREFMT05FIExJQlJBUlkgQkVHSU5cclxuLy8gQnJvd3NlcmlmeSBleHBvcnRcclxubW9kdWxlLmV4cG9ydHMgPSBVdGlsO1xyXG4vLyBCUkFUIFNUQU5EQUxPTkUgTElCUkFSWSBFTkRcclxuIiwiLy8gLSotIE1vZGU6IEphdmFTY3JpcHQ7IHRhYi13aWR0aDogMjsgaW5kZW50LXRhYnMtbW9kZTogbmlsOyAtKi1cclxuLy8gdmltOnNldCBmdD1qYXZhc2NyaXB0IHRzPTIgc3c9MiBzdHM9MiBjaW5kZW50OlxyXG5cclxudmFyIFZpc3VhbGl6ZXIgPSAoZnVuY3Rpb24oJCwgd2luZG93LCB1bmRlZmluZWQpIHtcclxuICAgIHZhciBmb250TG9hZFRpbWVvdXQgPSA1MDAwOyAvLyA1IHNlY29uZHNcclxuICBcclxuICAgIHZhciBEb2N1bWVudERhdGEgPSBmdW5jdGlvbih0ZXh0KSB7XHJcbiAgICAgIHRoaXMudGV4dCA9IHRleHQ7XHJcbiAgICAgIHRoaXMuY2h1bmtzID0gW107XHJcbiAgICAgIHRoaXMuc3BhbnMgPSB7fTtcclxuICAgICAgdGhpcy5ldmVudERlc2NzID0ge307XHJcbiAgICAgIHRoaXMuc2VudENvbW1lbnQgPSB7fTtcclxuICAgICAgdGhpcy5hcmNzID0gW107XHJcbiAgICAgIHRoaXMuYXJjQnlJZCA9IHt9O1xyXG4gICAgICB0aGlzLm1hcmtlZFNlbnQgPSB7fTtcclxuICAgICAgdGhpcy5zcGFuQW5uVGV4dHMgPSB7fTtcclxuICAgICAgdGhpcy50b3dlcnMgPSB7fTtcclxuICAgICAgLy8gdGhpcy5zaXplcyA9IHt9O1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgRnJhZ21lbnQgPSBmdW5jdGlvbihpZCwgc3BhbiwgZnJvbSwgdG8pIHtcclxuICAgICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgICB0aGlzLnNwYW4gPSBzcGFuO1xyXG4gICAgICB0aGlzLmZyb20gPSBmcm9tO1xyXG4gICAgICB0aGlzLnRvID0gdG87XHJcbiAgICAgIC8vIHRoaXMudG93ZXJJZCA9IHVuZGVmaW5lZDtcclxuICAgICAgLy8gdGhpcy5kcmF3T3JkZXIgPSB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBTcGFuID0gZnVuY3Rpb24oaWQsIHR5cGUsIG9mZnNldHMsIGdlbmVyYWxUeXBlKSB7XHJcbiAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgICAgdGhpcy50b3RhbERpc3QgPSAwO1xyXG4gICAgICB0aGlzLm51bUFyY3MgPSAwO1xyXG4gICAgICB0aGlzLmdlbmVyYWxUeXBlID0gZ2VuZXJhbFR5cGU7XHJcbiAgICAgIHRoaXMub2Zmc2V0cyA9IG9mZnNldHM7XHJcbiAgICAgIHRoaXMuaGVhZEZyYWdtZW50ID0gbnVsbDtcclxuICAgICAgLy8gdGhpcy5mcm9tID0gdW5kZWZpbmVkO1xyXG4gICAgICAvLyB0aGlzLnRvID0gdW5kZWZpbmVkO1xyXG4gICAgICAvLyB0aGlzLndob2xlRnJvbSA9IHVuZGVmaW5lZDtcclxuICAgICAgLy8gdGhpcy53aG9sZVRvID0gdW5kZWZpbmVkO1xyXG4gICAgICAvLyB0aGlzLmhlYWRGcmFnbWVudCA9IHVuZGVmaW5lZDtcclxuICAgICAgLy8gdGhpcy5jaHVuayA9IHVuZGVmaW5lZDtcclxuICAgICAgLy8gdGhpcy5tYXJrZWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgIC8vIHRoaXMuYXZnRGlzdCA9IHVuZGVmaW5lZDtcclxuICAgICAgLy8gdGhpcy5jdXJseSA9IHVuZGVmaW5lZDtcclxuICAgICAgLy8gdGhpcy5jb21tZW50ID0gdW5kZWZpbmVkOyAvLyB7IHR5cGU6IHVuZGVmaW5lZCwgdGV4dDogdW5kZWZpbmVkIH07XHJcbiAgICAgIC8vIHRoaXMuYW5ub3RhdG9yTm90ZXMgPSB1bmRlZmluZWQ7XHJcbiAgICAgIC8vIHRoaXMuZHJhd0N1cmx5ID0gdW5kZWZpbmVkO1xyXG4gICAgICAvLyB0aGlzLmdseXBoZWRMYWJlbFRleHQgPSB1bmRlZmluZWQ7XHJcbiAgICAgIC8vIHRoaXMuZ3JvdXAgPSB1bmRlZmluZWQ7XHJcbiAgICAgIC8vIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAvLyB0aGlzLmhpZ2hsaWdodFBvcyA9IHVuZGVmaW5lZDtcclxuICAgICAgLy8gdGhpcy5pbmRleE51bWJlciA9IHVuZGVmaW5lZDtcclxuICAgICAgLy8gdGhpcy5sYWJlbFRleHQgPSB1bmRlZmluZWQ7XHJcbiAgICAgIC8vIHRoaXMubmVzdGluZ0RlcHRoID0gdW5kZWZpbmVkO1xyXG4gICAgICAvLyB0aGlzLm5lc3RpbmdEZXB0aExSID0gdW5kZWZpbmVkO1xyXG4gICAgICAvLyB0aGlzLm5lc3RpbmdEZXB0aFJMID0gdW5kZWZpbmVkO1xyXG4gICAgICAvLyB0aGlzLm5lc3RpbmdIZWlnaHQgPSB1bmRlZmluZWQ7XHJcbiAgICAgIC8vIHRoaXMubmVzdGluZ0hlaWdodExSID0gdW5kZWZpbmVkO1xyXG4gICAgICAvLyB0aGlzLm5lc3RpbmdIZWlnaHRSTCA9IHVuZGVmaW5lZDtcclxuICAgICAgLy8gdGhpcy5yZWN0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAvLyB0aGlzLnJlY3RCb3ggPSB1bmRlZmluZWQ7XHJcbiAgICAgIC8vIHRoaXMucmVmZWRJbmRleFN1bSA9IHVuZGVmaW5lZDtcclxuICAgICAgLy8gdGhpcy5yaWdodCA9IHVuZGVmaW5lZDtcclxuICAgICAgLy8gdGhpcy50b3RhbGRpc3QgPSB1bmRlZmluZWQ7XHJcbiAgICAgIC8vIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XHJcbiAgICAgIHRoaXMuaW5pdENvbnRhaW5lcnMob2Zmc2V0cyk7XHJcbiAgICB9O1xyXG5cclxuICAgIFNwYW4ucHJvdG90eXBlLmluaXRDb250YWluZXJzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHRoaXMuaW5jb21pbmcgPSBbXTtcclxuICAgICAgdGhpcy5vdXRnb2luZyA9IFtdO1xyXG4gICAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcclxuICAgICAgdGhpcy5hdHRyaWJ1dGVUZXh0ID0gW107XHJcbiAgICAgIHRoaXMuYXR0cmlidXRlQ3VlcyA9IHt9O1xyXG4gICAgICB0aGlzLmF0dHJpYnV0ZUN1ZUZvciA9IHt9O1xyXG4gICAgICB0aGlzLmF0dHJpYnV0ZU1lcmdlID0ge307IC8vIGZvciBib3gsIGNyb3NzLCBldGMuIHRoYXQgYXJlIHNwYW4tZ2xvYmFsXHJcbiAgICAgIHRoaXMuZnJhZ21lbnRzID0gW107XHJcbiAgICAgIHRoaXMubm9ybWFsaXphdGlvbnMgPSBbXTtcclxuICAgIH07XHJcblxyXG4gICAgU3Bhbi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICAgIHZhciBzcGFuID0gJC5leHRlbmQobmV3IFNwYW4oKSwgdGhpcyk7IC8vIGNsb25lXHJcbiAgICAgIHNwYW4uaWQgPSBpZDtcclxuICAgICAgc3Bhbi5pbml0Q29udGFpbmVycygpOyAvLyBwcm90ZWN0IGZyb20gc2hhbGxvdyBjb3B5XHJcbiAgICAgIHJldHVybiBzcGFuO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgRXZlbnREZXNjID0gZnVuY3Rpb24oaWQsIHRyaWdnZXJJZCwgcm9sZXMsIGtsYXNzKSB7XHJcbiAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgICAgdGhpcy50cmlnZ2VySWQgPSB0cmlnZ2VySWQ7XHJcbiAgICAgIHZhciByb2xlTGlzdCA9IHRoaXMucm9sZXMgPSBbXTtcclxuICAgICAgJC5lYWNoKHJvbGVzLCBmdW5jdGlvbihyb2xlTm8sIHJvbGUpIHtcclxuICAgICAgICByb2xlTGlzdC5wdXNoKHsgdHlwZTogcm9sZVswXSwgdGFyZ2V0SWQ6IHJvbGVbMV0gfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAoa2xhc3MgPT0gXCJlcXVpdlwiKSB7XHJcbiAgICAgICAgdGhpcy5lcXVpdiA9IHRydWU7XHJcbiAgICAgIH0gZWxzZSBpZiAoa2xhc3MgPT0gXCJyZWxhdGlvblwiKSB7XHJcbiAgICAgICAgdGhpcy5yZWxhdGlvbiA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgLy8gdGhpcy5sZWZ0U3BhbnMgPSB1bmRlZmluZWQ7XHJcbiAgICAgIC8vIHRoaXMucmlnaHRTcGFucyA9IHVuZGVmaW5lZDtcclxuICAgICAgLy8gdGhpcy5hbm5vdGF0b3JOb3RlcyA9IHVuZGVmaW5lZDtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIENodW5rID0gZnVuY3Rpb24oaW5kZXgsIHRleHQsIGZyb20sIHRvLCBzcGFjZSwgc3BhbnMpIHtcclxuICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gICAgICB0aGlzLnRleHQgPSB0ZXh0O1xyXG4gICAgICB0aGlzLmZyb20gPSBmcm9tO1xyXG4gICAgICB0aGlzLnRvID0gdG87XHJcbiAgICAgIHRoaXMuc3BhY2UgPSBzcGFjZTtcclxuICAgICAgdGhpcy5mcmFnbWVudHMgPSBbXTtcclxuICAgICAgLy8gdGhpcy5zZW50ZW5jZSA9IHVuZGVmaW5lZDtcclxuICAgICAgLy8gdGhpcy5ncm91cCA9IHVuZGVmaW5lZDtcclxuICAgICAgLy8gdGhpcy5oaWdobGlnaHRHcm91cCA9IHVuZGVmaW5lZDtcclxuICAgICAgLy8gdGhpcy5tYXJrZWRUZXh0U3RhcnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgIC8vIHRoaXMubWFya2VkVGV4dEVuZCA9IHVuZGVmaW5lZDtcclxuICAgICAgLy8gdGhpcy5uZXh0U3BhY2UgPSB1bmRlZmluZWQ7XHJcbiAgICAgIC8vIHRoaXMucmlnaHQgPSB1bmRlZmluZWQ7XHJcbiAgICAgIC8vIHRoaXMucm93ID0gdW5kZWZpbmVkO1xyXG4gICAgICAvLyB0aGlzLnRleHRYID0gdW5kZWZpbmVkO1xyXG4gICAgICAvLyB0aGlzLnRyYW5zbGF0aW9uID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBBcmMgPSBmdW5jdGlvbihldmVudERlc2MsIHJvbGUsIGRpc3QsIGV2ZW50Tm8pIHtcclxuICAgICAgdGhpcy5vcmlnaW4gPSBldmVudERlc2MuaWQ7XHJcbiAgICAgIHRoaXMudGFyZ2V0ID0gcm9sZS50YXJnZXRJZDtcclxuICAgICAgdGhpcy5kaXN0ID0gZGlzdDtcclxuICAgICAgdGhpcy50eXBlID0gcm9sZS50eXBlO1xyXG4gICAgICB0aGlzLnNoYWRvd0NsYXNzID0gZXZlbnREZXNjLnNoYWRvd0NsYXNzO1xyXG4gICAgICB0aGlzLmp1bXBIZWlnaHQgPSAwO1xyXG4gICAgICBpZiAoZXZlbnREZXNjLmVxdWl2KSB7XHJcbiAgICAgICAgdGhpcy5lcXVpdiA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5ldmVudERlc2NJZCA9IGV2ZW50Tm87XHJcbiAgICAgICAgZXZlbnREZXNjLmVxdWl2QXJjID0gdGhpcztcclxuICAgICAgfSBlbHNlIGlmIChldmVudERlc2MucmVsYXRpb24pIHtcclxuICAgICAgICB0aGlzLnJlbGF0aW9uID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmV2ZW50RGVzY0lkID0gZXZlbnRObztcclxuICAgICAgfVxyXG4gICAgICAvLyB0aGlzLm1hcmtlZCA9IHVuZGVmaW5lZDtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIFJvdyA9IGZ1bmN0aW9uKHN2Zykge1xyXG4gICAgICB0aGlzLmdyb3VwID0gc3ZnLmdyb3VwKCk7XHJcbiAgICAgIHRoaXMuYmFja2dyb3VuZCA9IHN2Zy5ncm91cCh0aGlzLmdyb3VwKTtcclxuICAgICAgdGhpcy5jaHVua3MgPSBbXTtcclxuICAgICAgdGhpcy5oYXNBbm5vdGF0aW9ucyA9IGZhbHNlO1xyXG4gICAgICB0aGlzLm1heEFyY0hlaWdodCA9IDA7XHJcbiAgICAgIHRoaXMubWF4U3BhbkhlaWdodCA9IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBNZWFzdXJlbWVudHMgPSBmdW5jdGlvbih3aWR0aHMsIGhlaWdodCwgeSkge1xyXG4gICAgICB0aGlzLndpZHRocyA9IHdpZHRocztcclxuICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgIHRoaXMueSA9IHk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEEgbmFpdmUgd2hpdGVzcGFjZSB0b2tlbmlzZXJcclxuICAgIHZhciB0b2tlbmlzZSA9IGZ1bmN0aW9uKHRleHQpIHtcclxuICAgICAgdmFyIHRva2VuT2Zmc2V0cyA9IFtdO1xyXG4gICAgICB2YXIgdG9rZW5TdGFydCA9IG51bGw7XHJcbiAgICAgIHZhciBsYXN0Q2hhclBvcyA9IG51bGw7XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgYyA9IHRleHRbaV07XHJcbiAgICAgICAgLy8gSGF2ZSB3ZSBmb3VuZCB0aGUgc3RhcnQgb2YgYSB0b2tlbj9cclxuICAgICAgICBpZiAodG9rZW5TdGFydCA9PSBudWxsICYmICEvXFxzLy50ZXN0KGMpKSB7XHJcbiAgICAgICAgICB0b2tlblN0YXJ0ID0gaTtcclxuICAgICAgICAgIGxhc3RDaGFyUG9zID0gaTtcclxuICAgICAgICAvLyBIYXZlIHdlIGZvdW5kIHRoZSBlbmQgb2YgYSB0b2tlbj9cclxuICAgICAgICB9IGVsc2UgaWYgKC9cXHMvLnRlc3QoYykgJiYgdG9rZW5TdGFydCAhPSBudWxsKSB7XHJcbiAgICAgICAgICB0b2tlbk9mZnNldHMucHVzaChbdG9rZW5TdGFydCwgaV0pO1xyXG4gICAgICAgICAgdG9rZW5TdGFydCA9IG51bGw7XHJcbiAgICAgICAgLy8gSXMgaXQgYSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXI/XHJcbiAgICAgICAgfSBlbHNlIGlmICghL1xccy8udGVzdChjKSkge1xyXG4gICAgICAgICAgbGFzdENoYXJQb3MgPSBpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvLyBEbyB3ZSBoYXZlIGEgdHJhaWxpbmcgdG9rZW4/XHJcbiAgICAgIGlmICh0b2tlblN0YXJ0ICE9IG51bGwpIHtcclxuICAgICAgICB0b2tlbk9mZnNldHMucHVzaChbdG9rZW5TdGFydCwgbGFzdENoYXJQb3MgKyAxXSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0b2tlbk9mZnNldHM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEEgbmFpdmUgbmV3bGluZSBzZW50ZW5jZSBzcGxpdHRlclxyXG4gICAgdmFyIHNlbnRlbmNlU3BsaXQgPSBmdW5jdGlvbih0ZXh0KSB7XHJcbiAgICAgIHZhciBzZW50ZW5jZU9mZnNldHMgPSBbXTtcclxuICAgICAgdmFyIHNlbnRTdGFydCA9IG51bGw7XHJcbiAgICAgIHZhciBsYXN0Q2hhclBvcyA9IG51bGw7XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgYyA9IHRleHRbaV07XHJcbiAgICAgICAgLy8gSGF2ZSB3ZSBmb3VuZCB0aGUgc3RhcnQgb2YgYSBzZW50ZW5jZT9cclxuICAgICAgICBpZiAoc2VudFN0YXJ0ID09IG51bGwgJiYgIS9cXHMvLnRlc3QoYykpIHtcclxuICAgICAgICAgIHNlbnRTdGFydCA9IGk7XHJcbiAgICAgICAgICBsYXN0Q2hhclBvcyA9IGk7XHJcbiAgICAgICAgLy8gSGF2ZSB3ZSBmb3VuZCB0aGUgZW5kIG9mIGEgc2VudGVuY2U/XHJcbiAgICAgICAgfSBlbHNlIGlmIChjID09ICdcXG4nICYmIHNlbnRTdGFydCAhPSBudWxsKSB7XHJcbiAgICAgICAgICBzZW50ZW5jZU9mZnNldHMucHVzaChbc2VudFN0YXJ0LCBpXSk7XHJcbiAgICAgICAgICBzZW50U3RhcnQgPSBudWxsO1xyXG4gICAgICAgIC8vIElzIGl0IGEgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyP1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIS9cXHMvLnRlc3QoYykpIHtcclxuICAgICAgICAgIGxhc3RDaGFyUG9zID0gaTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgLy8gRG8gd2UgaGF2ZSBhIHRyYWlsaW5nIHNlbnRlbmNlIHdpdGhvdXQgYSBjbG9zaW5nIG5ld2xpbmU/XHJcbiAgICAgIGlmIChzZW50U3RhcnQgIT0gbnVsbCkge1xyXG4gICAgICAgIHNlbnRlbmNlT2Zmc2V0cy5wdXNoKFtzZW50U3RhcnQsIGxhc3RDaGFyUG9zICsgMV0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gc2VudGVuY2VPZmZzZXRzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBTZXRzIGRlZmF1bHQgdmFsdWVzIGZvciBhIHdpZGUgcmFuZ2Ugb2Ygb3B0aW9uYWwgYXR0cmlidXRlc1xyXG4gICAgdmFyIHNldFNvdXJjZURhdGFEZWZhdWx0cyA9IGZ1bmN0aW9uKHNvdXJjZURhdGEpIHtcclxuICAgICAgLy8gVGhlIGZvbGxvd2luZyBhcmUgZW1wdHkgbGlzdHMgaWYgbm90IHNldFxyXG4gICAgICAkLmVhY2goW1xyXG4gICAgICAgICAgJ2F0dHJpYnV0ZXMnLFxyXG4gICAgICAgICAgJ2NvbW1lbnRzJyxcclxuICAgICAgICAgICdlbnRpdGllcycsXHJcbiAgICAgICAgICAnZXF1aXZzJyxcclxuICAgICAgICAgICdldmVudHMnLFxyXG4gICAgICAgICAgJ21vZGlmaWNhdGlvbnMnLFxyXG4gICAgICAgICAgJ25vcm1hbGl6YXRpb25zJyxcclxuICAgICAgICAgICdyZWxhdGlvbnMnLFxyXG4gICAgICAgICAgJ3RyaWdnZXJzJyxcclxuICAgICAgICAgIF0sIGZ1bmN0aW9uKGF0dHJObywgYXR0cikge1xyXG4gICAgICAgIGlmIChzb3VyY2VEYXRhW2F0dHJdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIHNvdXJjZURhdGFbYXR0cl0gPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gSWYgd2UgbGFjayBzZW50ZW5jZSBvZmZzZXRzIHdlIGZhbGwgYmFjayBvbiBuYWl2ZSBzZW50ZW5jZSBzcGxpdHRpbmdcclxuICAgICAgaWYgKHNvdXJjZURhdGEuc2VudGVuY2Vfb2Zmc2V0cyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgc291cmNlRGF0YS5zZW50ZW5jZV9vZmZzZXRzID0gc2VudGVuY2VTcGxpdChzb3VyY2VEYXRhLnRleHQpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIFNpbWlsYXJpbHkgd2UgZmFsbCBiYWNrIG9uIHdoaXRlc3BhY2UgdG9rZW5pc2F0aW9uXHJcbiAgICAgIGlmIChzb3VyY2VEYXRhLnRva2VuX29mZnNldHMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHNvdXJjZURhdGEudG9rZW5fb2Zmc2V0cyA9IHRva2VuaXNlKHNvdXJjZURhdGEudGV4dCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gU2V0IGRlZmF1bHQgdmFsdWVzIGZvciBhIHZhcmlldHkgb2YgY29sbGVjdGlvbiBhdHRyaWJ1dGVzXHJcbiAgICB2YXIgc2V0Q29sbGVjdGlvbkRlZmF1bHRzID0gZnVuY3Rpb24oY29sbGVjdGlvbkRhdGEpIHtcclxuICAgICAgLy8gVGhlIGZvbGxvd2luZyBhcmUgZW1wdHkgbGlzdHMgaWYgbm90IHNldFxyXG4gICAgICAkLmVhY2goW1xyXG4gICAgICAgICAgJ2VudGl0eV9hdHRyaWJ1dGVfdHlwZXMnLFxyXG4gICAgICAgICAgJ2VudGl0eV90eXBlcycsXHJcbiAgICAgICAgICAnZXZlbnRfYXR0cmlidXRlX3R5cGVzJyxcclxuICAgICAgICAgICdldmVudF90eXBlcycsXHJcbiAgICAgICAgICAncmVsYXRpb25fYXR0cmlidXRlX3R5cGVzJyxcclxuICAgICAgICAgICdyZWxhdGlvbl90eXBlcycsXHJcbiAgICAgICAgICAndW5jb25maWd1cmVkX3R5cGVzJyxcclxuICAgICAgICAgIF0sIGZ1bmN0aW9uKGF0dHJObywgYXR0cikge1xyXG4gICAgICAgIGlmIChjb2xsZWN0aW9uRGF0YVthdHRyXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBjb2xsZWN0aW9uRGF0YVthdHRyXSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBWaXN1YWxpemVyID0gZnVuY3Rpb24oZGlzcGF0Y2hlciwgc3ZnSWQsIHdlYkZvbnRVUkxzKSB7XHJcbiAgICAgIHZhciAkc3ZnRGl2ID0gJCgnIycgKyBzdmdJZCk7XHJcbiAgICAgIGlmICghJHN2Z0Rpdi5sZW5ndGgpIHtcclxuICAgICAgICB0aHJvdyBFcnJvcignQ291bGQgbm90IGZpbmQgY29udGFpbmVyIHdpdGggaWQ9XCInICsgc3ZnSWQgKyAnXCInKTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG4gICAgICAvLyBPUFRJT05TXHJcbiAgICAgIHZhciByb3VuZENvb3JkaW5hdGVzID0gdHJ1ZTsgLy8gdHJ5IHRvIGhhdmUgZXhhY3QgcGl4ZWwgb2Zmc2V0c1xyXG4gICAgICB2YXIgYm94VGV4dE1hcmdpbiA9IHsgeDogMCwgeTogMS41IH07IC8vIGVmZmVjdCBpcyBpbnZlcnNlIG9mIFwibWFyZ2luXCIgZm9yIHNvbWUgcmVhc29uXHJcbiAgICAgIHZhciBoaWdobGlnaHRSb3VuZGluZyA9IHsgeDogMywgeTozIH07IC8vIHJ4LCByeSBmb3IgaGlnaGxpZ2h0IGJveGVzXHJcbiAgICAgIHZhciBzcGFjZVdpZHRocyA9IHtcclxuICAgICAgICAnICc6IDQsXHJcbiAgICAgICAgJ1xcdTAwYTAnOiA0LFxyXG4gICAgICAgICdcXHUyMDBiJzogMCxcclxuICAgICAgICAnXFx1MzAwMCc6IDgsXHJcbiAgICAgICAgJ1xcdTAwMDknOiAxMiwgLy9Vbmljb2RlIHRhYnVsYXRpb25cclxuICAgICAgICAnXFxuJzogNFxyXG4gICAgICB9O1xyXG4gICAgICB2YXIgY29sb3JlZEN1cmxpZXMgPSB0cnVlOyAvLyBjb2xvciBjdXJsaWVzIGJ5IGJveCBCR1xyXG4gICAgICB2YXIgYXJjU2xhbnQgPSAxNTsgLy8xMDtcclxuICAgICAgdmFyIG1pbkFyY1NsYW50ID0gODtcclxuICAgICAgdmFyIGFyY0hvcml6b250YWxTcGFjaW5nID0gMTA7IC8vIG1pbiBzcGFjZSBib3hlcyB3aXRoIGNvbm5lY3RpbmcgYXJjXHJcbiAgICAgIHZhciByb3dTcGFjaW5nID0gLTU7ICAgICAgICAgIC8vIGZvciBzb21lIGZ1bm55IHJlYXNvbiBhcHByb3guIC0xMCBnaXZlcyBcInRpZ2h0XCIgcGFja2luZy5cclxuICAgICAgdmFyIHNlbnROdW1NYXJnaW4gPSA1MDtcclxuICAgICAgdmFyIHNtb290aEFyY0N1cnZlcyA9IHRydWU7ICAgLy8gd2hldGhlciB0byB1c2UgY3VydmVzICh2cyBsaW5lcykgaW4gYXJjc1xyXG4gICAgICB2YXIgc21vb3RoQXJjU3RlZXBuZXNzID0gMC41OyAvLyBzdGVlcG5lc3Mgb2Ygc21vb3RoIGN1cnZlcyAoY29udHJvbCBwb2ludClcclxuICAgICAgdmFyIHJldmVyc2VBcmNDb250cm9seCA9IDU7ICAgLy8gY29udHJvbCBwb2ludCBkaXN0YW5jZSBmb3IgXCJVRk8gY2F0Y2hlcnNcIlxyXG5cclxuICAgICAgLy8gXCJzaGFkb3dcIiBlZmZlY3Qgc2V0dGluZ3MgKG5vdGUsIGVycm9yLCBpbmNvbXBlbGV0ZSlcclxuICAgICAgdmFyIHJlY3RTaGFkb3dTaXplID0gMztcclxuICAgICAgdmFyIHJlY3RTaGFkb3dSb3VuZGluZyA9IDIuNTtcclxuICAgICAgdmFyIGFyY0xhYmVsU2hhZG93U2l6ZSA9IDE7XHJcbiAgICAgIHZhciBhcmNMYWJlbFNoYWRvd1JvdW5kaW5nID0gNTtcclxuICAgICAgdmFyIHNoYWRvd1N0cm9rZSA9IDIuNTsgLy8gVE9ETyBYWFg6IHRoaXMgZG9lc24ndCBhZmZlY3QgYW55dGhpbmcuLj9cclxuXHJcbiAgICAgIC8vIFwibWFya2VkXCIgZWZmZWN0IHNldHRpbmdzIChlZGl0ZWQsIGZvY3VzLCBtYXRjaClcclxuICAgICAgdmFyIG1hcmtlZFNwYW5TaXplID0gNjtcclxuICAgICAgdmFyIG1hcmtlZEFyY1NpemUgPSAyO1xyXG4gICAgICB2YXIgbWFya2VkQXJjU3Ryb2tlID0gNzsgLy8gVE9ETyBYWFg6IHRoaXMgZG9lc24ndCBzZWVtIHRvIGRvIGFueXRoaW5nLi4/XHJcblxyXG4gICAgICB2YXIgcm93UGFkZGluZyA9IDI7XHJcbiAgICAgIHZhciBuZXN0aW5nQWRqdXN0WVN0ZXBTaXplID0gMjsgLy8gc2l6ZSBvZiBoZWlnaHQgYWRqdXN0IGZvciBuZXN0ZWQvbmVzdGluZyBzcGFuc1xyXG4gICAgICB2YXIgbmVzdGluZ0FkanVzdFhTdGVwU2l6ZSA9IDE7IC8vIHNpemUgb2YgaGVpZ2h0IGFkanVzdCBmb3IgbmVzdGVkL25lc3Rpbmcgc3BhbnNcclxuXHJcbiAgICAgIHZhciBoaWdobGlnaHRTZXF1ZW5jZSA9ICcjRkY5NjMyOyNGRkNDMDA7I0ZGOTYzMic7IC8vIHllbGxvdyAtIGRlZXAgb3JhbmdlXHJcbiAgICAgIC8vdmFyIGhpZ2hsaWdodFNlcXVlbmNlID0gJyNGRkZDNjk7I0ZGQ0MwMDsjRkZGQzY5JzsgLy8gYSBiaXQgdG9uZWQgdG93blxyXG4gICAgICB2YXIgaGlnaGxpZ2h0U3BhblNlcXVlbmNlID0gaGlnaGxpZ2h0U2VxdWVuY2U7XHJcbiAgICAgIHZhciBoaWdobGlnaHRBcmNTZXF1ZW5jZSA9ICBoaWdobGlnaHRTZXF1ZW5jZTtcclxuICAgICAgdmFyIGhpZ2hsaWdodFRleHRTZXF1ZW5jZSA9IGhpZ2hsaWdodFNlcXVlbmNlO1xyXG4gICAgICB2YXIgaGlnaGxpZ2h0RHVyYXRpb24gPSAnMnMnO1xyXG4gICAgICAvLyBkaWZmZXJlbnQgc2VxdWVuY2UgZm9yIFwibWVyZVwiIG1hdGNoZXMgKGFzIG9wcG9zZWQgdG8gXCJmb2N1c1wiIGFuZFxyXG4gICAgICAvLyBcImVkaXRlZFwiIGhpZ2hsaWdodHMpXHJcbiAgICAgIHZhciBoaWdobGlnaHRNYXRjaFNlcXVlbmNlID0gJyNGRkZGMDAnOyAvLyBwbGFpbiB5ZWxsb3dcclxuXHJcbiAgICAgIHZhciBmcmFnbWVudENvbm5lY3RvckRhc2hBcnJheSA9ICcxLDMsMywzJztcclxuICAgICAgdmFyIGZyYWdtZW50Q29ubmVjdG9yQ29sb3IgPSAnIzAwMDAwMCc7XHJcblxyXG4gICAgICAvLyBFTkQgT1BUSU9OU1xyXG5cclxuXHJcbiAgICAgIHZhciBzdmc7XHJcbiAgICAgIHZhciAkc3ZnO1xyXG4gICAgICB2YXIgZGF0YSA9IG51bGw7XHJcbiAgICAgIHZhciBzb3VyY2VEYXRhID0gbnVsbDtcclxuICAgICAgdmFyIHJlcXVlc3RlZERhdGEgPSBudWxsO1xyXG4gICAgICB2YXIgY29sbCwgZG9jLCBhcmdzO1xyXG4gICAgICB2YXIgcmVsYXRpb25UeXBlc0hhc2g7XHJcbiAgICAgIHZhciBpc1JlbmRlclJlcXVlc3RlZDtcclxuICAgICAgdmFyIGlzQ29sbGVjdGlvbkxvYWRlZCA9IGZhbHNlO1xyXG4gICAgICB2YXIgZW50aXR5QXR0cmlidXRlVHlwZXMgPSBudWxsO1xyXG4gICAgICB2YXIgZXZlbnRBdHRyaWJ1dGVUeXBlcyA9IG51bGw7XHJcbiAgICAgIHZhciBzcGFuVHlwZXMgPSBudWxsO1xyXG4gICAgICB2YXIgaGlnaGxpZ2h0R3JvdXA7XHJcblxyXG4gICAgICAvLyB2YXIgY29tbWVudFByaW9MZXZlbHMgPSBbJ1VuY29uZmlybWVkJywgJ0luY29tcGxldGUnLCAnV2FybmluZycsICdFcnJvcicsICdBbm5vdGF0b3JOb3RlcyddO1xyXG4gICAgICAvLyBYWFggTWlnaHQgbmVlZCB0byBiZSB0d2Vha2VkIC0gaW5zZXJ0ZWQgZGlmZiBsZXZlbHNcclxuICAgICAgdmFyIGNvbW1lbnRQcmlvTGV2ZWxzID0gW1xyXG4gICAgICAgICdVbmNvbmZpcm1lZCcsICdJbmNvbXBsZXRlJywgJ1dhcm5pbmcnLCAnRXJyb3InLCAnQW5ub3RhdG9yTm90ZXMnLFxyXG4gICAgICAgICdBZGRlZEFubm90YXRpb24nLCAnTWlzc2luZ0Fubm90YXRpb24nLCAnQ2hhbmdlZEFubm90YXRpb24nXTtcclxuXHJcbiAgICAgIHRoaXMuYXJjRHJhZ09yaWdpbiA9IG51bGw7IC8vIFRPRE9cclxuXHJcbiAgICAgIC8vIGR1ZSB0byBzaWxseSBDaHJvbWUgYnVnLCBJIGhhdmUgdG8gbWFrZSBpdCBwYXkgYXR0ZW50aW9uXHJcbiAgICAgIHZhciBmb3JjZVJlZHJhdyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICghJC5icm93c2VyLmNocm9tZSkgcmV0dXJuOyAvLyBub3QgbmVlZGVkXHJcbiAgICAgICAgJHN2Zy5jc3MoJ21hcmdpbi1ib3R0b20nLCAxKTtcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyAkc3ZnLmNzcygnbWFyZ2luLWJvdHRvbScsIDApOyB9LCAwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHJvd0JCb3ggPSBmdW5jdGlvbihzcGFuKSB7XHJcbiAgICAgICAgdmFyIGJveCA9ICQuZXh0ZW5kKHt9LCBzcGFuLnJlY3RCb3gpOyAvLyBjbG9uZVxyXG4gICAgICAgIHZhciBjaHVua1RyYW5zbGF0aW9uID0gc3Bhbi5jaHVuay50cmFuc2xhdGlvbjtcclxuICAgICAgICBib3gueCArPSBjaHVua1RyYW5zbGF0aW9uLng7XHJcbiAgICAgICAgYm94LnkgKz0gY2h1bmtUcmFuc2xhdGlvbi55O1xyXG4gICAgICAgIHJldHVybiBib3g7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgY29tbWVudFByaW9yaXR5ID0gZnVuY3Rpb24oY29tbWVudENsYXNzKSB7XHJcbiAgICAgICAgaWYgKGNvbW1lbnRDbGFzcyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gLTE7XHJcbiAgICAgICAgdmFyIGxlbiA9IGNvbW1lbnRQcmlvTGV2ZWxzLmxlbmd0aDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICBpZiAoY29tbWVudENsYXNzLmluZGV4T2YoY29tbWVudFByaW9MZXZlbHNbaV0pICE9IC0xKSByZXR1cm4gaTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgY2xlYXJTVkcgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBkYXRhID0gbnVsbDtcclxuICAgICAgICBzb3VyY2VEYXRhID0gbnVsbDtcclxuICAgICAgICBzdmcuY2xlYXIoKTtcclxuICAgICAgICAkc3ZnRGl2LmhpZGUoKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciBzZXRNYXJrZWQgPSBmdW5jdGlvbihtYXJrZWRUeXBlKSB7XHJcbiAgICAgICAgJC5lYWNoKGFyZ3NbbWFya2VkVHlwZV0gfHwgW10sIGZ1bmN0aW9uKG1hcmtlZE5vLCBtYXJrZWQpIHtcclxuICAgICAgICAgIGlmIChtYXJrZWRbMF0gPT0gJ3NlbnQnKSB7XHJcbiAgICAgICAgICAgIGRhdGEubWFya2VkU2VudFttYXJrZWRbMV1dID0gdHJ1ZTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAobWFya2VkWzBdID09ICdlcXVpdicpIHsgLy8gW2VxdWl2LCBFcXVpdiwgVDFdXHJcbiAgICAgICAgICAgICQuZWFjaChzb3VyY2VEYXRhLmVxdWl2cywgZnVuY3Rpb24oZXF1aXZObywgZXF1aXYpIHtcclxuICAgICAgICAgICAgICBpZiAoZXF1aXZbMV0gPT0gbWFya2VkWzFdKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gZXF1aXYubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDI7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICBpZiAoZXF1aXZbaV0gPT0gbWFya2VkWzJdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZm91bmQgaXRcclxuICAgICAgICAgICAgICAgICAgICBsZW4gLT0gMztcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGFyYyA9IGRhdGEuZXZlbnREZXNjc1tlcXVpdlswXSArIFwiKlwiICsgaV0uZXF1aXZBcmM7XHJcbiAgICAgICAgICAgICAgICAgICAgICBhcmMubWFya2VkID0gbWFya2VkVHlwZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBuZXh0IGVxdWl2XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChtYXJrZWQubGVuZ3RoID09IDIpIHtcclxuICAgICAgICAgICAgbWFya2VkVGV4dC5wdXNoKFtwYXJzZUludChtYXJrZWRbMF0sIDEwKSwgcGFyc2VJbnQobWFya2VkWzFdLCAxMCksIG1hcmtlZFR5cGVdKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBzcGFuID0gZGF0YS5zcGFuc1ttYXJrZWRbMF1dO1xyXG4gICAgICAgICAgICBpZiAoc3Bhbikge1xyXG4gICAgICAgICAgICAgIGlmIChtYXJrZWQubGVuZ3RoID09IDMpIHsgLy8gYXJjXHJcbiAgICAgICAgICAgICAgICAkLmVhY2goc3Bhbi5vdXRnb2luZywgZnVuY3Rpb24oYXJjTm8sIGFyYykge1xyXG4gICAgICAgICAgICAgICAgICBpZiAoYXJjLnRhcmdldCA9PSBtYXJrZWRbMl0gJiYgYXJjLnR5cGUgPT0gbWFya2VkWzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJjLm1hcmtlZCA9IG1hcmtlZFR5cGU7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7IC8vIHNwYW5cclxuICAgICAgICAgICAgICAgIHNwYW4ubWFya2VkID0gbWFya2VkVHlwZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdmFyIGV2ZW50RGVzYyA9IGRhdGEuZXZlbnREZXNjc1ttYXJrZWRbMF1dO1xyXG4gICAgICAgICAgICAgIGlmIChldmVudERlc2MpIHsgLy8gcmVsYXRpb25cclxuICAgICAgICAgICAgICAgIHZhciByZWxBcmMgPSBldmVudERlc2Mucm9sZXNbMF07XHJcbiAgICAgICAgICAgICAgICAkLmVhY2goZGF0YS5zcGFuc1tldmVudERlc2MudHJpZ2dlcklkXS5vdXRnb2luZywgZnVuY3Rpb24oYXJjTm8sIGFyYykge1xyXG4gICAgICAgICAgICAgICAgICBpZiAoYXJjLnRhcmdldCA9PSByZWxBcmMudGFyZ2V0SWQgJiYgYXJjLnR5cGUgPT0gcmVsQXJjLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBhcmMubWFya2VkID0gbWFya2VkVHlwZTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gdHJ5IGZvciB0cmlnZ2VyXHJcbiAgICAgICAgICAgICAgICAkLmVhY2goZGF0YS5ldmVudERlc2NzLCBmdW5jdGlvbihldmVudERlc2NObywgZXZlbnREZXNjKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChldmVudERlc2MudHJpZ2dlcklkID09IG1hcmtlZFswXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc3BhbnNbZXZlbnREZXNjLmlkXS5tYXJrZWQgPSBtYXJrZWRUeXBlO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciBmcmFnbWVudENvbXBhcmF0b3IgPSBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgdmFyIHRtcDtcclxuICAgICAgICB2YXIgYVNwYW4gPSBhLnNwYW47XHJcbiAgICAgICAgdmFyIGJTcGFuID0gYi5zcGFuO1xyXG5cclxuICAgICAgICAvLyBzcGFucyB3aXRoIG1vcmUgZnJhZ21lbnRzIGdvIGZpcnN0XHJcbiAgICAgICAgdG1wID0gYVNwYW4uZnJhZ21lbnRzLmxlbmd0aCAtIGJTcGFuLmZyYWdtZW50cy5sZW5ndGg7XHJcbiAgICAgICAgaWYgKHRtcCkge1xyXG4gICAgICAgICAgcmV0dXJuIHRtcCA8IDAgPyAxIDogLTE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBsb25nZXIgYXJjIGRpc3RhbmNlcyBnbyBsYXN0XHJcbiAgICAgICAgdG1wID0gYVNwYW4uYXZnRGlzdCAtIGJTcGFuLmF2Z0Rpc3Q7XHJcbiAgICAgICAgaWYgKHRtcCkge1xyXG4gICAgICAgICAgcmV0dXJuIHRtcCA8IDAgPyAtMSA6IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNwYW5zIHdpdGggbW9yZSBhcmNzIGdvIGxhc3RcclxuICAgICAgICB0bXAgPSBhU3Bhbi5udW1BcmNzIC0gYlNwYW4ubnVtQXJjcztcclxuICAgICAgICBpZiAodG1wKSB7XHJcbiAgICAgICAgICByZXR1cm4gdG1wIDwgMCA/IC0xIDogMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY29tcGFyZSB0aGUgc3BhbiB3aWR0aHMsXHJcbiAgICAgICAgLy8gcHV0IHdpZGVyIG9uIGJvdHRvbSBzbyB0aGV5IGRvbid0IG1lc3Mgd2l0aCBhcmNzLCBvciBzaG9ydGVyXHJcbiAgICAgICAgLy8gb24gYm90dG9tIGlmIHRoZXJlIGFyZSBubyBhcmNzLlxyXG4gICAgICAgIHZhciBhZCA9IGEudG8gLSBhLmZyb207XHJcbiAgICAgICAgdmFyIGJkID0gYi50byAtIGIuZnJvbTtcclxuICAgICAgICB0bXAgPSBhZCAtIGJkO1xyXG4gICAgICAgIGlmIChhU3Bhbi5udW1BcmNzID09IDAgJiYgYlNwYW4ubnVtQXJjcyA9PSAwKSB7XHJcbiAgICAgICAgICB0bXAgPSAtdG1wO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodG1wKSB7XHJcbiAgICAgICAgICByZXR1cm4gdG1wIDwgMCA/IDEgOiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdG1wID0gYVNwYW4ucmVmZWRJbmRleFN1bSAtIGJTcGFuLnJlZmVkSW5kZXhTdW07XHJcbiAgICAgICAgaWYgKHRtcCkge1xyXG4gICAgICAgICAgcmV0dXJuIHRtcCA8IDAgPyAtMSA6IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmIG5vIG90aGVyIGNyaXRlcmlvbiBpcyBmb3VuZCwgc29ydCBieSB0eXBlIHRvIG1haW50YWluXHJcbiAgICAgICAgLy8gY29uc2lzdGVuY3lcclxuICAgICAgICAvLyBUT0RPOiBpc24ndCB0aGVyZSBhIGNtcCgpIGluIEpTP1xyXG4gICAgICAgIGlmIChhU3Bhbi50eXBlIDwgYlNwYW4udHlwZSkge1xyXG4gICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYVNwYW4udHlwZSA+IGJTcGFuLnR5cGUpIHtcclxuICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgIH07XHJcblxyXG5cclxuICAgICAgdmFyIHNldERhdGEgPSBmdW5jdGlvbihfc291cmNlRGF0YSkge1xyXG4gICAgICAgIGlmICghYXJncykgYXJncyA9IHt9O1xyXG4gICAgICAgIHNvdXJjZURhdGEgPSBfc291cmNlRGF0YTtcclxuICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ25ld1NvdXJjZURhdGEnLCBbc291cmNlRGF0YV0pO1xyXG4gICAgICAgIGRhdGEgPSBuZXcgRG9jdW1lbnREYXRhKHNvdXJjZURhdGEudGV4dCk7XHJcblxyXG4gICAgICAgIC8vIGNvbGxlY3QgYW5ub3RhdGlvbiBkYXRhXHJcbiAgICAgICAgJC5lYWNoKHNvdXJjZURhdGEuZW50aXRpZXMsIGZ1bmN0aW9uKGVudGl0eU5vLCBlbnRpdHkpIHtcclxuICAgICAgICAgIC8vIG9mZnNldHMgZ2l2ZW4gYXMgYXJyYXkgb2YgKHN0YXJ0LCBlbmQpIHBhaXJzXHJcbiAgICAgICAgICB2YXIgc3BhbiA9XHJcbiAgICAgICAgICAgICAgLy8gICAgICAoaWQsICAgICAgICB0eXBlLCAgICAgIG9mZnNldHMsICAgZ2VuZXJhbFR5cGUpXHJcbiAgICAgICAgICAgICAgbmV3IFNwYW4oZW50aXR5WzBdLCBlbnRpdHlbMV0sIGVudGl0eVsyXSwgJ2VudGl0eScpO1xyXG4gICAgICAgICAgZGF0YS5zcGFuc1tlbnRpdHlbMF1dID0gc3BhbjtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgdHJpZ2dlckhhc2ggPSB7fTtcclxuICAgICAgICAkLmVhY2goc291cmNlRGF0YS50cmlnZ2VycywgZnVuY3Rpb24odHJpZ2dlck5vLCB0cmlnZ2VyKSB7XHJcbiAgICAgICAgICB0cmlnZ2VySGFzaFt0cmlnZ2VyWzBdXSA9XHJcbiAgICAgICAgICAgICAgLy8gICAgICAgKGlkLCAgICAgICAgIHR5cGUsICAgICAgIG9mZnNldHMsICAgIGdlbmVyYWxUeXBlKSwgZXZlbnRMaXN0XHJcbiAgICAgICAgICAgICAgW25ldyBTcGFuKHRyaWdnZXJbMF0sIHRyaWdnZXJbMV0sIHRyaWdnZXJbMl0sICd0cmlnZ2VyJyksIFtdXTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAkLmVhY2goc291cmNlRGF0YS5ldmVudHMsIGZ1bmN0aW9uKGV2ZW50Tm8sIGV2ZW50Um93KSB7XHJcbiAgICAgICAgICB2YXIgZXZlbnREZXNjID0gZGF0YS5ldmVudERlc2NzW2V2ZW50Um93WzBdXSA9XHJcbiAgICAgICAgICAgICAgLy8gICAgICAgICAgIChpZCwgICAgICAgICAgdHJpZ2dlcklkLCAgIHJvbGVzLCAgICAgICAga2xhc3MpXHJcbiAgICAgICAgICAgICAgbmV3IEV2ZW50RGVzYyhldmVudFJvd1swXSwgZXZlbnRSb3dbMV0sIGV2ZW50Um93WzJdKTtcclxuICAgICAgICAgIHZhciB0cmlnZ2VyID0gdHJpZ2dlckhhc2hbZXZlbnREZXNjLnRyaWdnZXJJZF07XHJcbiAgICAgICAgICB2YXIgc3BhbiA9IHRyaWdnZXJbMF0uY29weShldmVudERlc2MuaWQpO1xyXG4gICAgICAgICAgdHJpZ2dlclsxXS5wdXNoKHNwYW4pO1xyXG4gICAgICAgICAgZGF0YS5zcGFuc1tldmVudERlc2MuaWRdID0gc3BhbjtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gWFhYIG1vZGlmaWNhdGlvbnM6IGRlbGV0ZSBsYXRlclxyXG4gICAgICAgICQuZWFjaChzb3VyY2VEYXRhLm1vZGlmaWNhdGlvbnMsIGZ1bmN0aW9uKG1vZE5vLCBtb2QpIHtcclxuICAgICAgICAgIC8vIG1vZDogW2lkLCBzcGFuSWQsIG1vZGlmaWNhdGlvbl1cclxuICAgICAgICAgIGlmICghZGF0YS5zcGFuc1ttb2RbMl1dKSB7XHJcbiAgICAgICAgICAgIGRpc3BhdGNoZXIucG9zdCgnbWVzc2FnZXMnLCBbW1snPHN0cm9uZz5FUlJPUjwvc3Ryb25nPjxici8+RXZlbnQgJyArIG1vZFsyXSArICcgKHJlZmVyZW5jZWQgZnJvbSBtb2RpZmljYXRpb24gJyArIG1vZFswXSArICcpIGRvZXMgbm90IG9jY3VyIGluIGRvY3VtZW50ICcgKyBkYXRhLmRvY3VtZW50ICsgJzxici8+KHBsZWFzZSBjb3JyZWN0IHRoZSBzb3VyY2UgZGF0YSknLCAnZXJyb3InLCA1XV1dKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZGF0YS5zcGFuc1ttb2RbMl1dW21vZFsxXV0gPSB0cnVlO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB2YXIgbWlkcG9pbnRDb21wYXJhdG9yID0gZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgICAgdmFyIHRtcCA9IGEuZnJvbSArIGEudG8gLSBiLmZyb20gLSBiLnRvO1xyXG4gICAgICAgICAgaWYgKCF0bXApIHJldHVybiAwO1xyXG4gICAgICAgICAgcmV0dXJuIHRtcCA8IDAgPyAtMSA6IDE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBzcGxpdCBzcGFucyBpbnRvIHNwYW4gZnJhZ21lbnRzIChmb3IgZGlzY29udGludW91cyBzcGFucylcclxuICAgICAgICAkLmVhY2goZGF0YS5zcGFucywgZnVuY3Rpb24oc3Bhbk5vLCBzcGFuKSB7XHJcbiAgICAgICAgICAkLmVhY2goc3Bhbi5vZmZzZXRzLCBmdW5jdGlvbihvZmZzZXRzTm8sIG9mZnNldHMpIHtcclxuICAgICAgICAgICAgdmFyIGZyb20gPSBwYXJzZUludChvZmZzZXRzWzBdLCAxMCk7XHJcbiAgICAgICAgICAgIHZhciB0byA9IHBhcnNlSW50KG9mZnNldHNbMV0sIDEwKTtcclxuICAgICAgICAgICAgdmFyIGZyYWdtZW50ID0gbmV3IEZyYWdtZW50KG9mZnNldHNObywgc3BhbiwgZnJvbSwgdG8pO1xyXG4gICAgICAgICAgICBzcGFuLmZyYWdtZW50cy5wdXNoKGZyYWdtZW50KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgLy8gZW5zdXJlIGFzY2VuZGluZyBvcmRlclxyXG4gICAgICAgICAgc3Bhbi5mcmFnbWVudHMuc29ydChtaWRwb2ludENvbXBhcmF0b3IpO1xyXG4gICAgICAgICAgc3Bhbi53aG9sZUZyb20gPSBzcGFuLmZyYWdtZW50c1swXS5mcm9tO1xyXG4gICAgICAgICAgc3Bhbi53aG9sZVRvID0gc3Bhbi5mcmFnbWVudHNbc3Bhbi5mcmFnbWVudHMubGVuZ3RoIC0gMV0udG87XHJcbiAgICAgICAgICBzcGFuLmhlYWRGcmFnbWVudCA9IHNwYW4uZnJhZ21lbnRzWyh0cnVlKSA/IHNwYW4uZnJhZ21lbnRzLmxlbmd0aCAtIDEgOiAwXTsgLy8gVE9ETyBjb25maWd1cmFibGUhXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHZhciBzcGFuQ29tcGFyYXRvciA9IGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICAgIHZhciBhU3BhbiA9IGRhdGEuc3BhbnNbYV07XHJcbiAgICAgICAgICB2YXIgYlNwYW4gPSBkYXRhLnNwYW5zW2JdO1xyXG4gICAgICAgICAgdmFyIHRtcCA9IGFTcGFuLmhlYWRGcmFnbWVudC5mcm9tICsgYVNwYW4uaGVhZEZyYWdtZW50LnRvIC0gYlNwYW4uaGVhZEZyYWdtZW50LmZyb20gLSBiU3Bhbi5oZWFkRnJhZ21lbnQudG87XHJcbiAgICAgICAgICBpZiAodG1wKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0bXAgPCAwID8gLTEgOiAxO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAkLmVhY2goc291cmNlRGF0YS5lcXVpdnMsIGZ1bmN0aW9uKGVxdWl2Tm8sIGVxdWl2KSB7XHJcbiAgICAgICAgICAvLyBlcXVpdjogWycqJywgJ0VxdWl2Jywgc3BhbklkLi4uXVxyXG4gICAgICAgICAgZXF1aXZbMF0gPSBcIipcIiArIGVxdWl2Tm87XHJcbiAgICAgICAgICB2YXIgZXF1aXZTcGFucyA9IGVxdWl2LnNsaWNlKDIpO1xyXG4gICAgICAgICAgdmFyIG9rRXF1aXZTcGFucyA9IFtdO1xyXG4gICAgICAgICAgLy8gY29sbGVjdCB0aGUgZXF1aXYgc3BhbnMgaW4gYW4gYXJyYXlcclxuICAgICAgICAgICQuZWFjaChlcXVpdlNwYW5zLCBmdW5jdGlvbihlcXVpdlNwYW5ObywgZXF1aXZTcGFuKSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhLnNwYW5zW2VxdWl2U3Bhbl0pIG9rRXF1aXZTcGFucy5wdXNoKGVxdWl2U3Bhbik7XHJcbiAgICAgICAgICAgIC8vIFRPRE86ICM0MDQsIGluZm9ybSB0aGUgdXNlciB3aXRoIGEgbWVzc2FnZT9cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgLy8gc29ydCBzcGFucyBpbiB0aGUgZXF1aXYgYnkgdGhlaXIgbWlkcG9pbnRcclxuICAgICAgICAgIG9rRXF1aXZTcGFucy5zb3J0KHNwYW5Db21wYXJhdG9yKTtcclxuICAgICAgICAgIC8vIGdlbmVyYXRlIHRoZSBhcmNzXHJcbiAgICAgICAgICB2YXIgbGVuID0gb2tFcXVpdlNwYW5zLmxlbmd0aDtcclxuICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGV2ZW50RGVzYyA9IGRhdGEuZXZlbnREZXNjc1tlcXVpdlswXSArICcqJyArIGldID1cclxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAoaWQsICAgICAgICAgICAgICAgICAgdHJpZ2dlcklkLCAgICAgICAgICAgcm9sZXMsICAgICAgICAgICAgICAgICAgICAgICAgIGtsYXNzKVxyXG4gICAgICAgICAgICAgICAgbmV3IEV2ZW50RGVzYyhva0VxdWl2U3BhbnNbaSAtIDFdLCBva0VxdWl2U3BhbnNbaSAtIDFdLCBbW2VxdWl2WzFdLCBva0VxdWl2U3BhbnNbaV1dXSwgJ2VxdWl2Jyk7XHJcbiAgICAgICAgICAgIGV2ZW50RGVzYy5sZWZ0U3BhbnMgPSBva0VxdWl2U3BhbnMuc2xpY2UoMCwgaSk7XHJcbiAgICAgICAgICAgIGV2ZW50RGVzYy5yaWdodFNwYW5zID0gb2tFcXVpdlNwYW5zLnNsaWNlKGkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgICQuZWFjaChzb3VyY2VEYXRhLnJlbGF0aW9ucywgZnVuY3Rpb24ocmVsTm8sIHJlbCkge1xyXG4gICAgICAgICAgLy8gcmVsWzJdIGlzIGFyZ3MsIHJlbFsyXVthXVswXSBpcyByb2xlIGFuZCByZWxbMl1bYV1bMV0gaXMgdmFsdWUgZm9yIGEgaW4gKDAsMSlcclxuICAgICAgICAgIHZhciBhcmdzRGVzYyA9IHJlbGF0aW9uVHlwZXNIYXNoW3JlbFsxXV07XHJcbiAgICAgICAgICBhcmdzRGVzYyA9IGFyZ3NEZXNjICYmIGFyZ3NEZXNjLmFyZ3M7XHJcbiAgICAgICAgICB2YXIgdDEsIHQyO1xyXG4gICAgICAgICAgaWYgKGFyZ3NEZXNjKSB7XHJcbiAgICAgICAgICAgIC8vIHNvcnQgdGhlIGFyZ3VtZW50cyBhY2NvcmRpbmcgdG8gdGhlIGNvbmZpZ1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IHt9XHJcbiAgICAgICAgICAgIGFyZ3NbcmVsWzJdWzBdWzBdXSA9IHJlbFsyXVswXVsxXTtcclxuICAgICAgICAgICAgYXJnc1tyZWxbMl1bMV1bMF1dID0gcmVsWzJdWzFdWzFdO1xyXG4gICAgICAgICAgICB0MSA9IGFyZ3NbYXJnc0Rlc2NbMF0ucm9sZV07XHJcbiAgICAgICAgICAgIHQyID0gYXJnc1thcmdzRGVzY1sxXS5yb2xlXTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIChvciBsZWF2ZSBhcy1pcyBpbiBpdHMgYWJzZW5jZSlcclxuICAgICAgICAgICAgdDEgPSByZWxbMl1bMF1bMV07XHJcbiAgICAgICAgICAgIHQyID0gcmVsWzJdWzFdWzFdO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZGF0YS5ldmVudERlc2NzW3JlbFswXV0gPVxyXG4gICAgICAgICAgICAgIC8vICAgICAgICAgICAoaWQsIHRyaWdnZXJJZCwgcm9sZXMsICAgICAgICAgIGtsYXNzKVxyXG4gICAgICAgICAgICAgIG5ldyBFdmVudERlc2ModDEsIHQxLCAgICAgICAgW1tyZWxbMV0sIHQyXV0sICdyZWxhdGlvbicpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBhdHRyaWJ1dGVzXHJcbiAgICAgICAgJC5lYWNoKHNvdXJjZURhdGEuYXR0cmlidXRlcywgZnVuY3Rpb24oYXR0ck5vLCBhdHRyKSB7XHJcbiAgICAgICAgICAvLyBhdHRyOiBbaWQsIG5hbWUsIHNwYW5JZCwgdmFsdWUsIGN1ZVNwYW5JZFxyXG5cclxuICAgICAgICAgIC8vIFRPRE86IG1pZ2h0IHdpc2ggdG8gY2hlY2sgd2hhdCdzIGFwcHJvcHJpYXRlIGZvciB0aGUgdHlwZVxyXG4gICAgICAgICAgLy8gaW5zdGVhZCBvZiB1c2luZyB0aGUgZmlyc3QgYXR0cmlidXRlIGRlZiBmb3VuZFxyXG4gICAgICAgICAgdmFyIGF0dHJUeXBlID0gKGV2ZW50QXR0cmlidXRlVHlwZXNbYXR0clsxXV0gfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRpdHlBdHRyaWJ1dGVUeXBlc1thdHRyWzFdXSk7XHJcbiAgICAgICAgICB2YXIgYXR0clZhbHVlID0gYXR0clR5cGUgJiYgYXR0clR5cGUudmFsdWVzW2F0dHJUeXBlLmJvb2wgfHwgYXR0clszXV07XHJcbiAgICAgICAgICB2YXIgc3BhbiA9IGRhdGEuc3BhbnNbYXR0clsyXV07XHJcbiAgICAgICAgICBpZiAoIXNwYW4pIHtcclxuICAgICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdtZXNzYWdlcycsIFtbWydBbm5vdGF0aW9uICcgKyBhdHRyWzJdICsgJywgcmVmZXJlbmNlZCBmcm9tIGF0dHJpYnV0ZSAnICsgYXR0clswXSArICcsIGRvZXMgbm90IGV4aXN0LicsICdlcnJvciddXV0pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB2YXIgdmFsVGV4dCA9IChhdHRyVmFsdWUgJiYgYXR0clZhbHVlLm5hbWUpIHx8IGF0dHJbM107XHJcbiAgICAgICAgICB2YXIgYXR0clRleHQgPSBhdHRyVHlwZVxyXG4gICAgICAgICAgICA/IChhdHRyVHlwZS5ib29sID8gYXR0clR5cGUubmFtZSA6IChhdHRyVHlwZS5uYW1lICsgJzogJyArIHZhbFRleHQpKVxyXG4gICAgICAgICAgICA6IChhdHRyWzNdID09IHRydWUgPyBhdHRyWzFdIDogYXR0clsxXSArICc6ICcgKyBhdHRyWzNdKTtcclxuICAgICAgICAgIHNwYW4uYXR0cmlidXRlVGV4dC5wdXNoKGF0dHJUZXh0KTtcclxuICAgICAgICAgIHNwYW4uYXR0cmlidXRlc1thdHRyWzFdXSA9IGF0dHJbM107XHJcbiAgICAgICAgICBpZiAoYXR0cls0XSkgeyAvLyBjdWVcclxuICAgICAgICAgICAgc3Bhbi5hdHRyaWJ1dGVDdWVzW2F0dHJbMV1dID0gYXR0cls0XTtcclxuICAgICAgICAgICAgdmFyIGN1ZVNwYW4gPSBkYXRhLnNwYW5zW2F0dHJbNF1dO1xyXG4gICAgICAgICAgICBjdWVTcGFuLmF0dHJpYnV0ZUN1ZUZvcltkYXRhLnNwYW5zWzFdXSA9IGF0dHJbMl07XHJcbiAgICAgICAgICAgIGN1ZVNwYW4uY3VlID0gJ0NVRSc7IC8vIHNwZWNpYWwgY3NzIHR5cGVcclxuICAgICAgICAgIH1cclxuICAgICAgICAgICQuZXh0ZW5kKHNwYW4uYXR0cmlidXRlTWVyZ2UsIGF0dHJWYWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIGNvbW1lbnRzXHJcbiAgICAgICAgJC5lYWNoKHNvdXJjZURhdGEuY29tbWVudHMsIGZ1bmN0aW9uKGNvbW1lbnRObywgY29tbWVudCkge1xyXG4gICAgICAgICAgLy8gY29tbWVudDogW2VudGl0eUlkLCB0eXBlLCB0ZXh0XVxyXG5cclxuICAgICAgICAgIC8vIFRPRE8gZXJyb3IgaGFuZGxpbmdcclxuXHJcbiAgICAgICAgICAvLyBzZW50ZW5jZSBpZDogWydzZW50Jywgc2VudElkXVxyXG4gICAgICAgICAgaWYgKGNvbW1lbnRbMF0gaW5zdGFuY2VvZiBBcnJheSAmJiBjb21tZW50WzBdWzBdID09ICdzZW50Jykge1xyXG4gICAgICAgICAgICAvLyBzZW50ZW5jZSBjb21tZW50XHJcbiAgICAgICAgICAgIHZhciBzZW50ID0gY29tbWVudFswXVsxXTtcclxuICAgICAgICAgICAgdmFyIHRleHQgPSBjb21tZW50WzJdO1xyXG4gICAgICAgICAgICBpZiAoZGF0YS5zZW50Q29tbWVudFtzZW50XSkge1xyXG4gICAgICAgICAgICAgIHRleHQgPSBkYXRhLnNlbnRDb21tZW50W3NlbnRdLnRleHQgKyAnPGJyLz4nICsgdGV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkYXRhLnNlbnRDb21tZW50W3NlbnRdID0geyB0eXBlOiBjb21tZW50WzFdLCB0ZXh0OiB0ZXh0IH07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgaWQgPSBjb21tZW50WzBdO1xyXG4gICAgICAgICAgICB2YXIgdHJpZ2dlciA9IHRyaWdnZXJIYXNoW2lkXTtcclxuICAgICAgICAgICAgdmFyIGV2ZW50RGVzYyA9IGRhdGEuZXZlbnREZXNjc1tpZF07XHJcbiAgICAgICAgICAgIHZhciBjb21tZW50RW50aXRpZXMgPVxyXG4gICAgICAgICAgICAgICAgdHJpZ2dlclxyXG4gICAgICAgICAgICAgICAgPyB0cmlnZ2VyWzFdIC8vIHRyaWdnZXI6IFtzcGFuLCAuLi5dXHJcbiAgICAgICAgICAgICAgICA6IGlkIGluIGRhdGEuc3BhbnNcclxuICAgICAgICAgICAgICAgICAgPyBbZGF0YS5zcGFuc1tpZF1dIC8vIHNwYW46IFtzcGFuXVxyXG4gICAgICAgICAgICAgICAgICA6IGlkIGluIGRhdGEuZXZlbnREZXNjc1xyXG4gICAgICAgICAgICAgICAgICAgID8gW2RhdGEuZXZlbnREZXNjc1tpZF1dIC8vIGFyYzogW2V2ZW50RGVzY11cclxuICAgICAgICAgICAgICAgICAgICA6IFtdO1xyXG4gICAgICAgICAgICAkLmVhY2goY29tbWVudEVudGl0aWVzLCBmdW5jdGlvbihlbnRpdHlJZCwgZW50aXR5KSB7XHJcbiAgICAgICAgICAgICAgLy8gaWYgZHVwbGljYXRlIGNvbW1lbnQgZm9yIGVudGl0eTpcclxuICAgICAgICAgICAgICAvLyBvdmVyd3JpdGUgdHlwZSwgY29uY2F0ZW5hdGUgY29tbWVudCB3aXRoIGEgbmV3bGluZVxyXG4gICAgICAgICAgICAgIGlmICghZW50aXR5LmNvbW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIGVudGl0eS5jb21tZW50ID0geyB0eXBlOiBjb21tZW50WzFdLCB0ZXh0OiBjb21tZW50WzJdIH07XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGVudGl0eS5jb21tZW50LnR5cGUgPSBjb21tZW50WzFdO1xyXG4gICAgICAgICAgICAgICAgZW50aXR5LmNvbW1lbnQudGV4dCArPSBcIlxcblwiICsgY29tbWVudFsyXTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgLy8gcGFydGlhbGx5IGR1cGxpY2F0ZSBtYXJraW5nIG9mIGFubm90YXRvciBub3RlIGNvbW1lbnRzXHJcbiAgICAgICAgICAgICAgaWYgKGNvbW1lbnRbMV0gPT0gXCJBbm5vdGF0b3JOb3Rlc1wiKSB7XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkuYW5ub3RhdG9yTm90ZXMgPSBjb21tZW50WzJdO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAvLyBwcmlvcml0aXplIHR5cGUgc2V0dGluZyB3aGVuIG11bHRpcGxlIGNvbW1lbnRzIGFyZSBwcmVzZW50XHJcbiAgICAgICAgICAgICAgaWYgKGNvbW1lbnRQcmlvcml0eShjb21tZW50WzFdKSA+IGNvbW1lbnRQcmlvcml0eShlbnRpdHkuc2hhZG93Q2xhc3MpKSB7XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkuc2hhZG93Q2xhc3MgPSBjb21tZW50WzFdO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIG5vcm1hbGl6YXRpb25zXHJcbiAgICAgICAgJC5lYWNoKHNvdXJjZURhdGEubm9ybWFsaXphdGlvbnMsIGZ1bmN0aW9uKG5vcm1Obywgbm9ybSkge1xyXG4gICAgICAgICAgdmFyIGlkID0gbm9ybVswXTtcclxuICAgICAgICAgIHZhciBub3JtVHlwZSA9IG5vcm1bMV07XHJcbiAgICAgICAgICB2YXIgdGFyZ2V0ID0gbm9ybVsyXTtcclxuICAgICAgICAgIHZhciByZWZkYiA9IG5vcm1bM107XHJcbiAgICAgICAgICB2YXIgcmVmaWQgPSBub3JtWzRdO1xyXG4gICAgICAgICAgdmFyIHJlZnRleHQgPSBub3JtWzVdO1xyXG5cclxuICAgICAgICAgIC8vIGdyYWIgZW50aXR5IC8gZXZlbnQgdGhlIG5vcm1hbGl6YXRpb24gYXBwbGllcyB0b1xyXG4gICAgICAgICAgdmFyIHNwYW4gPSBkYXRhLnNwYW5zW3RhcmdldF07XHJcbiAgICAgICAgICBpZiAoIXNwYW4pIHtcclxuICAgICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdtZXNzYWdlcycsIFtbWydBbm5vdGF0aW9uICcgKyB0YXJnZXQgKyAnLCByZWZlcmVuY2VkIGZyb20gbm9ybWFsaXphdGlvbiAnICsgaWQgKyAnLCBkb2VzIG5vdCBleGlzdC4nLCAnZXJyb3InXV1dKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFRPRE86IGRvIHdlIGhhdmUgYW55IHBvc3NpYmxlIHVzZSBmb3IgdGhlIG5vcm1UeXBlP1xyXG4gICAgICAgICAgc3Bhbi5ub3JtYWxpemF0aW9ucy5wdXNoKFtyZWZkYiwgcmVmaWQsIHJlZnRleHRdKTtcclxuXHJcbiAgICAgICAgICAvLyBxdWljayBoYWNrIGZvciBzcGFuIGJveCB2aXN1YWwgc3R5bGVcclxuICAgICAgICAgIHNwYW4ubm9ybWFsaXplZCA9ICdOb3JtYWxpemVkJztcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gcHJlcGFyZSBzcGFuIGJvdW5kYXJpZXMgZm9yIHRva2VuIGNvbnRhaW5tZW50IHRlc3RpbmdcclxuICAgICAgICB2YXIgc29ydGVkRnJhZ21lbnRzID0gW107XHJcbiAgICAgICAgJC5lYWNoKGRhdGEuc3BhbnMsIGZ1bmN0aW9uKHNwYW5Obywgc3Bhbikge1xyXG4gICAgICAgICAgJC5lYWNoKHNwYW4uZnJhZ21lbnRzLCBmdW5jdGlvbihmcmFnbWVudE5vLCBmcmFnbWVudCkge1xyXG4gICAgICAgICAgICBzb3J0ZWRGcmFnbWVudHMucHVzaChmcmFnbWVudCk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBzb3J0IGZyYWdtZW50cyBieSBiZWdpbm5pbmcsIHRoZW4gYnkgZW5kXHJcbiAgICAgICAgc29ydGVkRnJhZ21lbnRzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgICAgdmFyIHggPSBhLmZyb207XHJcbiAgICAgICAgICB2YXIgeSA9IGIuZnJvbTtcclxuICAgICAgICAgIGlmICh4ID09IHkpIHtcclxuICAgICAgICAgICAgeCA9IGEudG87XHJcbiAgICAgICAgICAgIHkgPSBiLnRvO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuICgoeCA8IHkpID8gLTEgOiAoKHggPiB5KSA/IDEgOiAwKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRGcmFnbWVudElkID0gMDtcclxuICAgICAgICB2YXIgc3RhcnRGcmFnbWVudElkID0gMDtcclxuICAgICAgICB2YXIgbnVtRnJhZ21lbnRzID0gc29ydGVkRnJhZ21lbnRzLmxlbmd0aDtcclxuICAgICAgICB2YXIgbGFzdFRvID0gMDtcclxuICAgICAgICB2YXIgZmlyc3RGcm9tID0gbnVsbDtcclxuICAgICAgICB2YXIgY2h1bmtObyA9IDA7XHJcbiAgICAgICAgdmFyIHNwYWNlO1xyXG4gICAgICAgIHZhciBjaHVuayA9IG51bGw7XHJcbiAgICAgICAgLy8gdG9rZW4gY29udGFpbm1lbnQgdGVzdGluZyAoY2h1bmsgcmVjb2duaXRpb24pXHJcbiAgICAgICAgJC5lYWNoKHNvdXJjZURhdGEudG9rZW5fb2Zmc2V0cywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICB2YXIgZnJvbSA9IHRoaXNbMF07XHJcbiAgICAgICAgICB2YXIgdG8gPSB0aGlzWzFdO1xyXG4gICAgICAgICAgaWYgKGZpcnN0RnJvbSA9PT0gbnVsbCkgZmlyc3RGcm9tID0gZnJvbTtcclxuXHJcbiAgICAgICAgICAvLyBSZXBsYWNlZCBmb3Igc3BlZWR1cDsgVE9ETyBjaGVjayBjb3JyZWN0bmVzc1xyXG4gICAgICAgICAgLy8gaW5TcGFuID0gZmFsc2U7XHJcbiAgICAgICAgICAvLyAkLmVhY2goZGF0YS5zcGFucywgZnVuY3Rpb24oc3Bhbk5vLCBzcGFuKSB7XHJcbiAgICAgICAgICAvLyAgIGlmIChzcGFuLmZyb20gPCB0byAmJiB0byA8IHNwYW4udG8pIHtcclxuICAgICAgICAgIC8vICAgICAvLyBpdCBkb2VzOyBubyB3b3JkIGJyZWFrXHJcbiAgICAgICAgICAvLyAgICAgaW5TcGFuID0gdHJ1ZTtcclxuICAgICAgICAgIC8vICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAvLyAgIH1cclxuICAgICAgICAgIC8vIH0pO1xyXG5cclxuICAgICAgICAgIC8vIElzIHRoZSB0b2tlbiBlbmQgaW5zaWRlIGEgc3Bhbj9cclxuICAgICAgICAgIGlmIChzdGFydEZyYWdtZW50SWQgJiYgdG8gPiBzb3J0ZWRGcmFnbWVudHNbc3RhcnRGcmFnbWVudElkIC0gMV0udG8pIHtcclxuICAgICAgICAgICAgd2hpbGUgKHN0YXJ0RnJhZ21lbnRJZCA8IG51bUZyYWdtZW50cyAmJiB0byA+IHNvcnRlZEZyYWdtZW50c1tzdGFydEZyYWdtZW50SWRdLmZyb20pIHtcclxuICAgICAgICAgICAgICBzdGFydEZyYWdtZW50SWQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY3VycmVudEZyYWdtZW50SWQgPSBzdGFydEZyYWdtZW50SWQ7XHJcbiAgICAgICAgICB3aGlsZSAoY3VycmVudEZyYWdtZW50SWQgPCBudW1GcmFnbWVudHMgJiYgdG8gPj0gc29ydGVkRnJhZ21lbnRzW2N1cnJlbnRGcmFnbWVudElkXS50bykge1xyXG4gICAgICAgICAgICBjdXJyZW50RnJhZ21lbnRJZCsrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gaWYgeWVzLCB0aGUgbmV4dCB0b2tlbiBpcyBpbiB0aGUgc2FtZSBjaHVua1xyXG4gICAgICAgICAgaWYgKGN1cnJlbnRGcmFnbWVudElkIDwgbnVtRnJhZ21lbnRzICYmIHRvID4gc29ydGVkRnJhZ21lbnRzW2N1cnJlbnRGcmFnbWVudElkXS5mcm9tKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvL1JlbmF1ZCB0ZXN0IGNodW5rIG11c3Qgbm90IGJlIGxvbmdlciB0aGFuIG5cclxuICAgICAgICAgIC8qdmFyIG4gPSA4MDtcclxuICAgICAgICAgIHZhciBsb29wID0gMztcclxuICAgICAgICAgIGlmKHRvIC0gZmlyc3RGcm9tID4gbil7IC8vMTAzXHJcbiAgICAgICAgICAgIC8vY3JlYXRlIDMgY2h1bmtzXHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsb29wOyArK2kpe1xyXG4gICAgICAgICAgICAgIHZhciBsZW5ndGggPSBNYXRoLmZsb29yKCh0byAtIGZpcnN0RnJvbSkvbG9vcCk7XHJcbiAgICAgICAgICAgICAgdmFyIHRvMiA9IGZpcnN0RnJvbSArIChsZW5ndGggKiAoaSArIDEpKTtcclxuICAgICAgICAgICAgICB2YXIgZmlyc3RGcm9tMiA9IChmaXJzdEZyb20gKyAobGVuZ3RoICogaSkpICsgMTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCBjcmVhdGUgdGhlIGNodW5rIGZvdW5kIHNvIGZhclxyXG4gICAgICAgICAgICAgIHNwYWNlID0gZGF0YS50ZXh0LnN1YnN0cmluZyh0bzIsIGZpcnN0RnJvbTIpO1xyXG4gICAgICAgICAgICAgIHZhciB0ZXh0ID0gZGF0YS50ZXh0LnN1YnN0cmluZyhmaXJzdEZyb20yLCB0bzIpO1xyXG4gICAgICAgICAgICAgIGlmIChjaHVuaykgY2h1bmsubmV4dFNwYWNlID0gc3BhY2U7XHJcbiAgICAgICAgICAgICAgY2h1bmsgPSBuZXcgQ2h1bmsoY2h1bmtObysrLCB0ZXh0LCBmaXJzdEZyb20yLCB0bzIsIHNwYWNlKTtcclxuICAgICAgICAgICAgICBkYXRhLmNodW5rcy5wdXNoKGNodW5rKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIH1lbHNleyovXHJcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgY3JlYXRlIHRoZSBjaHVuayBmb3VuZCBzbyBmYXJcclxuICAgICAgICAgICAgc3BhY2UgPSBkYXRhLnRleHQuc3Vic3RyaW5nKGxhc3RUbywgZmlyc3RGcm9tKTtcclxuICAgICAgICAgICAgdmFyIHRleHQgPSBkYXRhLnRleHQuc3Vic3RyaW5nKGZpcnN0RnJvbSwgdG8pO1xyXG4gICAgICAgICAgICBpZiAoY2h1bmspIGNodW5rLm5leHRTcGFjZSA9IHNwYWNlO1xyXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgIChpbmRleCwgICAgIHRleHQsIGZyb20sICAgICAgdG8sIHNwYWNlKSB7XHJcbiAgICAgICAgICAgIGNodW5rID0gbmV3IENodW5rKGNodW5rTm8rKywgdGV4dCwgZmlyc3RGcm9tLCB0bywgc3BhY2UpO1xyXG4gICAgICAgICAgICBkYXRhLmNodW5rcy5wdXNoKGNodW5rKTtcclxuICAgICAgICAgIC8qfSovXHJcbiAgICAgICAgICBsYXN0VG8gPSB0bztcclxuICAgICAgICAgIGZpcnN0RnJvbSA9IG51bGw7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIG51bUNodW5rcyA9IGNodW5rTm87XHJcblxyXG4gICAgICAgIC8vIGZpbmQgc2VudGVuY2UgYm91bmRhcmllcyBpbiByZWxhdGlvbiB0byBjaHVua3NcclxuICAgICAgICBjaHVua05vID0gMDtcclxuICAgICAgICB2YXIgc2VudGVuY2VObyA9IDA7XHJcbiAgICAgICAgdmFyIHBhc3RGaXJzdCA9IGZhbHNlO1xyXG4gICAgICAgICQuZWFjaChzb3VyY2VEYXRhLnNlbnRlbmNlX29mZnNldHMsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgdmFyIGZyb20gPSB0aGlzWzBdO1xyXG4gICAgICAgICAgaWYgKGNodW5rTm8gPj0gbnVtQ2h1bmtzKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICBpZiAoZGF0YS5jaHVua3NbY2h1bmtOb10uZnJvbSA+IGZyb20pIHJldHVybjtcclxuICAgICAgICAgIHZhciBjaHVuaztcclxuICAgICAgICAgIHdoaWxlIChjaHVua05vIDwgbnVtQ2h1bmtzICYmIChjaHVuayA9IGRhdGEuY2h1bmtzW2NodW5rTm9dKS5mcm9tIDwgZnJvbSkge1xyXG4gICAgICAgICAgICBjaHVua05vKys7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjaHVua05vKys7XHJcbiAgICAgICAgICBpZiAocGFzdEZpcnN0ICYmIGZyb20gPD0gY2h1bmsuZnJvbSkge1xyXG4gICAgICAgICAgICB2YXIgbnVtTkwgPSBjaHVuay5zcGFjZS5zcGxpdChcIlxcblwiKS5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICBpZiAoIW51bU5MKSBudW1OTCA9IDE7XHJcbiAgICAgICAgICAgIHNlbnRlbmNlTm8gKz0gbnVtTkw7XHJcbiAgICAgICAgICAgIGNodW5rLnNlbnRlbmNlID0gc2VudGVuY2VObztcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHBhc3RGaXJzdCA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIGFzc2lnbiBmcmFnbWVudHMgdG8gYXBwcm9wcmlhdGUgY2h1bmtzXHJcbiAgICAgICAgdmFyIGN1cnJlbnRDaHVua0lkID0gMDtcclxuICAgICAgICB2YXIgY2h1bms7XHJcbiAgICAgICAgJC5lYWNoKHNvcnRlZEZyYWdtZW50cywgZnVuY3Rpb24oZnJhZ21lbnRJZCwgZnJhZ21lbnQpIHtcclxuICAgICAgICAgIHdoaWxlIChmcmFnbWVudC50byA+IChjaHVuayA9IGRhdGEuY2h1bmtzW2N1cnJlbnRDaHVua0lkXSkudG8pIGN1cnJlbnRDaHVua0lkKys7XHJcbiAgICAgICAgICBjaHVuay5mcmFnbWVudHMucHVzaChmcmFnbWVudCk7XHJcbiAgICAgICAgICBmcmFnbWVudC50ZXh0ID0gY2h1bmsudGV4dC5zdWJzdHJpbmcoZnJhZ21lbnQuZnJvbSAtIGNodW5rLmZyb20sIGZyYWdtZW50LnRvIC0gY2h1bmsuZnJvbSk7XHJcbiAgICAgICAgICBmcmFnbWVudC5jaHVuayA9IGNodW5rO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBhc3NpZ24gYXJjcyB0byBzcGFuczsgY2FsY3VsYXRlIGFyYyBkaXN0YW5jZXNcclxuICAgICAgICAkLmVhY2goZGF0YS5ldmVudERlc2NzLCBmdW5jdGlvbihldmVudE5vLCBldmVudERlc2MpIHtcclxuICAgICAgICAgIHZhciBkaXN0ID0gMDtcclxuICAgICAgICAgIHZhciBvcmlnaW4gPSBkYXRhLnNwYW5zW2V2ZW50RGVzYy5pZF07XHJcbiAgICAgICAgICBpZiAoIW9yaWdpbikge1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBpbmNsdWRlIG1pc3NpbmcgdHJpZ2dlciBJRCBpbiBlcnJvciBtZXNzYWdlXHJcbiAgICAgICAgICAgIGRpc3BhdGNoZXIucG9zdCgnbWVzc2FnZXMnLCBbW1snPHN0cm9uZz5FUlJPUjwvc3Ryb25nPjxici8+VHJpZ2dlciBmb3IgZXZlbnQgXCInICsgZXZlbnREZXNjLmlkICsgJ1wiIG5vdCBmb3VuZCBpbiAnICsgZGF0YS5kb2N1bWVudCArICc8YnIvPihwbGVhc2UgY29ycmVjdCB0aGUgc291cmNlIGRhdGEpJywgJ2Vycm9yJywgNV1dXSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHZhciBoZXJlID0gb3JpZ2luLmhlYWRGcmFnbWVudC5mcm9tICsgb3JpZ2luLmhlYWRGcmFnbWVudC50bztcclxuICAgICAgICAgICQuZWFjaChldmVudERlc2Mucm9sZXMsIGZ1bmN0aW9uKHJvbGVObywgcm9sZSkge1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZGF0YS5zcGFuc1tyb2xlLnRhcmdldElkXTtcclxuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcclxuICAgICAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ21lc3NhZ2VzJywgW1tbJzxzdHJvbmc+RVJST1I8L3N0cm9uZz48YnIvPlwiJyArIHJvbGUudGFyZ2V0SWQgKyAnXCIgKHJlZmVyZW5jZWQgZnJvbSBcIicgKyBldmVudERlc2MuaWQgKyAnXCIpIG5vdCBmb3VuZCBpbiAnICsgZGF0YS5kb2N1bWVudCArICc8YnIvPihwbGVhc2UgY29ycmVjdCB0aGUgc291cmNlIGRhdGEpJywgJ2Vycm9yJywgNV1dXSk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0aGVyZSA9IHRhcmdldC5oZWFkRnJhZ21lbnQuZnJvbSArIHRhcmdldC5oZWFkRnJhZ21lbnQudG87XHJcbiAgICAgICAgICAgIHZhciBkaXN0ID0gTWF0aC5hYnMoaGVyZSAtIHRoZXJlKTtcclxuICAgICAgICAgICAgdmFyIGFyYyA9IG5ldyBBcmMoZXZlbnREZXNjLCByb2xlLCBkaXN0LCBldmVudE5vKTtcclxuICAgICAgICAgICAgb3JpZ2luLnRvdGFsRGlzdCArPSBkaXN0O1xyXG4gICAgICAgICAgICBvcmlnaW4ubnVtQXJjcysrO1xyXG4gICAgICAgICAgICB0YXJnZXQudG90YWxEaXN0ICs9IGRpc3Q7XHJcbiAgICAgICAgICAgIHRhcmdldC5udW1BcmNzKys7XHJcbiAgICAgICAgICAgIGRhdGEuYXJjcy5wdXNoKGFyYyk7XHJcbiAgICAgICAgICAgIHRhcmdldC5pbmNvbWluZy5wdXNoKGFyYyk7XHJcbiAgICAgICAgICAgIG9yaWdpbi5vdXRnb2luZy5wdXNoKGFyYyk7XHJcbiAgICAgICAgICAgIC8vIElEIGRpY3QgZm9yIGVhc3kgYWNjZXNzLiBUT0RPOiBoYXZlIGEgZnVuY3Rpb24gZGVmaW5pbmcgdGhlXHJcbiAgICAgICAgICAgIC8vIChvcmlnaW4sdHlwZSx0YXJnZXQpLT5pZCBtYXBwaW5nIChzZWUgYWxzbyBhbm5vdGF0b3JfdWkuanMpXHJcbiAgICAgICAgICAgIHZhciBhcmNJZCA9IG9yaWdpbi5pZCArICctLScgKyByb2xlLnR5cGUgKyAnLS0nICsgdGFyZ2V0LmlkO1xyXG4gICAgICAgICAgICBkYXRhLmFyY0J5SWRbYXJjSWRdID0gYXJjO1xyXG4gICAgICAgICAgfSk7IC8vIHJvbGVzXHJcbiAgICAgICAgfSk7IC8vIGV2ZW50RGVzY3NcclxuXHJcbiAgICAgICAgLy8gaGlnaGxpZ2h0aW5nXHJcbiAgICAgICAgbWFya2VkVGV4dCA9IFtdO1xyXG4gICAgICAgIHNldE1hcmtlZCgnZWRpdGVkJyk7IC8vIHNldCBieSBlZGl0aW5nIHByb2Nlc3NcclxuICAgICAgICBzZXRNYXJrZWQoJ2ZvY3VzJyk7IC8vIHNldCBieSBVUkxcclxuICAgICAgICBzZXRNYXJrZWQoJ21hdGNoZm9jdXMnKTsgLy8gc2V0IGJ5IHNlYXJjaCBwcm9jZXNzLCBmb2N1c2VkIG1hdGNoXHJcbiAgICAgICAgc2V0TWFya2VkKCdtYXRjaCcpOyAvLyBzZXQgYnkgc2VhcmNoIHByb2Nlc3MsIG90aGVyIChub24tZm9jdXNlZCkgbWF0Y2hcclxuXHJcbiAgICAgICAgJC5lYWNoKGRhdGEuc3BhbnMsIGZ1bmN0aW9uKHNwYW5JZCwgc3Bhbikge1xyXG4gICAgICAgICAgLy8gY2FsY3VsYXRlIGF2ZXJhZ2UgYXJjIGRpc3RhbmNlc1xyXG4gICAgICAgICAgLy8gYXZlcmFnZSBkaXN0YW5jZSBvZiBhcmNzICgwIGZvciBubyBhcmNzKVxyXG4gICAgICAgICAgc3Bhbi5hdmdEaXN0ID0gc3Bhbi5udW1BcmNzID8gc3Bhbi50b3RhbERpc3QgLyBzcGFuLm51bUFyY3MgOiAwO1xyXG4gICAgICAgICAgbGFzdFNwYW4gPSBzcGFuO1xyXG5cclxuICAgICAgICAgIC8vIGNvbGxlY3QgZnJhZ21lbnQgdGV4dHMgaW50byBzcGFuIHRleHRzXHJcbiAgICAgICAgICB2YXIgZnJhZ21lbnRUZXh0cyA9IFtdO1xyXG4gICAgICAgICAgJC5lYWNoKHNwYW4uZnJhZ21lbnRzLCBmdW5jdGlvbihmcmFnbWVudE5vLCBmcmFnbWVudCkge1xyXG4gICAgICAgICAgICAvLyBUT0RPIGhldXJpc3RpY3NcclxuICAgICAgICAgICAgZnJhZ21lbnRUZXh0cy5wdXNoKGZyYWdtZW50LnRleHQpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBzcGFuLnRleHQgPSBmcmFnbWVudFRleHRzLmpvaW4oJycpO1xyXG4gICAgICAgIH0pOyAvLyBkYXRhLnNwYW5zXHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XHJcbiAgICAgICAgICAvLyBwcmVsaW1pbmFyeSBzb3J0IHRvIGFzc2lnbiBoZWlnaHRzIGZvciBiYXNpYyBjYXNlc1xyXG4gICAgICAgICAgLy8gKGZpcnN0IHJvdW5kKSBhbmQgY2FzZXMgcmVzb2x2ZWQgaW4gdGhlIHByZXZpb3VzXHJcbiAgICAgICAgICAvLyByb3VuZChzKS5cclxuICAgICAgICAgICQuZWFjaChkYXRhLmNodW5rcywgZnVuY3Rpb24oY2h1bmtObywgY2h1bmspIHtcclxuICAgICAgICAgICAgLy8gc29ydFxyXG4gICAgICAgICAgICBjaHVuay5mcmFnbWVudHMuc29ydChmcmFnbWVudENvbXBhcmF0b3IpO1xyXG4gICAgICAgICAgICAvLyByZW51bWJlclxyXG4gICAgICAgICAgICAkLmVhY2goY2h1bmsuZnJhZ21lbnRzLCBmdW5jdGlvbihmcmFnbWVudE5vLCBmcmFnbWVudCkge1xyXG4gICAgICAgICAgICAgIGZyYWdtZW50LmluZGV4TnVtYmVyID0gZnJhZ21lbnRObztcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIC8vIG5peCB0aGUgc3Vtcywgc28gd2UgY2FuIHN1bSBhZ2FpblxyXG4gICAgICAgICAgJC5lYWNoKGRhdGEuc3BhbnMsIGZ1bmN0aW9uKHNwYW5Obywgc3Bhbikge1xyXG4gICAgICAgICAgICBzcGFuLnJlZmVkSW5kZXhTdW0gPSAwO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICAvLyByZXNvbHZlZCBjYXNlcyB3aWxsIG5vdyBoYXZlIGluZGV4TnVtYmVyIHNldFxyXG4gICAgICAgICAgLy8gdG8gaW5kaWNhdGUgdGhlaXIgcmVsYXRpdmUgb3JkZXIuIFN1bSB0aG9zZSBmb3IgcmVmZXJlbmNpbmcgY2FzZXNcclxuICAgICAgICAgIC8vIGZvciB1c2UgaW4gaXRlcmF0aXZlIHJlc29ydGluZ1xyXG4gICAgICAgICAgJC5lYWNoKGRhdGEuYXJjcywgZnVuY3Rpb24oYXJjTm8sIGFyYykge1xyXG4gICAgICAgICAgICBkYXRhLnNwYW5zW2FyYy5vcmlnaW5dLnJlZmVkSW5kZXhTdW0gKz0gZGF0YS5zcGFuc1thcmMudGFyZ2V0XS5oZWFkRnJhZ21lbnQuaW5kZXhOdW1iZXI7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZpbmFsIHNvcnQgb2YgZnJhZ21lbnRzIGluIGNodW5rcyBmb3IgZHJhd2luZyBwdXJwb3Nlc1xyXG4gICAgICAgIC8vIEFsc28gaWRlbnRpZnkgdGhlIG1hcmtlZCB0ZXh0IGJvdW5kYXJpZXMgcmVnYXJkaW5nIGNodW5rc1xyXG4gICAgICAgICQuZWFjaChkYXRhLmNodW5rcywgZnVuY3Rpb24oY2h1bmtObywgY2h1bmspIHtcclxuICAgICAgICAgIC8vIGFuZCBtYWtlIHRoZSBuZXh0IHNvcnQgdGFrZSB0aGlzIGludG8gYWNjb3VudC4gTm90ZSB0aGF0IHRoaXMgd2lsbFxyXG4gICAgICAgICAgLy8gbm93IHJlc29sdmUgZmlyc3Qtb3JkZXIgZGVwZW5kZW5jaWVzIGJldHdlZW4gc29ydCBvcmRlcnMgYnV0IG5vdFxyXG4gICAgICAgICAgLy8gc2Vjb25kLW9yZGVyIG9yIGhpZ2hlci5cclxuICAgICAgICAgIGNodW5rLmZyYWdtZW50cy5zb3J0KGZyYWdtZW50Q29tcGFyYXRvcik7XHJcbiAgICAgICAgICAkLmVhY2goY2h1bmsuZnJhZ21lbnRzLCBmdW5jdGlvbihmcmFnbWVudE5vLCBmcmFnbWVudCkge1xyXG4gICAgICAgICAgICBmcmFnbWVudC5kcmF3T3JkZXIgPSBmcmFnbWVudE5vO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGRhdGEuc3BhbkRyYXdPcmRlclBlcm11dGF0aW9uID0gT2JqZWN0LmtleXMoZGF0YS5zcGFucyk7XHJcbiAgICAgICAgZGF0YS5zcGFuRHJhd09yZGVyUGVybXV0YXRpb24uc29ydChmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICB2YXIgc3BhbkEgPSBkYXRhLnNwYW5zW2FdO1xyXG4gICAgICAgICAgdmFyIHNwYW5CID0gZGF0YS5zcGFuc1tiXTtcclxuXHJcbiAgICAgICAgICAvLyBXZSdyZSBqdW1waW5nIGFsbCBvdmVyIHRoZSBjaHVua3MsIGJ1dCBpdCdzIGVub3VnaCB0aGF0XHJcbiAgICAgICAgICAvLyB3ZSdyZSBkb2luZyBldmVyeXRoaW5nIGluc2lkZSBlYWNoIGNodW5rIGluIHRoZSByaWdodFxyXG4gICAgICAgICAgLy8gb3JkZXIuIHNob3VsZCBpdCBiZWNvbWUgbmVjZXNzYXJ5IHRvIGFjdHVhbGx5IGRvIHRoZXNlIGluXHJcbiAgICAgICAgICAvLyBsaW5lYXIgb3JkZXIsIHB1dCBpbiBhIHNpbWlsYXIgY29uZGl0aW9uIGZvclxyXG4gICAgICAgICAgLy8gc3BhblguaGVhZEZyYWdtZW50LmNodW5rLmluZGV4OyBidXQgaXQgc2hvdWxkIG5vdCBiZVxyXG4gICAgICAgICAgLy8gbmVlZGVkLlxyXG5cclxuICAgICAgICAgIHZhciB0bXAgPSBzcGFuQS5oZWFkRnJhZ21lbnQuZHJhd09yZGVyIC0gc3BhbkIuaGVhZEZyYWdtZW50LmRyYXdPcmRlcjtcclxuICAgICAgICAgIGlmICh0bXApIHJldHVybiB0bXAgPCAwID8gLTEgOiAxO1xyXG5cclxuICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyByZXNvcnQgdGhlIHNwYW5zIGZvciBsaW5lYXIgb3JkZXIgYnkgY2VudGVyXHJcbiAgICAgICAgc29ydGVkRnJhZ21lbnRzLnNvcnQobWlkcG9pbnRDb21wYXJhdG9yKTtcclxuXHJcbiAgICAgICAgLy8gc29ydCBmcmFnbWVudHMgaW50byB0b3dlcnMsIGNhbGN1bGF0ZSBhdmVyYWdlIGFyYyBkaXN0YW5jZXNcclxuICAgICAgICB2YXIgbGFzdEZyYWdtZW50ID0gbnVsbDtcclxuICAgICAgICB2YXIgdG93ZXJJZCA9IC0xO1xyXG4gICAgICAgICQuZWFjaChzb3J0ZWRGcmFnbWVudHMsIGZ1bmN0aW9uKGksIGZyYWdtZW50KSB7XHJcbiAgICAgICAgICBpZiAoIWxhc3RGcmFnbWVudCB8fCAobGFzdEZyYWdtZW50LmZyb20gIT0gZnJhZ21lbnQuZnJvbSB8fCBsYXN0RnJhZ21lbnQudG8gIT0gZnJhZ21lbnQudG8pKSB7XHJcbiAgICAgICAgICAgIHRvd2VySWQrKztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGZyYWdtZW50LnRvd2VySWQgPSB0b3dlcklkO1xyXG4gICAgICAgICAgbGFzdEZyYWdtZW50ID0gZnJhZ21lbnQ7XHJcbiAgICAgICAgfSk7IC8vIHNvcnRlZEZyYWdtZW50c1xyXG5cclxuICAgICAgICAvLyBmaW5kIGN1cmxpZXMgKG9ubHkgdGhlIGZpcnN0IGZyYWdtZW50IGRyYXduIGluIGEgdG93ZXIpXHJcbiAgICAgICAgJC5lYWNoKGRhdGEuc3BhbkRyYXdPcmRlclBlcm11dGF0aW9uLCBmdW5jdGlvbihzcGFuSWRObywgc3BhbklkKSB7XHJcbiAgICAgICAgICB2YXIgc3BhbiA9IGRhdGEuc3BhbnNbc3BhbklkXTtcclxuXHJcbiAgICAgICAgICAkLmVhY2goc3Bhbi5mcmFnbWVudHMsIGZ1bmN0aW9uKGZyYWdtZW50Tm8sIGZyYWdtZW50KSB7XHJcbiAgICAgICAgICAgIGlmICghZGF0YS50b3dlcnNbZnJhZ21lbnQudG93ZXJJZF0pIHtcclxuICAgICAgICAgICAgICBkYXRhLnRvd2Vyc1tmcmFnbWVudC50b3dlcklkXSA9IFtdO1xyXG4gICAgICAgICAgICAgIGZyYWdtZW50LmRyYXdDdXJseSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgZnJhZ21lbnQuc3Bhbi5kcmF3Q3VybHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRhdGEudG93ZXJzW2ZyYWdtZW50LnRvd2VySWRdLnB1c2goZnJhZ21lbnQpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHZhciBzcGFuQW5uVGV4dHMgPSB7fTtcclxuICAgICAgICAkLmVhY2goZGF0YS5jaHVua3MsIGZ1bmN0aW9uKGNodW5rTm8sIGNodW5rKSB7XHJcbiAgICAgICAgICBjaHVuay5tYXJrZWRUZXh0U3RhcnQgPSBbXTtcclxuICAgICAgICAgIGNodW5rLm1hcmtlZFRleHRFbmQgPSBbXTtcclxuXHJcbiAgICAgICAgICAkLmVhY2goY2h1bmsuZnJhZ21lbnRzLCBmdW5jdGlvbihmcmFnbWVudE5vLCBmcmFnbWVudCkge1xyXG4gICAgICAgICAgICBpZiAoY2h1bmsuZmlyc3RGcmFnbWVudEluZGV4ID09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgIGNodW5rLmZpcnN0RnJhZ21lbnRJbmRleCA9IGZyYWdtZW50LnRvd2VySWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2h1bmsubGFzdEZyYWdtZW50SW5kZXggPSBmcmFnbWVudC50b3dlcklkO1xyXG5cclxuICAgICAgICAgICAgdmFyIHNwYW5MYWJlbHMgPSBVdGlsLmdldFNwYW5MYWJlbHMoc3BhblR5cGVzLCBmcmFnbWVudC5zcGFuLnR5cGUpO1xyXG4gICAgICAgICAgICBmcmFnbWVudC5sYWJlbFRleHQgPSBVdGlsLnNwYW5EaXNwbGF5Rm9ybShzcGFuVHlwZXMsIGZyYWdtZW50LnNwYW4udHlwZSk7XHJcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIG1vc3QgYXBwcm9wcmlhdGUgbGFiZWwgYWNjb3JkaW5nIHRvIHRleHQgd2lkdGhcclxuICAgICAgICAgICAgaWYgKENvbmZpZ3VyYXRpb24uYWJicmV2c09uICYmIHNwYW5MYWJlbHMpIHtcclxuICAgICAgICAgICAgICB2YXIgbGFiZWxJZHggPSAxOyAvLyBmaXJzdCBhYmJyZXZcclxuICAgICAgICAgICAgICB2YXIgbWF4TGVuZ3RoID0gKGZyYWdtZW50LnRvIC0gZnJhZ21lbnQuZnJvbSkgLyAwLjg7XHJcbiAgICAgICAgICAgICAgd2hpbGUgKGZyYWdtZW50LmxhYmVsVGV4dC5sZW5ndGggPiBtYXhMZW5ndGggJiZcclxuICAgICAgICAgICAgICAgICAgc3BhbkxhYmVsc1tsYWJlbElkeF0pIHtcclxuICAgICAgICAgICAgICAgIGZyYWdtZW50LmxhYmVsVGV4dCA9IHNwYW5MYWJlbHNbbGFiZWxJZHhdO1xyXG4gICAgICAgICAgICAgICAgbGFiZWxJZHgrKztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBzdmd0ZXh0ID0gc3ZnLmNyZWF0ZVRleHQoKTsgLy8gb25lIFwidGV4dFwiIGVsZW1lbnQgcGVyIHJvd1xyXG4gICAgICAgICAgICB2YXIgcG9zdGZpeEFycmF5ID0gW107XHJcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSAnJztcclxuICAgICAgICAgICAgdmFyIHBvc3RmaXggPSAnJztcclxuICAgICAgICAgICAgdmFyIHdhcm5pbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgJC5lYWNoKGZyYWdtZW50LnNwYW4uYXR0cmlidXRlcywgZnVuY3Rpb24oYXR0clR5cGUsIHZhbFR5cGUpIHtcclxuICAgICAgICAgICAgICAvLyBUT0RPOiBtaWdodCB3aXNoIHRvIGNoZWNrIHdoYXQncyBhcHByb3ByaWF0ZSBmb3IgdGhlIHR5cGVcclxuICAgICAgICAgICAgICAvLyBpbnN0ZWFkIG9mIHVzaW5nIHRoZSBmaXJzdCBhdHRyaWJ1dGUgZGVmIGZvdW5kXHJcbiAgICAgICAgICAgICAgdmFyIGF0dHIgPSAoZXZlbnRBdHRyaWJ1dGVUeXBlc1thdHRyVHlwZV0gfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRpdHlBdHRyaWJ1dGVUeXBlc1thdHRyVHlwZV0pO1xyXG4gICAgICAgICAgICAgIGlmICghYXR0cikge1xyXG4gICAgICAgICAgICAgICAgLy8gbm9uLWV4aXN0ZW50IHR5cGVcclxuICAgICAgICAgICAgICAgIHdhcm5pbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB2YXIgdmFsID0gYXR0ci52YWx1ZXNbYXR0ci5ib29sIHx8IHZhbFR5cGVdO1xyXG4gICAgICAgICAgICAgIGlmICghdmFsKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBub24tZXhpc3RlbnQgdmFsdWVcclxuICAgICAgICAgICAgICAgIHdhcm5pbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAoJC5pc0VtcHR5T2JqZWN0KHZhbCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIGRlZmluZWQsIGJ1dCBsYWNrcyBhbnkgdmlzdWFsIHByZXNlbnRhdGlvblxyXG4gICAgICAgICAgICAgICAgd2FybmluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmICh2YWwuZ2x5cGgpIHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWwucG9zaXRpb24gPT0gXCJsZWZ0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgcHJlZml4ID0gdmFsLmdseXBoICsgcHJlZml4O1xyXG4gICAgICAgICAgICAgICAgICB2YXIgY3NzID0gJ2dseXBoJztcclxuICAgICAgICAgICAgICAgICAgaWYgKGF0dHIuY3NzKSBjc3MgKz0gJyBnbHlwaF8nICsgVXRpbC5lc2NhcGVRdW90ZXMoYXR0ci5jc3MpO1xyXG4gICAgICAgICAgICAgICAgICBzdmd0ZXh0LnNwYW4odmFsLmdseXBoLCB7ICdjbGFzcyc6IGNzcyB9KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIFhYWCByaWdodCBpcyBpbXBsaWVkIC0gbWF5YmUgY2hhbmdlXHJcbiAgICAgICAgICAgICAgICAgIHBvc3RmaXhBcnJheS5wdXNoKFthdHRyLCB2YWxdKTtcclxuICAgICAgICAgICAgICAgICAgcG9zdGZpeCArPSB2YWwuZ2x5cGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIHRleHQgPSBmcmFnbWVudC5sYWJlbFRleHQ7XHJcbiAgICAgICAgICAgIGlmIChwcmVmaXggIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgdGV4dCA9IHByZWZpeCArICcgJyArIHRleHQ7XHJcbiAgICAgICAgICAgICAgc3ZndGV4dC5zdHJpbmcoJyAnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdmd0ZXh0LnN0cmluZyhmcmFnbWVudC5sYWJlbFRleHQpO1xyXG4gICAgICAgICAgICBpZiAocG9zdGZpeEFycmF5Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgIHRleHQgKz0gJyAnICsgcG9zdGZpeDtcclxuICAgICAgICAgICAgICBzdmd0ZXh0LnN0cmluZygnICcpO1xyXG4gICAgICAgICAgICAgICQuZWFjaChwb3N0Zml4QXJyYXksIGZ1bmN0aW9uKGVsTm8sIGVsKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3NzID0gJ2dseXBoJztcclxuICAgICAgICAgICAgICAgIGlmIChlbFswXS5jc3MpIGNzcyArPSAnIGdseXBoXycgKyBVdGlsLmVzY2FwZVF1b3RlcyhlbFswXS5jc3MpO1xyXG4gICAgICAgICAgICAgICAgc3ZndGV4dC5zcGFuKGVsWzFdLmdseXBoLCB7ICdjbGFzcyc6IGNzcyB9KTtcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAod2FybmluZykge1xyXG4gICAgICAgICAgICAgIHN2Z3RleHQuc3BhbihcIiNcIiwgeyAnY2xhc3MnOiAnZ2x5cGggYXR0cmlidXRlX3dhcm5pbmcnIH0pO1xyXG4gICAgICAgICAgICAgIHRleHQgKz0gJyAjJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmcmFnbWVudC5nbHlwaGVkTGFiZWxUZXh0ID0gdGV4dDtcclxuXHJcbiAgICAgICAgICAgIGlmICghc3BhbkFublRleHRzW3RleHRdKSB7XHJcbiAgICAgICAgICAgICAgc3BhbkFublRleHRzW3RleHRdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICBkYXRhLnNwYW5Bbm5UZXh0c1t0ZXh0XSA9IHN2Z3RleHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pOyAvLyBjaHVuay5mcmFnbWVudHNcclxuICAgICAgICB9KTsgLy8gY2h1bmtzXHJcblxyXG4gICAgICAgIHZhciBudW1DaHVua3MgPSBkYXRhLmNodW5rcy5sZW5ndGg7XHJcbiAgICAgICAgLy8gbm90ZSB0aGUgbG9jYXRpb24gb2YgbWFya2VkIHRleHQgd2l0aCByZXNwZWN0IHRvIGNodW5rc1xyXG4gICAgICAgIHZhciBzdGFydENodW5rID0gMDtcclxuICAgICAgICB2YXIgY3VycmVudENodW5rO1xyXG4gICAgICAgIC8vIHNvcnQgYnkgXCJmcm9tXCI7IHdlIGRvbid0IG5lZWQgdG8gc29ydCBieSBcInRvXCIgYXMgd2VsbCxcclxuICAgICAgICAvLyBiZWNhdXNlIHVubGlrZSBzcGFucywgY2h1bmtzIGFyZSBkaXNqdW5jdFxyXG4gICAgICAgIG1hcmtlZFRleHQuc29ydChmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICByZXR1cm4gVXRpbC5jbXAoYVswXSwgYlswXSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgJC5lYWNoKG1hcmtlZFRleHQsIGZ1bmN0aW9uKHRleHRObywgdGV4dFBvcykge1xyXG4gICAgICAgICAgdmFyIGZyb20gPSB0ZXh0UG9zWzBdO1xyXG4gICAgICAgICAgdmFyIHRvID0gdGV4dFBvc1sxXTtcclxuICAgICAgICAgIHZhciBtYXJrZWRUeXBlID0gdGV4dFBvc1syXTtcclxuICAgICAgICAgIGlmIChmcm9tIDwgMCkgZnJvbSA9IDA7XHJcbiAgICAgICAgICBpZiAodG8gPCAwKSB0byA9IDA7XHJcbiAgICAgICAgICBpZiAodG8gPj0gZGF0YS50ZXh0Lmxlbmd0aCkgdG8gPSBkYXRhLnRleHQubGVuZ3RoIC0gMTtcclxuICAgICAgICAgIGlmIChmcm9tID4gdG8pIGZyb20gPSB0bztcclxuICAgICAgICAgIHdoaWxlIChzdGFydENodW5rIDwgbnVtQ2h1bmtzKSB7XHJcbiAgICAgICAgICAgIHZhciBjaHVuayA9IGRhdGEuY2h1bmtzW3N0YXJ0Q2h1bmtdO1xyXG4gICAgICAgICAgICBpZiAoZnJvbSA8PSBjaHVuay50bykge1xyXG4gICAgICAgICAgICAgIGNodW5rLm1hcmtlZFRleHRTdGFydC5wdXNoKFt0ZXh0Tm8sIHRydWUsIGZyb20gLSBjaHVuay5mcm9tLCBudWxsLCBtYXJrZWRUeXBlXSk7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3RhcnRDaHVuaysrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHN0YXJ0Q2h1bmsgPT0gbnVtQ2h1bmtzKSB7XHJcbiAgICAgICAgICAgIGRpc3BhdGNoZXIucG9zdCgnbWVzc2FnZXMnLCBbW1snV3JvbmcgdGV4dCBvZmZzZXQnLCAnZXJyb3InXV1dKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY3VycmVudENodW5rID0gc3RhcnRDaHVuaztcclxuICAgICAgICAgIHdoaWxlIChjdXJyZW50Q2h1bmsgPCBudW1DaHVua3MpIHtcclxuICAgICAgICAgICAgdmFyIGNodW5rID0gZGF0YS5jaHVua3NbY3VycmVudENodW5rXTtcclxuICAgICAgICAgICAgaWYgKHRvIDw9IGNodW5rLnRvKSB7XHJcbiAgICAgICAgICAgICAgY2h1bmsubWFya2VkVGV4dEVuZC5wdXNoKFt0ZXh0Tm8sIGZhbHNlLCB0byAtIGNodW5rLmZyb21dKTtcclxuICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnRDaHVuaysrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGN1cnJlbnRDaHVuayA9PSBudW1DaHVua3MpIHtcclxuICAgICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdtZXNzYWdlcycsIFtbWydXcm9uZyB0ZXh0IG9mZnNldCcsICdlcnJvciddXV0pO1xyXG4gICAgICAgICAgICB2YXIgY2h1bmsgPSBkYXRhLmNodW5rc1tkYXRhLmNodW5rcy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgY2h1bmsubWFya2VkVGV4dEVuZC5wdXNoKFt0ZXh0Tm8sIGZhbHNlLCBjaHVuay50ZXh0Lmxlbmd0aF0pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7IC8vIG1hcmtlZFRleHRcclxuXHJcbiAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdkYXRhUmVhZHknLCBbZGF0YV0pO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdmFyIHJlc2V0RGF0YSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHNldERhdGEoc291cmNlRGF0YSk7XHJcbiAgICAgICAgcmVuZGVyRGF0YSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgdHJhbnNsYXRlID0gZnVuY3Rpb24oZWxlbWVudCwgeCwgeSkge1xyXG4gICAgICAgICQoZWxlbWVudC5ncm91cCkuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgeCArICcsICcgKyB5ICsgJyknKTtcclxuICAgICAgICBlbGVtZW50LnRyYW5zbGF0aW9uID0geyB4OiB4LCB5OiB5IH07XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgc2hvd010aW1lID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKGRhdGEubXRpbWUpIHtcclxuICAgICAgICAgICAgLy8gd2UncmUgZ2V0dGluZyBzZWNvbmRzIGFuZCBuZWVkIG1pbGxpc2Vjb25kc1xyXG4gICAgICAgICAgICAvLyQoJyNkb2N1bWVudF9jdGltZScpLnRleHQoXCJDcmVhdGVkOiBcIiArIEFubm90YXRvci5mb3JtYXRUaW1lKDEwMDAgKiBkYXRhLmN0aW1lKSkuY3NzKFwiZGlzcGxheVwiLCBcImlubGluZVwiKTtcclxuICAgICAgICAgICAgJCgnI2RvY3VtZW50X210aW1lJykudGV4dChcIkxhc3QgbW9kaWZpZWQ6IFwiICsgVXRpbC5mb3JtYXRUaW1lQWdvKDEwMDAgKiBkYXRhLm10aW1lKSkuY3NzKFwiZGlzcGxheVwiLCBcImlubGluZVwiKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyQoJyNkb2N1bWVudF9jdGltZScpLmNzcyhcImRpc3BsYXlcIiwgXCJub25lXCIpO1xyXG4gICAgICAgICAgICAkKCcjZG9jdW1lbnRfbXRpbWUnKS5jc3MoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgYWRkSGVhZGVyQW5kRGVmcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBjb21tZW50TmFtZSA9IChjb2xsICsgJy8nICsgZG9jKS5yZXBsYWNlKCctLScsICctXFxcXC0nKTtcclxuICAgICAgICAkc3ZnLmFwcGVuZCgnPCEtLSBkb2N1bWVudDogJyArIGNvbW1lbnROYW1lICsgJyAtLT4nKTtcclxuICAgICAgICB2YXIgZGVmcyA9IHN2Zy5kZWZzKCk7XHJcbiAgICAgICAgdmFyICRibHVyRmlsdGVyID0gJCgnPGZpbHRlciBpZD1cIkdhdXNzaWFuX0JsdXJcIj48ZmVHYXVzc2lhbkJsdXIgaW49XCJTb3VyY2VHcmFwaGljXCIgc3RkRGV2aWF0aW9uPVwiMlwiIC8+PC9maWx0ZXI+Jyk7XHJcbiAgICAgICAgc3ZnLmFkZChkZWZzLCAkYmx1ckZpbHRlcik7XHJcbiAgICAgICAgcmV0dXJuIGRlZnM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBnZXRUZXh0TWVhc3VyZW1lbnRzID0gZnVuY3Rpb24odGV4dHNIYXNoLCBvcHRpb25zLCBjYWxsYmFjaykge1xyXG4gICAgICAgIC8vIG1ha2Ugc29tZSB0ZXh0IGVsZW1lbnRzLCBmaW5kIG91dCB0aGUgZGltZW5zaW9uc1xyXG4gICAgICAgIHZhciB0ZXh0TWVhc3VyZUdyb3VwID0gc3ZnLmdyb3VwKG9wdGlvbnMpO1xyXG5cclxuICAgICAgICAvLyBjaGFuZ2VkIGZyb20gJC5lYWNoIGJlY2F1c2Ugb2YgIzI2NCAoJ2xlbmd0aCcgY2FuIGFwcGVhcilcclxuICAgICAgICBmb3IgKHZhciB0ZXh0IGluIHRleHRzSGFzaCkge1xyXG4gICAgICAgICAgaWYgKHRleHRzSGFzaC5oYXNPd25Qcm9wZXJ0eSh0ZXh0KSkge1xyXG4gICAgICAgICAgICBzdmcudGV4dCh0ZXh0TWVhc3VyZUdyb3VwLCAwLCAwLCB0ZXh0KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIG1lYXN1cmluZyBnb2VzIG9uIGhlcmVcclxuICAgICAgICB2YXIgd2lkdGhzID0ge307XHJcbiAgICAgICAgJCh0ZXh0TWVhc3VyZUdyb3VwKS5maW5kKCd0ZXh0JykuZWFjaChmdW5jdGlvbihzdmdUZXh0Tm8sIHN2Z1RleHQpIHtcclxuICAgICAgICAgIHZhciB0ZXh0ID0gJChzdmdUZXh0KS50ZXh0KCk7XHJcbiAgICAgICAgICB3aWR0aHNbdGV4dF0gPSB0aGlzLmdldENvbXB1dGVkVGV4dExlbmd0aCgpO1xyXG5cclxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAkLmVhY2godGV4dHNIYXNoW3RleHRdLCBmdW5jdGlvbih0ZXh0LCBvYmplY3QpIHtcclxuICAgICAgICAgICAgICBjYWxsYmFjayhvYmplY3QsIHN2Z1RleHQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgYmJveCA9IHRleHRNZWFzdXJlR3JvdXAuZ2V0QkJveCgpO1xyXG4gICAgICAgIHN2Zy5yZW1vdmUodGV4dE1lYXN1cmVHcm91cCk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgTWVhc3VyZW1lbnRzKHdpZHRocywgYmJveC5oZWlnaHQsIGJib3gueSk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgZ2V0VGV4dEFuZFNwYW5UZXh0TWVhc3VyZW1lbnRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy8gZ2V0IHRoZSBzcGFuIHRleHQgc2l6ZXNcclxuICAgICAgICB2YXIgY2h1bmtUZXh0cyA9IHt9OyAvLyBzZXQgb2Ygc3BhbiB0ZXh0c1xyXG4gICAgICAgICQuZWFjaChkYXRhLmNodW5rcywgZnVuY3Rpb24oY2h1bmtObywgY2h1bmspIHtcclxuICAgICAgICAgIGNodW5rLnJvdyA9IHVuZGVmaW5lZDsgLy8gcmVzZXRcclxuICAgICAgICAgIGlmICghKGNodW5rLnRleHQgaW4gY2h1bmtUZXh0cykpIGNodW5rVGV4dHNbY2h1bmsudGV4dF0gPSBbXVxyXG4gICAgICAgICAgdmFyIGNodW5rVGV4dCA9IGNodW5rVGV4dHNbY2h1bmsudGV4dF07XHJcblxyXG4gICAgICAgICAgLy8gaGVyZSB3ZSBhbHNvIG5lZWQgYWxsIHRoZSBzcGFucyB0aGF0IGFyZSBjb250YWluZWQgaW5cclxuICAgICAgICAgIC8vIGNodW5rcyB3aXRoIHRoaXMgdGV4dCwgYmVjYXVzZSB3ZSBuZWVkIHRvIGtub3cgdGhlIHBvc2l0aW9uXHJcbiAgICAgICAgICAvLyBvZiB0aGUgc3BhbiB0ZXh0IHdpdGhpbiB0aGUgcmVzcGVjdGl2ZSBjaHVuayB0ZXh0XHJcbiAgICAgICAgICBjaHVua1RleHQucHVzaC5hcHBseShjaHVua1RleHQsIGNodW5rLmZyYWdtZW50cyk7XHJcbiAgICAgICAgICAvLyBhbmQgYWxzbyB0aGUgbWFya2VkVGV4dCBib3VuZGFyaWVzXHJcbiAgICAgICAgICBjaHVua1RleHQucHVzaC5hcHBseShjaHVua1RleHQsIGNodW5rLm1hcmtlZFRleHRTdGFydCk7XHJcbiAgICAgICAgICBjaHVua1RleHQucHVzaC5hcHBseShjaHVua1RleHQsIGNodW5rLm1hcmtlZFRleHRFbmQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciB0ZXh0U2l6ZXMgPSBnZXRUZXh0TWVhc3VyZW1lbnRzKFxyXG4gICAgICAgICAgY2h1bmtUZXh0cyxcclxuICAgICAgICAgIHVuZGVmaW5lZCxcclxuICAgICAgICAgIGZ1bmN0aW9uKGZyYWdtZW50LCB0ZXh0KSB7XHJcbiAgICAgICAgICAgIGlmIChmcmFnbWVudCBpbnN0YW5jZW9mIEZyYWdtZW50KSB7IC8vIGl0J3MgYSBmcmFnbWVudCFcclxuICAgICAgICAgICAgICAvLyBtZWFzdXJlIHRoZSBmcmFnbWVudCB0ZXh0IHBvc2l0aW9uIGluIHBpeGVsc1xyXG4gICAgICAgICAgICAgIHZhciBmaXJzdENoYXIgPSBmcmFnbWVudC5mcm9tIC0gZnJhZ21lbnQuY2h1bmsuZnJvbTtcclxuICAgICAgICAgICAgICBpZiAoZmlyc3RDaGFyIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgZmlyc3RDaGFyID0gMDtcclxuICAgICAgICAgICAgICAgIGRpc3BhdGNoZXIucG9zdCgnbWVzc2FnZXMnLCBbW1snPHN0cm9uZz5XQVJOSU5HPC9zdHJvbmc+JyArXHJcbiAgICAgICAgICAgICAgICAgICc8YnIvPiAnICtcclxuICAgICAgICAgICAgICAgICAgJ1RoZSBmcmFnbWVudCBbJyArIGZyYWdtZW50LmZyb20gKyAnLCAnICsgZnJhZ21lbnQudG8gKyAnXSAoJyArIGZyYWdtZW50LnRleHQgKyAnKSBpcyBub3QgJyArXHJcbiAgICAgICAgICAgICAgICAgICdjb250YWluZWQgaW4gaXRzIGRlc2lnbmF0ZWQgY2h1bmsgWycgK1xyXG4gICAgICAgICAgICAgICAgICBmcmFnbWVudC5jaHVuay5mcm9tICsgJywgJyArIGZyYWdtZW50LmNodW5rLnRvICsgJ10gbW9zdCBsaWtlbHkgJyArXHJcbiAgICAgICAgICAgICAgICAgICdkdWUgdG8gdGhlIGZyYWdtZW50IHN0YXJ0aW5nIG9yIGVuZGluZyB3aXRoIGEgc3BhY2UsIHBsZWFzZSAnICtcclxuICAgICAgICAgICAgICAgICAgJ3ZlcmlmeSB0aGUgc2FuaXR5IG9mIHlvdXIgZGF0YSBzaW5jZSB3ZSBhcmUgdW5hYmxlIHRvICcgK1xyXG4gICAgICAgICAgICAgICAgICAndmlzdWFsaXNlIHRoaXMgZnJhZ21lbnQgY29ycmVjdGx5IGFuZCB3aWxsIGRyb3AgbGVhZGluZyAnICtcclxuICAgICAgICAgICAgICAgICAgJ3NwYWNlIGNoYXJhY3RlcnMnXHJcbiAgICAgICAgICAgICAgICAgICwgJ3dhcm5pbmcnLCAxNV1dXSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHZhciBzdGFydFBvcyA9IHRleHQuZ2V0U3RhcnRQb3NpdGlvbk9mQ2hhcihmaXJzdENoYXIpLng7XHJcbiAgICAgICAgICAgICAgdmFyIGxhc3RDaGFyID0gZnJhZ21lbnQudG8gLSBmcmFnbWVudC5jaHVuay5mcm9tIC0gMTtcclxuICAgICAgICAgICAgICB2YXIgZW5kUG9zID0gKGxhc3RDaGFyIDwgMClcclxuICAgICAgICAgICAgICAgID8gc3RhcnRQb3NcclxuICAgICAgICAgICAgICAgIDogdGV4dC5nZXRFbmRQb3NpdGlvbk9mQ2hhcihsYXN0Q2hhcikueDtcclxuICAgICAgICAgICAgICBmcmFnbWVudC5jdXJseSA9IHtcclxuICAgICAgICAgICAgICAgIGZyb206IHN0YXJ0UG9zLFxyXG4gICAgICAgICAgICAgICAgdG86IGVuZFBvc1xyXG4gICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIGl0J3MgbWFya2VkVGV4dCBbaWQsIHN0YXJ0PywgY2hhciMsIG9mZnNldF1cclxuICAgICAgICAgICAgICBpZiAoZnJhZ21lbnRbMl0gPCAwKSBmcmFnbWVudFsyXSA9IDA7XHJcbiAgICAgICAgICAgICAgaWYgKCFmcmFnbWVudFsyXSkgeyAvLyBzdGFydFxyXG4gICAgICAgICAgICAgICAgZnJhZ21lbnRbM10gPSB0ZXh0LmdldFN0YXJ0UG9zaXRpb25PZkNoYXIoZnJhZ21lbnRbMl0pLng7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZyYWdtZW50WzNdID0gdGV4dC5nZXRFbmRQb3NpdGlvbk9mQ2hhcihmcmFnbWVudFsyXSAtIDEpLnggKyAxO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIGdldCB0aGUgZnJhZ21lbnQgYW5ub3RhdGlvbiB0ZXh0IHNpemVzXHJcbiAgICAgICAgdmFyIGZyYWdtZW50VGV4dHMgPSB7fTtcclxuICAgICAgICB2YXIgbm9TcGFucyA9IHRydWU7XHJcbiAgICAgICAgJC5lYWNoKGRhdGEuc3BhbnMsIGZ1bmN0aW9uKHNwYW5Obywgc3Bhbikge1xyXG4gICAgICAgICAgJC5lYWNoKHNwYW4uZnJhZ21lbnRzLCBmdW5jdGlvbihmcmFnbWVudE5vLCBmcmFnbWVudCkge1xyXG4gICAgICAgICAgICBmcmFnbWVudFRleHRzW2ZyYWdtZW50LmdseXBoZWRMYWJlbFRleHRdID0gdHJ1ZTtcclxuICAgICAgICAgICAgbm9TcGFucyA9IGZhbHNlO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKG5vU3BhbnMpIGZyYWdtZW50VGV4dHMuJCA9IHRydWU7IC8vIGR1bW15IHNvIHdlIGNhbiBhdCBsZWFzdCBnZXQgdGhlIGhlaWdodFxyXG4gICAgICAgIHZhciBmcmFnbWVudFNpemVzID0gZ2V0VGV4dE1lYXN1cmVtZW50cyhmcmFnbWVudFRleHRzLCB7J2NsYXNzJzogJ3NwYW4nfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICB0ZXh0czogdGV4dFNpemVzLFxyXG4gICAgICAgICAgZnJhZ21lbnRzOiBmcmFnbWVudFNpemVzXHJcbiAgICAgICAgfTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciBhZGRBcmNUZXh0TWVhc3VyZW1lbnRzID0gZnVuY3Rpb24oc2l6ZXMpIHtcclxuICAgICAgICAvLyBnZXQgdGhlIGFyYyBhbm5vdGF0aW9uIHRleHQgc2l6ZXMgKGZvciBhbGwgbGFiZWxzKVxyXG4gICAgICAgIHZhciBhcmNUZXh0cyA9IHt9O1xyXG4gICAgICAgICQuZWFjaChkYXRhLmFyY3MsIGZ1bmN0aW9uKGFyY05vLCBhcmMpIHtcclxuICAgICAgICAgIHZhciBsYWJlbHMgPSBVdGlsLmdldEFyY0xhYmVscyhzcGFuVHlwZXMsIGRhdGEuc3BhbnNbYXJjLm9yaWdpbl0udHlwZSwgYXJjLnR5cGUsIHJlbGF0aW9uVHlwZXNIYXNoKTtcclxuICAgICAgICAgIGlmICghbGFiZWxzLmxlbmd0aCkgbGFiZWxzID0gW2FyYy50eXBlXTtcclxuICAgICAgICAgICQuZWFjaChsYWJlbHMsIGZ1bmN0aW9uKGxhYmVsTm8sIGxhYmVsKSB7XHJcbiAgICAgICAgICAgIGFyY1RleHRzW2xhYmVsXSA9IHRydWU7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgYXJjU2l6ZXMgPSBnZXRUZXh0TWVhc3VyZW1lbnRzKGFyY1RleHRzLCB7J2NsYXNzJzogJ2FyY3MnfSk7XHJcbiAgICAgICAgc2l6ZXMuYXJjcyA9IGFyY1NpemVzO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdmFyIGFkanVzdFRvd2VyQW5ub3RhdGlvblNpemVzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy8gZmluZCBiaWdnZXN0IGFubm90YXRpb24gaW4gZWFjaCB0b3dlclxyXG4gICAgICAgICQuZWFjaChkYXRhLnRvd2VycywgZnVuY3Rpb24odG93ZXJObywgdG93ZXIpIHtcclxuICAgICAgICAgIHZhciBtYXhXaWR0aCA9IDA7XHJcbiAgICAgICAgICAkLmVhY2godG93ZXIsIGZ1bmN0aW9uKGZyYWdtZW50Tm8sIGZyYWdtZW50KSB7XHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGRhdGEuc2l6ZXMuZnJhZ21lbnRzLndpZHRoc1tmcmFnbWVudC5nbHlwaGVkTGFiZWxUZXh0XTtcclxuICAgICAgICAgICAgaWYgKHdpZHRoID4gbWF4V2lkdGgpIG1heFdpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgICB9KTsgLy8gdG93ZXJcclxuICAgICAgICAgICQuZWFjaCh0b3dlciwgZnVuY3Rpb24oZnJhZ21lbnRObywgZnJhZ21lbnQpIHtcclxuICAgICAgICAgICAgZnJhZ21lbnQud2lkdGggPSBtYXhXaWR0aDtcclxuICAgICAgICAgIH0pOyAvLyB0b3dlclxyXG4gICAgICAgIH0pOyAvLyBkYXRhLnRvd2Vyc1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdmFyIG1ha2VBcnJvdyA9IGZ1bmN0aW9uKGRlZnMsIHNwZWMpIHtcclxuICAgICAgICB2YXIgcGFyc2VkU3BlYyA9IHNwZWMuc3BsaXQoJywnKTtcclxuICAgICAgICB2YXIgdHlwZSA9IHBhcnNlZFNwZWNbMF07XHJcbiAgICAgICAgaWYgKHR5cGUgPT0gJ25vbmUnKSByZXR1cm47XHJcblxyXG4gICAgICAgIHZhciB3aWR0aCA9IDU7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IDU7XHJcbiAgICAgICAgdmFyIGNvbG9yID0gXCJibGFja1wiO1xyXG4gICAgICAgIGlmICgkLmlzTnVtZXJpYyhwYXJzZWRTcGVjWzFdKSAmJiBwYXJzZWRTcGVjWzJdKSB7XHJcbiAgICAgICAgICBpZiAoJC5pc051bWVyaWMocGFyc2VkU3BlY1syXSkgJiYgcGFyc2VkU3BlY1szXSkge1xyXG4gICAgICAgICAgICAvLyAzIGFyZ3MsIDIgbnVtZXJpYzogYXNzdW1lIHdpZHRoLCBoZWlnaHQsIGNvbG9yXHJcbiAgICAgICAgICAgIHdpZHRoID0gcGFyc2VkU3BlY1sxXTtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gcGFyc2VkU3BlY1syXTtcclxuICAgICAgICAgICAgY29sb3IgPSBwYXJzZWRTcGVjWzNdIHx8ICdibGFjayc7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyAyIGFyZ3MsIDEgbnVtZXJpYzogYXNzdW1lIHdpZHRoL2hlaWdodCwgY29sb3JcclxuICAgICAgICAgICAgd2lkdGggPSBoZWlnaHQgPSBwYXJzZWRTcGVjWzFdO1xyXG4gICAgICAgICAgICBjb2xvciA9IHBhcnNlZFNwZWNbMl0gfHwgJ2JsYWNrJztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gb3RoZXI6IGFzc3VtZSBjb2xvciBvbmx5XHJcbiAgICAgICAgICB3aWR0aCA9IGhlaWdodCA9IDU7XHJcbiAgICAgICAgICBjb2xvciA9IHBhcnNlZFNwZWNbMV0gfHwgJ2JsYWNrJztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaGFzaCBuZWVkcyB0byBiZSByZXBsYWNlZCBhcyBJRHMgZG9uJ3QgcGVybWl0IGl0LlxyXG4gICAgICAgIHZhciBhcnJvd0lkID0gJ2Fycm93XycgKyBzcGVjLnJlcGxhY2UoLyMvZywgJycpLnJlcGxhY2UoLywvZywgJ18nKTtcclxuXHJcbiAgICAgICAgdmFyIGFycm93O1xyXG4gICAgICAgIGlmICh0eXBlID09ICd0cmlhbmdsZScpIHtcclxuICAgICAgICAgIGFycm93ID0gc3ZnLm1hcmtlcihkZWZzLCBhcnJvd0lkLFxyXG4gICAgICAgICAgICB3aWR0aCwgaGVpZ2h0IC8gMiwgd2lkdGgsIGhlaWdodCwgJ2F1dG8nLFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgbWFya2VyVW5pdHM6ICdzdHJva2VXaWR0aCcsXHJcbiAgICAgICAgICAgICAgJ2ZpbGwnOiBjb2xvcixcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICBzdmcucG9seWxpbmUoYXJyb3csIFtbMCwgMF0sIFt3aWR0aCwgaGVpZ2h0IC8gMl0sIFswLCBoZWlnaHRdLCBbd2lkdGggLyAxMiwgaGVpZ2h0IC8gMl1dKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFycm93SWQ7XHJcbiAgICAgIH1cclxuXHJcblxyXG4gICAgICB2YXIgZHJhd2luZyA9IGZhbHNlO1xyXG4gICAgICB2YXIgcmVkcmF3ID0gZmFsc2U7XHJcblxyXG4gICAgICB2YXIgcmVuZGVyRGF0YVJlYWwgPSBmdW5jdGlvbihzb3VyY2VEYXRhKSB7XHJcblxyXG5cclxuVXRpbC5wcm9maWxlRW5kKCdiZWZvcmUgcmVuZGVyJyk7XHJcblV0aWwucHJvZmlsZVN0YXJ0KCdyZW5kZXInKTtcclxuVXRpbC5wcm9maWxlU3RhcnQoJ2luaXQnKTtcclxuXHJcbiAgICAgICAgaWYgKCFzb3VyY2VEYXRhICYmICFkYXRhKSB7XHJcbiAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ2RvbmVSZW5kZXJpbmcnLCBbY29sbCwgZG9jLCBhcmdzXSk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgICRzdmdEaXYuc2hvdygpO1xyXG4gICAgICAgIGlmICgoc291cmNlRGF0YSAmJiBzb3VyY2VEYXRhLmNvbGxlY3Rpb24gJiYgKHNvdXJjZURhdGEuZG9jdW1lbnQgIT09IGRvYyB8fCBzb3VyY2VEYXRhLmNvbGxlY3Rpb24gIT09IGNvbGwpKSB8fCBkcmF3aW5nKSB7XHJcbiAgICAgICAgICByZWRyYXcgPSB0cnVlO1xyXG4gICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdkb25lUmVuZGVyaW5nJywgW2NvbGwsIGRvYywgYXJnc10pO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZWRyYXcgPSBmYWxzZTtcclxuICAgICAgICBkcmF3aW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgaWYgKHNvdXJjZURhdGEpIHNldERhdGEoc291cmNlRGF0YSk7XHJcbiAgICAgICAgc2hvd010aW1lKCk7XHJcblxyXG4gICAgICAgIC8vIGNsZWFyIHRoZSBTVkdcclxuICAgICAgICBzdmcuY2xlYXIodHJ1ZSk7XHJcbiAgICAgICAgaWYgKCFkYXRhIHx8IGRhdGEubGVuZ3RoID09IDApIHJldHVybjtcclxuXHJcbiAgICAgICAgLy8gZXN0YWJsaXNoIHRoZSB3aWR0aCBhY2NvcmRpbmcgdG8gdGhlIGVuY2xvc2luZyBlbGVtZW50XHJcbiAgICAgICAgY2FudmFzV2lkdGggPSB0aGF0LmZvcmNlV2lkdGggfHwgJHN2Z0Rpdi53aWR0aCgpO1xyXG5cclxuICAgICAgICB2YXIgZGVmcyA9IGFkZEhlYWRlckFuZERlZnMoKTtcclxuXHJcbiAgICAgICAgdmFyIGJhY2tncm91bmRHcm91cCA9IHN2Zy5ncm91cCh7ICdjbGFzcyc6ICdiYWNrZ3JvdW5kJyB9KTtcclxuICAgICAgICB2YXIgZ2xvd0dyb3VwID0gc3ZnLmdyb3VwKHsgJ2NsYXNzJzogJ2dsb3cnIH0pO1xyXG4gICAgICAgIGhpZ2hsaWdodEdyb3VwID0gc3ZnLmdyb3VwKHsgJ2NsYXNzJzogJ2hpZ2hsaWdodCcgfSk7XHJcbiAgICAgICAgdmFyIHRleHRHcm91cCA9IHN2Zy5ncm91cCh7ICdjbGFzcyc6ICd0ZXh0JyB9KTtcclxuXHJcblV0aWwucHJvZmlsZUVuZCgnaW5pdCcpO1xyXG5VdGlsLnByb2ZpbGVTdGFydCgnbWVhc3VyZXMnKTtcclxuXHJcbiAgICAgICAgdmFyIHNpemVzID0gZ2V0VGV4dEFuZFNwYW5UZXh0TWVhc3VyZW1lbnRzKCk7XHJcbiAgICAgICAgZGF0YS5zaXplcyA9IHNpemVzO1xyXG5cclxuICAgICAgICBhZGp1c3RUb3dlckFubm90YXRpb25TaXplcygpO1xyXG4gICAgICAgIHZhciBtYXhUZXh0V2lkdGggPSAwO1xyXG4gICAgICAgIGZvciAodmFyIHRleHQgaW4gc2l6ZXMudGV4dHMud2lkdGhzKSB7XHJcbiAgICAgICAgICBpZiAoc2l6ZXMudGV4dHMud2lkdGhzLmhhc093blByb3BlcnR5KHRleHQpKSB7XHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHNpemVzLnRleHRzLndpZHRoc1t0ZXh0XVxyXG4gICAgICAgICAgICBpZiAod2lkdGggPiBtYXhUZXh0V2lkdGgpIG1heFRleHRXaWR0aCA9IHdpZHRoO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcblV0aWwucHJvZmlsZUVuZCgnbWVhc3VyZXMnKTtcclxuVXRpbC5wcm9maWxlU3RhcnQoJ2NodW5rcycpO1xyXG5cclxuICAgICAgICB2YXIgY3VycmVudFggPSBDb25maWd1cmF0aW9uLnZpc3VhbC5tYXJnaW4ueCArIHNlbnROdW1NYXJnaW4gKyByb3dQYWRkaW5nO1xyXG4gICAgICAgIHZhciByb3dzID0gW107XHJcbiAgICAgICAgdmFyIGZyYWdtZW50SGVpZ2h0cyA9IFtdO1xyXG4gICAgICAgIHZhciBzZW50ZW5jZVRvZ2dsZSA9IDA7XHJcbiAgICAgICAgdmFyIHNlbnRlbmNlTnVtYmVyID0gMDtcclxuICAgICAgICB2YXIgcm93ID0gbmV3IFJvdyhzdmcpO1xyXG4gICAgICAgIHJvdy5zZW50ZW5jZSA9ICsrc2VudGVuY2VOdW1iZXI7XHJcbiAgICAgICAgcm93LmJhY2tncm91bmRJbmRleCA9IHNlbnRlbmNlVG9nZ2xlO1xyXG4gICAgICAgIHJvdy5pbmRleCA9IDA7XHJcbiAgICAgICAgdmFyIHJvd0luZGV4ID0gMDtcclxuICAgICAgICB2YXIgdHdvQmFyV2lkdGhzOyAvLyBIQUNLIHRvIGF2b2lkIG1lYXN1cmluZyBzcGFjZSdzIHdpZHRoXHJcbiAgICAgICAgdmFyIG9wZW5UZXh0SGlnaGxpZ2h0cyA9IHt9O1xyXG4gICAgICAgIHZhciB0ZXh0TWFya2VkUm93cyA9IFtdO1xyXG5cclxuICAgICAgICBhZGRBcmNUZXh0TWVhc3VyZW1lbnRzKHNpemVzKTtcclxuXHJcbiAgICAgICAgLy8gcmVzZXJ2ZSBwbGFjZXMgZm9yIHNwYW5zXHJcbiAgICAgICAgdmFyIGZsb29ycyA9IFtdO1xyXG4gICAgICAgIHZhciByZXNlcnZhdGlvbnMgPSBbXTsgLy8gcmVzZXJ2YXRpb25zW2NodW5rXVtmbG9vcl0gPSBbW2Zyb20sIHRvLCBoZWFkcm9vbV0uLi5dXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gZGF0YS5sYXN0RnJhZ21lbnRJbmRleDsgaSsrKSB7XHJcbiAgICAgICAgICByZXNlcnZhdGlvbltpXSA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaW5mID0gMS4wLzAuMDtcclxuXHJcbiAgICAgICAgJC5lYWNoKGRhdGEuc3BhbkRyYXdPcmRlclBlcm11dGF0aW9uLCBmdW5jdGlvbihzcGFuSWRObywgc3BhbklkKSB7XHJcbiAgICAgICAgICB2YXIgc3BhbiA9IGRhdGEuc3BhbnNbc3BhbklkXTtcclxuXHJcbiAgICAgICAgICB2YXIgZjEgPSBzcGFuLmZyYWdtZW50c1swXTtcclxuICAgICAgICAgIHZhciBmMiA9IHNwYW4uZnJhZ21lbnRzW3NwYW4uZnJhZ21lbnRzLmxlbmd0aCAtIDFdO1xyXG5cclxuICAgICAgICAgIHZhciB4MSA9IChmMS5jdXJseS5mcm9tICsgZjEuY3VybHkudG8gLSBmMS53aWR0aCkgLyAyIC1cclxuICAgICAgICAgICAgICBDb25maWd1cmF0aW9uLnZpc3VhbC5tYXJnaW4ueDtcclxuICAgICAgICAgIHZhciBpMSA9IGYxLmNodW5rLmluZGV4O1xyXG5cclxuICAgICAgICAgIHZhciB4MiA9IChmMi5jdXJseS5mcm9tICsgZjIuY3VybHkudG8gKyBmMi53aWR0aCkgLyAyICtcclxuICAgICAgICAgICAgICBDb25maWd1cmF0aW9uLnZpc3VhbC5tYXJnaW4ueDtcclxuICAgICAgICAgIHZhciBpMiA9IGYyLmNodW5rLmluZGV4O1xyXG5cclxuICAgICAgICAgIC8vIFN0YXJ0IGZyb20gdGhlIGdyb3VuZCBsZXZlbCwgZ29pbmcgdXAgZmxvb3IgYnkgZmxvb3IuXHJcbiAgICAgICAgICAvLyBJZiBubyBtb3JlIGZsb29ycywgbWFrZSBhIG5ldyBhdmFpbGFibGUgb25lLlxyXG4gICAgICAgICAgLy8gSWYgYSBmbG9vciBpcyBhdmFpbGFibGUgYW5kIHRoZXJlIGlzIG5vIGNhcnBldCwgbWFyayBpdCBhcyBjYXJwZXQuXHJcbiAgICAgICAgICAvLyBJZiBhIGZsb29yIGlzIGF2YWlsYWJsZSBhbmQgdGhlcmUgaXMgY2FycGV0IGFuZCBoZWlnaHRcclxuICAgICAgICAgIC8vICAgZGlmZmVyZW5jZSBpcyBhdCBsZWFzdCBmcmFnbWVudCBoZWlnaHQgKyBjdXJseSwgT0suXHJcbiAgICAgICAgICAvLyBJZiBhIGZsb29yIGlzIG5vdCBhdmFpbGFibGUsIGZvcmdldCBhYm91dCBjYXJwZXQuXHJcbiAgICAgICAgICAvLyAtLVxyXG4gICAgICAgICAgLy8gV2hlbiBPSywgY2FsY3VsYXRlIGV4YWN0IGNlaWxpbmcuXHJcbiAgICAgICAgICAvLyBJZiB0aGVyZSBpc24ndCBvbmUsIG1ha2UgYSBuZXcgZmxvb3IsIGNvcHkgcmVzZXJ2YXRpb25zXHJcbiAgICAgICAgICAvLyAgIGZyb20gZmxvb3IgYmVsb3cgKHdpdGggZGVjcmVhc2VkIGNlaWxpbmcpXHJcbiAgICAgICAgICAvLyBNYWtlIHRoZSByZXNlcnZhdGlvbiBmcm9tIHRoZSBjYXJwZXQgdG8ganVzdCBiZWxvdyB0aGVcclxuICAgICAgICAgIC8vICAgY3VycmVudCBmbG9vci5cclxuICAgICAgICAgIC8vXHJcbiAgICAgICAgICAvLyBUT0RPIGRyYXdDdXJseSBhbmQgaGVpZ2h0IGNvdWxkIGJlIHByZXR0aWZpZWQgdG8gb25seSBjaGVja1xyXG4gICAgICAgICAgLy8gYWN0dWFsIHBvc2l0aW9ucyBvZiBjdXJsaWVzXHJcbiAgICAgICAgICB2YXIgY2FycGV0ID0gMDtcclxuICAgICAgICAgIHZhciBvdXRzaWRlID0gdHJ1ZTtcclxuICAgICAgICAgIHZhciB0aGlzQ3VybHlIZWlnaHQgPSBzcGFuLmRyYXdDdXJseSA/IENvbmZpZ3VyYXRpb24udmlzdWFsLmN1cmx5SGVpZ2h0IDogMDtcclxuICAgICAgICAgIHZhciBoZWlnaHQgPSBzaXplcy5mcmFnbWVudHMuaGVpZ2h0ICsgdGhpc0N1cmx5SGVpZ2h0ICsgQ29uZmlndXJhdGlvbi52aXN1YWwuYm94U3BhY2luZyArXHJcbiAgICAgICAgICAgICAgMiAqIENvbmZpZ3VyYXRpb24udmlzdWFsLm1hcmdpbi55IC0gMztcclxuICAgICAgICAgICQuZWFjaChmbG9vcnMsIGZ1bmN0aW9uKGZsb29yTm8sIGZsb29yKSB7XHJcbiAgICAgICAgICAgIHZhciBmbG9vckF2YWlsYWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBpMTsgaSA8PSBpMjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgaWYgKCEocmVzZXJ2YXRpb25zW2ldICYmIHJlc2VydmF0aW9uc1tpXVtmbG9vcl0pKSBjb250aW51ZTtcclxuICAgICAgICAgICAgICB2YXIgZnJvbSA9IChpID09IGkxKSA/IHgxIDogLWluZjtcclxuICAgICAgICAgICAgICB2YXIgdG8gPSAoaSA9PSBpMikgPyB4MiA6IGluZjtcclxuICAgICAgICAgICAgICAkLmVhY2gocmVzZXJ2YXRpb25zW2ldW2Zsb29yXSwgZnVuY3Rpb24ocmVzTm8sIHJlcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc1swXSA8IHRvICYmIGZyb20gPCByZXNbMV0pIHtcclxuICAgICAgICAgICAgICAgICAgZmxvb3JBdmFpbGFibGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmbG9vckF2YWlsYWJsZSkge1xyXG4gICAgICAgICAgICAgIGlmIChjYXJwZXQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNhcnBldCA9IGZsb29yO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGVpZ2h0ICsgY2FycGV0IDw9IGZsb29yKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBmb3VuZCBvdXIgZmxvb3IhXHJcbiAgICAgICAgICAgICAgICBvdXRzaWRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGNhcnBldCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgdmFyIHJlc2xlbiA9IHJlc2VydmF0aW9ucy5sZW5ndGg7XHJcbiAgICAgICAgICB2YXIgbWFrZU5ld0Zsb29ySWZOZWVkZWQgPSBmdW5jdGlvbihmbG9vcikge1xyXG4gICAgICAgICAgICB2YXIgZmxvb3JObyA9ICQuaW5BcnJheShmbG9vciwgZmxvb3JzKTtcclxuICAgICAgICAgICAgaWYgKGZsb29yTm8gPT0gLTEpIHtcclxuICAgICAgICAgICAgICBmbG9vcnMucHVzaChmbG9vcik7XHJcbiAgICAgICAgICAgICAgZmxvb3JzLnNvcnQoVXRpbC5jbXApO1xyXG4gICAgICAgICAgICAgIGZsb29yTm8gPSAkLmluQXJyYXkoZmxvb3IsIGZsb29ycyk7XHJcbiAgICAgICAgICAgICAgaWYgKGZsb29yTm8gIT0gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gY29weSByZXNlcnZhdGlvbnMgZnJvbSB0aGUgZmxvb3IgYmVsb3dcclxuICAgICAgICAgICAgICAgIHZhciBwYXJxdWV0ID0gZmxvb3JzW2Zsb29yTm8gLSAxXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHJlc2xlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChyZXNlcnZhdGlvbnNbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc2VydmF0aW9uc1tpXVtwYXJxdWV0XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgcmVzZXJ2YXRpb25zW2ldW3BhcnF1ZXRdID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmb290cm9vbSA9IGZsb29yIC0gcGFycXVldDtcclxuICAgICAgICAgICAgICAgICAgICAkLmVhY2gocmVzZXJ2YXRpb25zW2ldW3BhcnF1ZXRdLCBmdW5jdGlvbihyZXNObywgcmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzWzJdID4gZm9vdHJvb20pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXNlcnZhdGlvbnNbaV1bZmxvb3JdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXJ2YXRpb25zW2ldW2Zsb29yXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2VydmF0aW9uc1tpXVtmbG9vcl0ucHVzaChbcmVzWzBdLCByZXNbMV0sIHJlc1syXSAtIGZvb3Ryb29tXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZsb29yTm87XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB2YXIgY2VpbGluZyA9IGNhcnBldCArIGhlaWdodDtcclxuICAgICAgICAgIHZhciBjZWlsaW5nTm8gPSBtYWtlTmV3Rmxvb3JJZk5lZWRlZChjZWlsaW5nKTtcclxuICAgICAgICAgIHZhciBjYXJwZXRObyA9IG1ha2VOZXdGbG9vcklmTmVlZGVkKGNhcnBldCk7XHJcbiAgICAgICAgICAvLyBtYWtlIHRoZSByZXNlcnZhdGlvblxyXG4gICAgICAgICAgdmFyIGZsb29yLCBmbG9vck5vO1xyXG4gICAgICAgICAgZm9yIChmbG9vck5vID0gY2FycGV0Tm87XHJcbiAgICAgICAgICAgICAgKGZsb29yID0gZmxvb3JzW2Zsb29yTm9dKSAhPT0gdW5kZWZpbmVkICYmIGZsb29yIDwgY2VpbGluZztcclxuICAgICAgICAgICAgICBmbG9vck5vKyspIHtcclxuICAgICAgICAgICAgdmFyIGhlYWRyb29tID0gY2VpbGluZyAtIGZsb29yO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gaTE7IGkgPD0gaTI7IGkrKykge1xyXG4gICAgICAgICAgICAgIHZhciBmcm9tID0gKGkgPT0gaTEpID8geDEgOiAwO1xyXG4gICAgICAgICAgICAgIHZhciB0byA9IChpID09IGkyKSA/IHgyIDogaW5mO1xyXG4gICAgICAgICAgICAgIGlmICghcmVzZXJ2YXRpb25zW2ldKSByZXNlcnZhdGlvbnNbaV0gPSB7fTtcclxuICAgICAgICAgICAgICBpZiAoIXJlc2VydmF0aW9uc1tpXVtmbG9vcl0pIHJlc2VydmF0aW9uc1tpXVtmbG9vcl0gPSBbXTtcclxuICAgICAgICAgICAgICByZXNlcnZhdGlvbnNbaV1bZmxvb3JdLnB1c2goW2Zyb20sIHRvLCBoZWFkcm9vbV0pOyAvLyBYWFggbWF5YmUgYWRkIGZyYWdtZW50OyBwcm9iYWJseSB1bm5lY2Vzc2FyeVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBzcGFuLmZsb29yID0gY2FycGV0ICsgdGhpc0N1cmx5SGVpZ2h0O1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAkLmVhY2goZGF0YS5jaHVua3MsIGZ1bmN0aW9uKGNodW5rTm8sIGNodW5rKSB7XHJcbiAgICAgICAgICByZXNlcnZhdGlvbnMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgIGNodW5rLmdyb3VwID0gc3ZnLmdyb3VwKHJvdy5ncm91cCk7XHJcbiAgICAgICAgICBjaHVuay5oaWdobGlnaHRHcm91cCA9IHN2Zy5ncm91cChjaHVuay5ncm91cCk7XHJcblxyXG4gICAgICAgICAgdmFyIHkgPSAwO1xyXG4gICAgICAgICAgdmFyIG1pbkFyY0Rpc3Q7XHJcbiAgICAgICAgICB2YXIgaGFzTGVmdEFyY3MsIGhhc1JpZ2h0QXJjcywgaGFzSW50ZXJuYWxBcmNzO1xyXG4gICAgICAgICAgdmFyIGhhc0Fubm90YXRpb25zO1xyXG4gICAgICAgICAgdmFyIGNodW5rRnJvbSA9IEluZmluaXR5O1xyXG4gICAgICAgICAgdmFyIGNodW5rVG8gPSAwO1xyXG4gICAgICAgICAgdmFyIGNodW5rSGVpZ2h0ID0gMDtcclxuICAgICAgICAgIHZhciBzcGFjaW5nID0gMDtcclxuICAgICAgICAgIHZhciBzcGFjaW5nQ2h1bmtJZCA9IG51bGw7XHJcbiAgICAgICAgICB2YXIgc3BhY2luZ1Jvd0JyZWFrID0gMDtcclxuXHJcbiAgICAgICAgICAkLmVhY2goY2h1bmsuZnJhZ21lbnRzLCBmdW5jdGlvbihmcmFnbWVudE5vLCBmcmFnbWVudCkge1xyXG4gICAgICAgICAgICB2YXIgc3BhbiA9IGZyYWdtZW50LnNwYW47XHJcbiAgICAgICAgICAgIHZhciBzcGFuRGVzYyA9IHNwYW5UeXBlc1tzcGFuLnR5cGVdO1xyXG4gICAgICAgICAgICB2YXIgYmdDb2xvciA9ICgoc3BhbkRlc2MgJiYgc3BhbkRlc2MuYmdDb2xvcikgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNwYW5UeXBlcy5TUEFOX0RFRkFVTFQgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYW5UeXBlcy5TUEFOX0RFRkFVTFQuYmdDb2xvcikgfHwgJyNmZmZmZmYnKTtcclxuICAgICAgICAgICAgdmFyIGZnQ29sb3IgPSAoKHNwYW5EZXNjICYmIHNwYW5EZXNjLmZnQ29sb3IpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChzcGFuVHlwZXMuU1BBTl9ERUZBVUxUICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuVHlwZXMuU1BBTl9ERUZBVUxULmZnQ29sb3IpIHx8ICcjMDAwMDAwJyk7XHJcbiAgICAgICAgICAgIHZhciBib3JkZXJDb2xvciA9ICgoc3BhbkRlc2MgJiYgc3BhbkRlc2MuYm9yZGVyQ29sb3IpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc3BhblR5cGVzLlNQQU5fREVGQVVMVCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYW5UeXBlcy5TUEFOX0RFRkFVTFQuYm9yZGVyQ29sb3IpIHx8ICcjMDAwMDAwJyk7XHJcblxyXG4gICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2U6IGlmIHRoZSBib3JkZXIgJ2NvbG9yJyB2YWx1ZSBpcyAnZGFya2VuJyxcclxuICAgICAgICAgICAgLy8gdGhlbiBqdXN0IGRhcmtlbiB0aGUgQkcgY29sb3IgYSBiaXQgZm9yIHRoZSBib3JkZXIuXHJcbiAgICAgICAgICAgIGlmIChib3JkZXJDb2xvciA9PSAnZGFya2VuJykge1xyXG4gICAgICAgICAgICAgICAgYm9yZGVyQ29sb3IgPSBVdGlsLmFkanVzdENvbG9yTGlnaHRuZXNzKGJnQ29sb3IsIC0wLjYpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmcmFnbWVudC5ncm91cCA9IHN2Zy5ncm91cChjaHVuay5ncm91cCwge1xyXG4gICAgICAgICAgICAgICdjbGFzcyc6ICdzcGFuJyxcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgZnJhZ21lbnRIZWlnaHQgPSAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKCF5KSB5ID0gLXNpemVzLnRleHRzLmhlaWdodDtcclxuICAgICAgICAgICAgdmFyIHggPSAoZnJhZ21lbnQuY3VybHkuZnJvbSArIGZyYWdtZW50LmN1cmx5LnRvKSAvIDI7XHJcblxyXG4gICAgICAgICAgICAvLyBYWFggaXMgaXQgbWF5YmUgc2l6ZXMudGV4dHM/XHJcbiAgICAgICAgICAgIHZhciB5eSA9IHkgKyBzaXplcy5mcmFnbWVudHMueTtcclxuICAgICAgICAgICAgdmFyIGhoID0gc2l6ZXMuZnJhZ21lbnRzLmhlaWdodDtcclxuICAgICAgICAgICAgdmFyIHd3ID0gZnJhZ21lbnQud2lkdGg7XHJcbiAgICAgICAgICAgIHZhciB4eCA9IHggLSB3dyAvIDI7XHJcblxyXG4gICAgICAgICAgICAvLyB0ZXh0IG1hcmdpbiBmaW5lLXR1bmluZ1xyXG4gICAgICAgICAgICB5eSArPSBib3hUZXh0TWFyZ2luLnk7XHJcbiAgICAgICAgICAgIGhoIC09IDIqYm94VGV4dE1hcmdpbi55O1xyXG4gICAgICAgICAgICB4eCArPSBib3hUZXh0TWFyZ2luLng7XHJcbiAgICAgICAgICAgIHd3IC09IDIqYm94VGV4dE1hcmdpbi54O1xyXG4gICAgICAgICAgICB2YXIgcmVjdENsYXNzID0gJ3NwYW5fJyArIChzcGFuLmN1ZSB8fCBzcGFuLnR5cGUpICsgJyBzcGFuX2RlZmF1bHQnOyAvLyBUT0RPIFhYWCBmaXJzdCBwYXJ0IHVubmVlZGVkIEkgdGhpbms7IHJlbW92ZVxyXG5cclxuICAgICAgICAgICAgLy8gYXR0YWNoIGUuZy4gXCJGYWxzZV9wb3NpdGl2ZVwiIGludG8gdGhlIHR5cGVcclxuICAgICAgICAgICAgaWYgKHNwYW4uY29tbWVudCAmJiBzcGFuLmNvbW1lbnQudHlwZSkgeyByZWN0Q2xhc3MgKz0gJyAnK3NwYW4uY29tbWVudC50eXBlOyB9XHJcbiAgICAgICAgICAgIHZhciBieCA9IHh4IC0gQ29uZmlndXJhdGlvbi52aXN1YWwubWFyZ2luLnggLSBib3hUZXh0TWFyZ2luLng7XHJcbiAgICAgICAgICAgIHZhciBieSA9IHl5IC0gQ29uZmlndXJhdGlvbi52aXN1YWwubWFyZ2luLnk7XHJcbiAgICAgICAgICAgIHZhciBidyA9IHd3ICsgMiAqIENvbmZpZ3VyYXRpb24udmlzdWFsLm1hcmdpbi54O1xyXG4gICAgICAgICAgICB2YXIgYmggPSBoaCArIDIgKiBDb25maWd1cmF0aW9uLnZpc3VhbC5tYXJnaW4ueTtcclxuXHJcbiAgICAgICAgICAgIGlmIChyb3VuZENvb3JkaW5hdGVzKSB7XHJcbiAgICAgICAgICAgICAgeCAgPSAoeHwwKSswLjU7XHJcbiAgICAgICAgICAgICAgYnggPSAoYnh8MCkrMC41O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgc2hhZG93UmVjdDtcclxuICAgICAgICAgICAgdmFyIG1hcmtlZFJlY3Q7XHJcbiAgICAgICAgICAgIGlmIChzcGFuLm1hcmtlZCkge1xyXG4gICAgICAgICAgICAgIG1hcmtlZFJlY3QgPSBzdmcucmVjdChjaHVuay5oaWdobGlnaHRHcm91cCxcclxuICAgICAgICAgICAgICAgICAgYnggLSBtYXJrZWRTcGFuU2l6ZSwgYnkgLSBtYXJrZWRTcGFuU2l6ZSxcclxuICAgICAgICAgICAgICAgICAgYncgKyAyICogbWFya2VkU3BhblNpemUsIGJoICsgMiAqIG1hcmtlZFNwYW5TaXplLCB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBmaWx0ZXI6ICd1cmwoI0dhdXNzaWFuX0JsdXIpJyxcclxuICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogXCJzaGFkb3dfRWRpdEhpZ2hsaWdodFwiLFxyXG4gICAgICAgICAgICAgICAgICByeDogbWFya2VkU3BhblNpemUsXHJcbiAgICAgICAgICAgICAgICAgIHJ5OiBtYXJrZWRTcGFuU2l6ZSxcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICBzdmcub3RoZXIobWFya2VkUmVjdCwgJ2FuaW1hdGUnLCB7XHJcbiAgICAgICAgICAgICAgICAnZGF0YS10eXBlJzogc3Bhbi5tYXJrZWQsXHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lOiAnZmlsbCcsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IChzcGFuLm1hcmtlZCA9PSAnbWF0Y2gnPyBoaWdobGlnaHRNYXRjaFNlcXVlbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICA6IGhpZ2hsaWdodFNwYW5TZXF1ZW5jZSksXHJcbiAgICAgICAgICAgICAgICBkdXI6IGhpZ2hsaWdodER1cmF0aW9uLFxyXG4gICAgICAgICAgICAgICAgcmVwZWF0Q291bnQ6ICdpbmRlZmluaXRlJyxcclxuICAgICAgICAgICAgICAgIGJlZ2luOiAnaW5kZWZpbml0ZSdcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICBjaHVua0Zyb20gPSBNYXRoLm1pbihieCAtIG1hcmtlZFNwYW5TaXplLCBjaHVua0Zyb20pO1xyXG4gICAgICAgICAgICAgIGNodW5rVG8gPSBNYXRoLm1heChieCArIGJ3ICsgbWFya2VkU3BhblNpemUsIGNodW5rVG8pO1xyXG4gICAgICAgICAgICAgIGZyYWdtZW50SGVpZ2h0ID0gTWF0aC5tYXgoYmggKyAyICogbWFya2VkU3BhblNpemUsIGZyYWdtZW50SGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyAubWF0Y2goKSByZW1vdmVzIHVuY29uZmlndXJlZCBzaGFkb3dzLCB3aGljaCB3ZXJlXHJcbiAgICAgICAgICAgIC8vIGFsd2F5cyBzaG93aW5nIHVwIGFzIGJsYWNrLlxyXG4gICAgICAgICAgICAvLyBUT0RPOiBkb24ndCBoYXJkLWNvZGUgY29uZmlndXJlZCBzaGFkb3djbGFzc2VzLlxyXG4gICAgICAgICAgICBpZiAoc3Bhbi5zaGFkb3dDbGFzcyAmJlxyXG4gICAgICAgICAgICAgICAgc3Bhbi5zaGFkb3dDbGFzcy5tYXRjaCgnVHJ1ZV9wb3NpdGl2ZXxGYWxzZV9wb3NpdGl2ZXxGYWxzZV9uZWdhdGl2ZXxBbm5vdGF0aW9uRXJyb3J8QW5ub3RhdGlvbldhcm5pbmd8QW5ub3RhdG9yTm90ZXN8Tm9ybWFsaXplZHxBbm5vdGF0aW9uSW5jb21wbGV0ZXxBbm5vdGF0aW9uVW5jb25maXJtZWR8cmVjdEVkaXRIaWdobGlnaHR8RWRpdEhpZ2hsaWdodF9hcmN8TWlzc2luZ0Fubm90YXRpb258Q2hhbmdlZEFubm90YXRpb24gJykpIHtcclxuICAgICAgICAgICAgICBzaGFkb3dSZWN0ID0gc3ZnLnJlY3QoZnJhZ21lbnQuZ3JvdXAsXHJcbiAgICAgICAgICAgICAgICAgIGJ4IC0gcmVjdFNoYWRvd1NpemUsIGJ5IC0gcmVjdFNoYWRvd1NpemUsXHJcbiAgICAgICAgICAgICAgICAgIGJ3ICsgMiAqIHJlY3RTaGFkb3dTaXplLCBiaCArIDIgKiByZWN0U2hhZG93U2l6ZSwge1xyXG4gICAgICAgICAgICAgICAgICAnY2xhc3MnOiAnc2hhZG93XycgKyBzcGFuLnNoYWRvd0NsYXNzLFxyXG4gICAgICAgICAgICAgICAgICBmaWx0ZXI6ICd1cmwoI0dhdXNzaWFuX0JsdXIpJyxcclxuICAgICAgICAgICAgICAgICAgcng6IHJlY3RTaGFkb3dSb3VuZGluZyxcclxuICAgICAgICAgICAgICAgICAgcnk6IHJlY3RTaGFkb3dSb3VuZGluZyxcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICBjaHVua0Zyb20gPSBNYXRoLm1pbihieCAtIHJlY3RTaGFkb3dTaXplLCBjaHVua0Zyb20pO1xyXG4gICAgICAgICAgICAgIGNodW5rVG8gPSBNYXRoLm1heChieCArIGJ3ICsgcmVjdFNoYWRvd1NpemUsIGNodW5rVG8pO1xyXG4gICAgICAgICAgICAgIGZyYWdtZW50SGVpZ2h0ID0gTWF0aC5tYXgoYmggKyAyICogcmVjdFNoYWRvd1NpemUsIGZyYWdtZW50SGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmcmFnbWVudC5yZWN0ID0gc3ZnLnJlY3QoZnJhZ21lbnQuZ3JvdXAsXHJcbiAgICAgICAgICAgICAgICBieCwgYnksIGJ3LCBiaCwge1xyXG5cclxuICAgICAgICAgICAgICAgICdjbGFzcyc6IHJlY3RDbGFzcyxcclxuICAgICAgICAgICAgICAgIGZpbGw6IGJnQ29sb3IsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IGJvcmRlckNvbG9yLFxyXG4gICAgICAgICAgICAgICAgcng6IENvbmZpZ3VyYXRpb24udmlzdWFsLm1hcmdpbi54LFxyXG4gICAgICAgICAgICAgICAgcnk6IENvbmZpZ3VyYXRpb24udmlzdWFsLm1hcmdpbi55LFxyXG4gICAgICAgICAgICAgICAgJ2RhdGEtc3Bhbi1pZCc6IHNwYW4uaWQsXHJcbiAgICAgICAgICAgICAgICAnZGF0YS1mcmFnbWVudC1pZCc6IGZyYWdtZW50LmlkLFxyXG4gICAgICAgICAgICAgICAgJ3N0cm9rZURhc2hBcnJheSc6IHNwYW4uYXR0cmlidXRlTWVyZ2UuZGFzaEFycmF5LFxyXG4gICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gVE9ETyBYWFg6IHF1aWNrIG5hc3R5IGhhY2sgdG8gYWxsb3cgbm9ybWFsaXphdGlvbnNcclxuICAgICAgICAgICAgLy8gdG8gYmUgbWFya2VkIHZpc3VhbGx5OyBkbyBzb21ldGhpbmcgY2xlYW5lciFcclxuICAgICAgICAgICAgaWYgKHNwYW4ubm9ybWFsaXplZCkge1xyXG4gICAgICAgICAgICAgICQoZnJhZ21lbnQucmVjdCkuYWRkQ2xhc3Moc3Bhbi5ub3JtYWxpemVkKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnJhZ21lbnQucmlnaHQgPSBieCArIGJ3OyAvLyBUT0RPIHB1dCBpdCBzb21ld2hlcmUgbmljZXI/XHJcbiAgICAgICAgICAgIGlmICghKHNwYW4uc2hhZG93Q2xhc3MgfHwgc3Bhbi5tYXJrZWQpKSB7XHJcbiAgICAgICAgICAgICAgY2h1bmtGcm9tID0gTWF0aC5taW4oYngsIGNodW5rRnJvbSk7XHJcbiAgICAgICAgICAgICAgY2h1bmtUbyA9IE1hdGgubWF4KGJ4ICsgYncsIGNodW5rVG8pO1xyXG4gICAgICAgICAgICAgIGZyYWdtZW50SGVpZ2h0ID0gTWF0aC5tYXgoYmgsIGZyYWdtZW50SGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnJhZ21lbnQucmVjdEJveCA9IHsgeDogYngsIHk6IGJ5IC0gc3Bhbi5mbG9vciwgd2lkdGg6IGJ3LCBoZWlnaHQ6IGJoIH07XHJcbiAgICAgICAgICAgIGZyYWdtZW50LmhlaWdodCA9IHNwYW4uZmxvb3IgKyBoaCArIDMgKiBDb25maWd1cmF0aW9uLnZpc3VhbC5tYXJnaW4ueSArIENvbmZpZ3VyYXRpb24udmlzdWFsLmN1cmx5SGVpZ2h0ICsgQ29uZmlndXJhdGlvbi52aXN1YWwuYXJjU3BhY2luZztcclxuICAgICAgICAgICAgdmFyIHNwYWNlZFRvd2VySWQgPSBmcmFnbWVudC50b3dlcklkICogMjtcclxuICAgICAgICAgICAgaWYgKCFmcmFnbWVudEhlaWdodHNbc3BhY2VkVG93ZXJJZF0gfHwgZnJhZ21lbnRIZWlnaHRzW3NwYWNlZFRvd2VySWRdIDwgZnJhZ21lbnQuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgZnJhZ21lbnRIZWlnaHRzW3NwYWNlZFRvd2VySWRdID0gZnJhZ21lbnQuaGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICQoZnJhZ21lbnQucmVjdCkuYXR0cigneScsIHl5IC0gQ29uZmlndXJhdGlvbi52aXN1YWwubWFyZ2luLnkgLSBzcGFuLmZsb29yKTtcclxuICAgICAgICAgICAgaWYgKHNoYWRvd1JlY3QpIHtcclxuICAgICAgICAgICAgICAkKHNoYWRvd1JlY3QpLmF0dHIoJ3knLCB5eSAtIHJlY3RTaGFkb3dTaXplIC0gQ29uZmlndXJhdGlvbi52aXN1YWwubWFyZ2luLnkgLSBzcGFuLmZsb29yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWFya2VkUmVjdCkge1xyXG4gICAgICAgICAgICAgICQobWFya2VkUmVjdCkuYXR0cigneScsIHl5IC0gbWFya2VkU3BhblNpemUgLSBDb25maWd1cmF0aW9uLnZpc3VhbC5tYXJnaW4ueSAtIHNwYW4uZmxvb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzcGFuLmF0dHJpYnV0ZU1lcmdlLmJveCA9PT0gXCJjcm9zc2VkXCIpIHtcclxuICAgICAgICAgICAgICBzdmcucGF0aChmcmFnbWVudC5ncm91cCwgc3ZnLmNyZWF0ZVBhdGgoKS5cclxuICAgICAgICAgICAgICAgICAgbW92ZSh4eCwgeXkgLSBDb25maWd1cmF0aW9uLnZpc3VhbC5tYXJnaW4ueSAtIHNwYW4uZmxvb3IpLlxyXG4gICAgICAgICAgICAgICAgICBsaW5lKHh4ICsgZnJhZ21lbnQud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgeXkgKyBoaCArIENvbmZpZ3VyYXRpb24udmlzdWFsLm1hcmdpbi55IC0gc3Bhbi5mbG9vciksXHJcbiAgICAgICAgICAgICAgICAgIHsgJ2NsYXNzJzogJ2JveGNyb3NzJyB9KTtcclxuICAgICAgICAgICAgICBzdmcucGF0aChmcmFnbWVudC5ncm91cCwgc3ZnLmNyZWF0ZVBhdGgoKS5cclxuICAgICAgICAgICAgICAgICAgbW92ZSh4eCArIGZyYWdtZW50LndpZHRoLCB5eSAtIENvbmZpZ3VyYXRpb24udmlzdWFsLm1hcmdpbi55IC0gc3Bhbi5mbG9vcikuXHJcbiAgICAgICAgICAgICAgICAgIGxpbmUoeHgsIHl5ICsgaGggKyBDb25maWd1cmF0aW9uLnZpc3VhbC5tYXJnaW4ueSAtIHNwYW4uZmxvb3IpLFxyXG4gICAgICAgICAgICAgICAgICB7ICdjbGFzcyc6ICdib3hjcm9zcycgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGZyYWdtZW50VGV4dCA9IHN2Zy50ZXh0KGZyYWdtZW50Lmdyb3VwLCB4LCB5IC0gc3Bhbi5mbG9vciwgZGF0YS5zcGFuQW5uVGV4dHNbZnJhZ21lbnQuZ2x5cGhlZExhYmVsVGV4dF0sIHsgZmlsbDogZmdDb2xvciB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIE1ha2UgY3VybGllcyB0byBzaG93IHRoZSBmcmFnbWVudFxyXG4gICAgICAgICAgICBpZiAoZnJhZ21lbnQuZHJhd0N1cmx5KSB7XHJcbiAgICAgICAgICAgICAgdmFyIGN1cmx5Q29sb3IgPSAnZ3JleSc7XHJcbiAgICAgICAgICAgICAgaWYgKGNvbG9yZWRDdXJsaWVzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3BhbkRlc2MgPSBzcGFuVHlwZXNbc3Bhbi50eXBlXTtcclxuICAgICAgICAgICAgICAgIHZhciBiZ0NvbG9yID0gKChzcGFuRGVzYyAmJiBzcGFuRGVzYy5iZ0NvbG9yKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNwYW5UeXBlcy5TUEFOX0RFRkFVTFQgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuVHlwZXMuU1BBTl9ERUZBVUxULmZnQ29sb3IpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIzAwMDAwMCcpO1xyXG4gICAgICAgICAgICAgICAgY3VybHlDb2xvciA9IFV0aWwuYWRqdXN0Q29sb3JMaWdodG5lc3MoYmdDb2xvciwgLTAuNik7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICB2YXIgYm90dG9tID0geXkgKyBoaCArIENvbmZpZ3VyYXRpb24udmlzdWFsLm1hcmdpbi55IC0gc3Bhbi5mbG9vciArIDE7XHJcbiAgICAgICAgICAgICAgc3ZnLnBhdGgoZnJhZ21lbnQuZ3JvdXAsIHN2Zy5jcmVhdGVQYXRoKClcclxuICAgICAgICAgICAgICAgICAgLm1vdmUoZnJhZ21lbnQuY3VybHkuZnJvbSwgYm90dG9tICsgQ29uZmlndXJhdGlvbi52aXN1YWwuY3VybHlIZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAgIC5jdXJ2ZUMoZnJhZ21lbnQuY3VybHkuZnJvbSwgYm90dG9tLFxyXG4gICAgICAgICAgICAgICAgICAgIHgsIGJvdHRvbSArIENvbmZpZ3VyYXRpb24udmlzdWFsLmN1cmx5SGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgIHgsIGJvdHRvbSlcclxuICAgICAgICAgICAgICAgICAgLmN1cnZlQyh4LCBib3R0b20gKyBDb25maWd1cmF0aW9uLnZpc3VhbC5jdXJseUhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudC5jdXJseS50bywgYm90dG9tLFxyXG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50LmN1cmx5LnRvLCBib3R0b20gKyBDb25maWd1cmF0aW9uLnZpc3VhbC5jdXJseUhlaWdodCksXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdjdXJseScsXHJcbiAgICAgICAgICAgICAgICAgICdzdHJva2UnOiBjdXJseUNvbG9yLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgY2h1bmtGcm9tID0gTWF0aC5taW4oZnJhZ21lbnQuY3VybHkuZnJvbSwgY2h1bmtGcm9tKTtcclxuICAgICAgICAgICAgICBjaHVua1RvID0gTWF0aC5tYXgoZnJhZ21lbnQuY3VybHkudG8sIGNodW5rVG8pO1xyXG4gICAgICAgICAgICAgIGZyYWdtZW50SGVpZ2h0ID0gTWF0aC5tYXgoQ29uZmlndXJhdGlvbi52aXN1YWwuY3VybHlIZWlnaHQsIGZyYWdtZW50SGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGZyYWdtZW50ID09IHNwYW4uaGVhZEZyYWdtZW50KSB7XHJcbiAgICAgICAgICAgICAgLy8gZmluZCB0aGUgZ2FwIHRvIGZpdCB0aGUgYmFja3dhcmRzIGFyY3MsIGJ1dCBvbmx5IG9uXHJcbiAgICAgICAgICAgICAgLy8gaGVhZCBmcmFnbWVudCAtIG90aGVyIGZyYWdtZW50cyBkb24ndCBoYXZlIGFyY3NcclxuICAgICAgICAgICAgICAkLmVhY2goc3Bhbi5pbmNvbWluZywgZnVuY3Rpb24oYXJjSWQsIGFyYykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxlZnRTcGFuID0gZGF0YS5zcGFuc1thcmMub3JpZ2luXTtcclxuICAgICAgICAgICAgICAgIHZhciBvcmlnaW4gPSBsZWZ0U3Bhbi5oZWFkRnJhZ21lbnQuY2h1bms7XHJcbiAgICAgICAgICAgICAgICB2YXIgYm9yZGVyO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNodW5rLmluZGV4ID09IG9yaWdpbi5pbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICBoYXNJbnRlcm5hbEFyY3MgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbi5yb3cpIHtcclxuICAgICAgICAgICAgICAgICAgdmFyIGxhYmVscyA9IFV0aWwuZ2V0QXJjTGFiZWxzKHNwYW5UeXBlcywgbGVmdFNwYW4udHlwZSwgYXJjLnR5cGUsIHJlbGF0aW9uVHlwZXNIYXNoKTtcclxuICAgICAgICAgICAgICAgICAgaWYgKCFsYWJlbHMubGVuZ3RoKSBsYWJlbHMgPSBbYXJjLnR5cGVdO1xyXG4gICAgICAgICAgICAgICAgICBpZiAob3JpZ2luLnJvdy5pbmRleCA9PSByb3dJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNhbWUgcm93LCBidXQgYmVmb3JlIHRoaXNcclxuICAgICAgICAgICAgICAgICAgICBib3JkZXIgPSBvcmlnaW4udHJhbnNsYXRpb24ueCArIGxlZnRTcGFuLmZyYWdtZW50c1tsZWZ0U3Bhbi5mcmFnbWVudHMubGVuZ3RoIC0gMV0ucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyID0gQ29uZmlndXJhdGlvbi52aXN1YWwubWFyZ2luLnggKyBzZW50TnVtTWFyZ2luICsgcm93UGFkZGluZztcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB2YXIgbGFiZWxObyA9IENvbmZpZ3VyYXRpb24uYWJicmV2c09uID8gbGFiZWxzLmxlbmd0aCAtIDEgOiAwO1xyXG4gICAgICAgICAgICAgICAgICB2YXIgc21hbGxlc3RMYWJlbFdpZHRoID0gc2l6ZXMuYXJjcy53aWR0aHNbbGFiZWxzW2xhYmVsTm9dXSArIDIgKiBtaW5BcmNTbGFudDtcclxuICAgICAgICAgICAgICAgICAgdmFyIGdhcCA9IGN1cnJlbnRYICsgYnggLSBib3JkZXI7XHJcbiAgICAgICAgICAgICAgICAgIHZhciBhcmNTcGFjaW5nID0gc21hbGxlc3RMYWJlbFdpZHRoIC0gZ2FwO1xyXG4gICAgICAgICAgICAgICAgICBpZiAoIWhhc0xlZnRBcmNzIHx8IHNwYWNpbmcgPCBhcmNTcGFjaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3BhY2luZyA9IGFyY1NwYWNpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgc3BhY2luZ0NodW5rSWQgPSBvcmlnaW4uaW5kZXggKyAxO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGFyY1NwYWNpbmcgPSBzbWFsbGVzdExhYmVsV2lkdGggLSBieDtcclxuICAgICAgICAgICAgICAgICAgaWYgKCFoYXNMZWZ0QXJjcyB8fCBzcGFjaW5nUm93QnJlYWsgPCBhcmNTcGFjaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3BhY2luZ1Jvd0JyZWFrID0gYXJjU3BhY2luZztcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBoYXNMZWZ0QXJjcyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBoYXNSaWdodEFyY3MgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICQuZWFjaChzcGFuLm91dGdvaW5nLCBmdW5jdGlvbihhcmNJZCwgYXJjKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVmdFNwYW4gPSBkYXRhLnNwYW5zW2FyYy50YXJnZXRdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IGxlZnRTcGFuLmhlYWRGcmFnbWVudC5jaHVuaztcclxuICAgICAgICAgICAgICAgIHZhciBib3JkZXI7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LnJvdykge1xyXG4gICAgICAgICAgICAgICAgICB2YXIgbGFiZWxzID0gVXRpbC5nZXRBcmNMYWJlbHMoc3BhblR5cGVzLCBzcGFuLnR5cGUsIGFyYy50eXBlLCByZWxhdGlvblR5cGVzSGFzaCk7XHJcbiAgICAgICAgICAgICAgICAgIGlmICghbGFiZWxzLmxlbmd0aCkgbGFiZWxzID0gW2FyYy50eXBlXTtcclxuICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldC5yb3cuaW5kZXggPT0gcm93SW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzYW1lIHJvdywgYnV0IGJlZm9yZSB0aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyID0gdGFyZ2V0LnRyYW5zbGF0aW9uLnggKyBsZWZ0U3Bhbi5mcmFnbWVudHNbbGVmdFNwYW4uZnJhZ21lbnRzLmxlbmd0aCAtIDFdLnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlciA9IENvbmZpZ3VyYXRpb24udmlzdWFsLm1hcmdpbi54ICsgc2VudE51bU1hcmdpbiArIHJvd1BhZGRpbmc7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgdmFyIGxhYmVsTm8gPSBDb25maWd1cmF0aW9uLmFiYnJldnNPbiA/IGxhYmVscy5sZW5ndGggLSAxIDogMDtcclxuICAgICAgICAgICAgICAgICAgdmFyIHNtYWxsZXN0TGFiZWxXaWR0aCA9IHNpemVzLmFyY3Mud2lkdGhzW2xhYmVsc1tsYWJlbE5vXV0gKyAyICogbWluQXJjU2xhbnQ7XHJcbiAgICAgICAgICAgICAgICAgIHZhciBnYXAgPSBjdXJyZW50WCArIGJ4IC0gYm9yZGVyO1xyXG4gICAgICAgICAgICAgICAgICB2YXIgYXJjU3BhY2luZyA9IHNtYWxsZXN0TGFiZWxXaWR0aCAtIGdhcDtcclxuICAgICAgICAgICAgICAgICAgaWYgKCFoYXNMZWZ0QXJjcyB8fCBzcGFjaW5nIDwgYXJjU3BhY2luZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNwYWNpbmcgPSBhcmNTcGFjaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIHNwYWNpbmdDaHVua0lkID0gdGFyZ2V0LmluZGV4ICsgMTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBhcmNTcGFjaW5nID0gc21hbGxlc3RMYWJlbFdpZHRoIC0gYng7XHJcbiAgICAgICAgICAgICAgICAgIGlmICghaGFzTGVmdEFyY3MgfHwgc3BhY2luZ1Jvd0JyZWFrIDwgYXJjU3BhY2luZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNwYWNpbmdSb3dCcmVhayA9IGFyY1NwYWNpbmc7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgaGFzTGVmdEFyY3MgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgaGFzUmlnaHRBcmNzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmcmFnbWVudEhlaWdodCArPSBzcGFuLmZsb29yIHx8IENvbmZpZ3VyYXRpb24udmlzdWFsLmN1cmx5SGVpZ2h0O1xyXG4gICAgICAgICAgICBpZiAoZnJhZ21lbnRIZWlnaHQgPiBjaHVua0hlaWdodCkgY2h1bmtIZWlnaHQgPSBmcmFnbWVudEhlaWdodDtcclxuICAgICAgICAgICAgaGFzQW5ub3RhdGlvbnMgPSB0cnVlO1xyXG4gICAgICAgICAgfSk7IC8vIGZyYWdtZW50c1xyXG5cclxuICAgICAgICAgIC8vIHBvc2l0aW9uaW5nIG9mIHRoZSBjaHVua1xyXG4gICAgICAgICAgY2h1bmsucmlnaHQgPSBjaHVua1RvO1xyXG4gICAgICAgICAgdmFyIHRleHRXaWR0aCA9IHNpemVzLnRleHRzLndpZHRoc1tjaHVuay50ZXh0XTtcclxuICAgICAgICAgIGNodW5rSGVpZ2h0ICs9IHNpemVzLnRleHRzLmhlaWdodDtcclxuICAgICAgICAgIHZhciBib3hYID0gLU1hdGgubWluKGNodW5rRnJvbSwgMCk7XHJcbiAgICAgICAgICB2YXIgYm94V2lkdGggPVxyXG4gICAgICAgICAgICAgIE1hdGgubWF4KHRleHRXaWR0aCwgY2h1bmtUbykgLVxyXG4gICAgICAgICAgICAgIE1hdGgubWluKDAsIGNodW5rRnJvbSk7XHJcbiAgICAgICAgICAvLyBpZiAoaGFzTGVmdEFyY3MpIHtcclxuICAgICAgICAgICAgLy8gVE9ETyBjaGFuZ2UgdGhpcyB3aXRoIHNtYWxsZXN0TGVmdEFyY1xyXG4gICAgICAgICAgICAvLyB2YXIgc3BhY2luZyA9IGFyY0hvcml6b250YWxTcGFjaW5nIC0gKGN1cnJlbnRYIC0gbGFzdEFyY0JvcmRlcik7XHJcbiAgICAgICAgICAgIC8vIGFyYyB0b28gc21hbGw/XHJcbiAgICAgICAgICBpZiAoc3BhY2luZyA+IDApIGN1cnJlbnRYICs9IHNwYWNpbmc7XHJcbiAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICB2YXIgcmlnaHRCb3JkZXJGb3JBcmNzID0gaGFzUmlnaHRBcmNzID8gYXJjSG9yaXpvbnRhbFNwYWNpbmcgOiAoaGFzSW50ZXJuYWxBcmNzID8gYXJjU2xhbnQgOiAwKTtcclxuXHJcbiAgICAgICAgICB2YXIgbGFzdFggPSBjdXJyZW50WDtcclxuICAgICAgICAgIHZhciBsYXN0Um93ID0gcm93O1xyXG5cclxuICAgICAgICAgIGlmIChjaHVuay5zZW50ZW5jZSkge1xyXG4gICAgICAgICAgICB3aGlsZSAoc2VudGVuY2VOdW1iZXIgPCBjaHVuay5zZW50ZW5jZSkge1xyXG4gICAgICAgICAgICAgIHNlbnRlbmNlTnVtYmVyKys7XHJcbiAgICAgICAgICAgICAgcm93LmFyY3MgPSBzdmcuZ3JvdXAocm93Lmdyb3VwLCB7ICdjbGFzcyc6ICdhcmNzJyB9KTtcclxuICAgICAgICAgICAgICByb3dzLnB1c2gocm93KTtcclxuICAgICAgICAgICAgICByb3cgPSBuZXcgUm93KHN2Zyk7XHJcbiAgICAgICAgICAgICAgc2VudGVuY2VUb2dnbGUgPSAxIC0gc2VudGVuY2VUb2dnbGU7XHJcbiAgICAgICAgICAgICAgcm93LmJhY2tncm91bmRJbmRleCA9IHNlbnRlbmNlVG9nZ2xlO1xyXG4gICAgICAgICAgICAgIHJvdy5pbmRleCA9ICsrcm93SW5kZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VudGVuY2VUb2dnbGUgPSAxIC0gc2VudGVuY2VUb2dnbGU7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKGNodW5rLnNlbnRlbmNlIHx8XHJcbiAgICAgICAgICAgICAgY3VycmVudFggKyBib3hXaWR0aCArIHJpZ2h0Qm9yZGVyRm9yQXJjcyA+PSBjYW52YXNXaWR0aCAtIDIgKiBDb25maWd1cmF0aW9uLnZpc3VhbC5tYXJnaW4ueCkge1xyXG4gICAgICAgICAgICAvLyB0aGUgY2h1bmsgZG9lcyBub3QgZml0XHJcbiAgICAgICAgICAgIHJvdy5hcmNzID0gc3ZnLmdyb3VwKHJvdy5ncm91cCwgeyAnY2xhc3MnOiAnYXJjcycgfSk7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IHJlbGF0ZWQgdG8gaXNzdWUgIzU3MVxyXG4gICAgICAgICAgICAvLyByZXBsYWNlIGFyY0hvcml6b250YWxTcGFjaW5nIHdpdGggYSBjYWxjdWxhdGVkIHZhbHVlXHJcbiAgICAgICAgICAgIGN1cnJlbnRYID0gQ29uZmlndXJhdGlvbi52aXN1YWwubWFyZ2luLnggKyBzZW50TnVtTWFyZ2luICsgcm93UGFkZGluZyArXHJcbiAgICAgICAgICAgICAgICAoaGFzTGVmdEFyY3MgPyBhcmNIb3Jpem9udGFsU3BhY2luZyA6IChoYXNJbnRlcm5hbEFyY3MgPyBhcmNTbGFudCA6IDApKTtcclxuICAgICAgICAgICAgaWYgKGhhc0xlZnRBcmNzKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGFkanVzdGVkQ3VyVGV4dFdpZHRoID0gc2l6ZXMudGV4dHMud2lkdGhzW2NodW5rLnRleHRdICsgYXJjSG9yaXpvbnRhbFNwYWNpbmc7XHJcbiAgICAgICAgICAgICAgaWYgKGFkanVzdGVkQ3VyVGV4dFdpZHRoID4gbWF4VGV4dFdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICBtYXhUZXh0V2lkdGggPSBhZGp1c3RlZEN1clRleHRXaWR0aDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNwYWNpbmdSb3dCcmVhayA+IDApIHtcclxuICAgICAgICAgICAgICBjdXJyZW50WCArPSBzcGFjaW5nUm93QnJlYWs7XHJcbiAgICAgICAgICAgICAgc3BhY2luZyA9IDA7IC8vIGRvIG5vdCBjZW50ZXIgaW50ZXJ2ZW5pbmcgZWxlbWVudHNcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gbmV3IHJvd1xyXG4gICAgICAgICAgICByb3dzLnB1c2gocm93KTtcclxuXHJcbiAgICAgICAgICAgIHN2Zy5yZW1vdmUoY2h1bmsuZ3JvdXApO1xyXG4gICAgICAgICAgICByb3cgPSBuZXcgUm93KHN2Zyk7XHJcbiAgICAgICAgICAgIHJvdy5iYWNrZ3JvdW5kSW5kZXggPSBzZW50ZW5jZVRvZ2dsZTtcclxuICAgICAgICAgICAgcm93LmluZGV4ID0gKytyb3dJbmRleDtcclxuICAgICAgICAgICAgc3ZnLmFkZChyb3cuZ3JvdXAsIGNodW5rLmdyb3VwKTtcclxuICAgICAgICAgICAgY2h1bmsuZ3JvdXAgPSByb3cuZ3JvdXAubGFzdEVsZW1lbnRDaGlsZDtcclxuICAgICAgICAgICAgJChjaHVuay5ncm91cCkuY2hpbGRyZW4oXCJnW2NsYXNzPSdzcGFuJ11cIikuXHJcbiAgICAgICAgICAgICAgZWFjaChmdW5jdGlvbihpbmRleCwgZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICBjaHVuay5mcmFnbWVudHNbaW5kZXhdLmdyb3VwID0gZWxlbWVudDtcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgJChjaHVuay5ncm91cCkuZmluZChcInJlY3RbZGF0YS1zcGFuLWlkXVwiKS5cclxuICAgICAgICAgICAgICBlYWNoKGZ1bmN0aW9uKGluZGV4LCBlbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgIGNodW5rLmZyYWdtZW50c1tpbmRleF0ucmVjdCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gYnJlYWsgdGhlIHRleHQgaGlnaGxpZ2h0cyB3aGVuIHRoZSByb3cgYnJlYWtzXHJcbiAgICAgICAgICBpZiAocm93LmluZGV4ICE9PSBsYXN0Um93LmluZGV4KSB7XHJcbiAgICAgICAgICAgICQuZWFjaChvcGVuVGV4dEhpZ2hsaWdodHMsIGZ1bmN0aW9uKHRleHRJZCwgdGV4dERlc2MpIHtcclxuICAgICAgICAgICAgICBpZiAodGV4dERlc2NbM10gIT0gbGFzdFgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZXdEZXNjID0gW2xhc3RSb3csIHRleHREZXNjWzNdLCBsYXN0WCArIGJveFgsIHRleHREZXNjWzRdXTtcclxuICAgICAgICAgICAgICAgIHRleHRNYXJrZWRSb3dzLnB1c2gobmV3RGVzYyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHRleHREZXNjWzNdID0gY3VycmVudFg7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIG9wZW4gdGV4dCBoaWdobGlnaHRzXHJcbiAgICAgICAgICAkLmVhY2goY2h1bmsubWFya2VkVGV4dFN0YXJ0LCBmdW5jdGlvbih0ZXh0Tm8sIHRleHREZXNjKSB7XHJcbiAgICAgICAgICAgIHRleHREZXNjWzNdICs9IGN1cnJlbnRYICsgYm94WDtcclxuICAgICAgICAgICAgb3BlblRleHRIaWdobGlnaHRzW3RleHREZXNjWzBdXSA9IHRleHREZXNjO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgLy8gY2xvc2UgdGV4dCBoaWdobGlnaHRzXHJcbiAgICAgICAgICAkLmVhY2goY2h1bmsubWFya2VkVGV4dEVuZCwgZnVuY3Rpb24odGV4dE5vLCB0ZXh0RGVzYykge1xyXG4gICAgICAgICAgICB0ZXh0RGVzY1szXSArPSBjdXJyZW50WCArIGJveFg7XHJcbiAgICAgICAgICAgIHZhciBzdGFydERlc2MgPSBvcGVuVGV4dEhpZ2hsaWdodHNbdGV4dERlc2NbMF1dO1xyXG4gICAgICAgICAgICBkZWxldGUgb3BlblRleHRIaWdobGlnaHRzW3RleHREZXNjWzBdXTtcclxuICAgICAgICAgICAgbWFya2VkUm93ID0gW3Jvdywgc3RhcnREZXNjWzNdLCB0ZXh0RGVzY1szXSwgc3RhcnREZXNjWzRdXTtcclxuICAgICAgICAgICAgdGV4dE1hcmtlZFJvd3MucHVzaChtYXJrZWRSb3cpO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgLy8gWFhYIGNoZWNrIHRoaXMgLSBpcyBpdCB1c2VkPyBzaG91bGQgaXQgYmUgbGFzdFJvdz9cclxuICAgICAgICAgIGlmIChoYXNBbm5vdGF0aW9ucykgcm93Lmhhc0Fubm90YXRpb25zID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICBpZiAoY2h1bmsuc2VudGVuY2UpIHtcclxuICAgICAgICAgICAgcm93LnNlbnRlbmNlID0gKytzZW50ZW5jZU51bWJlcjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoc3BhY2luZyA+IDApIHtcclxuICAgICAgICAgICAgLy8gaWYgd2UgYWRkZWQgYSBnYXAsIGNlbnRlciB0aGUgaW50ZXJ2ZW5pbmcgZWxlbWVudHNcclxuICAgICAgICAgICAgc3BhY2luZyAvPSAyO1xyXG4gICAgICAgICAgICB2YXIgZmlyc3RDaHVua0luUm93ID0gcm93LmNodW5rc1tyb3cuY2h1bmtzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICBpZiAoc3BhY2luZ0NodW5rSWQgPCBmaXJzdENodW5rSW5Sb3cuaW5kZXgpIHtcclxuICAgICAgICAgICAgICBzcGFjaW5nQ2h1bmtJZCA9IGZpcnN0Q2h1bmtJblJvdy5pbmRleCArIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgY2h1bmtJbmRleCA9IHNwYWNpbmdDaHVua0lkOyBjaHVua0luZGV4IDwgY2h1bmsuaW5kZXg7IGNodW5rSW5kZXgrKykge1xyXG4gICAgICAgICAgICAgIHZhciBtb3ZlZENodW5rID0gZGF0YS5jaHVua3NbY2h1bmtJbmRleF07XHJcbiAgICAgICAgICAgICAgdHJhbnNsYXRlKG1vdmVkQ2h1bmssIG1vdmVkQ2h1bmsudHJhbnNsYXRpb24ueCArIHNwYWNpbmcsIDApO1xyXG4gICAgICAgICAgICAgIG1vdmVkQ2h1bmsudGV4dFggKz0gc3BhY2luZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJvdy5jaHVua3MucHVzaChjaHVuayk7XHJcbiAgICAgICAgICBjaHVuay5yb3cgPSByb3c7XHJcblxyXG4gICAgICAgICAgdHJhbnNsYXRlKGNodW5rLCBjdXJyZW50WCArIGJveFgsIDApO1xyXG4gICAgICAgICAgY2h1bmsudGV4dFggPSBjdXJyZW50WCArIGJveFg7XHJcblxyXG4gICAgICAgICAgdmFyIHNwYWNlV2lkdGggPSAwO1xyXG4gICAgICAgICAgdmFyIHNwYWNlTGVuID0gY2h1bmsubmV4dFNwYWNlICYmIGNodW5rLm5leHRTcGFjZS5sZW5ndGggfHwgMDtcclxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BhY2VMZW47IGkrKykgc3BhY2VXaWR0aCArPSBzcGFjZVdpZHRoc1tjaHVuay5uZXh0U3BhY2VbaV1dIHx8IDA7XHJcbiAgICAgICAgICBjdXJyZW50WCArPSBzcGFjZVdpZHRoICsgYm94V2lkdGg7XHJcbiAgICAgICAgfSk7IC8vIGNodW5rc1xyXG5cclxuICAgICAgICAvLyBmaW5pc2ggdGhlIGxhc3Qgcm93XHJcbiAgICAgICAgcm93LmFyY3MgPSBzdmcuZ3JvdXAocm93Lmdyb3VwLCB7ICdjbGFzcyc6ICdhcmNzJyB9KTtcclxuICAgICAgICByb3dzLnB1c2gocm93KTtcclxuXHJcblV0aWwucHJvZmlsZUVuZCgnY2h1bmtzJyk7XHJcblV0aWwucHJvZmlsZVN0YXJ0KCdhcmNzUHJlcCcpO1xyXG5cclxuICAgICAgICB2YXIgYXJyb3dzID0ge307XHJcbiAgICAgICAgdmFyIGFycm93ID0gbWFrZUFycm93KGRlZnMsICdub25lJyk7XHJcbiAgICAgICAgaWYgKGFycm93KSBhcnJvd3NbJ25vbmUnXSA9IGFycm93O1xyXG5cclxuICAgICAgICB2YXIgbGVuID0gZnJhZ21lbnRIZWlnaHRzLmxlbmd0aDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICBpZiAoIWZyYWdtZW50SGVpZ2h0c1tpXSB8fCBmcmFnbWVudEhlaWdodHNbaV0gPCBDb25maWd1cmF0aW9uLnZpc3VhbC5hcmNTdGFydEhlaWdodCkge1xyXG4gICAgICAgICAgICBmcmFnbWVudEhlaWdodHNbaV0gPSBDb25maWd1cmF0aW9uLnZpc3VhbC5hcmNTdGFydEhlaWdodDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGZpbmQgb3V0IGhvdyBoaWdoIHRoZSBhcmNzIGhhdmUgdG8gZ29cclxuICAgICAgICAkLmVhY2goZGF0YS5hcmNzLCBmdW5jdGlvbihhcmNObywgYXJjKSB7XHJcbiAgICAgICAgICBhcmMuanVtcEhlaWdodCA9IDA7XHJcbiAgICAgICAgICB2YXIgZnJvbUZyYWdtZW50ID0gZGF0YS5zcGFuc1thcmMub3JpZ2luXS5oZWFkRnJhZ21lbnQ7XHJcbiAgICAgICAgICB2YXIgdG9GcmFnbWVudCA9IGRhdGEuc3BhbnNbYXJjLnRhcmdldF0uaGVhZEZyYWdtZW50O1xyXG4gICAgICAgICAgaWYgKGZyb21GcmFnbWVudC50b3dlcklkID4gdG9GcmFnbWVudC50b3dlcklkKSB7XHJcbiAgICAgICAgICAgIHZhciB0bXAgPSBmcm9tRnJhZ21lbnQ7IGZyb21GcmFnbWVudCA9IHRvRnJhZ21lbnQ7IHRvRnJhZ21lbnQgPSB0bXA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB2YXIgZnJvbSwgdG87XHJcbiAgICAgICAgICBpZiAoZnJvbUZyYWdtZW50LmNodW5rLmluZGV4ID09IHRvRnJhZ21lbnQuY2h1bmsuaW5kZXgpIHtcclxuICAgICAgICAgICAgZnJvbSA9IGZyb21GcmFnbWVudC50b3dlcklkO1xyXG4gICAgICAgICAgICB0byA9IHRvRnJhZ21lbnQudG93ZXJJZDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZyb20gPSBmcm9tRnJhZ21lbnQudG93ZXJJZCArIDE7XHJcbiAgICAgICAgICAgIHRvID0gdG9GcmFnbWVudC50b3dlcklkIC0gMTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGZvciAodmFyIGkgPSBmcm9tOyBpIDw9IHRvOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGFyYy5qdW1wSGVpZ2h0IDwgZnJhZ21lbnRIZWlnaHRzW2kgKiAyXSkgYXJjLmp1bXBIZWlnaHQgPSBmcmFnbWVudEhlaWdodHNbaSAqIDJdO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBzb3J0IHRoZSBhcmNzXHJcbiAgICAgICAgZGF0YS5hcmNzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgICAgLy8gZmlyc3Qgd3JpdGUgdGhvc2UgdGhhdCBoYXZlIGxlc3MgdG8ganVtcCBvdmVyXHJcbiAgICAgICAgICB2YXIgdG1wID0gYS5qdW1wSGVpZ2h0IC0gYi5qdW1wSGVpZ2h0O1xyXG4gICAgICAgICAgaWYgKHRtcCkgcmV0dXJuIHRtcCA8IDAgPyAtMSA6IDE7XHJcbiAgICAgICAgICAvLyBpZiBlcXVhbCwgdGhlbiB0aG9zZSB0aGF0IHNwYW4gbGVzcyBkaXN0YW5jZVxyXG4gICAgICAgICAgdG1wID0gYS5kaXN0IC0gYi5kaXN0O1xyXG4gICAgICAgICAgaWYgKHRtcCkgcmV0dXJuIHRtcCA8IDAgPyAtMSA6IDE7XHJcbiAgICAgICAgICAvLyBpZiBlcXVhbCwgdGhlbiB0aG9zZSB3aGVyZSBoZWlnaHRzIG9mIHRoZSB0YXJnZXRzIGFyZSBzbWFsbGVyXHJcbiAgICAgICAgICB0bXAgPSBkYXRhLnNwYW5zW2Eub3JpZ2luXS5oZWFkRnJhZ21lbnQuaGVpZ2h0ICsgZGF0YS5zcGFuc1thLnRhcmdldF0uaGVhZEZyYWdtZW50LmhlaWdodCAtXHJcbiAgICAgICAgICAgIGRhdGEuc3BhbnNbYi5vcmlnaW5dLmhlYWRGcmFnbWVudC5oZWlnaHQgLSBkYXRhLnNwYW5zW2IudGFyZ2V0XS5oZWFkRnJhZ21lbnQuaGVpZ2h0O1xyXG4gICAgICAgICAgaWYgKHRtcCkgcmV0dXJuIHRtcCA8IDAgPyAtMSA6IDE7XHJcbiAgICAgICAgICAvLyBpZiBlcXVhbCwgdGhlbiB0aG9zZSB3aXRoIHRoZSBsb3dlciBvcmlnaW5cclxuICAgICAgICAgIHRtcCA9IGRhdGEuc3BhbnNbYS5vcmlnaW5dLmhlYWRGcmFnbWVudC5oZWlnaHQgLSBkYXRhLnNwYW5zW2Iub3JpZ2luXS5oZWFkRnJhZ21lbnQuaGVpZ2h0O1xyXG4gICAgICAgICAgaWYgKHRtcCkgcmV0dXJuIHRtcCA8IDAgPyAtMSA6IDE7XHJcbiAgICAgICAgICAvLyBpZiBlcXVhbCwgdGhleSdyZSBqdXN0IGVxdWFsLlxyXG4gICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIGRyYXcgdGhlIGRyYWcgYXJjIG1hcmtlclxyXG4gICAgICAgIHZhciBhcnJvd2hlYWQgPSBzdmcubWFya2VyKGRlZnMsICdkcmFnX2Fycm93JyxcclxuICAgICAgICAgIDUsIDIuNSwgNSwgNSwgJ2F1dG8nLFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBtYXJrZXJVbml0czogJ3N0cm9rZVdpZHRoJyxcclxuICAgICAgICAgICAgJ2NsYXNzJzogJ2RyYWdfZmlsbCcsXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICBzdmcucG9seWxpbmUoYXJyb3doZWFkLCBbWzAsIDBdLCBbNSwgMi41XSwgWzAsIDVdLCBbMC4yLCAyLjVdXSk7XHJcblxyXG5VdGlsLnByb2ZpbGVFbmQoJ2FyY3NQcmVwJyk7XHJcblV0aWwucHJvZmlsZVN0YXJ0KCdhcmNzJyk7XHJcblxyXG4gICAgICAgIC8vIGFkZCB0aGUgYXJjc1xyXG4gICAgICAgICQuZWFjaChkYXRhLmFyY3MsIGZ1bmN0aW9uKGFyY05vLCBhcmMpIHtcclxuICAgICAgICAgIC8vIHNlcGFyYXRlIG91dCBwb3NzaWJsZSBudW1lcmljIHN1ZmZpeCBmcm9tIHR5cGVcclxuICAgICAgICAgIHZhciBub051bUFyY1R5cGU7XHJcbiAgICAgICAgICB2YXIgc3BsaXRBcmNUeXBlO1xyXG4gICAgICAgICAgaWYgKGFyYy50eXBlKSB7XHJcbiAgICAgICAgICAgIHNwbGl0QXJjVHlwZSA9IGFyYy50eXBlLm1hdGNoKC9eKC4qPykoXFxkKikkLyk7XHJcbiAgICAgICAgICAgIG5vTnVtQXJjVHlwZSA9IHNwbGl0QXJjVHlwZVsxXTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB2YXIgb3JpZ2luU3BhbiA9IGRhdGEuc3BhbnNbYXJjLm9yaWdpbl07XHJcbiAgICAgICAgICB2YXIgdGFyZ2V0U3BhbiA9IGRhdGEuc3BhbnNbYXJjLnRhcmdldF07XHJcblxyXG4gICAgICAgICAgdmFyIGxlZnRUb1JpZ2h0ID0gb3JpZ2luU3Bhbi5oZWFkRnJhZ21lbnQudG93ZXJJZCA8IHRhcmdldFNwYW4uaGVhZEZyYWdtZW50LnRvd2VySWQ7XHJcbiAgICAgICAgICB2YXIgbGVmdCwgcmlnaHQ7XHJcbiAgICAgICAgICBpZiAobGVmdFRvUmlnaHQpIHtcclxuICAgICAgICAgICAgbGVmdCA9IG9yaWdpblNwYW4uaGVhZEZyYWdtZW50O1xyXG4gICAgICAgICAgICByaWdodCA9IHRhcmdldFNwYW4uaGVhZEZyYWdtZW50O1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbGVmdCA9IHRhcmdldFNwYW4uaGVhZEZyYWdtZW50O1xyXG4gICAgICAgICAgICByaWdodCA9IG9yaWdpblNwYW4uaGVhZEZyYWdtZW50O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHZhciBzcGFuRGVzYyA9IHNwYW5UeXBlc1tvcmlnaW5TcGFuLnR5cGVdO1xyXG4gICAgICAgICAgLy8gVE9ETzogbWlnaHQgbWFrZSBtb3JlIHNlbnNlIHRvIHJlZm9ybWF0IHRoaXMgYXMgZGljdCBpbnN0ZWFkXHJcbiAgICAgICAgICAvLyBvZiBzZWFyY2hpbmcgdGhyb3VnaCB0aGUgbGlzdCBldmVyeSB0eXBlXHJcbiAgICAgICAgICB2YXIgYXJjRGVzYztcclxuICAgICAgICAgIGlmIChzcGFuRGVzYyAmJiBzcGFuRGVzYy5hcmNzKSB7XHJcbiAgICAgICAgICAgICQuZWFjaChzcGFuRGVzYy5hcmNzLCBmdW5jdGlvbihhcmNEZXNjTm8sIGFyY0Rlc2NJdGVyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJjRGVzY0l0ZXIudHlwZSA9PSBhcmMudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICBhcmNEZXNjID0gYXJjRGVzY0l0ZXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBmYWxsIGJhY2sgb24gdW5udW1iZXJlZCB0eXBlIGlmIG5vdCBmb3VuZCBpbiBmdWxsXHJcbiAgICAgICAgICBpZiAoIWFyY0Rlc2MgJiYgbm9OdW1BcmNUeXBlICYmIG5vTnVtQXJjVHlwZSAhPSBhcmMudHlwZSAmJlxyXG4gICAgICAgICAgICBzcGFuRGVzYyAmJiBzcGFuRGVzYy5hcmNzKSB7XHJcbiAgICAgICAgICAgICQuZWFjaChzcGFuRGVzYy5hcmNzLCBmdW5jdGlvbihhcmNEZXNjTm8sIGFyY0Rlc2NJdGVyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJjRGVzY0l0ZXIudHlwZSA9PSBub051bUFyY1R5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgYXJjRGVzYyA9IGFyY0Rlc2NJdGVyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gZmFsbCBiYWNrIG9uIHJlbGF0aW9uIHR5cGVzIGluIGNhc2Ugd2Ugc3RpbGwgZG9uJ3QgaGF2ZVxyXG4gICAgICAgICAgLy8gYW4gYXJjIGRlc2NyaXB0aW9uLCB3aXRoIGZpbmFsIGZhbGxiYWNrIHRvIHVubnVtYmVyZWQgcmVsYXRpb25cclxuICAgICAgICAgIGlmICghYXJjRGVzYykge1xyXG4gICAgICAgICAgICBhcmNEZXNjID0gJC5leHRlbmQoe30sIHJlbGF0aW9uVHlwZXNIYXNoW2FyYy50eXBlXSB8fCByZWxhdGlvblR5cGVzSGFzaFtub051bUFyY1R5cGVdKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHZhciBjb2xvciA9ICgoYXJjRGVzYyAmJiBhcmNEZXNjLmNvbG9yKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgIChzcGFuVHlwZXMuQVJDX0RFRkFVTFQgJiYgc3BhblR5cGVzLkFSQ19ERUZBVUxULmNvbG9yKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICcjMDAwMDAwJyk7XHJcbiAgICAgICAgICB2YXIgc3ltbWV0cmljID0gYXJjRGVzYyAmJiBhcmNEZXNjLnByb3BlcnRpZXMgJiYgYXJjRGVzYy5wcm9wZXJ0aWVzLnN5bW1ldHJpYztcclxuICAgICAgICAgIHZhciBkYXNoQXJyYXkgPSBhcmNEZXNjICYmIGFyY0Rlc2MuZGFzaEFycmF5O1xyXG4gICAgICAgICAgdmFyIGFycm93SGVhZCA9ICgoYXJjRGVzYyAmJiBhcmNEZXNjLmFycm93SGVhZCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNwYW5UeXBlcy5BUkNfREVGQVVMVCAmJiBzcGFuVHlwZXMuQVJDX0RFRkFVTFQuYXJyb3dIZWFkKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAndHJpYW5nbGUsNScpICsgJywnICsgY29sb3I7XHJcbiAgICAgICAgICB2YXIgbGFiZWxBcnJvd0hlYWQgPSAoKGFyY0Rlc2MgJiYgYXJjRGVzYy5sYWJlbEFycm93KSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzcGFuVHlwZXMuQVJDX0RFRkFVTFQgJiYgc3BhblR5cGVzLkFSQ19ERUZBVUxULmxhYmVsQXJyb3cpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RyaWFuZ2xlLDUnKSArICcsJyArIGNvbG9yO1xyXG5cclxuICAgICAgICAgIHZhciBsZWZ0Qm94ID0gcm93QkJveChsZWZ0KTtcclxuICAgICAgICAgIHZhciByaWdodEJveCA9IHJvd0JCb3gocmlnaHQpO1xyXG4gICAgICAgICAgdmFyIGxlZnRSb3cgPSBsZWZ0LmNodW5rLnJvdy5pbmRleDtcclxuICAgICAgICAgIHZhciByaWdodFJvdyA9IHJpZ2h0LmNodW5rLnJvdy5pbmRleDtcclxuXHJcbiAgICAgICAgICBpZiAoIWFycm93c1thcnJvd0hlYWRdKSB7XHJcbiAgICAgICAgICAgIHZhciBhcnJvdyA9IG1ha2VBcnJvdyhkZWZzLCBhcnJvd0hlYWQpO1xyXG4gICAgICAgICAgICBpZiAoYXJyb3cpIGFycm93c1thcnJvd0hlYWRdID0gYXJyb3c7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoIWFycm93c1tsYWJlbEFycm93SGVhZF0pIHtcclxuICAgICAgICAgICAgdmFyIGFycm93ID0gbWFrZUFycm93KGRlZnMsIGxhYmVsQXJyb3dIZWFkKTtcclxuICAgICAgICAgICAgaWYgKGFycm93KSBhcnJvd3NbbGFiZWxBcnJvd0hlYWRdID0gYXJyb3c7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gZmluZCB0aGUgbmV4dCBoZWlnaHRcclxuICAgICAgICAgIHZhciBoZWlnaHQgPSAwO1xyXG5cclxuICAgICAgICAgIHZhciBmcm9tSW5kZXgyLCB0b0luZGV4MjtcclxuICAgICAgICAgIGlmIChsZWZ0LmNodW5rLmluZGV4ID09IHJpZ2h0LmNodW5rLmluZGV4KSB7XHJcbiAgICAgICAgICAgIGZyb21JbmRleDIgPSBsZWZ0LnRvd2VySWQgKiAyO1xyXG4gICAgICAgICAgICB0b0luZGV4MiA9IHJpZ2h0LnRvd2VySWQgKiAyO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZnJvbUluZGV4MiA9IGxlZnQudG93ZXJJZCAqIDIgKyAxO1xyXG4gICAgICAgICAgICB0b0luZGV4MiA9IHJpZ2h0LnRvd2VySWQgKiAyIC0gMTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGZvciAodmFyIGkgPSBmcm9tSW5kZXgyOyBpIDw9IHRvSW5kZXgyOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGZyYWdtZW50SGVpZ2h0c1tpXSA+IGhlaWdodCkgaGVpZ2h0ID0gZnJhZ21lbnRIZWlnaHRzW2ldO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaGVpZ2h0ICs9IENvbmZpZ3VyYXRpb24udmlzdWFsLmFyY1NwYWNpbmc7XHJcbiAgICAgICAgICB2YXIgbGVmdFNsYW50Qm91bmQsIHJpZ2h0U2xhbnRCb3VuZDtcclxuICAgICAgICAgIGZvciAodmFyIGkgPSBmcm9tSW5kZXgyOyBpIDw9IHRvSW5kZXgyOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGZyYWdtZW50SGVpZ2h0c1tpXSA8IGhlaWdodCkgZnJhZ21lbnRIZWlnaHRzW2ldID0gaGVpZ2h0O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEFkanVzdCB0aGUgaGVpZ2h0IHRvIGFsaWduIHdpdGggcGl4ZWxzIHdoZW4gcmVuZGVyZWRcclxuXHJcbiAgICAgICAgICAvLyBUT0RPOiBvbiBhdCBsZWFzdCBDaHJvbWUsIHRoaXMgZG9lc24ndCBtYWtlIGEgZGlmZmVyZW5jZTpcclxuICAgICAgICAgIC8vIHRoZSBsaW5lcyBjb21lIG91dCBwaXhlbC13aWR0aCBldmVuIHdpdGhvdXQgaXQuIENoZWNrLlxyXG4gICAgICAgICAgaGVpZ2h0ICs9IDAuNVxyXG5cclxuICAgICAgICAgIHZhciBjaHVua1JldmVyc2UgPSBmYWxzZTtcclxuICAgICAgICAgIHZhciB1Zm9DYXRjaGVyID0gb3JpZ2luU3Bhbi5oZWFkRnJhZ21lbnQuY2h1bmsuaW5kZXggPT0gdGFyZ2V0U3Bhbi5oZWFkRnJhZ21lbnQuY2h1bmsuaW5kZXg7XHJcbiAgICAgICAgICBpZiAodWZvQ2F0Y2hlcikge1xyXG4gICAgICAgICAgICBjaHVua1JldmVyc2UgPVxyXG4gICAgICAgICAgICAgIGxlZnRCb3gueCArIGxlZnRCb3gud2lkdGggLyAyIDwgcmlnaHRCb3gueCArIHJpZ2h0Qm94LndpZHRoIC8gMjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHZhciB1Zm9DYXRjaGVyTW9kID0gdWZvQ2F0Y2hlciA/IGNodW5rUmV2ZXJzZSA/IC0wLjUgOiAwLjUgOiAxO1xyXG5cclxuICAgICAgICAgIGZvciAodmFyIHJvd0luZGV4ID0gbGVmdFJvdzsgcm93SW5kZXggPD0gcmlnaHRSb3c7IHJvd0luZGV4KyspIHtcclxuICAgICAgICAgICAgdmFyIHJvdyA9IHJvd3Nbcm93SW5kZXhdO1xyXG4gICAgICAgICAgICByb3cuaGFzQW5ub3RhdGlvbnMgPSB0cnVlO1xyXG4gICAgICAgICAgICB2YXIgYXJjR3JvdXAgPSBzdmcuZ3JvdXAocm93LmFyY3MsIHtcclxuICAgICAgICAgICAgICAgICdkYXRhLWZyb20nOiBhcmMub3JpZ2luLFxyXG4gICAgICAgICAgICAgICAgJ2RhdGEtdG8nOiBhcmMudGFyZ2V0XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIgZnJvbSwgdG87XHJcblxyXG4gICAgICAgICAgICBpZiAocm93SW5kZXggPT0gbGVmdFJvdykge1xyXG4gICAgICAgICAgICAgIGZyb20gPSBsZWZ0Qm94LnggKyAoY2h1bmtSZXZlcnNlID8gMCA6IGxlZnRCb3gud2lkdGgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGZyb20gPSBzZW50TnVtTWFyZ2luO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocm93SW5kZXggPT0gcmlnaHRSb3cpIHtcclxuICAgICAgICAgICAgICB0byA9IHJpZ2h0Qm94LnggKyAoY2h1bmtSZXZlcnNlID8gcmlnaHRCb3gud2lkdGggOiAwKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB0byA9IGNhbnZhc1dpZHRoIC0gMiAqIENvbmZpZ3VyYXRpb24udmlzdWFsLm1hcmdpbi55O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgb3JpZ2luVHlwZSA9IGRhdGEuc3BhbnNbYXJjLm9yaWdpbl0udHlwZTtcclxuICAgICAgICAgICAgdmFyIGFyY0xhYmVscyA9IFV0aWwuZ2V0QXJjTGFiZWxzKHNwYW5UeXBlcywgb3JpZ2luVHlwZSwgYXJjLnR5cGUsIHJlbGF0aW9uVHlwZXNIYXNoKTtcclxuICAgICAgICAgICAgdmFyIGxhYmVsVGV4dCA9IFV0aWwuYXJjRGlzcGxheUZvcm0oc3BhblR5cGVzLCBvcmlnaW5UeXBlLCBhcmMudHlwZSwgcmVsYXRpb25UeXBlc0hhc2gpO1xyXG4gICAgICAgICAgICAvLyBpZiAoQ29uZmlndXJhdGlvbi5hYmJyZXZzT24gJiYgIXVmb0NhdGNoZXIgJiYgYXJjTGFiZWxzKSB7XHJcbiAgICAgICAgICAgIGlmIChDb25maWd1cmF0aW9uLmFiYnJldnNPbiAmJiBhcmNMYWJlbHMpIHtcclxuICAgICAgICAgICAgICB2YXIgbGFiZWxJZHggPSAxOyAvLyBmaXJzdCBhYmJyZXZpYXRpb25cclxuICAgICAgICAgICAgICAvLyBzdHJpY3RseSBzcGVha2luZyAyKmFyY1NsYW50IHdvdWxkIGJlIG5lZWRlZCB0byBhbGxvdyBmb3JcclxuICAgICAgICAgICAgICAvLyB0aGUgZnVsbC13aWR0aCBhcmNzIHRvIGZpdCwgYnV0IGp1ZGdlZCB1bmFiYnJldmlhdGVkIHRleHRcclxuICAgICAgICAgICAgICAvLyB0byBiZSBtb3JlIGltcG9ydGFudCB0aGFuIHRoZSBzcGFjZSBmb3IgYXJjcy5cclxuICAgICAgICAgICAgICB2YXIgbWF4TGVuZ3RoID0gKHRvIC0gZnJvbSkgLSAoYXJjU2xhbnQpO1xyXG4gICAgICAgICAgICAgIHdoaWxlIChzaXplcy5hcmNzLndpZHRoc1tsYWJlbFRleHRdID4gbWF4TGVuZ3RoICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIGFyY0xhYmVsc1tsYWJlbElkeF0pIHtcclxuICAgICAgICAgICAgICAgIGxhYmVsVGV4dCA9IGFyY0xhYmVsc1tsYWJlbElkeF07XHJcbiAgICAgICAgICAgICAgICBsYWJlbElkeCsrO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHNoYWRvd0dyb3VwO1xyXG4gICAgICAgICAgICBpZiAoYXJjLnNoYWRvd0NsYXNzIHx8IGFyYy5tYXJrZWQpIHtcclxuICAgICAgICAgICAgICBzaGFkb3dHcm91cCA9IHN2Zy5ncm91cChhcmNHcm91cCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgJ2ZpbGwnOiBjb2xvcixcclxuICAgICAgICAgICAgICAnZGF0YS1hcmMtcm9sZSc6IGFyYy50eXBlLFxyXG4gICAgICAgICAgICAgICdkYXRhLWFyYy1vcmlnaW4nOiBhcmMub3JpZ2luLFxyXG4gICAgICAgICAgICAgICdkYXRhLWFyYy10YXJnZXQnOiBhcmMudGFyZ2V0LFxyXG4gICAgICAgICAgICAgIC8vIFRPRE86IGNvbmZpcm0gdGhpcyBpcyB1bnVzZWQgYW5kIHJlbW92ZS5cclxuICAgICAgICAgICAgICAvLydkYXRhLWFyYy1pZCc6IGFyYy5pZCxcclxuICAgICAgICAgICAgICAnZGF0YS1hcmMtZWQnOiBhcmMuZXZlbnREZXNjSWQsXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvLyBjb25zdHJ1Y3QgU1ZHIHRleHQsIHNob3dpbmcgcG9zc2libGUgdHJhaWxpbmcgaW5kZXhcclxuICAgICAgICAgICAgLy8gbnVtYmVycyAoYXMgaW4gZS5nLiBcIlRoZW1lMlwiKSBhcyBzdWJzY3JpcHRzXHJcbiAgICAgICAgICAgIHZhciBzdmdUZXh0O1xyXG4gICAgICAgICAgICBpZiAoIXNwbGl0QXJjVHlwZVsyXSkge1xyXG4gICAgICAgICAgICAgICAgLy8gbm8gc3Vic2NyaXB0LCBzaW1wbGUgc3RyaW5nIHN1ZmZpY2VzXHJcbiAgICAgICAgICAgICAgICBzdmdUZXh0ID0gbGFiZWxUZXh0O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTmVlZCB0byBwYXJzZSBvdXQgcG9zc2libGUgbnVtZXJpYyBzdWZmaXhlcyB0byBhdm9pZFxyXG4gICAgICAgICAgICAgICAgLy8gZHVwbGljYXRpbmcgbnVtYmVyIGluIGxhYmVsIGFuZCBpdHMgc3Vic2NyaXB0XHJcbiAgICAgICAgICAgICAgICB2YXIgc3BsaXRMYWJlbFRleHQgPSBsYWJlbFRleHQubWF0Y2goL14oLio/KShcXGQqKSQvKTtcclxuICAgICAgICAgICAgICAgIHZhciBub051bUxhYmVsVGV4dCA9IHNwbGl0TGFiZWxUZXh0WzFdO1xyXG5cclxuICAgICAgICAgICAgICAgIHN2Z1RleHQgPSBzdmcuY3JlYXRlVGV4dCgpO1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogdG8gYWRkcmVzcyBpc3N1ZSAjNDUzLCBhdHRhY2hpbmcgb3B0aW9ucyBhbHNvXHJcbiAgICAgICAgICAgICAgICAvLyB0byBzcGFucywgbm90IG9ubHkgcHJpbWFyeSB0ZXh0LiBNYWtlIHN1cmUgdGhlcmVcclxuICAgICAgICAgICAgICAgIC8vIGFyZSBubyBwcm9ibGVtcyB3aXRoIHRoaXMuXHJcbiAgICAgICAgICAgICAgICBzdmdUZXh0LnNwYW4obm9OdW1MYWJlbFRleHQsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHN1YnNjcmlwdFNldHRpbmdzID0ge1xyXG4gICAgICAgICAgICAgICAgICAnZHknOiAnMC4zZW0nLFxyXG4gICAgICAgICAgICAgICAgICAnZm9udC1zaXplJzogJzgwJSdcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvLyBhbHRlcm5hdGUgcG9zc2liaWxpdHlcclxuLy8gICAgICAgICAgICAgICAgIHZhciBzdWJzY3JpcHRTZXR0aW5ncyA9IHtcclxuLy8gICAgICAgICAgICAgICAgICAgJ2Jhc2VsaW5lLXNoaWZ0JzogJ3N1YicsXHJcbi8vICAgICAgICAgICAgICAgICAgICdmb250LXNpemUnOiAnODAlJ1xyXG4vLyAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICQuZXh0ZW5kKHN1YnNjcmlwdFNldHRpbmdzLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIHN2Z1RleHQuc3BhbihzcGxpdEFyY1R5cGVbMl0sIHN1YnNjcmlwdFNldHRpbmdzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gZ3Vlc3MgYXQgdGhlIGNvcnJlY3QgYmFzZWxpbmUgc2hpZnQgdG8gZ2V0IHZlcnRpY2FsIGNlbnRlcmluZy5cclxuICAgICAgICAgICAgLy8gKENTUyBkb21pbmFudC1iYXNlbGluZSBjYW4ndCBiZSB1c2VkIGFzIG5vdCBhbGwgU1ZHIHJlbmRlcmVkcyBzdXBwb3J0IGl0LilcclxuICAgICAgICAgICAgdmFyIGJhc2VsaW5lX3NoaWZ0ID0gc2l6ZXMuYXJjcy5oZWlnaHQgLyA0O1xyXG4gICAgICAgICAgICB2YXIgdGV4dCA9IHN2Zy50ZXh0KGFyY0dyb3VwLCAoZnJvbSArIHRvKSAvIDIsIC1oZWlnaHQgKyBiYXNlbGluZV9zaGlmdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdmdUZXh0LCBvcHRpb25zKTtcclxuXHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHNpemVzLmFyY3Mud2lkdGhzW2xhYmVsVGV4dF07XHJcbiAgICAgICAgICAgIHZhciB0ZXh0Qm94ID0ge1xyXG4gICAgICAgICAgICAgIHg6IChmcm9tICsgdG8gLSB3aWR0aCkgLyAyLFxyXG4gICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICAgICAgICB5OiAtaGVpZ2h0IC0gc2l6ZXMuYXJjcy5oZWlnaHQgLyAyLFxyXG4gICAgICAgICAgICAgIGhlaWdodDogc2l6ZXMuYXJjcy5oZWlnaHQsXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGFyYy5tYXJrZWQpIHtcclxuICAgICAgICAgICAgICB2YXIgbWFya2VkUmVjdCA9IHN2Zy5yZWN0KHNoYWRvd0dyb3VwLFxyXG4gICAgICAgICAgICAgICAgICB0ZXh0Qm94LnggLSBtYXJrZWRBcmNTaXplLCB0ZXh0Qm94LnkgLSBtYXJrZWRBcmNTaXplLFxyXG4gICAgICAgICAgICAgICAgICB0ZXh0Qm94LndpZHRoICsgMiAqIG1hcmtlZEFyY1NpemUsIHRleHRCb3guaGVpZ2h0ICsgMiAqIG1hcmtlZEFyY1NpemUsIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBmaWx0ZXI6ICd1cmwoI0dhdXNzaWFuX0JsdXIpJyxcclxuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBcInNoYWRvd19FZGl0SGlnaGxpZ2h0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgcng6IG1hcmtlZEFyY1NpemUsXHJcbiAgICAgICAgICAgICAgICAgICAgcnk6IG1hcmtlZEFyY1NpemUsXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgc3ZnLm90aGVyKG1hcmtlZFJlY3QsICdhbmltYXRlJywge1xyXG4gICAgICAgICAgICAgICAgJ2RhdGEtdHlwZSc6IGFyYy5tYXJrZWQsXHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lOiAnZmlsbCcsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IChhcmMubWFya2VkID09ICdtYXRjaCcgPyBoaWdobGlnaHRNYXRjaFNlcXVlbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICA6IGhpZ2hsaWdodEFyY1NlcXVlbmNlKSxcclxuICAgICAgICAgICAgICAgIGR1cjogaGlnaGxpZ2h0RHVyYXRpb24sXHJcbiAgICAgICAgICAgICAgICByZXBlYXRDb3VudDogJ2luZGVmaW5pdGUnLFxyXG4gICAgICAgICAgICAgICAgYmVnaW46ICdpbmRlZmluaXRlJ1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhcmMuc2hhZG93Q2xhc3MpIHtcclxuICAgICAgICAgICAgICBzdmcucmVjdChzaGFkb3dHcm91cCxcclxuICAgICAgICAgICAgICAgICAgdGV4dEJveC54IC0gYXJjTGFiZWxTaGFkb3dTaXplLFxyXG4gICAgICAgICAgICAgICAgICB0ZXh0Qm94LnkgLSBhcmNMYWJlbFNoYWRvd1NpemUsXHJcbiAgICAgICAgICAgICAgICAgIHRleHRCb3gud2lkdGggICsgMiAqIGFyY0xhYmVsU2hhZG93U2l6ZSxcclxuICAgICAgICAgICAgICAgICAgdGV4dEJveC5oZWlnaHQgKyAyICogYXJjTGFiZWxTaGFkb3dTaXplLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ3NoYWRvd18nICsgYXJjLnNoYWRvd0NsYXNzLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcjogJ3VybCgjR2F1c3NpYW5fQmx1ciknLFxyXG4gICAgICAgICAgICAgICAgICAgIHJ4OiBhcmNMYWJlbFNoYWRvd1JvdW5kaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgIHJ5OiBhcmNMYWJlbFNoYWRvd1JvdW5kaW5nLFxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0ZXh0U3RhcnQgPSB0ZXh0Qm94Lng7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0RW5kID0gdGV4dEJveC54ICsgdGV4dEJveC53aWR0aDtcclxuXHJcbiAgICAgICAgICAgIC8vIGFkanVzdCBieSBtYXJnaW4gZm9yIGFyYyBkcmF3aW5nXHJcbiAgICAgICAgICAgIHRleHRTdGFydCAtPSBDb25maWd1cmF0aW9uLnZpc3VhbC5hcmNUZXh0TWFyZ2luO1xyXG4gICAgICAgICAgICB0ZXh0RW5kICs9IENvbmZpZ3VyYXRpb24udmlzdWFsLmFyY1RleHRNYXJnaW47XHJcblxyXG4gICAgICAgICAgICBpZiAoZnJvbSA+IHRvKSB7XHJcbiAgICAgICAgICAgICAgdmFyIHRtcCA9IHRleHRTdGFydDsgdGV4dFN0YXJ0ID0gdGV4dEVuZDsgdGV4dEVuZCA9IHRtcDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHBhdGg7XHJcblxyXG4gICAgICAgICAgICBpZiAocm91bmRDb29yZGluYXRlcykge1xyXG4gICAgICAgICAgICAgIC8vIGRvbid0IGFza1xyXG4gICAgICAgICAgICAgIGhlaWdodCA9IChoZWlnaHR8MCkrMC41O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChoZWlnaHQgPiByb3cubWF4QXJjSGVpZ2h0KSByb3cubWF4QXJjSGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgdmFyIG15QXJyb3dIZWFkICAgPSAoKGFyY0Rlc2MgJiYgYXJjRGVzYy5hcnJvd0hlYWQpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzcGFuVHlwZXMuQVJDX0RFRkFVTFQgJiYgc3BhblR5cGVzLkFSQ19ERUZBVUxULmFycm93SGVhZCkpO1xyXG4gICAgICAgICAgICB2YXIgYXJyb3dOYW1lID0gKGxlZnRUb1JpZ2h0ID9cclxuICAgICAgICAgICAgICAgIHN5bW1ldHJpYyAmJiBteUFycm93SGVhZCB8fCAnbm9uZScgOlxyXG4gICAgICAgICAgICAgICAgbXlBcnJvd0hlYWQgfHwgJ3RyaWFuZ2xlLDUnKSArICcsJyArIGNvbG9yO1xyXG4gICAgICAgICAgICB2YXIgYXJyb3dUeXBlID0gYXJyb3dzW2Fycm93TmFtZV07XHJcbiAgICAgICAgICAgIHZhciBhcnJvd0RlY2wgPSBhcnJvd1R5cGUgJiYgKCd1cmwoIycgKyBhcnJvd1R5cGUgKyAnKScpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGFycm93QXRMYWJlbEFkanVzdCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBsYWJlbEFycm93RGVjbCA9IG51bGw7XHJcbiAgICAgICAgICAgIHZhciBteUxhYmVsQXJyb3dIZWFkID0gKChhcmNEZXNjICYmIGFyY0Rlc2MubGFiZWxBcnJvdykgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNwYW5UeXBlcy5BUkNfREVGQVVMVCAmJiBzcGFuVHlwZXMuQVJDX0RFRkFVTFQubGFiZWxBcnJvdykpO1xyXG4gICAgICAgICAgICBpZiAobXlMYWJlbEFycm93SGVhZCkge1xyXG4gICAgICAgICAgICAgIHZhciBsYWJlbEFycm93TmFtZSA9IChsZWZ0VG9SaWdodCA/XHJcbiAgICAgICAgICAgICAgICAgIHN5bW1ldHJpYyAmJiBteUxhYmVsQXJyb3dIZWFkIHx8ICdub25lJyA6XHJcbiAgICAgICAgICAgICAgICAgIG15TGFiZWxBcnJvd0hlYWQgfHwgJ3RyaWFuZ2xlLDUnKSArICcsJyArIGNvbG9yO1xyXG4gICAgICAgICAgICAgIHZhciBsYWJlbEFycm93U3BsaXQgPSBsYWJlbEFycm93TmFtZS5zcGxpdCgnLCcpO1xyXG4gICAgICAgICAgICAgIGFycm93QXRMYWJlbEFkanVzdCA9IGxhYmVsQXJyb3dTcGxpdFswXSAhPSAnbm9uZScgJiYgcGFyc2VJbnQobGFiZWxBcnJvd1NwbGl0WzFdLCAxMCkgfHwgMDtcclxuICAgICAgICAgICAgICB2YXIgbGFiZWxBcnJvd1R5cGUgPSBhcnJvd3NbbGFiZWxBcnJvd05hbWVdO1xyXG4gICAgICAgICAgICAgIHZhciBsYWJlbEFycm93RGVjbCA9IGxhYmVsQXJyb3dUeXBlICYmICgndXJsKCMnICsgbGFiZWxBcnJvd1R5cGUgKyAnKScpO1xyXG4gICAgICAgICAgICAgIGlmICh1Zm9DYXRjaGVyKSBhcnJvd0F0TGFiZWxBZGp1c3QgPSAtYXJyb3dBdExhYmVsQWRqdXN0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBhcnJvd1N0YXJ0ID0gdGV4dFN0YXJ0IC0gYXJyb3dBdExhYmVsQWRqdXN0O1xyXG4gICAgICAgICAgICBwYXRoID0gc3ZnLmNyZWF0ZVBhdGgoKS5tb3ZlKGFycm93U3RhcnQsIC1oZWlnaHQpO1xyXG4gICAgICAgICAgICBpZiAocm93SW5kZXggPT0gbGVmdFJvdykge1xyXG4gICAgICAgICAgICAgIHZhciBjb3JuZXJ4ID0gZnJvbSArIHVmb0NhdGNoZXJNb2QgKiBhcmNTbGFudDtcclxuICAgICAgICAgICAgICAvLyBmb3Igbm9ybWFsIGNhc2VzLCBzaG91bGQgbm90IGJlIHBhc3QgdGV4dFN0YXJ0IGV2ZW4gaWYgbmFycm93XHJcbiAgICAgICAgICAgICAgaWYgKCF1Zm9DYXRjaGVyICYmIGNvcm5lcnggPiBhcnJvd1N0YXJ0IC0gMSkgeyBjb3JuZXJ4ID0gYXJyb3dTdGFydCAtIDE7IH1cclxuICAgICAgICAgICAgICBpZiAoc21vb3RoQXJjQ3VydmVzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udHJvbHggPSB1Zm9DYXRjaGVyID8gY29ybmVyeCArIDIqdWZvQ2F0Y2hlck1vZCpyZXZlcnNlQXJjQ29udHJvbHggOiBzbW9vdGhBcmNTdGVlcG5lc3MqZnJvbSsoMS1zbW9vdGhBcmNTdGVlcG5lc3MpKmNvcm5lcng7XHJcbiAgICAgICAgICAgICAgICB2YXIgZW5keSA9IGxlZnRCb3gueSArIChsZWZ0VG9SaWdodCB8fCBhcmMuZXF1aXYgPyBsZWZ0Qm94LmhlaWdodCAvIDIgOiBDb25maWd1cmF0aW9uLnZpc3VhbC5tYXJnaW4ueSk7XHJcbiAgICAgICAgICAgICAgICAvLyBubyBjdXJ2aW5nIGZvciBzaG9ydCBsaW5lcyBjb3ZlcmluZyBzaG9ydCB2ZXJ0aWNhbFxyXG4gICAgICAgICAgICAgICAgLy8gZGlzdGFuY2VzLCB0aGUgYXJyb3doZWFkcyBjYW4gZ28gb2ZmICgjOTI1KVxyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKC1oZWlnaHQtZW5keSkgPCAyICYmXHJcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMoY29ybmVyeC1mcm9tKSA8IDUpIHtcclxuICAgICAgICAgICAgICAgICAgZW5keSA9IC1oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsaW5lID0gcGF0aC5saW5lKGNvcm5lcngsIC1oZWlnaHQpLlxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnZlUShjb250cm9seCwgLWhlaWdodCwgZnJvbSwgZW5keSk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBhdGgubGluZShjb3JuZXJ4LCAtaGVpZ2h0KS5cclxuICAgICAgICAgICAgICAgICAgICBsaW5lKGZyb20sIGxlZnRCb3gueSArIChsZWZ0VG9SaWdodCB8fCBhcmMuZXF1aXYgPyBsZWZ0Qm94LmhlaWdodCAvIDIgOiBDb25maWd1cmF0aW9uLnZpc3VhbC5tYXJnaW4ueSkpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBwYXRoLmxpbmUoZnJvbSwgLWhlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3ZnLnBhdGgoYXJjR3JvdXAsIHBhdGgsIHtcclxuICAgICAgICAgICAgICAgIG1hcmtlckVuZDogYXJyb3dEZWNsLFxyXG4gICAgICAgICAgICAgICAgbWFya2VyU3RhcnQ6IGxhYmVsQXJyb3dEZWNsLFxyXG4gICAgICAgICAgICAgICAgc3R5bGU6ICdzdHJva2U6ICcgKyBjb2xvcixcclxuICAgICAgICAgICAgICAgICdzdHJva2VEYXNoQXJyYXknOiBkYXNoQXJyYXksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoYXJjLm1hcmtlZCkge1xyXG4gICAgICAgICAgICAgIHN2Zy5wYXRoKHNoYWRvd0dyb3VwLCBwYXRoLCB7XHJcbiAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdzaGFkb3dfRWRpdEhpZ2hsaWdodF9hcmMnLFxyXG4gICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogbWFya2VkQXJjU3Ryb2tlLFxyXG4gICAgICAgICAgICAgICAgICAnc3Ryb2tlRGFzaEFycmF5JzogZGFzaEFycmF5LFxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIHN2Zy5vdGhlcihtYXJrZWRSZWN0LCAnYW5pbWF0ZScsIHtcclxuICAgICAgICAgICAgICAgICdkYXRhLXR5cGUnOiBhcmMubWFya2VkLFxyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlTmFtZTogJ2ZpbGwnLFxyXG4gICAgICAgICAgICAgICAgdmFsdWVzOiAoYXJjLm1hcmtlZCA9PSAnbWF0Y2gnID8gaGlnaGxpZ2h0TWF0Y2hTZXF1ZW5jZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgOiBoaWdobGlnaHRBcmNTZXF1ZW5jZSksXHJcbiAgICAgICAgICAgICAgICBkdXI6IGhpZ2hsaWdodER1cmF0aW9uLFxyXG4gICAgICAgICAgICAgICAgcmVwZWF0Q291bnQ6ICdpbmRlZmluaXRlJyxcclxuICAgICAgICAgICAgICAgIGJlZ2luOiAnaW5kZWZpbml0ZSdcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYXJjLnNoYWRvd0NsYXNzKSB7XHJcbiAgICAgICAgICAgICAgc3ZnLnBhdGgoc2hhZG93R3JvdXAsIHBhdGgsIHtcclxuICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ3NoYWRvd18nICsgYXJjLnNoYWRvd0NsYXNzLFxyXG4gICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogc2hhZG93U3Ryb2tlLFxyXG4gICAgICAgICAgICAgICAgICAnc3Ryb2tlRGFzaEFycmF5JzogZGFzaEFycmF5LFxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBteUFycm93SGVhZCA9ICgoYXJjRGVzYyAmJiBhcmNEZXNjLmFycm93SGVhZCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzcGFuVHlwZXMuQVJDX0RFRkFVTFQgJiYgc3BhblR5cGVzLkFSQ19ERUZBVUxULmFycm93SGVhZCkpO1xyXG4gICAgICAgICAgICB2YXIgYXJyb3dOYW1lID0gKGxlZnRUb1JpZ2h0ID9cclxuICAgICAgICAgICAgICAgIG15QXJyb3dIZWFkIHx8ICd0cmlhbmdsZSw1JyA6XHJcbiAgICAgICAgICAgICAgICBzeW1tZXRyaWMgJiYgbXlBcnJvd0hlYWQgfHwgJ25vbmUnKSArICcsJyArIGNvbG9yO1xyXG4gICAgICAgICAgICB2YXIgYXJyb3dUeXBlID0gYXJyb3dzW2Fycm93TmFtZV07XHJcbiAgICAgICAgICAgIHZhciBhcnJvd0RlY2wgPSBhcnJvd1R5cGUgJiYgKCd1cmwoIycgKyBhcnJvd1R5cGUgKyAnKScpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGFycm93QXRMYWJlbEFkanVzdCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBsYWJlbEFycm93RGVjbCA9IG51bGw7XHJcbiAgICAgICAgICAgIHZhciBteUxhYmVsQXJyb3dIZWFkID0gKChhcmNEZXNjICYmIGFyY0Rlc2MubGFiZWxBcnJvdykgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNwYW5UeXBlcy5BUkNfREVGQVVMVCAmJiBzcGFuVHlwZXMuQVJDX0RFRkFVTFQubGFiZWxBcnJvdykpO1xyXG4gICAgICAgICAgICBpZiAobXlMYWJlbEFycm93SGVhZCkge1xyXG4gICAgICAgICAgICAgIHZhciBsYWJlbEFycm93TmFtZSA9IChsZWZ0VG9SaWdodCA/XHJcbiAgICAgICAgICAgICAgICAgIG15TGFiZWxBcnJvd0hlYWQgfHwgJ3RyaWFuZ2xlLDUnIDpcclxuICAgICAgICAgICAgICAgICAgc3ltbWV0cmljICYmIG15TGFiZWxBcnJvd0hlYWQgfHwgJ25vbmUnKSArICcsJyArIGNvbG9yO1xyXG4gICAgICAgICAgICAgIHZhciBsYWJlbEFycm93U3BsaXQgPSBsYWJlbEFycm93TmFtZS5zcGxpdCgnLCcpO1xyXG4gICAgICAgICAgICAgIGFycm93QXRMYWJlbEFkanVzdCA9IGxhYmVsQXJyb3dTcGxpdFswXSAhPSAnbm9uZScgJiYgcGFyc2VJbnQobGFiZWxBcnJvd1NwbGl0WzFdLCAxMCkgfHwgMDtcclxuICAgICAgICAgICAgICB2YXIgbGFiZWxBcnJvd1R5cGUgPSBhcnJvd3NbbGFiZWxBcnJvd05hbWVdO1xyXG4gICAgICAgICAgICAgIHZhciBsYWJlbEFycm93RGVjbCA9IGxhYmVsQXJyb3dUeXBlICYmICgndXJsKCMnICsgbGFiZWxBcnJvd1R5cGUgKyAnKScpO1xyXG4gICAgICAgICAgICAgIGlmICh1Zm9DYXRjaGVyKSBhcnJvd0F0TGFiZWxBZGp1c3QgPSAtYXJyb3dBdExhYmVsQWRqdXN0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBhcnJvd0VuZCA9IHRleHRFbmQgKyBhcnJvd0F0TGFiZWxBZGp1c3Q7XHJcbiAgICAgICAgICAgIHBhdGggPSBzdmcuY3JlYXRlUGF0aCgpLm1vdmUoYXJyb3dFbmQsIC1oZWlnaHQpO1xyXG4gICAgICAgICAgICBpZiAocm93SW5kZXggPT0gcmlnaHRSb3cpIHtcclxuICAgICAgICAgICAgICB2YXIgY29ybmVyeCAgPSB0byAtIHVmb0NhdGNoZXJNb2QgKiBhcmNTbGFudDtcclxuICAgICAgICAgICAgICAvLyBUT0RPOiBkdXBsaWNhdGVzIGFib3ZlIGluIHBhcnQsIG1ha2UgZnVuY3NcclxuICAgICAgICAgICAgICAvLyBmb3Igbm9ybWFsIGNhc2VzLCBzaG91bGQgbm90IGJlIHBhc3QgdGV4dEVuZCBldmVuIGlmIG5hcnJvd1xyXG4gICAgICAgICAgICAgIGlmICghdWZvQ2F0Y2hlciAmJiBjb3JuZXJ4IDwgYXJyb3dFbmQgKyAxKSB7IGNvcm5lcnggPSBhcnJvd0VuZCArIDE7IH1cclxuICAgICAgICAgICAgICBpZiAoc21vb3RoQXJjQ3VydmVzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udHJvbHggPSB1Zm9DYXRjaGVyID8gY29ybmVyeCAtIDIqdWZvQ2F0Y2hlck1vZCpyZXZlcnNlQXJjQ29udHJvbHggOiBzbW9vdGhBcmNTdGVlcG5lc3MqdG8rKDEtc21vb3RoQXJjU3RlZXBuZXNzKSpjb3JuZXJ4O1xyXG4gICAgICAgICAgICAgICAgdmFyIGVuZHkgPSByaWdodEJveC55ICsgKGxlZnRUb1JpZ2h0ICYmICFhcmMuZXF1aXYgPyBDb25maWd1cmF0aW9uLnZpc3VhbC5tYXJnaW4ueSA6IHJpZ2h0Qm94LmhlaWdodCAvIDIpO1xyXG4gICAgICAgICAgICAgICAgLy8gbm8gY3VydmluZyBmb3Igc2hvcnQgbGluZXMgY292ZXJpbmcgc2hvcnQgdmVydGljYWxcclxuICAgICAgICAgICAgICAgIC8vIGRpc3RhbmNlcywgdGhlIGFycm93aGVhZHMgY2FuIGdvIG9mZiAoIzkyNSlcclxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicygtaGVpZ2h0LWVuZHkpIDwgMiAmJlxyXG4gICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKGNvcm5lcngtdG8pIDwgNSkge1xyXG4gICAgICAgICAgICAgICAgICBlbmR5ID0gLWhlaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBhdGgubGluZShjb3JuZXJ4LCAtaGVpZ2h0KS5cclxuICAgICAgICAgICAgICAgICAgICBjdXJ2ZVEoY29udHJvbHgsIC1oZWlnaHQsIHRvLCBlbmR5KTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcGF0aC5saW5lKGNvcm5lcngsIC1oZWlnaHQpLlxyXG4gICAgICAgICAgICAgICAgICAgIGxpbmUodG8sIHJpZ2h0Qm94LnkgKyAobGVmdFRvUmlnaHQgJiYgIWFyYy5lcXVpdiA/IENvbmZpZ3VyYXRpb24udmlzdWFsLm1hcmdpbi55IDogcmlnaHRCb3guaGVpZ2h0IC8gMikpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBwYXRoLmxpbmUodG8sIC1oZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN2Zy5wYXRoKGFyY0dyb3VwLCBwYXRoLCB7XHJcbiAgICAgICAgICAgICAgICBtYXJrZXJFbmQ6IGFycm93RGVjbCxcclxuICAgICAgICAgICAgICAgIG1hcmtlclN0YXJ0OiBsYWJlbEFycm93RGVjbCxcclxuICAgICAgICAgICAgICAgIHN0eWxlOiAnc3Ryb2tlOiAnICsgY29sb3IsXHJcbiAgICAgICAgICAgICAgICAnc3Ryb2tlRGFzaEFycmF5JzogZGFzaEFycmF5LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKGFyYy5tYXJrZWQpIHtcclxuICAgICAgICAgICAgICBzdmcucGF0aChzaGFkb3dHcm91cCwgcGF0aCwge1xyXG4gICAgICAgICAgICAgICAgICAnY2xhc3MnOiAnc2hhZG93X0VkaXRIaWdobGlnaHRfYXJjJyxcclxuICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IG1hcmtlZEFyY1N0cm9rZSxcclxuICAgICAgICAgICAgICAgICAgJ3N0cm9rZURhc2hBcnJheSc6IGRhc2hBcnJheSxcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc2hhZG93R3JvdXApIHtcclxuICAgICAgICAgICAgICBzdmcucGF0aChzaGFkb3dHcm91cCwgcGF0aCwge1xyXG4gICAgICAgICAgICAgICAgICAnY2xhc3MnOiAnc2hhZG93XycgKyBhcmMuc2hhZG93Q2xhc3MsXHJcbiAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBzaGFkb3dTdHJva2UsXHJcbiAgICAgICAgICAgICAgICAgICdzdHJva2VEYXNoQXJyYXknOiBkYXNoQXJyYXksXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gLy8gYXJjIHJvd3NcclxuICAgICAgICB9KTsgLy8gYXJjc1xyXG5cclxuVXRpbC5wcm9maWxlRW5kKCdhcmNzJyk7XHJcblV0aWwucHJvZmlsZVN0YXJ0KCdmcmFnbWVudENvbm5lY3RvcnMnKTtcclxuXHJcbiAgICAgICAgJC5lYWNoKGRhdGEuc3BhbnMsIGZ1bmN0aW9uKHNwYW5Obywgc3Bhbikge1xyXG4gICAgICAgICAgdmFyIG51bUNvbm5lY3RvcnMgPSBzcGFuLmZyYWdtZW50cy5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgZm9yICh2YXIgY29ubmVjdG9yTm8gPSAwOyBjb25uZWN0b3JObyA8IG51bUNvbm5lY3RvcnM7IGNvbm5lY3Rvck5vKyspIHtcclxuICAgICAgICAgICAgdmFyIGxlZnQgPSBzcGFuLmZyYWdtZW50c1tjb25uZWN0b3JOb107XHJcbiAgICAgICAgICAgIHZhciByaWdodCA9IHNwYW4uZnJhZ21lbnRzW2Nvbm5lY3Rvck5vICsgMV07XHJcblxyXG4gICAgICAgICAgICB2YXIgbGVmdEJveCA9IHJvd0JCb3gobGVmdCk7XHJcbiAgICAgICAgICAgIHZhciByaWdodEJveCA9IHJvd0JCb3gocmlnaHQpO1xyXG4gICAgICAgICAgICB2YXIgbGVmdFJvdyA9IGxlZnQuY2h1bmsucm93LmluZGV4O1xyXG4gICAgICAgICAgICB2YXIgcmlnaHRSb3cgPSByaWdodC5jaHVuay5yb3cuaW5kZXg7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciByb3dJbmRleCA9IGxlZnRSb3c7IHJvd0luZGV4IDw9IHJpZ2h0Um93OyByb3dJbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgdmFyIHJvdyA9IHJvd3Nbcm93SW5kZXhdO1xyXG4gICAgICAgICAgICAgIHJvdy5oYXNBbm5vdGF0aW9ucyA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgIGlmIChyb3dJbmRleCA9PSBsZWZ0Um93KSB7XHJcbiAgICAgICAgICAgICAgICBmcm9tID0gbGVmdEJveC54ICsgbGVmdEJveC53aWR0aDtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZnJvbSA9IHNlbnROdW1NYXJnaW47XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBpZiAocm93SW5kZXggPT0gcmlnaHRSb3cpIHtcclxuICAgICAgICAgICAgICAgIHRvID0gcmlnaHRCb3gueDtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdG8gPSBjYW52YXNXaWR0aCAtIDIgKiBDb25maWd1cmF0aW9uLnZpc3VhbC5tYXJnaW4ueTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBsZWZ0Qm94LnkgKyBsZWZ0Qm94LmhlaWdodCAtIENvbmZpZ3VyYXRpb24udmlzdWFsLm1hcmdpbi55O1xyXG4gICAgICAgICAgICAgIGlmIChyb3VuZENvb3JkaW5hdGVzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBhc2tcclxuICAgICAgICAgICAgICAgIGhlaWdodCA9IChoZWlnaHR8MCkrMC41O1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgdmFyIHBhdGggPSBzdmcuY3JlYXRlUGF0aCgpLm1vdmUoZnJvbSwgaGVpZ2h0KS5saW5lKHRvLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICAgIHN2Zy5wYXRoKHJvdy5hcmNzLCBwYXRoLCB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZTogJ3N0cm9rZTogJyArIGZyYWdtZW50Q29ubmVjdG9yQ29sb3IsXHJcbiAgICAgICAgICAgICAgICAnc3Ryb2tlRGFzaEFycmF5JzogZnJhZ21lbnRDb25uZWN0b3JEYXNoQXJyYXlcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSAvLyByb3dJbmRleFxyXG4gICAgICAgICAgfSAvLyBjb25uZWN0b3JOb1xyXG4gICAgICAgIH0pOyAvLyBzcGFuc1xyXG5cclxuVXRpbC5wcm9maWxlRW5kKCdmcmFnbWVudENvbm5lY3RvcnMnKTtcclxuVXRpbC5wcm9maWxlU3RhcnQoJ3Jvd3MnKTtcclxuXHJcbiAgICAgICAgLy8gcG9zaXRpb24gdGhlIHJvd3NcclxuICAgICAgICB2YXIgeSA9IENvbmZpZ3VyYXRpb24udmlzdWFsLm1hcmdpbi55O1xyXG4gICAgICAgIHZhciBzZW50TnVtR3JvdXAgPSBzdmcuZ3JvdXAoeydjbGFzcyc6ICdzZW50bnVtJ30pO1xyXG4gICAgICAgIHZhciBjdXJyZW50U2VudDtcclxuICAgICAgICAkLmVhY2gocm93cywgZnVuY3Rpb24ocm93SWQsIHJvdykge1xyXG4gICAgICAgICAgJC5lYWNoKHJvdy5jaHVua3MsIGZ1bmN0aW9uKGNodW5rSWQsIGNodW5rKSB7XHJcbiAgICAgICAgICAgICQuZWFjaChjaHVuay5mcmFnbWVudHMsIGZ1bmN0aW9uKGZyYWdtZW50SWQsIGZyYWdtZW50KSB7XHJcbiAgICAgICAgICAgICAgaWYgKHJvdy5tYXhTcGFuSGVpZ2h0IDwgZnJhZ21lbnQuaGVpZ2h0KSByb3cubWF4U3BhbkhlaWdodCA9IGZyYWdtZW50LmhlaWdodDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIGlmIChyb3cuc2VudGVuY2UpIHtcclxuICAgICAgICAgICAgY3VycmVudFNlbnQgPSByb3cuc2VudGVuY2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBTTE9XICgjNzI0KSBhbmQgcmVwbGFjZWQgd2l0aCBjYWxjdWxhdGlvbnM6XHJcbiAgICAgICAgICAvL1xyXG4gICAgICAgICAgLy8gdmFyIHJvd0JveCA9IHJvdy5ncm91cC5nZXRCQm94KCk7XHJcbiAgICAgICAgICAvLyAvLyBNYWtlIGl0IHdvcmsgb24gSUVcclxuICAgICAgICAgIC8vIHJvd0JveCA9IHsgeDogcm93Qm94LngsIHk6IHJvd0JveC55LCBoZWlnaHQ6IHJvd0JveC5oZWlnaHQsIHdpZHRoOiByb3dCb3gud2lkdGggfTtcclxuICAgICAgICAgIC8vIC8vIE1ha2UgaXQgd29yayBvbiBGaXJlZm94IGFuZCBPcGVyYVxyXG4gICAgICAgICAgLy8gaWYgKHJvd0JveC5oZWlnaHQgPT0gLUluZmluaXR5KSB7XHJcbiAgICAgICAgICAvLyAgIHJvd0JveCA9IHsgeDogMCwgeTogMCwgaGVpZ2h0OiAwLCB3aWR0aDogMCB9O1xyXG4gICAgICAgICAgLy8gfVxyXG5cclxuICAgICAgICAgIC8vIFhYWCBUT0RPIEhBQ0s6IGZpbmQgb3V0IHdoZXJlIDUgYW5kIDEuNSBjb21lIGZyb20hXHJcbiAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBmaXggZm9yICM3MjQsIGJ1dCB0aGUgbnVtYmVycyBhcmUgZ3Vlc3NlZC5cclxuICAgICAgICAgIHZhciByb3dCb3hIZWlnaHQgPSBNYXRoLm1heChyb3cubWF4QXJjSGVpZ2h0ICsgNSwgcm93Lm1heFNwYW5IZWlnaHQgKyAxLjUpOyAvLyBYWFggVE9ETyBIQUNLOiB3aHkgNSwgMS41P1xyXG4gICAgICAgICAgaWYgKHJvdy5oYXNBbm5vdGF0aW9ucykge1xyXG4gICAgICAgICAgICAvLyByb3dCb3guaGVpZ2h0ID0gLXJvd0JveC55ICsgcm93U3BhY2luZztcclxuICAgICAgICAgICAgcm93Qm94SGVpZ2h0ICs9IHJvd1NwYWNpbmcgKyAxLjU7IC8vIFhYWCBUT0RPIEhBQ0s6IHdoeSAxLjU/XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByb3dCb3hIZWlnaHQgLT0gNTsgLy8gWFhYIFRPRE8gSEFDSzogd2h5IC01P1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJvd0JveEhlaWdodCArPSByb3dQYWRkaW5nO1xyXG4gICAgICAgICAgdmFyIGJnQ2xhc3M7XHJcbiAgICAgICAgICBpZiAoZGF0YS5tYXJrZWRTZW50W2N1cnJlbnRTZW50XSkge1xyXG4gICAgICAgICAgICAvLyBzcGVjaWZpY2FsbHkgaGlnaGxpZ2h0ZWRcclxuICAgICAgICAgICAgYmdDbGFzcyA9ICdiYWNrZ3JvdW5kSGlnaGxpZ2h0JztcclxuICAgICAgICAgIH0gZWxzZSBpZiAoQ29uZmlndXJhdGlvbi50ZXh0QmFja2dyb3VuZHMgPT0gXCJzdHJpcGVkXCIpIHtcclxuICAgICAgICAgICAgLy8gZ2l2ZSBldmVyeSBvdGhlciBzZW50ZW5jZSBhIGRpZmZlcmVudCBiZyBjbGFzc1xyXG4gICAgICAgICAgICBiZ0NsYXNzID0gJ2JhY2tncm91bmQnKyByb3cuYmFja2dyb3VuZEluZGV4O1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gcGxhaW4gXCJzdGFuZGFyZFwiIGJnXHJcbiAgICAgICAgICAgIGJnQ2xhc3MgPSAnYmFja2dyb3VuZDAnO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgc3ZnLnJlY3QoYmFja2dyb3VuZEdyb3VwLFxyXG4gICAgICAgICAgICAwLCB5ICsgc2l6ZXMudGV4dHMueSArIHNpemVzLnRleHRzLmhlaWdodCxcclxuICAgICAgICAgICAgY2FudmFzV2lkdGgsIHJvd0JveEhlaWdodCArIHNpemVzLnRleHRzLmhlaWdodCArIDEsIHtcclxuICAgICAgICAgICAgJ2NsYXNzJzogYmdDbGFzcyxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgeSArPSByb3dCb3hIZWlnaHQ7XHJcbiAgICAgICAgICB5ICs9IHNpemVzLnRleHRzLmhlaWdodDtcclxuICAgICAgICAgIHJvdy50ZXh0WSA9IHkgLSByb3dQYWRkaW5nO1xyXG4gICAgICAgICAgaWYgKHJvdy5zZW50ZW5jZSkge1xyXG4gICAgICAgICAgICB2YXIgc2VudGVuY2VfaGFzaCA9IG5ldyBVUkxIYXNoKGNvbGwsIGRvYywgeyBmb2N1czogW1sgJ3NlbnQnLCByb3cuc2VudGVuY2UgXV0gfSApO1xyXG4gICAgICAgICAgICB2YXIgbGluayA9IHN2Zy5saW5rKHNlbnROdW1Hcm91cCwgc2VudGVuY2VfaGFzaC5nZXRIYXNoKCkpO1xyXG4gICAgICAgICAgICB2YXIgdGV4dCA9IHN2Zy50ZXh0KGxpbmssIHNlbnROdW1NYXJnaW4gLSBDb25maWd1cmF0aW9uLnZpc3VhbC5tYXJnaW4ueCwgeSAtIHJvd1BhZGRpbmcsXHJcbiAgICAgICAgICAgICAgICAnJyArIHJvdy5zZW50ZW5jZSwgeyAnZGF0YS1zZW50Jzogcm93LnNlbnRlbmNlIH0pO1xyXG4gICAgICAgICAgICB2YXIgc2VudENvbW1lbnQgPSBkYXRhLnNlbnRDb21tZW50W3Jvdy5zZW50ZW5jZV07XHJcbiAgICAgICAgICAgIGlmIChzZW50Q29tbWVudCkge1xyXG4gICAgICAgICAgICAgIHZhciBib3ggPSB0ZXh0LmdldEJCb3goKTtcclxuICAgICAgICAgICAgICBzdmcucmVtb3ZlKHRleHQpO1xyXG4gICAgICAgICAgICAgIC8vIFRPRE86IHVzaW5nIHJlY3RTaGFkb3dTaXplLCBidXQgdGhpcyBzaGFkb3cgc2hvdWxkXHJcbiAgICAgICAgICAgICAgLy8gcHJvYmFibHkgaGF2ZSBpdHMgb3duIHNldHRpbmcgZm9yIHNoYWRvdyBzaXplXHJcbiAgICAgICAgICAgICAgc2hhZG93UmVjdCA9IHN2Zy5yZWN0KHNlbnROdW1Hcm91cCxcclxuICAgICAgICAgICAgICAgICAgYm94LnggLSByZWN0U2hhZG93U2l6ZSwgYm94LnkgLSByZWN0U2hhZG93U2l6ZSxcclxuICAgICAgICAgICAgICAgICAgYm94LndpZHRoICsgMiAqIHJlY3RTaGFkb3dTaXplLCBib3guaGVpZ2h0ICsgMiAqIHJlY3RTaGFkb3dTaXplLCB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAnY2xhc3MnOiAnc2hhZG93XycgKyBzZW50Q29tbWVudC50eXBlLFxyXG4gICAgICAgICAgICAgICAgICBmaWx0ZXI6ICd1cmwoI0dhdXNzaWFuX0JsdXIpJyxcclxuICAgICAgICAgICAgICAgICAgcng6IHJlY3RTaGFkb3dSb3VuZGluZyxcclxuICAgICAgICAgICAgICAgICAgcnk6IHJlY3RTaGFkb3dSb3VuZGluZyxcclxuICAgICAgICAgICAgICAgICAgJ2RhdGEtc2VudCc6IHJvdy5zZW50ZW5jZSxcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICB2YXIgdGV4dCA9IHN2Zy50ZXh0KHNlbnROdW1Hcm91cCwgc2VudE51bU1hcmdpbiAtIENvbmZpZ3VyYXRpb24udmlzdWFsLm1hcmdpbi54LCB5IC0gcm93UGFkZGluZyxcclxuICAgICAgICAgICAgICAgICAgJycgKyByb3cuc2VudGVuY2UsIHsgJ2RhdGEtc2VudCc6IHJvdy5zZW50ZW5jZSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHZhciByb3dZID0geSAtIHJvd1BhZGRpbmc7XHJcbiAgICAgICAgICBpZiAocm91bmRDb29yZGluYXRlcykge1xyXG4gICAgICAgICAgICByb3dZID0gcm93WXwwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdHJhbnNsYXRlKHJvdywgMCwgcm93WSk7XHJcbiAgICAgICAgICB5ICs9IENvbmZpZ3VyYXRpb24udmlzdWFsLm1hcmdpbi55O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHkgKz0gQ29uZmlndXJhdGlvbi52aXN1YWwubWFyZ2luLnk7XHJcblxyXG5VdGlsLnByb2ZpbGVFbmQoJ3Jvd3MnKTtcclxuVXRpbC5wcm9maWxlU3RhcnQoJ2NodW5rRmluaXNoJyk7XHJcblxyXG4gICAgICAgIC8vIGNodW5rIGluZGV4IHNvcnQgZnVuY3Rpb25zIGZvciBvdmVybGFwcGluZyBmcmFnbWVudCBkcmF3aW5nXHJcbiAgICAgICAgLy8gYWxnb3JpdGhtOyBmaXJzdCBmb3IgbGVmdC10by1yaWdodCBwYXNzLCBzb3J0aW5nIHByaW1hcmlseVxyXG4gICAgICAgIC8vIGJ5IHN0YXJ0IG9mZnNldCwgc2Vjb25kIGZvciByaWdodC10by1sZWZ0IHBhc3MgYnkgZW5kXHJcbiAgICAgICAgLy8gb2Zmc2V0LiBTZWNvbmRhcnkgc29ydCBieSBmcmFnbWVudCBsZW5ndGggaW4gYm90aCBjYXNlcy5cclxuICAgICAgICB2YXIgY3VycmVudENodW5rO1xyXG4gICAgICAgIHZhciBsckNodW5rQ29tcCA9IGZ1bmN0aW9uKGEsYikge1xyXG4gICAgICAgICAgdmFyIGFjID0gY3VycmVudENodW5rLmZyYWdtZW50c1thXTtcclxuICAgICAgICAgIHZhciBiYyA9IGN1cnJlbnRDaHVuay5mcmFnbWVudHNbYl1cclxuICAgICAgICAgIHZhciBzdGFydERpZmYgPSBVdGlsLmNtcChhYy5mcm9tLCBiYy5mcm9tKTtcclxuICAgICAgICAgIHJldHVybiBzdGFydERpZmYgIT0gMCA/IHN0YXJ0RGlmZiA6IFV0aWwuY21wKGJjLnRvLWJjLmZyb20sIGFjLnRvLWFjLmZyb20pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmxDaHVua0NvbXAgPSBmdW5jdGlvbihhLGIpIHtcclxuICAgICAgICAgIHZhciBhYyA9IGN1cnJlbnRDaHVuay5mcmFnbWVudHNbYV07XHJcbiAgICAgICAgICB2YXIgYmMgPSBjdXJyZW50Q2h1bmsuZnJhZ21lbnRzW2JdXHJcbiAgICAgICAgICB2YXIgZW5kRGlmZiA9IFV0aWwuY21wKGJjLnRvLCBhYy50byk7XHJcbiAgICAgICAgICByZXR1cm4gZW5kRGlmZiAhPSAwID8gZW5kRGlmZiA6IFV0aWwuY21wKGJjLnRvLWJjLmZyb20sIGFjLnRvLWFjLmZyb20pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHNlbnRlbmNlVGV4dCA9IG51bGw7XHJcbiAgICAgICAgJC5lYWNoKGRhdGEuY2h1bmtzLCBmdW5jdGlvbihjaHVua05vLCBjaHVuaykge1xyXG4gICAgICAgICAgLy8gY29udGV4dCBmb3Igc29ydFxyXG4gICAgICAgICAgY3VycmVudENodW5rID0gY2h1bms7XHJcblxyXG4gICAgICAgICAgLy8gdGV4dCByZW5kZXJpbmdcclxuICAgICAgICAgIGlmIChjaHVuay5zZW50ZW5jZSkge1xyXG4gICAgICAgICAgICBpZiAoc2VudGVuY2VUZXh0KSB7XHJcbiAgICAgICAgICAgICAgLy8gc3ZnLnRleHQodGV4dEdyb3VwLCBzZW50ZW5jZVRleHQpOyAvLyBhdm9pZHMgalF1ZXJ5U1ZHIGJ1Z1xyXG4gICAgICAgICAgICAgIHN2Zy50ZXh0KHRleHRHcm91cCwgMCwgMCwgc2VudGVuY2VUZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZW50ZW5jZVRleHQgPSBudWxsO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCFzZW50ZW5jZVRleHQpIHtcclxuICAgICAgICAgICAgc2VudGVuY2VUZXh0ID0gc3ZnLmNyZWF0ZVRleHQoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHZhciBuZXh0Q2h1bmsgPSBkYXRhLmNodW5rc1tjaHVua05vICsgMV07XHJcbiAgICAgICAgICB2YXIgbmV4dFNwYWNlID0gbmV4dENodW5rID8gbmV4dENodW5rLnNwYWNlIDogJyc7XHJcbiAgICAgICAgICBzZW50ZW5jZVRleHQuc3BhbigvKmNodW5rLnNwYWNlICsqLyBjaHVuay50ZXh0ICsgbmV4dFNwYWNlLCB7XHJcbiAgICAgICAgICAgIHg6IGNodW5rLnRleHRYLFxyXG4gICAgICAgICAgICB5OiBjaHVuay5yb3cudGV4dFksXHJcbiAgICAgICAgICAgICdkYXRhLWNodW5rLWlkJzogY2h1bmsuaW5kZXhcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIC8vIGNodW5rIGJhY2tncm91bmRzXHJcbiAgICAgICAgICBpZiAoY2h1bmsuZnJhZ21lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB2YXIgb3JkZXJlZElkeCA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpPWNodW5rLmZyYWdtZW50cy5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgb3JkZXJlZElkeC5wdXNoKGkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBNYXJrIGVudGl0eSBuZXN0aW5nIGhlaWdodC9kZXB0aCAobnVtYmVyIG9mXHJcbiAgICAgICAgICAgIC8vIG5lc3RlZC9uZXN0aW5nIGVudGl0aWVzKS4gVG8gYWNjb3VudCBmb3IgY3Jvc3NpbmdcclxuICAgICAgICAgICAgLy8gYnJhY2tldHMgaW4gYSAobW9zdGx5KSByZWFzb25hYmxlIHdheSwgZGV0ZXJtaW5lXHJcbiAgICAgICAgICAgIC8vIGRlcHRoL2hlaWdodCBzZXBhcmF0ZWx5IGluIGEgbGVmdC10by1yaWdodCB0cmF2ZXJzYWxcclxuICAgICAgICAgICAgLy8gYW5kIGEgcmlnaHQtdG8tbGVmdCB0cmF2ZXJzYWwuXHJcbiAgICAgICAgICAgIG9yZGVyZWRJZHguc29ydChsckNodW5rQ29tcCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgb3BlbkZyYWdtZW50cyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaTxvcmRlcmVkSWR4Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBjaHVuay5mcmFnbWVudHNbb3JkZXJlZElkeFtpXV07XHJcbiAgICAgICAgICAgICAgY3VycmVudC5uZXN0aW5nSGVpZ2h0TFIgPSAwO1xyXG4gICAgICAgICAgICAgIGN1cnJlbnQubmVzdGluZ0RlcHRoTFIgPSAwO1xyXG4gICAgICAgICAgICAgIHZhciBzdGlsbE9wZW4gPSBbXTtcclxuICAgICAgICAgICAgICBmb3IodmFyIG89MDsgbzxvcGVuRnJhZ21lbnRzLmxlbmd0aDsgbysrKSB7XHJcbiAgICAgICAgICAgICAgICBpZihvcGVuRnJhZ21lbnRzW29dLnRvID4gY3VycmVudC5mcm9tKSB7XHJcbiAgICAgICAgICAgICAgICAgIHN0aWxsT3Blbi5wdXNoKG9wZW5GcmFnbWVudHNbb10pO1xyXG4gICAgICAgICAgICAgICAgICBvcGVuRnJhZ21lbnRzW29dLm5lc3RpbmdIZWlnaHRMUisrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBvcGVuRnJhZ21lbnRzID0gc3RpbGxPcGVuO1xyXG4gICAgICAgICAgICAgIGN1cnJlbnQubmVzdGluZ0RlcHRoTFI9b3BlbkZyYWdtZW50cy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgb3BlbkZyYWdtZW50cy5wdXNoKGN1cnJlbnQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyByZS1zb3J0IGZvciByaWdodC10by1sZWZ0IHRyYXZlcnNhbCBieSBlbmQgcG9zaXRpb25cclxuICAgICAgICAgICAgb3JkZXJlZElkeC5zb3J0KHJsQ2h1bmtDb21wKTtcclxuXHJcbiAgICAgICAgICAgIG9wZW5GcmFnbWVudHMgPSBbXTtcclxuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGk8b3JkZXJlZElkeC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gY2h1bmsuZnJhZ21lbnRzW29yZGVyZWRJZHhbaV1dO1xyXG4gICAgICAgICAgICAgIGN1cnJlbnQubmVzdGluZ0hlaWdodFJMID0gMDtcclxuICAgICAgICAgICAgICBjdXJyZW50Lm5lc3RpbmdEZXB0aFJMID0gMDtcclxuICAgICAgICAgICAgICB2YXIgc3RpbGxPcGVuID0gW107XHJcbiAgICAgICAgICAgICAgZm9yKHZhciBvPTA7IG88b3BlbkZyYWdtZW50cy5sZW5ndGg7IG8rKykge1xyXG4gICAgICAgICAgICAgICAgaWYob3BlbkZyYWdtZW50c1tvXS5mcm9tIDwgY3VycmVudC50bykge1xyXG4gICAgICAgICAgICAgICAgICBzdGlsbE9wZW4ucHVzaChvcGVuRnJhZ21lbnRzW29dKTtcclxuICAgICAgICAgICAgICAgICAgb3BlbkZyYWdtZW50c1tvXS5uZXN0aW5nSGVpZ2h0UkwrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgb3BlbkZyYWdtZW50cyA9IHN0aWxsT3BlbjtcclxuICAgICAgICAgICAgICBjdXJyZW50Lm5lc3RpbmdEZXB0aFJMPW9wZW5GcmFnbWVudHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgIG9wZW5GcmFnbWVudHMucHVzaChjdXJyZW50KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gdGhlIGVmZmVjdGl2ZSBkZXB0aCBhbmQgaGVpZ2h0IGFyZSB0aGUgbWF4IG9mIHRob3NlXHJcbiAgICAgICAgICAgIC8vIGZvciB0aGUgbGVmdC10by1yaWdodCBhbmQgcmlnaHQtdG8tbGVmdCB0cmF2ZXJzYWxzLlxyXG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaTxvcmRlcmVkSWR4Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGMgPSBjaHVuay5mcmFnbWVudHNbb3JkZXJlZElkeFtpXV07XHJcbiAgICAgICAgICAgICAgYy5uZXN0aW5nSGVpZ2h0ID0gYy5uZXN0aW5nSGVpZ2h0TFIgPiBjLm5lc3RpbmdIZWlnaHRSTCA/IGMubmVzdGluZ0hlaWdodExSIDogYy5uZXN0aW5nSGVpZ2h0Ukw7XHJcbiAgICAgICAgICAgICAgYy5uZXN0aW5nRGVwdGggPSBjLm5lc3RpbmdEZXB0aExSID4gYy5uZXN0aW5nRGVwdGhSTCA/IGMubmVzdGluZ0RlcHRoTFIgOiBjLm5lc3RpbmdEZXB0aFJMO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBSZS1vcmRlciBieSBuZXN0aW5nIGhlaWdodCBhbmQgZHJhdyBpbiBvcmRlclxyXG4gICAgICAgICAgICBvcmRlcmVkSWR4LnNvcnQoZnVuY3Rpb24oYSxiKSB7IHJldHVybiBVdGlsLmNtcChjaHVuay5mcmFnbWVudHNbYl0ubmVzdGluZ0hlaWdodCwgY2h1bmsuZnJhZ21lbnRzW2FdLm5lc3RpbmdIZWlnaHQpIH0pO1xyXG5cclxuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGk8Y2h1bmsuZnJhZ21lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGZyYWdtZW50PWNodW5rLmZyYWdtZW50c1tvcmRlcmVkSWR4W2ldXTtcclxuICAgICAgICAgICAgICB2YXIgc3BhbkRlc2MgPSBzcGFuVHlwZXNbZnJhZ21lbnQuc3Bhbi50eXBlXTtcclxuICAgICAgICAgICAgICB2YXIgYmdDb2xvciA9ICgoc3BhbkRlc2MgJiYgc3BhbkRlc2MuYmdDb2xvcikgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc3BhblR5cGVzLlNQQU5fREVGQVVMVCAmJiBzcGFuVHlwZXMuU1BBTl9ERUZBVUxULmJnQ29sb3IpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyNmZmZmZmYnKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gVHdlYWsgZm9yIG5lc3RpbmcgZGVwdGgvaGVpZ2h0LiBSZWNvZ25pemUganVzdCB0aHJlZVxyXG4gICAgICAgICAgICAgIC8vIGxldmVscyBmb3Igbm93OiBub3JtYWwsIG5lc3RlZCwgYW5kIG5lc3RpbmcsIHdoZXJlXHJcbiAgICAgICAgICAgICAgLy8gbmVzdGVkK25lc3RpbmcgeWllbGRzIG5vcm1hbC4gKEN1cnJlbnRseSB0ZXN0aW5nXHJcbiAgICAgICAgICAgICAgLy8gbWlub3IgdHdlYWs6IGRvbid0IHNocmluayBmb3IgZGVwdGggMSBhcyB0aGUgbmVzdGluZ1xyXG4gICAgICAgICAgICAgIC8vIGhpZ2hsaWdodCB3aWxsIGdyb3cgYW55d2F5IFtjaGVjayBuZXN0aW5nRGVwdGggPiAxXSlcclxuICAgICAgICAgICAgICB2YXIgc2hyaW5rID0gMDtcclxuICAgICAgICAgICAgICBpZihmcmFnbWVudC5uZXN0aW5nRGVwdGggPiAxICYmIGZyYWdtZW50Lm5lc3RpbmdIZWlnaHQgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICBzaHJpbmsgPSAxO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSBpZihmcmFnbWVudC5uZXN0aW5nRGVwdGggPT0gMCAmJiBmcmFnbWVudC5uZXN0aW5nSGVpZ2h0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICBzaHJpbmsgPSAtMTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgdmFyIHlTaHJpbmsgPSBzaHJpbmsgKiBuZXN0aW5nQWRqdXN0WVN0ZXBTaXplO1xyXG4gICAgICAgICAgICAgIHZhciB4U2hyaW5rID0gc2hyaW5rICogbmVzdGluZ0FkanVzdFhTdGVwU2l6ZTtcclxuICAgICAgICAgICAgICAvLyBiaXQgbGlnaHRlclxyXG4gICAgICAgICAgICAgIHZhciBsaWdodEJnQ29sb3IgPSBVdGlsLmFkanVzdENvbG9yTGlnaHRuZXNzKGJnQ29sb3IsIDAuOCk7XHJcbiAgICAgICAgICAgICAgLy8gdHdlYWsgZm9yIFkgc3RhcnQgb2Zmc2V0IChhbmQgY29ycmVzcG9uZGluZyBoZWlnaHRcclxuICAgICAgICAgICAgICAvLyByZWR1Y3Rpb24pOiB0ZXh0IHJhcmVseSBoaXRzIGZvbnQgbWF4IGhlaWdodCwgc28gdGhpc1xyXG4gICAgICAgICAgICAgIC8vIHRlbmRzIHRvIGxvb2sgYmV0dGVyXHJcbiAgICAgICAgICAgICAgdmFyIHlTdGFydFR3ZWFrID0gMTtcclxuICAgICAgICAgICAgICAvLyBzdG9yZSB0byBoYXZlIHNhbWUgbW91c2VvdmVyIGhpZ2hsaWdodCB3aXRob3V0IHJlY2FsY1xyXG4gICAgICAgICAgICAgIGZyYWdtZW50LmhpZ2hsaWdodFBvcyA9IHtcclxuICAgICAgICAgICAgICAgICAgeDogY2h1bmsudGV4dFggKyBmcmFnbWVudC5jdXJseS5mcm9tICsgeFNocmluayxcclxuICAgICAgICAgICAgICAgICAgeTogY2h1bmsucm93LnRleHRZICsgc2l6ZXMudGV4dHMueSArIHlTaHJpbmsgKyB5U3RhcnRUd2VhayxcclxuICAgICAgICAgICAgICAgICAgdzogZnJhZ21lbnQuY3VybHkudG8gLSBmcmFnbWVudC5jdXJseS5mcm9tIC0gMip4U2hyaW5rLFxyXG4gICAgICAgICAgICAgICAgICBoOiBzaXplcy50ZXh0cy5oZWlnaHQgLSAyKnlTaHJpbmsgLSB5U3RhcnRUd2VhayxcclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgIHN2Zy5yZWN0KGhpZ2hsaWdodEdyb3VwLFxyXG4gICAgICAgICAgICAgICAgICBmcmFnbWVudC5oaWdobGlnaHRQb3MueCwgZnJhZ21lbnQuaGlnaGxpZ2h0UG9zLnksXHJcbiAgICAgICAgICAgICAgICAgIGZyYWdtZW50LmhpZ2hsaWdodFBvcy53LCBmcmFnbWVudC5oaWdobGlnaHRQb3MuaCxcclxuICAgICAgICAgICAgICAgICAgeyBmaWxsOiBsaWdodEJnQ29sb3IsIC8vb3BhY2l0eToxLFxyXG4gICAgICAgICAgICAgICAgICAgIHJ4OiBoaWdobGlnaHRSb3VuZGluZy54LFxyXG4gICAgICAgICAgICAgICAgICAgIHJ5OiBoaWdobGlnaHRSb3VuZGluZy55LFxyXG4gICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChzZW50ZW5jZVRleHQpIHtcclxuICAgICAgICAgIC8vIHN2Zy50ZXh0KHRleHRHcm91cCwgc2VudGVuY2VUZXh0KTsgLy8gYXZvaWRzIGpRdWVyeVNWRyBidWdcclxuICAgICAgICAgIHN2Zy50ZXh0KHRleHRHcm91cCwgMCwgMCwgc2VudGVuY2VUZXh0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGRyYXcgdGhlIG1hcmtlZFRleHRcclxuICAgICAgICAkLmVhY2godGV4dE1hcmtlZFJvd3MsIGZ1bmN0aW9uKHRleHRSb3dObywgdGV4dFJvd0Rlc2MpIHsgLy8gcm93LCBmcm9tLCB0b1xyXG4gICAgICAgICAgdmFyIHRleHRIaWdobGlnaHQgPSBzdmcucmVjdChoaWdobGlnaHRHcm91cCxcclxuICAgICAgICAgICAgICB0ZXh0Um93RGVzY1sxXSAtIDIsIHRleHRSb3dEZXNjWzBdLnRleHRZIC0gc2l6ZXMuZnJhZ21lbnRzLmhlaWdodCxcclxuICAgICAgICAgICAgICB0ZXh0Um93RGVzY1syXSAtIHRleHRSb3dEZXNjWzFdICsgNCwgc2l6ZXMuZnJhZ21lbnRzLmhlaWdodCArIDQsXHJcbiAgICAgICAgICAgICAgeyBmaWxsOiAneWVsbG93JyB9IC8vIFRPRE86IHB1dCBpbnRvIGNzcyBmaWxlLCBhcyBkZWZhdWx0IC0gdHVybiBpbnRvIGNsYXNzXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgLy8gTk9URTogY2hhbmdpbmcgaGlnaGxpZ2h0VGV4dFNlcXVlbmNlIGhlcmUgd2lsbCBnaXZlXHJcbiAgICAgICAgICAvLyBkaWZmZXJlbnQtY29sb3JlZCBoaWdobGlnaHRzXHJcbiAgICAgICAgICAvLyBUT0RPOiBlbnRpcmVseSBkaWZmZXJlbnQgc2V0dGluZ3MgZm9yIG5vbi1hbmltYXRpb25zP1xyXG4gICAgICAgICAgdmFyIG1hcmtlZFR5cGUgPSB0ZXh0Um93RGVzY1szXTtcclxuICAgICAgICAgIHN2Zy5vdGhlcih0ZXh0SGlnaGxpZ2h0LCAnYW5pbWF0ZScsIHtcclxuICAgICAgICAgICAgJ2RhdGEtdHlwZSc6IG1hcmtlZFR5cGUsXHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWU6ICdmaWxsJyxcclxuICAgICAgICAgICAgdmFsdWVzOiAobWFya2VkVHlwZSA9PSAnbWF0Y2gnID8gaGlnaGxpZ2h0TWF0Y2hTZXF1ZW5jZVxyXG4gICAgICAgICAgICAgICAgICAgICA6IGhpZ2hsaWdodFRleHRTZXF1ZW5jZSksXHJcbiAgICAgICAgICAgIGR1cjogaGlnaGxpZ2h0RHVyYXRpb24sXHJcbiAgICAgICAgICAgIHJlcGVhdENvdW50OiAnaW5kZWZpbml0ZScsXHJcbiAgICAgICAgICAgIGJlZ2luOiAnaW5kZWZpbml0ZSdcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcblV0aWwucHJvZmlsZUVuZCgnY2h1bmtGaW5pc2gnKTtcclxuVXRpbC5wcm9maWxlU3RhcnQoJ2ZpbmlzaCcpO1xyXG5cclxuICAgICAgICBzdmcucGF0aChzZW50TnVtR3JvdXAsIHN2Zy5jcmVhdGVQYXRoKCkuXHJcbiAgICAgICAgICBtb3ZlKHNlbnROdW1NYXJnaW4sIDApLlxyXG4gICAgICAgICAgbGluZShzZW50TnVtTWFyZ2luLCB5KSk7XHJcblxyXG4gICAgICAgIC8vIHJlc2l6ZSB0aGUgU1ZHXHJcbiAgICAgICAgdmFyIHdpZHRoID0gbWF4VGV4dFdpZHRoICsgc2VudE51bU1hcmdpbiArIDIgKiBDb25maWd1cmF0aW9uLnZpc3VhbC5tYXJnaW4ueCArIDE7XHJcbiAgICAgICAgaWYgKHdpZHRoID4gY2FudmFzV2lkdGgpIGNhbnZhc1dpZHRoID0gd2lkdGg7XHJcblxyXG4gICAgICAgICRzdmcud2lkdGgoY2FudmFzV2lkdGgpO1xyXG4gICAgICAgICRzdmcuaGVpZ2h0KHkpO1xyXG4gICAgICAgICRzdmdEaXYuaGVpZ2h0KHkpO1xyXG5cclxuVXRpbC5wcm9maWxlRW5kKCdmaW5pc2gnKTtcclxuVXRpbC5wcm9maWxlRW5kKCdyZW5kZXInKTtcclxuVXRpbC5wcm9maWxlUmVwb3J0KCk7XHJcblxyXG5cclxuICAgICAgICBkcmF3aW5nID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHJlZHJhdykge1xyXG4gICAgICAgICAgcmVkcmF3ID0gZmFsc2U7XHJcbiAgICAgICAgICByZW5kZXJEYXRhUmVhbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAkc3ZnLmZpbmQoJ2FuaW1hdGUnKS5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgaWYgKHRoaXMuYmVnaW5FbGVtZW50KSB7IC8vIHByb3RlY3QgYWdhaW5zdCBub24tU01JTCBicm93c2Vyc1xyXG4gICAgICAgICAgICB0aGlzLmJlZ2luRWxlbWVudCgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGRpc3BhdGNoZXIucG9zdCgnZG9uZVJlbmRlcmluZycsIFtjb2xsLCBkb2MsIGFyZ3NdKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciByZW5kZXJFcnJvcnMgPSB7XHJcbiAgICAgICAgdW5hYmxlVG9SZWFkVGV4dEZpbGU6IHRydWUsXHJcbiAgICAgICAgYW5ub3RhdGlvbkZpbGVOb3RGb3VuZDogdHJ1ZSxcclxuICAgICAgICBpc0RpcmVjdG9yeUVycm9yOiB0cnVlXHJcbiAgICAgIH07XHJcbiAgICAgIHZhciByZW5kZXJEYXRhID0gZnVuY3Rpb24oc291cmNlRGF0YSkge1xyXG4gICAgICAgIFV0aWwucHJvZmlsZUVuZCgnaW52b2tlIGdldERvY3VtZW50Jyk7XHJcbiAgICAgICAgaWYgKHNvdXJjZURhdGEgJiYgc291cmNlRGF0YS5leGNlcHRpb24pIHtcclxuICAgICAgICAgIGlmIChyZW5kZXJFcnJvcnNbc291cmNlRGF0YS5leGNlcHRpb25dKSB7XHJcbiAgICAgICAgICAgIGRpc3BhdGNoZXIucG9zdCgncmVuZGVyRXJyb3I6JyArIHNvdXJjZURhdGEuZXhjZXB0aW9uLCBbc291cmNlRGF0YV0pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCd1bmtub3duRXJyb3InLCBbc291cmNlRGF0YS5leGNlcHRpb25dKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gRmlsbCBpbiBkZWZhdWx0IHZhbHVlcyB0aGF0IGRvbid0IG5lY2Vzc2FyaWx5IGdvIG92ZXIgdGhlIHByb3RvY29sXHJcbiAgICAgICAgICBpZiAoc291cmNlRGF0YSkge1xyXG4gICAgICAgICAgICBzZXRTb3VyY2VEYXRhRGVmYXVsdHMoc291cmNlRGF0YSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdzdGFydGVkUmVuZGVyaW5nJywgW2NvbGwsIGRvYywgYXJnc10pO1xyXG4gICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdzcGluJyk7XHJcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJEYXRhUmVhbChzb3VyY2VEYXRhKTtcclxuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgc3VyZSBub3QgdG8gYmUgZHJhd2luZyBhbnltb3JlLCByZXNldCB0aGUgc3RhdGVcclxuICAgICAgICAgICAgICAgIGRyYXdpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IEhvb2sgcHJpbnRvdXQgaW50byBkaXNwYXRjaCBlbHNld2hlcmU/XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1JlbmRlcmluZyB0ZXJtaW5hdGVkIGR1ZSB0bzonLCBlKTtcclxuICAgICAgICAgICAgICAgIGRpc3BhdGNoZXIucG9zdCgncmVuZGVyRXJyb3I6IEZhdGFsJywgW3NvdXJjZURhdGEsIGVdKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCd1bnNwaW4nKTtcclxuICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciByZW5kZXJEb2N1bWVudCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIFV0aWwucHJvZmlsZVN0YXJ0KCdpbnZva2UgZ2V0RG9jdW1lbnQnKTtcclxuICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ2FqYXgnLCBbe1xyXG4gICAgICAgICAgICBhY3Rpb246ICdnZXREb2N1bWVudCcsXHJcbiAgICAgICAgICAgIGNvbGxlY3Rpb246IGNvbGwsXHJcbiAgICAgICAgICAgICdkb2N1bWVudCc6IGRvYyxcclxuICAgICAgICAgIH0sICdyZW5kZXJEYXRhJywge1xyXG4gICAgICAgICAgICBjb2xsZWN0aW9uOiBjb2xsLFxyXG4gICAgICAgICAgICAnZG9jdW1lbnQnOiBkb2NcclxuICAgICAgICAgIH1dKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciB0cmlnZ2VyUmVuZGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHN2ZyAmJiAoKGlzUmVuZGVyUmVxdWVzdGVkICYmIGlzQ29sbGVjdGlvbkxvYWRlZCkgfHwgcmVxdWVzdGVkRGF0YSkgJiYgVmlzdWFsaXplci5hcmVGb250c0xvYWRlZCkge1xyXG4gICAgICAgICAgaXNSZW5kZXJSZXF1ZXN0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgIGlmIChyZXF1ZXN0ZWREYXRhKSB7XHJcblxyXG5VdGlsLnByb2ZpbGVDbGVhcigpO1xyXG5VdGlsLnByb2ZpbGVTdGFydCgnYmVmb3JlIHJlbmRlcicpO1xyXG5cclxuICAgICAgICAgICAgcmVuZGVyRGF0YShyZXF1ZXN0ZWREYXRhKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoZG9jLmxlbmd0aCkge1xyXG5cclxuVXRpbC5wcm9maWxlQ2xlYXIoKTtcclxuVXRpbC5wcm9maWxlU3RhcnQoJ2JlZm9yZSByZW5kZXInKTtcclxuXHJcbiAgICAgICAgICAgIHJlbmRlckRvY3VtZW50KCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoMCwgJ3JlbmRlckVycm9yOm5vRmlsZVNwZWNpZmllZCcpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciByZXF1ZXN0UmVuZGVyRGF0YSA9IGZ1bmN0aW9uKHNvdXJjZURhdGEpIHtcclxuICAgICAgICByZXF1ZXN0ZWREYXRhID0gc291cmNlRGF0YTtcclxuICAgICAgICB0cmlnZ2VyUmVuZGVyKCk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgY29sbGVjdGlvbkNoYW5nZWQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpc0NvbGxlY3Rpb25Mb2FkZWQgPSBmYWxzZTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciBnb3RDdXJyZW50ID0gZnVuY3Rpb24oX2NvbGwsIF9kb2MsIF9hcmdzLCByZWxvYWREYXRhKSB7XHJcbiAgICAgICAgY29sbCA9IF9jb2xsO1xyXG4gICAgICAgIGRvYyAgPSBfZG9jO1xyXG4gICAgICAgIGFyZ3MgPSBfYXJncztcclxuICAgICAgICBpZiAocmVsb2FkRGF0YSkge1xyXG4gICAgICAgICAgaXNSZW5kZXJSZXF1ZXN0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgdHJpZ2dlclJlbmRlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcblxyXG4gICAgICAvLyBldmVudCBoYW5kbGVyc1xyXG5cclxuICAgICAgdmFyIGhpZ2hsaWdodCwgaGlnaGxpZ2h0QXJjcywgaGlnaGxpZ2h0U3BhbnMsIGNvbW1lbnRJZDtcclxuXHJcbiAgICAgIHZhciBvbk1vdXNlT3ZlciA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgIHZhciB0YXJnZXQgPSAkKGV2dC50YXJnZXQpO1xyXG4gICAgICAgIHZhciBpZDtcclxuICAgICAgICBpZiAoaWQgPSB0YXJnZXQuYXR0cignZGF0YS1zcGFuLWlkJykpIHtcclxuICAgICAgICAgIGNvbW1lbnRJZCA9IGlkO1xyXG4gICAgICAgICAgdmFyIHNwYW4gPSBkYXRhLnNwYW5zW2lkXTtcclxuICAgICAgICAgIGRpc3BhdGNoZXIucG9zdCgnZGlzcGxheVNwYW5Db21tZW50JywgW1xyXG4gICAgICAgICAgICAgIGV2dCwgdGFyZ2V0LCBpZCwgc3Bhbi50eXBlLCBzcGFuLmF0dHJpYnV0ZVRleHQsXHJcbiAgICAgICAgICAgICAgc3Bhbi50ZXh0LFxyXG4gICAgICAgICAgICAgIHNwYW4uY29tbWVudCAmJiBzcGFuLmNvbW1lbnQudGV4dCxcclxuICAgICAgICAgICAgICBzcGFuLmNvbW1lbnQgJiYgc3Bhbi5jb21tZW50LnR5cGUsXHJcbiAgICAgICAgICAgICAgc3Bhbi5ub3JtYWxpemF0aW9uc10pO1xyXG5cclxuICAgICAgICAgIHZhciBzcGFuRGVzYyA9IHNwYW5UeXBlc1tzcGFuLnR5cGVdO1xyXG4gICAgICAgICAgdmFyIGJnQ29sb3IgPSAoKHNwYW5EZXNjICYmIHNwYW5EZXNjLmJnQ29sb3IpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAoc3BhblR5cGVzLlNQQU5fREVGQVVMVCAmJiBzcGFuVHlwZXMuU1BBTl9ERUZBVUxULmJnQ29sb3IpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAnI2ZmZmZmZicpO1xyXG4gICAgICAgICAgaGlnaGxpZ2h0ID0gW107XHJcbiAgICAgICAgICAkLmVhY2goc3Bhbi5mcmFnbWVudHMsIGZ1bmN0aW9uKGZyYWdtZW50Tm8sIGZyYWdtZW50KSB7XHJcbiAgICAgICAgICAgIGhpZ2hsaWdodC5wdXNoKHN2Zy5yZWN0KGhpZ2hsaWdodEdyb3VwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudC5oaWdobGlnaHRQb3MueCwgZnJhZ21lbnQuaGlnaGxpZ2h0UG9zLnksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50LmhpZ2hsaWdodFBvcy53LCBmcmFnbWVudC5oaWdobGlnaHRQb3MuaCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyAnZmlsbCc6IGJnQ29sb3IsIG9wYWNpdHk6MC43NSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByeDogaGlnaGxpZ2h0Um91bmRpbmcueCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByeTogaGlnaGxpZ2h0Um91bmRpbmcueSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgaWYgKHRoYXQuYXJjRHJhZ09yaWdpbikge1xyXG4gICAgICAgICAgICB0YXJnZXQucGFyZW50KCkuYWRkQ2xhc3MoJ2hpZ2hsaWdodCcpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaGlnaGxpZ2h0QXJjcyA9ICRzdmcuXHJcbiAgICAgICAgICAgICAgICBmaW5kKCdnW2RhdGEtZnJvbT1cIicgKyBpZCArICdcIl0sIGdbZGF0YS10bz1cIicgKyBpZCArICdcIl0nKS5cclxuICAgICAgICAgICAgICAgIGFkZENsYXNzKCdoaWdobGlnaHQnKTtcclxuICAgICAgICAgICAgdmFyIHNwYW5zID0ge307XHJcbiAgICAgICAgICAgIHNwYW5zW2lkXSA9IHRydWU7XHJcbiAgICAgICAgICAgIHZhciBzcGFuSWRzID0gW107XHJcbiAgICAgICAgICAgICQuZWFjaChzcGFuLmluY29taW5nLCBmdW5jdGlvbihhcmNObywgYXJjKSB7XHJcbiAgICAgICAgICAgICAgICBzcGFuc1thcmMub3JpZ2luXSA9IHRydWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAkLmVhY2goc3Bhbi5vdXRnb2luZywgZnVuY3Rpb24oYXJjTm8sIGFyYykge1xyXG4gICAgICAgICAgICAgICAgc3BhbnNbYXJjLnRhcmdldF0gPSB0cnVlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgJC5lYWNoKHNwYW5zLCBmdW5jdGlvbihzcGFuSWQsIGR1bW15KSB7XHJcbiAgICAgICAgICAgICAgICBzcGFuSWRzLnB1c2goJ3JlY3RbZGF0YS1zcGFuLWlkPVwiJyArIHNwYW5JZCArICdcIl0nKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGhpZ2hsaWdodFNwYW5zID0gJHN2Zy5cclxuICAgICAgICAgICAgICAgIGZpbmQoc3Bhbklkcy5qb2luKCcsICcpKS5cclxuICAgICAgICAgICAgICAgIHBhcmVudCgpLlxyXG4gICAgICAgICAgICAgICAgYWRkQ2xhc3MoJ2hpZ2hsaWdodCcpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZm9yY2VSZWRyYXcoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKCF0aGF0LmFyY0RyYWdPcmlnaW4gJiYgKGlkID0gdGFyZ2V0LmF0dHIoJ2RhdGEtYXJjLXJvbGUnKSkpIHtcclxuICAgICAgICAgIHZhciBvcmlnaW5TcGFuSWQgPSB0YXJnZXQuYXR0cignZGF0YS1hcmMtb3JpZ2luJyk7XHJcbiAgICAgICAgICB2YXIgdGFyZ2V0U3BhbklkID0gdGFyZ2V0LmF0dHIoJ2RhdGEtYXJjLXRhcmdldCcpO1xyXG4gICAgICAgICAgdmFyIHJvbGUgPSB0YXJnZXQuYXR0cignZGF0YS1hcmMtcm9sZScpO1xyXG4gICAgICAgICAgdmFyIHN5bW1ldHJpYyA9IChyZWxhdGlvblR5cGVzSGFzaCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZWxhdGlvblR5cGVzSGFzaFtyb2xlXSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZWxhdGlvblR5cGVzSGFzaFtyb2xlXS5wcm9wZXJ0aWVzICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aW9uVHlwZXNIYXNoW3JvbGVdLnByb3BlcnRpZXMuc3ltbWV0cmljKTtcclxuICAgICAgICAgIC8vIE5PVEU6IG5vIGNvbW1lbnRUZXh0LCBjb21tZW50VHlwZSBmb3Igbm93XHJcbiAgICAgICAgICB2YXIgYXJjRXZlbnREZXNjSWQgPSB0YXJnZXQuYXR0cignZGF0YS1hcmMtZWQnKTtcclxuICAgICAgICAgIHZhciBjb21tZW50VGV4dCA9ICcnO1xyXG4gICAgICAgICAgdmFyIGNvbW1lbnRUeXBlID0gJyc7XHJcbiAgICAgICAgICB2YXIgYXJjSWQ7XHJcbiAgICAgICAgICBpZiAoYXJjRXZlbnREZXNjSWQpIHtcclxuICAgICAgICAgICAgdmFyIGV2ZW50RGVzYyA9IGRhdGEuZXZlbnREZXNjc1thcmNFdmVudERlc2NJZF07XHJcbiAgICAgICAgICAgIHZhciBjb21tZW50ID0gZXZlbnREZXNjLmNvbW1lbnQ7XHJcbiAgICAgICAgICAgIGlmIChjb21tZW50KSB7XHJcbiAgICAgICAgICAgICAgY29tbWVudFRleHQgPSBjb21tZW50LnRleHQ7XHJcbiAgICAgICAgICAgICAgY29tbWVudFR5cGUgPSBjb21tZW50LnR5cGU7XHJcbiAgICAgICAgICAgICAgaWYgKGNvbW1lbnRUZXh0ID09ICcnICYmIGNvbW1lbnRUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gdHlwZSBpZiBtaXNzaW5nIHRleHRcclxuICAgICAgICAgICAgICAgICAgY29tbWVudFRleHQgPSBjb21tZW50VHlwZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGV2ZW50RGVzYy5yZWxhdGlvbikge1xyXG4gICAgICAgICAgICAgIC8vIGFtb25nIGFyY3MsIG9ubHkgb25lcyBjb3JyZXNwb25kaW5nIHRvIHJlbGF0aW9ucyBoYXZlXHJcbiAgICAgICAgICAgICAgLy8gXCJpbmRlcGVuZGVudFwiIElEc1xyXG4gICAgICAgICAgICAgIGFyY0lkID0gYXJjRXZlbnREZXNjSWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHZhciBvcmlnaW5TcGFuVHlwZSA9IGRhdGEuc3BhbnNbb3JpZ2luU3BhbklkXS50eXBlIHx8ICcnO1xyXG4gICAgICAgICAgdmFyIHRhcmdldFNwYW5UeXBlID0gZGF0YS5zcGFuc1t0YXJnZXRTcGFuSWRdLnR5cGUgfHwgJyc7XHJcbiAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ2Rpc3BsYXlBcmNDb21tZW50JywgW1xyXG4gICAgICAgICAgICAgIGV2dCwgdGFyZ2V0LCBzeW1tZXRyaWMsIGFyY0lkLFxyXG4gICAgICAgICAgICAgIG9yaWdpblNwYW5JZCwgb3JpZ2luU3BhblR5cGUsIHJvbGUsXHJcbiAgICAgICAgICAgICAgdGFyZ2V0U3BhbklkLCB0YXJnZXRTcGFuVHlwZSxcclxuICAgICAgICAgICAgICBjb21tZW50VGV4dCwgY29tbWVudFR5cGVdKTtcclxuICAgICAgICAgIGhpZ2hsaWdodEFyY3MgPSAkc3ZnLlxyXG4gICAgICAgICAgICAgIGZpbmQoJ2dbZGF0YS1mcm9tPVwiJyArIG9yaWdpblNwYW5JZCArICdcIl1bZGF0YS10bz1cIicgKyB0YXJnZXRTcGFuSWQgKyAnXCJdJykuXHJcbiAgICAgICAgICAgICAgYWRkQ2xhc3MoJ2hpZ2hsaWdodCcpO1xyXG4gICAgICAgICAgaGlnaGxpZ2h0U3BhbnMgPSAkKCRzdmcpLlxyXG4gICAgICAgICAgICAgIGZpbmQoJ3JlY3RbZGF0YS1zcGFuLWlkPVwiJyArIG9yaWdpblNwYW5JZCArICdcIl0sIHJlY3RbZGF0YS1zcGFuLWlkPVwiJyArIHRhcmdldFNwYW5JZCArICdcIl0nKS5cclxuICAgICAgICAgICAgICBwYXJlbnQoKS5cclxuICAgICAgICAgICAgICBhZGRDbGFzcygnaGlnaGxpZ2h0Jyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpZCA9IHRhcmdldC5hdHRyKCdkYXRhLXNlbnQnKSkge1xyXG4gICAgICAgICAgdmFyIGNvbW1lbnQgPSBkYXRhLnNlbnRDb21tZW50W2lkXTtcclxuICAgICAgICAgIGlmIChjb21tZW50KSB7XHJcbiAgICAgICAgICAgIGRpc3BhdGNoZXIucG9zdCgnZGlzcGxheVNlbnRDb21tZW50JywgW2V2dCwgdGFyZ2V0LCBjb21tZW50LnRleHQsIGNvbW1lbnQudHlwZV0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciBvbk1vdXNlT3V0ID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgdmFyIHRhcmdldCA9ICQoZXZ0LnRhcmdldCk7XHJcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUNsYXNzKCdiYWRUYXJnZXQnKTtcclxuICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ2hpZGVDb21tZW50Jyk7XHJcbiAgICAgICAgaWYgKGhpZ2hsaWdodCkge1xyXG4gICAgICAgICAgJC5lYWNoKGhpZ2hsaWdodCwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHN2Zy5yZW1vdmUodGhpcyk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIGhpZ2hsaWdodCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhpZ2hsaWdodFNwYW5zKSB7XHJcbiAgICAgICAgICBoaWdobGlnaHRBcmNzLnJlbW92ZUNsYXNzKCdoaWdobGlnaHQnKTtcclxuICAgICAgICAgIGhpZ2hsaWdodFNwYW5zLnJlbW92ZUNsYXNzKCdoaWdobGlnaHQnKTtcclxuICAgICAgICAgIGhpZ2hsaWdodFNwYW5zID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3JjZVJlZHJhdygpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdmFyIHNldEFiYnJldnMgPSBmdW5jdGlvbihfYWJicmV2c09uKSB7XHJcbiAgICAgICAgLy8gVE9ETzogdGhpcyBpcyBhIHNsaWdodGx5IHdlaXJkIHBsYWNlIHRvIHR3ZWFrIHRoZSBjb25maWd1cmF0aW9uXHJcbiAgICAgICAgQ29uZmlndXJhdGlvbi5hYmJyZXZzT24gPSBfYWJicmV2c09uO1xyXG4gICAgICAgIGRpc3BhdGNoZXIucG9zdCgnY29uZmlndXJhdGlvbkNoYW5nZWQnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHNldFRleHRCYWNrZ3JvdW5kcyA9IGZ1bmN0aW9uKF90ZXh0QmFja2dyb3VuZHMpIHtcclxuICAgICAgICBDb25maWd1cmF0aW9uLnRleHRCYWNrZ3JvdW5kcyA9IF90ZXh0QmFja2dyb3VuZHM7XHJcbiAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdjb25maWd1cmF0aW9uQ2hhbmdlZCcpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgc2V0TGF5b3V0RGVuc2l0eSA9IGZ1bmN0aW9uKF9kZW5zaXR5KSB7XHJcbiAgICAgICAgLy9kaXNwYXRjaGVyLnBvc3QoJ21lc3NhZ2VzJywgW1tbJ1NldHRpbmcgbGF5b3V0IGRlbnNpdHkgJyArIF9kZW5zaXR5LCAnY29tbWVudCddXV0pO1xyXG4gICAgICAgIC8vIFRPRE86IHN0b3JlIHN0YW5kYXJkIHNldHRpbmdzIGluc3RlYWQgb2YgaGFyZC1jb2RpbmdcclxuICAgICAgICAvLyB0aGVtIGhlcmUgKGFnYWluKVxyXG4gICAgICAgIGlmIChfZGVuc2l0eSA8IDIpIHtcclxuICAgICAgICAgIC8vIGRlbnNlXHJcbiAgICAgICAgICBDb25maWd1cmF0aW9uLnZpc3VhbC5tYXJnaW4gPSB7IHg6IDEsIHk6IDAgfTtcclxuICAgICAgICAgIENvbmZpZ3VyYXRpb24udmlzdWFsLmJveFNwYWNpbmcgPSAxO1xyXG4gICAgICAgICAgQ29uZmlndXJhdGlvbi52aXN1YWwuY3VybHlIZWlnaHQgPSAxO1xyXG4gICAgICAgICAgQ29uZmlndXJhdGlvbi52aXN1YWwuYXJjU3BhY2luZyA9IDc7XHJcbiAgICAgICAgICBDb25maWd1cmF0aW9uLnZpc3VhbC5hcmNTdGFydEhlaWdodCA9IDE4XHJcbiAgICAgICAgfSBlbHNlIGlmKF9kZW5zaXR5ID4gMikge1xyXG4gICAgICAgICAgLy8gc3BhY2lvdXNcclxuICAgICAgICAgIENvbmZpZ3VyYXRpb24udmlzdWFsLm1hcmdpbiA9IHsgeDogMiwgeTogMSB9O1xyXG4gICAgICAgICAgQ29uZmlndXJhdGlvbi52aXN1YWwuYm94U3BhY2luZyA9IDM7XHJcbiAgICAgICAgICBDb25maWd1cmF0aW9uLnZpc3VhbC5jdXJseUhlaWdodCA9IDY7XHJcbiAgICAgICAgICBDb25maWd1cmF0aW9uLnZpc3VhbC5hcmNTcGFjaW5nID0gMTI7XHJcbiAgICAgICAgICBDb25maWd1cmF0aW9uLnZpc3VhbC5hcmNTdGFydEhlaWdodCA9IDIzO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBzdGFuZGFyZFxyXG4gICAgICAgICAgQ29uZmlndXJhdGlvbi52aXN1YWwubWFyZ2luID0geyB4OiAyLCB5OiAxIH07XHJcbiAgICAgICAgICBDb25maWd1cmF0aW9uLnZpc3VhbC5ib3hTcGFjaW5nID0gMTtcclxuICAgICAgICAgIENvbmZpZ3VyYXRpb24udmlzdWFsLmN1cmx5SGVpZ2h0ID0gNDtcclxuICAgICAgICAgIENvbmZpZ3VyYXRpb24udmlzdWFsLmFyY1NwYWNpbmcgPSA5O1xyXG4gICAgICAgICAgQ29uZmlndXJhdGlvbi52aXN1YWwuYXJjU3RhcnRIZWlnaHQgPSAxOTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdjb25maWd1cmF0aW9uQ2hhbmdlZCcpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgc2V0U3ZnV2lkdGggPSBmdW5jdGlvbihfd2lkdGgpIHtcclxuICAgICAgICAkc3ZnRGl2LndpZHRoKF93aWR0aCk7XHJcbiAgICAgICAgaWYgKENvbmZpZ3VyYXRpb24uc3ZnV2lkdGggIT0gX3dpZHRoKSB7XHJcbiAgICAgICAgICBDb25maWd1cmF0aW9uLnN2Z1dpZHRoID0gX3dpZHRoO1xyXG4gICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdjb25maWd1cmF0aW9uQ2hhbmdlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgJHN2Z0RpdiA9ICQoJHN2Z0RpdikuaGlkZSgpO1xyXG5cclxuICAgICAgLy8gcmVnaXN0ZXIgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICAgIHZhciByZWdpc3RlckhhbmRsZXJzID0gZnVuY3Rpb24oZWxlbWVudCwgZXZlbnRzKSB7XHJcbiAgICAgICAgJC5lYWNoKGV2ZW50cywgZnVuY3Rpb24oZXZlbnRObywgZXZlbnROYW1lKSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuYmluZChldmVudE5hbWUsXHJcbiAgICAgICAgICAgICAgZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoZXZlbnROYW1lLCBbZXZ0XSwgJ2FsbCcpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfTtcclxuICAgICAgcmVnaXN0ZXJIYW5kbGVycygkc3ZnRGl2LCBbXHJcbiAgICAgICAgICAnbW91c2VvdmVyJywgJ21vdXNlb3V0JywgJ21vdXNlbW92ZScsXHJcbiAgICAgICAgICAnbW91c2V1cCcsICdtb3VzZWRvd24nLFxyXG4gICAgICAgICAgJ2RyYWdzdGFydCcsXHJcbiAgICAgICAgICAnZGJsY2xpY2snLCAnY2xpY2snXHJcbiAgICAgIF0pO1xyXG4gICAgICByZWdpc3RlckhhbmRsZXJzKCQoZG9jdW1lbnQpLCBbXHJcbiAgICAgICAgICAna2V5ZG93bicsICdrZXlwcmVzcycsXHJcbiAgICAgICAgICAndG91Y2hzdGFydCcsICd0b3VjaGVuZCdcclxuICAgICAgXSk7XHJcbiAgICAgIHJlZ2lzdGVySGFuZGxlcnMoJCh3aW5kb3cpLCBbXHJcbiAgICAgICAgICAncmVzaXplJ1xyXG4gICAgICBdKTtcclxuXHJcbiAgICAgIC8vIGNyZWF0ZSB0aGUgc3ZnIHdyYXBwZXJcclxuICAgICAgJHN2Z0Rpdi5zdmcoe1xyXG4gICAgICAgICAgb25Mb2FkOiBmdW5jdGlvbihfc3ZnKSB7XHJcbiAgICAgICAgICAgICAgdGhhdC5zdmcgPSBzdmcgPSBfc3ZnO1xyXG4gICAgICAgICAgICAgICRzdmcgPSAkKHN2Zy5fc3ZnKTtcclxuXHJcbiAgICAgICAgICAgICAgLyogWFhYIEhBQ0sgUkVNT1ZFRCAtIG5vdCBlZmZpY2llbnQ/XHJcblxyXG4gICAgICAgICAgICAgIC8vIFhYWCBIQUNLIHRvIGFsbG93IG9mZi1ET00gU1ZHIGVsZW1lbnQgY3JlYXRpb25cclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHJlcGxhY2UgdGhlIGpRdWVyeSBTVkcncyBfbWFrZU5vZGUgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAvLyB3aXRoIGEgbW9kaWZpZWQgb25lLlxyXG4gICAgICAgICAgICAgIC8vIEJlIGF3YXJlIG9mIHBvdGVudGlhbCBicmVha2FnZSB1cG9uIGpRdWVyeSBTVkcgdXBncmFkZS5cclxuICAgICAgICAgICAgICBzdmcuX21ha2VOb2RlID0gZnVuY3Rpb24ocGFyZW50LCBuYW1lLCBzZXR0aW5ncykge1xyXG4gICAgICAgICAgICAgICAgICAvLyBDT01NRU5URUQgT1VUOiBwYXJlbnQgPSBwYXJlbnQgfHwgdGhpcy5fc3ZnO1xyXG4gICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX3N2Zy5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygkLnN2Zy5zdmdOUywgbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzZXR0aW5nc1tuYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSAhPSBudWxsICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycgfHwgdmFsdWUgIT0gJycpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgkLnN2Zy5fYXR0ck5hbWVzW25hbWVdIHx8IG5hbWUsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgLy8gQURERUQgSU46XHJcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgICAgdHJpZ2dlclJlbmRlcigpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHZhciBsb2FkU3BhblR5cGVzID0gZnVuY3Rpb24odHlwZXMpIHtcclxuICAgICAgICAkLmVhY2godHlwZXMsIGZ1bmN0aW9uKHR5cGVObywgdHlwZSkge1xyXG4gICAgICAgICAgaWYgKHR5cGUpIHtcclxuICAgICAgICAgICAgc3BhblR5cGVzW3R5cGUudHlwZV0gPSB0eXBlO1xyXG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0eXBlLmNoaWxkcmVuO1xyXG4gICAgICAgICAgICBpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgbG9hZFNwYW5UeXBlcyhjaGlsZHJlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGxvYWRBdHRyaWJ1dGVUeXBlcyA9IGZ1bmN0aW9uKHJlc3BvbnNlX3R5cGVzKSB7XHJcbiAgICAgICAgdmFyIHByb2Nlc3NlZCA9IHt9O1xyXG4gICAgICAgICQuZWFjaChyZXNwb25zZV90eXBlcywgZnVuY3Rpb24oYVR5cGVObywgYVR5cGUpIHtcclxuICAgICAgICAgIHByb2Nlc3NlZFthVHlwZS50eXBlXSA9IGFUeXBlO1xyXG4gICAgICAgICAgLy8gY291bnQgdGhlIHZhbHVlczsgaWYgb25seSBvbmUsIGl0J3MgYSBib29sZWFuIGF0dHJpYnV0ZVxyXG4gICAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xyXG4gICAgICAgICAgZm9yICh2YXIgaSBpbiBhVHlwZS52YWx1ZXMpIHtcclxuICAgICAgICAgICAgaWYgKGFUeXBlLnZhbHVlcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xyXG4gICAgICAgICAgICAgIHZhbHVlcy5wdXNoKGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PSAxKSB7XHJcbiAgICAgICAgICAgIGFUeXBlLmJvb2wgPSB2YWx1ZXNbMF07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NlZDtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGxvYWRSZWxhdGlvblR5cGVzID0gZnVuY3Rpb24ocmVsYXRpb25fdHlwZXMpIHtcclxuICAgICAgICAkLmVhY2gocmVsYXRpb25fdHlwZXMsIGZ1bmN0aW9uKHJlbFR5cGVObywgcmVsVHlwZSkge1xyXG4gICAgICAgICAgaWYgKHJlbFR5cGUpIHtcclxuICAgICAgICAgICAgcmVsYXRpb25UeXBlc0hhc2hbcmVsVHlwZS50eXBlXSA9IHJlbFR5cGU7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHJlbFR5cGUuY2hpbGRyZW47XHJcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICBsb2FkUmVsYXRpb25UeXBlcyhjaGlsZHJlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGNvbGxlY3Rpb25Mb2FkZWQgPSBmdW5jdGlvbihyZXNwb25zZSkge1xyXG4gICAgICAgIGlmICghcmVzcG9uc2UuZXhjZXB0aW9uKSB7XHJcbiAgICAgICAgICBzZXRDb2xsZWN0aW9uRGVmYXVsdHMocmVzcG9uc2UpO1xyXG4gICAgICAgICAgZXZlbnRBdHRyaWJ1dGVUeXBlcyA9IGxvYWRBdHRyaWJ1dGVUeXBlcyhyZXNwb25zZS5ldmVudF9hdHRyaWJ1dGVfdHlwZXMpO1xyXG4gICAgICAgICAgZW50aXR5QXR0cmlidXRlVHlwZXMgPSBsb2FkQXR0cmlidXRlVHlwZXMocmVzcG9uc2UuZW50aXR5X2F0dHJpYnV0ZV90eXBlcyk7XHJcbiAgICAgICAgICBzcGFuVHlwZXMgPSB7fTtcclxuICAgICAgICAgIGxvYWRTcGFuVHlwZXMocmVzcG9uc2UuZW50aXR5X3R5cGVzKTtcclxuICAgICAgICAgIGxvYWRTcGFuVHlwZXMocmVzcG9uc2UuZXZlbnRfdHlwZXMpO1xyXG4gICAgICAgICAgbG9hZFNwYW5UeXBlcyhyZXNwb25zZS51bmNvbmZpZ3VyZWRfdHlwZXMpO1xyXG4gICAgICAgICAgcmVsYXRpb25UeXBlc0hhc2ggPSB7fTtcclxuICAgICAgICAgIGxvYWRSZWxhdGlvblR5cGVzKHJlc3BvbnNlLnJlbGF0aW9uX3R5cGVzKTtcclxuICAgICAgICAgIGxvYWRSZWxhdGlvblR5cGVzKHJlc3BvbnNlLnVuY29uZmlndXJlZF90eXBlcyk7XHJcbiAgICAgICAgICAvLyBUT0RPIFhYWDogaXNuJ3QgdGhlIGZvbGxvd2luZyBjb21wbGV0ZWx5IHJlZHVuZGFudCB3aXRoXHJcbiAgICAgICAgICAvLyBsb2FkUmVsYXRpb25UeXBlcz9cclxuICAgICAgICAgICQuZWFjaChyZXNwb25zZS5yZWxhdGlvbl90eXBlcywgZnVuY3Rpb24ocmVsVHlwZU5vLCByZWxUeXBlKSB7XHJcbiAgICAgICAgICAgIHJlbGF0aW9uVHlwZXNIYXNoW3JlbFR5cGUudHlwZV0gPSByZWxUeXBlO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdzcGFuQW5kQXR0cmlidXRlVHlwZXNMb2FkZWQnLCBbc3BhblR5cGVzLCBlbnRpdHlBdHRyaWJ1dGVUeXBlcywgZXZlbnRBdHRyaWJ1dGVUeXBlcywgcmVsYXRpb25UeXBlc0hhc2hdKTtcclxuXHJcbiAgICAgICAgICBpc0NvbGxlY3Rpb25Mb2FkZWQgPSB0cnVlO1xyXG4gICAgICAgICAgdHJpZ2dlclJlbmRlcigpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBleGNlcHRpb24gb24gY29sbGVjdGlvbiBsb2FkOyBhbGxvdyB2aXN1YWxpemVyX3VpXHJcbiAgICAgICAgICAvLyBjb2xsZWN0aW9uTG9hZGVkIHRvIGhhbmRsZSB0aGlzXHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgdmFyIGlzUmVsb2FkT2theSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vIGRvIG5vdCByZWxvYWQgd2hpbGUgdGhlIHVzZXIgaXMgaW4gdGhlIGRpYWxvZ1xyXG4gICAgICAgIHJldHVybiAhZHJhd2luZztcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIElmIHdlIGFyZSB5ZXQgdG8gbG9hZCBvdXIgZm9udHMsIGRpc3BhdGNoIHRoZW1cclxuICAgICAgaWYgKCFWaXN1YWxpemVyLmFyZUZvbnRzTG9hZGVkKSB7XHJcbiAgICAgICAgdmFyIHdlYkZvbnRDb25maWcgPSB7XHJcbiAgICAgICAgICBjdXN0b206IHtcclxuICAgICAgICAgICAgZmFtaWxpZXM6IFtcclxuICAgICAgICAgICAgICAnQXN0bG9jaCcsXHJcbiAgICAgICAgICAgICAgJ1BUIFNhbnMgQ2FwdGlvbicsXHJcbiAgICAgICAgICAgICAgLy8gICAgICAgICdVYnVudHUnLFxyXG4gICAgICAgICAgICAgICdMaWJlcmF0aW9uIFNhbnMnXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIC8qIEZvciBzb21lIGNhc2VzLCBpbiBwYXJ0aWN1bGFyIGZvciBlbWJlZGRpbmcsIHdlIG5lZWQgdG9cclxuICAgICAgICAgICAgICBhbGxvdyBmb3IgZm9udHMgYmVpbmcgaG9zdGVkIGVsc2V3aGVyZSAqL1xyXG4gICAgICAgICAgICB1cmxzOiB3ZWJGb250VVJMcyAhPT0gdW5kZWZpbmVkID8gd2ViRm9udFVSTHMgOiBbXHJcbiAgICAgICAgICAgICAgJ3N0YXRpYy9mb250cy9Bc3Rsb2NoLUJvbGQudHRmJyxcclxuICAgICAgICAgICAgICAnc3RhdGljL2ZvbnRzL1BUX1NhbnMtQ2FwdGlvbi1XZWItUmVndWxhci50dGYnLFxyXG4gICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgJ3N0YXRpYy9mb250cy9MaWJlcmF0aW9uX1NhbnMtUmVndWxhci50dGYnXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgYWN0aXZlOiBwcm9jZWVkV2l0aEZvbnRzLFxyXG4gICAgICAgICAgaW5hY3RpdmU6IHByb2NlZWRXaXRoRm9udHMsXHJcbiAgICAgICAgICBmb250YWN0aXZlOiBmdW5jdGlvbihmb250RmFtaWx5LCBmb250RGVzY3JpcHRpb24pIHtcclxuICAgICAgICAgICAgLy8gTm90ZTogRW5hYmxlIGZvciBmb250IGRlYnVnZ2luZ1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiZm9udCBhY3RpdmU6IFwiLCBmb250RmFtaWx5LCBmb250RGVzY3JpcHRpb24pO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGZvbnRsb2FkaW5nOiBmdW5jdGlvbihmb250RmFtaWx5LCBmb250RGVzY3JpcHRpb24pIHtcclxuICAgICAgICAgICAgLy8gTm90ZTogRW5hYmxlIGZvciBmb250IGRlYnVnZ2luZ1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiZm9udCBsb2FkaW5nOlwiLCBmb250RmFtaWx5LCBmb250RGVzY3JpcHRpb24pO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIFdlYkZvbnQubG9hZCh3ZWJGb250Q29uZmlnKTtcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgaWYgKCFWaXN1YWxpemVyLmFyZUZvbnRzTG9hZGVkKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RpbWVvdXQgaW4gbG9hZGluZyBmb250cycpO1xyXG4gICAgICAgICAgICBwcm9jZWVkV2l0aEZvbnRzKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSwgZm9udExvYWRUaW1lb3V0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZGlzcGF0Y2hlci5cclxuICAgICAgICAgIG9uKCdjb2xsZWN0aW9uQ2hhbmdlZCcsIGNvbGxlY3Rpb25DaGFuZ2VkKS5cclxuICAgICAgICAgIG9uKCdjb2xsZWN0aW9uTG9hZGVkJywgY29sbGVjdGlvbkxvYWRlZCkuXHJcbiAgICAgICAgICBvbigncmVuZGVyRGF0YScsIHJlbmRlckRhdGEpLlxyXG4gICAgICAgICAgb24oJ3RyaWdnZXJSZW5kZXInLCB0cmlnZ2VyUmVuZGVyKS5cclxuICAgICAgICAgIG9uKCdyZXF1ZXN0UmVuZGVyRGF0YScsIHJlcXVlc3RSZW5kZXJEYXRhKS5cclxuICAgICAgICAgIG9uKCdpc1JlbG9hZE9rYXknLCBpc1JlbG9hZE9rYXkpLlxyXG4gICAgICAgICAgb24oJ3Jlc2V0RGF0YScsIHJlc2V0RGF0YSkuXHJcbiAgICAgICAgICBvbignYWJicmV2cycsIHNldEFiYnJldnMpLlxyXG4gICAgICAgICAgb24oJ3RleHRCYWNrZ3JvdW5kcycsIHNldFRleHRCYWNrZ3JvdW5kcykuXHJcbiAgICAgICAgICBvbignbGF5b3V0RGVuc2l0eScsIHNldExheW91dERlbnNpdHkpLlxyXG4gICAgICAgICAgb24oJ3N2Z1dpZHRoJywgc2V0U3ZnV2lkdGgpLlxyXG4gICAgICAgICAgb24oJ2N1cnJlbnQnLCBnb3RDdXJyZW50KS5cclxuICAgICAgICAgIG9uKCdjbGVhclNWRycsIGNsZWFyU1ZHKS5cclxuICAgICAgICAgIG9uKCdtb3VzZW92ZXInLCBvbk1vdXNlT3ZlcikuXHJcbiAgICAgICAgICBvbignbW91c2VvdXQnLCBvbk1vdXNlT3V0KTtcclxuICAgIH07XHJcblxyXG4gICAgVmlzdWFsaXplci5hcmVGb250c0xvYWRlZCA9IGZhbHNlO1xyXG5cclxuICAgIHZhciBwcm9jZWVkV2l0aEZvbnRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIFZpc3VhbGl6ZXIuYXJlRm9udHNMb2FkZWQgPSB0cnVlO1xyXG4gICAgICAvLyBOb3RlOiBFbmFibGUgZm9yIGZvbnQgZGVidWdnaW5nXHJcbiAgICAgIC8vY29uc29sZS5sb2coXCJmb250cyBkb25lXCIpO1xyXG4gICAgICBEaXNwYXRjaGVyLnBvc3QoJ3RyaWdnZXJSZW5kZXInKTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIFZpc3VhbGl6ZXI7XHJcbn0pKGpRdWVyeSwgd2luZG93KTtcclxuXHJcbi8vIEJSQVQgU1RBTkRBTE9ORSBMSUJSQVJZIEJFR0lOXHJcbi8vIEJyb3dzZXJpZnkgZXhwb3J0XHJcbm1vZHVsZS5leHBvcnRzID0gVmlzdWFsaXplcjtcclxuLy8gQlJBVCBTVEFOREFMT05FIExJQlJBUlkgRU5EXHJcbiIsIi8vIC0qLSBNb2RlOiBKYXZhU2NyaXB0OyB0YWItd2lkdGg6IDI7IGluZGVudC10YWJzLW1vZGU6IG5pbDsgLSotXHJcbi8vIHZpbTpzZXQgZnQ9amF2YXNjcmlwdCB0cz0yIHN3PTIgc3RzPTIgY2luZGVudDpcclxudmFyIFZpc3VhbGl6ZXJVSSA9IChmdW5jdGlvbigkLCB3aW5kb3csIHVuZGVmaW5lZCkge1xyXG4gICAgdmFyIFZpc3VhbGl6ZXJVSSA9IGZ1bmN0aW9uKGRpc3BhdGNoZXIsIHN2Zywgc2hvd1Rvb2x0aXAsIG92ZXJXcml0ZU1vZGFscykge1xyXG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG4gICAgICB2YXIgbWVzc2FnZVBvc3RPdXRGYWRlRGVsYXkgPSAxMDAwO1xyXG4gICAgICB2YXIgbWVzc2FnZURlZmF1bHRGYWRlRGVsYXkgPSAzMDAwO1xyXG4gICAgICB2YXIgZGVmYXVsdEZsb2F0Rm9ybWF0ID0gJyUuMWYvcmlnaHQnO1xyXG5cclxuICAgICAgdmFyIGRvY3VtZW50TGlzdGluZyA9IG51bGw7IC8vIGFsd2F5cyBkb2N1bWVudHMgb2YgY3VycmVudCBjb2xsZWN0aW9uXHJcbiAgICAgIHZhciBzZWxlY3RvckRhdGEgPSBudWxsOyAgICAvLyBjYW4gYmUgc2VhcmNoIHJlc3VsdHMgd2hlbiBhdmFpbGFibGVcclxuICAgICAgdmFyIHNlYXJjaEFjdGl2ZSA9IGZhbHNlOyAgIC8vIHdoZXRoZXIgc2VhcmNoIHJlc3VsdHMgcmVjZWl2ZWQgYW5kIGluIHVzZVxyXG4gICAgICB2YXIgbG9hZGVkU2VhcmNoRGF0YSA9IG51bGw7XHJcblxyXG4gICAgICB2YXIgY3VycmVudEZvcm07XHJcbiAgICAgIHZhciBzcGFuVHlwZXMgPSBudWxsO1xyXG4gICAgICB2YXIgcmVsYXRpb25UeXBlc0hhc2ggPSBudWxsO1xyXG4gICAgICAvLyBUT0RPOiBjb25maXJtIHVubmVjZXNzYXJ5IGFuZCByZW1vdmVcclxuLy8gICAgICAgdmFyIGF0dHJpYnV0ZVR5cGVzID0gbnVsbDtcclxuICAgICAgdmFyIGRhdGEgPSBudWxsO1xyXG4gICAgICB2YXIgbXRpbWUgPSBudWxsO1xyXG4gICAgICB2YXIgc2VhcmNoQ29uZmlnID0gbnVsbDtcclxuICAgICAgdmFyIGNvbGwsIGRvYywgYXJncztcclxuICAgICAgdmFyIGNvbGxTY3JvbGw7XHJcbiAgICAgIHZhciBkb2NTY3JvbGw7XHJcbiAgICAgIHZhciB1c2VyID0gbnVsbDtcclxuICAgICAgdmFyIGFubm90YXRpb25BdmFpbGFibGUgPSBmYWxzZTtcclxuXHJcbiAgICAgIHZhciBzdmdFbGVtZW50ID0gJChzdmcuX3N2Zyk7XHJcbiAgICAgIHZhciBzdmdJZCA9IHN2Z0VsZW1lbnQucGFyZW50KCkuYXR0cignaWQnKTtcclxuXHJcbiAgICAgIHZhciBtYXhNZXNzYWdlcyA9IDEwMDtcclxuXHJcbiAgICAgIHZhciBjdXJyZW50RG9jdW1lbnRTVkdzYXZlZCA9IGZhbHNlO1xyXG4gICAgICB2YXIgZmlsZUJyb3dzZXJDbG9zZWRXaXRoU3VibWl0ID0gZmFsc2U7XHJcblxyXG4gICAgICAvLyBub3JtYWxpemF0aW9uOiBzZXJ2ZXItc2lkZSBEQiBieSBub3JtIERCIG5hbWVcclxuICAgICAgdmFyIG5vcm1TZXJ2ZXJEYkJ5Tm9ybURiTmFtZSA9IHt9O1xyXG5cclxuICAgICAgdmFyIG1hdGNoRm9jdXMgPSAnJztcclxuICAgICAgdmFyIG1hdGNoZXMgPSAnJztcclxuXHJcbiAgICAgIC8qIFNUQVJUIFwibm8gc3ZnXCIgbWVzc2FnZSAtIHJlbGF0ZWQgKi9cclxuXHJcbiAgICAgIHZhciBub1N2Z1RpbWVyID0gbnVsbDtcclxuXHJcbiAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBjZW50ZXJpbmdcclxuICAgICAgJCgnI25vX3N2Z193cmFwcGVyJykuY3NzKCdkaXNwbGF5JywgJ3RhYmxlJyk7XHJcbiAgICAgIC8vIG9uIGluaXRpYWwgbG9hZCwgaGlkZSB0aGUgXCJubyBTVkdcIiBtZXNzYWdlXHJcbiAgICAgICQoJyNub19zdmdfd3JhcHBlcicpLmhpZGUoKTtcclxuXHJcbiAgICAgIHZhciBoaWRlTm9Eb2NNZXNzYWdlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KG5vU3ZnVGltZXIpO1xyXG4gICAgICAgICQoJyNub19zdmdfd3JhcHBlcicpLmhpZGUoMCk7XHJcbiAgICAgICAgJCgnI3NvdXJjZV9maWxlcycpLnNob3coKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHNob3dOb0RvY01lc3NhZ2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBjbGVhclRpbWVvdXQobm9TdmdUaW1lcik7XHJcbiAgICAgICAgbm9TdmdUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAkKCcjbm9fc3ZnX3dyYXBwZXInKS5mYWRlSW4oNTAwKTtcclxuICAgICAgICB9LCAyMDAwKTtcclxuICAgICAgICAkKCcjc291cmNlX2ZpbGVzJykuaGlkZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvKiBFTkQgXCJubyBzdmdcIiBtZXNzYWdlIC0gcmVsYXRlZCAqL1xyXG5cclxuICAgICAgLyogU1RBUlQgY29sbGVjdGlvbiBicm93c2VyIHNvcnRpbmcgLSByZWxhdGVkICovXHJcblxyXG4gICAgICB2YXIgbGFzdEdvb2RDb2xsZWN0aW9uID0gJy8nO1xyXG4gICAgICB2YXIgc29ydE9yZGVyID0gWzIsIDFdOyAvLyBjb2x1bW4gKDAuLiksIHNvcnQgb3JkZXIgKDEsIC0xKVxyXG4gICAgICB2YXIgY29sbGVjdGlvblNvcnRPcmRlcjsgLy8gaG9sZHMgcHJldmlvdXMgc29ydCB3aGlsZSBzZWFyY2ggaXMgYWN0aXZlXHJcbiAgICAgIHZhciBkb2NTb3J0RnVuY3Rpb24gPSBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICAvLyBwYXJlbnQgYXQgdGhlIHRvcFxyXG4gICAgICAgICAgaWYgKGFbMl0gPT09ICcuLicpIHJldHVybiAtMTtcclxuICAgICAgICAgIGlmIChiWzJdID09PSAnLi4nKSByZXR1cm4gMTtcclxuXHJcbiAgICAgICAgICAvLyB0aGVuIG90aGVyIGNvbGxlY3Rpb25zXHJcbiAgICAgICAgICB2YXIgYUlzQ29sbCA9IGFbMF0gPT0gXCJjXCI7XHJcbiAgICAgICAgICB2YXIgYklzQ29sbCA9IGJbMF0gPT0gXCJjXCI7XHJcbiAgICAgICAgICBpZiAoYUlzQ29sbCAhPT0gYklzQ29sbCkgcmV0dXJuIGFJc0NvbGwgPyAtMSA6IDE7XHJcblxyXG4gICAgICAgICAgLy8gZGVzaXJlZCBjb2x1bW4gaW4gdGhlIGRlc2lyZWQgb3JkZXJcclxuICAgICAgICAgIHZhciBjb2wgPSBzb3J0T3JkZXJbMF07XHJcbiAgICAgICAgICB2YXIgYWEgPSBhW2NvbF07XHJcbiAgICAgICAgICB2YXIgYmIgPSBiW2NvbF07XHJcbiAgICAgICAgICBpZiAoc2VsZWN0b3JEYXRhLmhlYWRlcltjb2wgLSAyXVsxXSA9PT0gJ3N0cmluZy1yZXZlcnNlJykge1xyXG4gICAgICAgICAgICBhYSA9IGFhLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJyk7XHJcbiAgICAgICAgICAgIGJiID0gYmIuc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChhYSAhPSBiYikgcmV0dXJuIChhYSA8IGJiKSA/IC1zb3J0T3JkZXJbMV0gOiBzb3J0T3JkZXJbMV07XHJcblxyXG4gICAgICAgICAgLy8gcHJldmVudCByYW5kb20gc2h1ZmZsZXMgb24gY29sdW1ucyB3aXRoIGR1cGxpY2F0ZSB2YWx1ZXNcclxuICAgICAgICAgIC8vIChhbHBoYWJldGljYWwgb3JkZXIgb2YgZG9jdW1lbnRzKVxyXG4gICAgICAgICAgYWEgPSBhWzJdO1xyXG4gICAgICAgICAgYmIgPSBiWzJdO1xyXG4gICAgICAgICAgaWYgKGFhICE9IGJiKSByZXR1cm4gKGFhIDwgYmIpID8gLTEgOiAxO1xyXG4gICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgbWFrZVNvcnRDaGFuZ2VGdW5jdGlvbiA9IGZ1bmN0aW9uKHNvcnQsIHRoLCB0aE5vKSB7XHJcbiAgICAgICAgICAkKHRoKS5jbGljayhmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAvLyBUT0RPOiBhdm9pZCBtYWdpYyBudW1iZXJzIGluIGFjY2VzcyB0byB0aGUgc2VsZWN0b3JcclxuICAgICAgICAgICAgICAvLyBkYXRhIChjb2x1bW4gMCBpcyB0eXBlLCAxIGlzIGFyZ3MsIHJlc3QgaXMgZGF0YSlcclxuICAgICAgICAgICAgICBpZiAoc29ydFswXSA9PT0gdGhObyArIDEpIHNvcnRbMV0gPSAtc29ydFsxXTtcclxuICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gc2VsZWN0b3JEYXRhLmhlYWRlclt0aE5vIC0gMV1bMV07XHJcbiAgICAgICAgICAgICAgICB2YXIgYXNjZW5kaW5nID0gdHlwZSA9PT0gXCJzdHJpbmdcIjtcclxuICAgICAgICAgICAgICAgIHNvcnRbMF0gPSB0aE5vICsgMTtcclxuICAgICAgICAgICAgICAgIHNvcnRbMV0gPSBhc2NlbmRpbmcgPyAxIDogLTE7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHNlbGVjdG9yRGF0YS5pdGVtcy5zb3J0KGRvY1NvcnRGdW5jdGlvbik7XHJcbiAgICAgICAgICAgICAgZG9jU2Nyb2xsID0gMDtcclxuICAgICAgICAgICAgICBzaG93RmlsZUJyb3dzZXIoKTsgLy8gcmVzb3J0XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLyogRU5EIGNvbGxlY3Rpb24gYnJvd3NlciBzb3J0aW5nIC0gcmVsYXRlZCAqL1xyXG5cclxuXHJcbiAgICAgIC8qIFNUQVJUIG1lc3NhZ2UgZGlzcGxheSAtIHJlbGF0ZWQgKi9cclxuXHJcbiAgICAgIHZhciBzaG93UHVsbHVwVHJpZ2dlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICQoJyNwdWxsdXB0cmlnZ2VyJykuc2hvdygncHVmZicpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgJG1lc3NhZ2VDb250YWluZXIgPSAkKCcjbWVzc2FnZXMnKTtcclxuICAgICAgdmFyICRtZXNzYWdlcHVsbHVwID0gJCgnI21lc3NhZ2VwdWxsdXAnKTtcclxuICAgICAgdmFyIHB1bGx1cFRpbWVyID0gbnVsbDtcclxuICAgICAgdmFyIGRpc3BsYXlNZXNzYWdlcyA9IGZ1bmN0aW9uKG1zZ3MpIHtcclxuICAgICAgICB2YXIgaW5pdGlhbE1lc3NhZ2VOdW0gPSAkbWVzc2FnZXB1bGx1cC5jaGlsZHJlbigpLmxlbmd0aDtcclxuXHJcbiAgICAgICAgaWYgKG1zZ3MgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAkbWVzc2FnZUNvbnRhaW5lci5jaGlsZHJlbigpLmVhY2goZnVuY3Rpb24obXNnRWxObywgbXNnRWwpIHtcclxuICAgICAgICAgICAgICAkKG1zZ0VsKS5yZW1vdmUoKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAkLmVhY2gobXNncywgZnVuY3Rpb24obXNnTm8sIG1zZykge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudDtcclxuICAgICAgICAgICAgdmFyIHRpbWVyID0gbnVsbDtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICBlbGVtZW50ID0gJCgnPGRpdiBjbGFzcz1cIicgKyBtc2dbMV0gKyAnXCI+JyArIG1zZ1swXSArICc8L2Rpdj4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCh4KSB7XHJcbiAgICAgICAgICAgICAgZXNjYXBlZCA9IG1zZ1swXS5yZXBsYWNlKC8mL2csIFwiJmFtcDtcIikucmVwbGFjZSgvPC9nLCBcIiZsdDtcIikucmVwbGFjZSgvPi9nLCBcIiZndDtcIik7XHJcbiAgICAgICAgICAgICAgZWxlbWVudCA9ICQoJzxkaXYgY2xhc3M9XCJlcnJvclwiPjxiPltFUlJPUjogY291bGQgbm90IGRpc3BsYXkgdGhlIGZvbGxvd2luZyBtZXNzYWdlIG5vcm1hbGx5IGR1ZSB0byBtYWxmb3JtZWQgWE1MOl08L2I+PGJyLz4nICsgZXNjYXBlZCArICc8L2Rpdj4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcHVsbHVwRWxlbWVudCA9IGVsZW1lbnQuY2xvbmUoKTtcclxuICAgICAgICAgICAgJG1lc3NhZ2VDb250YWluZXIuYXBwZW5kKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAkbWVzc2FnZXB1bGx1cC5hcHBlbmQocHVsbHVwRWxlbWVudC5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpKTtcclxuICAgICAgICAgICAgc2xpZGVUb2dnbGUocHVsbHVwRWxlbWVudCwgdHJ1ZSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgZmFkZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICBpZiAoJG1lc3NhZ2VwdWxsdXAuaXMoJzp2aXNpYmxlJykpIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuaGlkZSgnc2xvdycsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgZGVsYXkgPSAobXNnWzJdID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyBtZXNzYWdlRGVmYXVsdEZhZGVEZWxheVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogKG1zZ1syXSA9PT0gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IChtc2dbMl0gKiAxMDAwKTtcclxuICAgICAgICAgICAgaWYgKGRlbGF5ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGJ1dHRvbiA9ICQoJzxpbnB1dCB0eXBlPVwiYnV0dG9uXCIgdmFsdWU9XCJPS1wiLz4nKTtcclxuICAgICAgICAgICAgICBlbGVtZW50LnByZXBlbmQoYnV0dG9uKTtcclxuICAgICAgICAgICAgICBidXR0b24uY2xpY2soZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZmFkZXIsIDApO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dChmYWRlciwgZGVsYXkpO1xyXG4gICAgICAgICAgICAgIGVsZW1lbnQubW91c2VvdmVyKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xyXG4gICAgICAgICAgICAgICAgICBlbGVtZW50LnNob3coKTtcclxuICAgICAgICAgICAgICB9KS5tb3VzZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZhZGVyLCBtZXNzYWdlUG9zdE91dEZhZGVEZWxheSk7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gc2V0VGltZW91dChmYWRlciwgbWVzc2FnZURlZmF1bHRGYWRlRGVsYXkpO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgLy8gbGltaXRlZCBoaXN0b3J5IC0gZGVsZXRlIG9sZGVzdFxyXG4gICAgICAgICAgdmFyICRtZXNzYWdlcyA9ICRtZXNzYWdlcHVsbHVwLmNoaWxkcmVuKCk7XHJcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8ICRtZXNzYWdlcy5sZW5ndGggLSBtYXhNZXNzYWdlczsgaSsrKSB7XHJcbiAgICAgICAgICAgICQoJG1lc3NhZ2VzW2ldKS5yZW1vdmUoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIGNoYW5nZSBpbiB0aGUgbnVtYmVyIG9mIG1lc3NhZ2VzLCBtYXkgbmVlZCB0b1xyXG4gICAgICAgIC8vIHR3ZWFrIHRyaWdnZXIgdmlzaWJpbGl0eVxyXG4gICAgICAgIHZhciBtZXNzYWdlTnVtID0gJG1lc3NhZ2VwdWxsdXAuY2hpbGRyZW4oKS5sZW5ndGg7XHJcbiAgICAgICAgaWYgKG1lc3NhZ2VOdW0gIT0gaW5pdGlhbE1lc3NhZ2VOdW0pIHtcclxuICAgICAgICAgIGlmIChtZXNzYWdlTnVtID09IDApIHtcclxuICAgICAgICAgICAgLy8gYWxsIGdvbmU7IG5vdGhpbmcgdG8gdHJpZ2dlclxyXG4gICAgICAgICAgICAkKCcjcHVsbHVwdHJpZ2dlcicpLmhpZGUoJ3Nsb3cnKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoaW5pdGlhbE1lc3NhZ2VOdW0gPT0gMCkge1xyXG4gICAgICAgICAgICAvLyBmaXJzdCBtZXNzYWdlcywgc2hvdyB0cmlnZ2VyIGF0IGZhZGVcclxuICAgICAgICAgICAgc2V0VGltZW91dChzaG93UHVsbHVwVHJpZ2dlciwgbWVzc2FnZURlZmF1bHRGYWRlRGVsYXkrMjUwKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBoaWRlIHB1bGx1cCB0cmlnZ2VyIGJ5IGRlZmF1bHQsIHNob3cgb24gZmlyc3QgbWVzc2FnZVxyXG4gICAgICAkKCcjcHVsbHVwdHJpZ2dlcicpLmhpZGUoKTtcclxuICAgICAgJCgnI3B1bGx1cHRyaWdnZXInKS5cclxuICAgICAgICBtb3VzZWVudGVyKGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgICAgJCgnI3B1bGx1cHRyaWdnZXInKS5oaWRlKCdwdWZmJyk7XHJcbiAgICAgICAgICBjbGVhclRpbWVvdXQocHVsbHVwVGltZXIpO1xyXG4gICAgICAgICAgc2xpZGVUb2dnbGUoJG1lc3NhZ2VwdWxsdXAuc3RvcCgpLCB0cnVlLCB0cnVlLCB0cnVlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgJCgnI21lc3NhZ2VwdWxsdXAnKS5cclxuICAgICAgICBtb3VzZWxlYXZlKGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgICAgc2V0VGltZW91dChzaG93UHVsbHVwVHJpZ2dlciwgNTAwKTtcclxuICAgICAgICAgIGNsZWFyVGltZW91dChwdWxsdXBUaW1lcik7XHJcbiAgICAgICAgICBwdWxsdXBUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHNsaWRlVG9nZ2xlKCRtZXNzYWdlcHVsbHVwLnN0b3AoKSwgZmFsc2UsIHRydWUsIHRydWUpO1xyXG4gICAgICAgICAgfSwgNTAwKTtcclxuICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAvKiBFTkQgbWVzc2FnZSBkaXNwbGF5IC0gcmVsYXRlZCAqL1xyXG5cclxuXHJcbiAgICAgIC8qIFNUQVJUIGNvbW1lbnQgcG9wdXAgLSByZWxhdGVkICovXHJcblxyXG4gICAgICB2YXIgYWRqdXN0VG9DdXJzb3IgPSBmdW5jdGlvbihldnQsIGVsZW1lbnQsIG9mZnNldCwgdG9wLCByaWdodCkge1xyXG4gICAgICAgIC8vIGdldCB0aGUgcmVhbCB3aWR0aCwgd2l0aG91dCB3cmFwcGluZ1xyXG4gICAgICAgIGVsZW1lbnQuY3NzKHsgbGVmdDogMCwgdG9wOiAwIH0pO1xyXG4gICAgICAgIHZhciBzY3JlZW5IZWlnaHQgPSAkKHdpbmRvdykuaGVpZ2h0KCk7XHJcbiAgICAgICAgdmFyIHNjcmVlbldpZHRoID0gJCh3aW5kb3cpLndpZHRoKCk7XHJcbiAgICAgICAgLy8gRklYTUUgd2h5IHRoZSBoZWxsIGlzIHRoaXMgMjIgbmVjZXNzYXJ5PyE/XHJcbiAgICAgICAgdmFyIGVsZW1lbnRIZWlnaHQgPSBlbGVtZW50LmhlaWdodCgpICsgMjI7XHJcbiAgICAgICAgdmFyIGVsZW1lbnRXaWR0aCA9IGVsZW1lbnQud2lkdGgoKSArIDIyO1xyXG4gICAgICAgIHZhciB4LCB5O1xyXG4gICAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xyXG4gICAgICAgIGlmICh0b3ApIHtcclxuICAgICAgICAgIHkgPSBldnQuY2xpZW50WSAtIGVsZW1lbnRIZWlnaHQgLSBvZmZzZXQ7XHJcbiAgICAgICAgICBpZiAoeSA8IDApIHRvcCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRvcCkge1xyXG4gICAgICAgICAgeSA9IGV2dC5jbGllbnRZICsgb2Zmc2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmlnaHQpIHtcclxuICAgICAgICAgIHggPSBldnQuY2xpZW50WCArIG9mZnNldDtcclxuICAgICAgICAgIGlmICh4ID49IHNjcmVlbldpZHRoIC0gZWxlbWVudFdpZHRoKSByaWdodCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXJpZ2h0KSB7XHJcbiAgICAgICAgICB4ID0gZXZ0LmNsaWVudFggLSBlbGVtZW50V2lkdGggLSBvZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh5IDwgMCkgeSA9IDA7XHJcbiAgICAgICAgaWYgKHggPCAwKSB4ID0gMDtcclxuICAgICAgICBlbGVtZW50LmNzcyh7IHRvcDogeSwgbGVmdDogeCB9KTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciBjb21tZW50UG9wdXAgPSAkKCcjY29tbWVudHBvcHVwJyk7XHJcbiAgICAgIHZhciBjb21tZW50RGlzcGxheWVkID0gZmFsc2U7XHJcblxyXG4gICAgICB2YXIgZGlzcGxheUNvbW1lbnRUaW1lciA9IG51bGw7XHJcbiAgICAgIHZhciBkaXNwbGF5Q29tbWVudCA9IGZ1bmN0aW9uKGV2dCwgdGFyZ2V0LCBjb21tZW50LCBjb21tZW50VGV4dCwgY29tbWVudFR5cGUsIGltbWVkaWF0ZWx5KSB7XHJcbiAgICAgICAgdmFyIGlkdHlwZTtcclxuICAgICAgICBpZiAoY29tbWVudFR5cGUpIHtcclxuICAgICAgICAgIC8vIGxhYmVsIGNvbW1lbnQgYnkgdHlwZSwgd2l0aCBzcGVjaWFsIGNhc2UgZm9yIGRlZmF1bHQgbm90ZSB0eXBlXHJcbiAgICAgICAgICB2YXIgY29tbWVudExhYmVsO1xyXG4gICAgICAgICAgaWYgKGNvbW1lbnRUeXBlID09ICdBbm5vdGF0b3JOb3RlcycpIHtcclxuICAgICAgICAgICAgY29tbWVudExhYmVsID0gJzxiPk5vdGU6PC9iPiAnO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29tbWVudExhYmVsID0gJzxiPicrVXRpbC5lc2NhcGVIVE1MKGNvbW1lbnRUeXBlKSsnOjwvYj4gJztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGNvbW1lbnQgKz0gY29tbWVudExhYmVsICsgVXRpbC5lc2NhcGVIVE1Md2l0aE5ld2xpbmVzKGNvbW1lbnRUZXh0KTtcclxuICAgICAgICAgIGlkdHlwZSA9ICdjb21tZW50XycgKyBjb21tZW50VHlwZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tbWVudFBvcHVwWzBdLmNsYXNzTmFtZSA9IGlkdHlwZTtcclxuICAgICAgICBjb21tZW50UG9wdXAuaHRtbChjb21tZW50KTtcclxuICAgICAgICBpZihzaG93VG9vbHRpcCkge1xyXG4gICAgICAgICAgYWRqdXN0VG9DdXJzb3IoZXZ0LCBjb21tZW50UG9wdXAsIDEwLCB0cnVlLCB0cnVlKTtcclxuICAgICAgICAgIGNsZWFyVGltZW91dChkaXNwbGF5Q29tbWVudFRpbWVyKTtcclxuICAgICAgICAgIC8qIHNsaWdodCBcInRvb2x0aXBcIiBkZWxheSB0byBhbGxvdyBoaWdobGlnaHRzIHRvIGJlIHNlZW5cclxuICAgICAgICAgICBiZWZvcmUgdGhlIHBvcHVwIG9ic3RydWN0cyB0aGVtLiAqL1xyXG4gICAgICAgICAgZGlzcGxheUNvbW1lbnRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGNvbW1lbnRQb3B1cC5zdG9wKHRydWUsIHRydWUpLmZhZGVJbigpO1xyXG4gICAgICAgICAgICBjb21tZW50RGlzcGxheWVkID0gdHJ1ZTtcclxuICAgICAgICAgIH0sIGltbWVkaWF0ZWx5ID8gMCA6IDUwMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gdG8gYXZvaWQgY2xvYmJlcmluZyBvbiBkZWxheWVkIHJlc3BvbnNlXHJcbiAgICAgIHZhciBjb21tZW50UG9wdXBOb3JtSW5mb1NlcUlkID0gMDtcclxuXHJcbiAgICAgIHZhciBub3JtSW5mb1NvcnRGdW5jdGlvbiA9IGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICAvLyBpbWFnZXMgYXQgdGhlIHRvcFxyXG4gICAgICAgIGlmIChhWzBdLnRvTG93ZXJDYXNlKCkgPT0gJzxpbWc+JykgcmV0dXJuIC0xO1xyXG4gICAgICAgIGlmIChiWzBdLnRvTG93ZXJDYXNlKCkgPT0gJzxpbWc+JykgcmV0dXJuIDE7XHJcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHN0YWJsZVxyXG4gICAgICAgIHJldHVybiBVdGlsLmNtcChhWzJdLGJbMl0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgZGlzcGxheVNwYW5Db21tZW50ID0gZnVuY3Rpb24oXHJcbiAgICAgICAgICBldnQsIHRhcmdldCwgc3BhbklkLCBzcGFuVHlwZSwgbW9kcywgc3BhblRleHQsIGNvbW1lbnRUZXh0LCBcclxuICAgICAgICAgIGNvbW1lbnRUeXBlLCBub3JtYWxpemF0aW9ucykge1xyXG5cclxuICAgICAgICB2YXIgaW1tZWRpYXRlbHkgPSBmYWxzZTtcclxuICAgICAgICB2YXIgY29tbWVudCA9ICggJzxkaXY+PHNwYW4gY2xhc3M9XCJjb21tZW50X3R5cGVfaWRfd3JhcHBlclwiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJjb21tZW50X3R5cGVcIj4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVXRpbC5lc2NhcGVIVE1MKFV0aWwuc3BhbkRpc3BsYXlGb3JtKHNwYW5UeXBlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYW5UeXBlKSkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPC9zcGFuPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJjb21tZW50X2lkXCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdJRDonK1V0aWwuZXNjYXBlSFRNTChzcGFuSWQpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJzwvc3Bhbj48L3NwYW4+JyApO1xyXG4gICAgICAgIGlmIChtb2RzLmxlbmd0aCkge1xyXG4gICAgICAgICAgY29tbWVudCArPSAnPGRpdj4nICsgVXRpbC5lc2NhcGVIVE1MKG1vZHMuam9pbignLCAnKSkgKyAnPC9kaXY+JztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbW1lbnQgKz0gJzwvZGl2Pic7XHJcbiAgICAgICAgY29tbWVudCArPSAoJzxkaXYgY2xhc3M9XCJjb21tZW50X3RleHRcIj5cIicgKyBcclxuICAgICAgICAgICAgICAgICAgICBVdGlsLmVzY2FwZUhUTUwoc3BhblRleHQpICsgXHJcbiAgICAgICAgICAgICAgICAgICAgJ1wiPC9kaXY+Jyk7XHJcbiAgICAgICAgdmFyIHZhbGlkQXJjVHlwZXNGb3JEcmFnID0gZGlzcGF0Y2hlci5wb3N0KCdnZXRWYWxpZEFyY1R5cGVzRm9yRHJhZycsIFtzcGFuSWQsIHNwYW5UeXBlXSk7XHJcbiAgICAgICAgaWYgKHZhbGlkQXJjVHlwZXNGb3JEcmFnICYmIHZhbGlkQXJjVHlwZXNGb3JEcmFnWzBdKSB7XHJcbiAgICAgICAgICBpZiAodmFsaWRBcmNUeXBlc0ZvckRyYWdbMF0ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvbW1lbnQgKz0gJzxkaXY+JyArIHZhbGlkQXJjVHlwZXNGb3JEcmFnWzBdLmpvaW4oJywgJykgKyAnPC9kaXY+JztcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICQoJ3JlY3RbZGF0YS1zcGFuLWlkPVwiJyArIHNwYW5JZCArICdcIl0nKS5hZGRDbGFzcygnYmFkVGFyZ2V0Jyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpbW1lZGlhdGVseSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHByb2Nlc3Mgbm9ybWFsaXphdGlvbnNcclxuICAgICAgICB2YXIgbm9ybXNUb1F1ZXJ5ID0gW107XHJcbiAgICAgICAgJC5lYWNoKG5vcm1hbGl6YXRpb25zLCBmdW5jdGlvbihub3JtTm8sIG5vcm0pIHtcclxuICAgICAgICAgIHZhciBkYk5hbWUgPSBub3JtWzBdLCBkYktleSA9IG5vcm1bMV07XHJcbiAgICAgICAgICBjb21tZW50ICs9ICggJzxoci8+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiY29tbWVudF9pZFwiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgIFV0aWwuZXNjYXBlSFRNTChkYk5hbWUpICsgJzonICtcclxuICAgICAgICAgICAgICAgICAgICAgICBVdGlsLmVzY2FwZUhUTUwoZGJLZXkpICsgJzwvc3Bhbj4nKTtcclxuICAgICAgICAgIGlmIChkYk5hbWUgaW4gbm9ybVNlcnZlckRiQnlOb3JtRGJOYW1lICYmXHJcbiAgICAgICAgICAgICAgbm9ybVNlcnZlckRiQnlOb3JtRGJOYW1lW2RiTmFtZV0gIT0gJzxOT05FPicpIHtcclxuICAgICAgICAgICAgLy8gREIgYXZhaWxhYmxlLCBhZGQgZHJvcC1vZmYgcG9pbnQgdG8gSFRNTCBhbmQgc3RvcmVcclxuICAgICAgICAgICAgLy8gcXVlcnkgcGFyYW1ldGVyc1xyXG4gICAgICAgICAgICBjb21tZW50UG9wdXBOb3JtSW5mb1NlcUlkKys7XHJcbiAgICAgICAgICAgIGNvbW1lbnQgKz0gKCc8YnIvPjxkaXYgaWQ9XCJub3JtX2luZm9fZHJvcF9wb2ludF8nK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50UG9wdXBOb3JtSW5mb1NlcUlkKydcIi8+Jyk7XHJcbiAgICAgICAgICAgIG5vcm1zVG9RdWVyeS5wdXNoKFtkYk5hbWUsIGRiS2V5LCBjb21tZW50UG9wdXBOb3JtSW5mb1NlcUlkXSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBubyBEQiwganVzdCBhdHRhY2ggXCJodW1hbi1yZWFkYWJsZVwiIHRleHQgcHJvdmlkZWRcclxuICAgICAgICAgICAgLy8gd2l0aCB0aGUgYW5ub3RhdGlvbiwgaWYgYW55XHJcbiAgICAgICAgICAgIGlmIChub3JtWzJdKSB7XHJcbiAgICAgICAgICAgICAgICBjb21tZW50ICs9ICgnPGJyLz48c3BhbiBjbGFzcz1cIm5vcm1faW5mb192YWx1ZVwiPicrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBVdGlsLmVzY2FwZUhUTUwobm9ybVsyXSkrJzwvc3Bhbj4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBkaXNwbGF5IGluaXRpYWwgY29tbWVudCBIVE1MXHJcbiAgICAgICAgaWYgKHNob3dUb29sdGlwKSB7XHJcbiAgICAgICAgICBkaXNwbGF5Q29tbWVudChldnQsIHRhcmdldCwgY29tbWVudCwgY29tbWVudFRleHQsIGNvbW1lbnRUeXBlLFxyXG4gICAgICAgICAgICAgIGltbWVkaWF0ZWx5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGluaXRpYXRlIEFKQVggY2FsbHMgZm9yIHRoZSBub3JtYWxpemF0aW9uIGRhdGEgdG8gcXVlcnlcclxuICAgICAgICAkLmVhY2gobm9ybXNUb1F1ZXJ5LCBmdW5jdGlvbihub3JtcU5vLCBub3JtcSkge1xyXG4gICAgICAgICAgLy8gVE9ETzogY2FjaGUgc29tZSBudW1iZXIgb2YgbW9zdCByZWNlbnQgbm9ybV9nZXRfZGF0YSByZXN1bHRzXHJcbiAgICAgICAgICB2YXIgZGJOYW1lID0gbm9ybXFbMF0sIGRiS2V5ID0gbm9ybXFbMV0sIGluZm9TZXFJZCA9IG5vcm1xWzJdO1xyXG4gICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdhamF4JywgW3tcclxuICAgICAgICAgICAgYWN0aW9uOiAnbm9ybURhdGEnLFxyXG4gICAgICAgICAgICBkYXRhYmFzZTogZGJOYW1lLFxyXG4gICAgICAgICAgICBrZXk6IGRiS2V5LFxyXG4gICAgICAgICAgICBjb2xsZWN0aW9uOiBjb2xsLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5leGNlcHRpb24pIHtcclxuICAgICAgICAgICAgICA7IC8vIFRPRE86IHJlc3BvbnNlIHRvIGVycm9yXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXJlc3BvbnNlLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgOyAvLyBUT0RPOiByZXNwb25zZSB0byBtaXNzaW5nIGtleVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIC8vIGV4dGVuZCBjb21tZW50IHBvcHVwIHdpdGggbm9ybWFsaXphdGlvbiBkYXRhXHJcbiAgICAgICAgICAgICAgbm9ybWluZm8gPSAnJztcclxuICAgICAgICAgICAgICAvLyBmbGF0dGVuIG91dGVyIChuYW1lLCBhdHRyLCBpbmZvKSBhcnJheSAoaWR4IGZvciBzb3J0KVxyXG4gICAgICAgICAgICAgIGluZm9zID0gW107XHJcbiAgICAgICAgICAgICAgdmFyIGlkeCA9IDA7XHJcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXNwb25zZS52YWx1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZXNwb25zZS52YWx1ZVtpXS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICB2YXIgbGFiZWwgPSByZXNwb25zZS52YWx1ZVtpXVtqXVswXTtcclxuICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcmVzcG9uc2UudmFsdWVbaV1bal1bMV07XHJcbiAgICAgICAgICAgICAgICAgIGluZm9zLnB1c2goW2xhYmVsLCB2YWx1ZSwgaWR4KytdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgLy8gc29ydCwgcHJpb3JpdGl6aW5nIGltYWdlcyAodG8gZ2V0IGZsb2F0cyByaWdodClcclxuICAgICAgICAgICAgICBpbmZvcyA9IGluZm9zLnNvcnQobm9ybUluZm9Tb3J0RnVuY3Rpb24pO1xyXG4gICAgICAgICAgICAgIC8vIGdlbmVyYXRlIEhUTUxcclxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZm9zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGFiZWwgPSBpbmZvc1tpXVswXTtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGluZm9zW2ldWzFdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhYmVsICYmIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgIC8vIHNwZWNpYWwgdHJlYXRtZW50IGZvciBzb21lIGxhYmVsIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICBpZiAobGFiZWwudG9Mb3dlckNhc2UoKSA9PSAnPGltZz4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW1hZ2VcclxuICAgICAgICAgICAgICAgICAgICBub3JtaW5mbyArPSAoJzxpbWcgY2xhc3M9XCJub3JtX2luZm9faW1nXCIgc3JjPVwiJytcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcIi8+Jyk7XHJcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9ybWFsLCBhcyB0ZXh0XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1heCBsZW5ndGggcmVzdHJpY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMzAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cigwLCAzMDApICsgJyAuLi4nO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBub3JtaW5mbyArPSAoJzxzcGFuIGNsYXNzPVwibm9ybV9pbmZvX2xhYmVsXCI+JytcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVXRpbC5lc2NhcGVIVE1MKGxhYmVsKStcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzwvc3Bhbj4nK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJub3JtX2luZm9fdmFsdWVcIj4nKyc6JytcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVXRpbC5lc2NhcGVIVE1MKHZhbHVlKStcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzwvc3Bhbj4nK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPGJyLz4nKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB2YXIgZHJvcD0kKCcjbm9ybV9pbmZvX2Ryb3BfcG9pbnRfJytpbmZvU2VxSWQpO1xyXG4gICAgICAgICAgICAgIGlmIChkcm9wKSB7XHJcbiAgICAgICAgICAgICAgICBkcm9wLmh0bWwobm9ybWluZm8pO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnbm9ybSBpbmZvIGRyb3AgcG9pbnQgbm90IGZvdW5kIScpOyAvL1RPRE8gWFhYXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgb25Eb2NDaGFuZ2VkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgY29tbWVudFBvcHVwLmhpZGUoKTtcclxuICAgICAgICBjb21tZW50RGlzcGxheWVkID0gZmFsc2U7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgZGlzcGxheUFyY0NvbW1lbnQgPSBmdW5jdGlvbihcclxuICAgICAgICAgIGV2dCwgdGFyZ2V0LCBzeW1tZXRyaWMsIGFyY0lkLFxyXG4gICAgICAgICAgb3JpZ2luU3BhbklkLCBvcmlnaW5TcGFuVHlwZSwgcm9sZSwgXHJcbiAgICAgICAgICB0YXJnZXRTcGFuSWQsIHRhcmdldFNwYW5UeXBlLFxyXG4gICAgICAgICAgY29tbWVudFRleHQsIGNvbW1lbnRUeXBlKSB7XHJcbiAgICAgICAgdmFyIGFyY1JvbGUgPSB0YXJnZXQuYXR0cignZGF0YS1hcmMtcm9sZScpO1xyXG4gICAgICAgIC8vIGluIGFycm93U3RyLCAmIzgyMTIgPT0gbWRhc2gsICYjODU5NCA9PSBVbmljb2RlIHJpZ2h0IGFycm93XHJcbiAgICAgICAgdmFyIGFycm93U3RyID0gc3ltbWV0cmljID8gJyYjODIxMjsnIDogJyYjODU5NDsnO1xyXG4gICAgICAgIHZhciBhcmNEaXNwbGF5Rm9ybSA9IFV0aWwuYXJjRGlzcGxheUZvcm0oc3BhblR5cGVzLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc3BhbnNbb3JpZ2luU3BhbklkXS50eXBlLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyY1JvbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxhdGlvblR5cGVzSGFzaCk7XHJcbiAgICAgICAgdmFyIGNvbW1lbnQgPSBcIlwiO1xyXG4gICAgICAgIGNvbW1lbnQgKz0gKCc8c3BhbiBjbGFzcz1cImNvbW1lbnRfdHlwZV9pZF93cmFwcGVyXCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiY29tbWVudF90eXBlXCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgVXRpbC5lc2NhcGVIVE1MKFV0aWwuc3BhbkRpc3BsYXlGb3JtKHNwYW5UeXBlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luU3BhblR5cGUpKSArXHJcbiAgICAgICAgICAgICAgICAgICAgJyAnICsgYXJyb3dTdHIgKyAnICcgK1xyXG4gICAgICAgICAgICAgICAgICAgIFV0aWwuZXNjYXBlSFRNTChhcmNEaXNwbGF5Rm9ybSkgK1xyXG4gICAgICAgICAgICAgICAgICAgICcgJyArIGFycm93U3RyICsgJyAnICtcclxuICAgICAgICAgICAgICAgICAgICBVdGlsLmVzY2FwZUhUTUwoVXRpbC5zcGFuRGlzcGxheUZvcm0oc3BhblR5cGVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRTcGFuVHlwZSkpICtcclxuICAgICAgICAgICAgICAgICAgICAnPC9zcGFuPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cImNvbW1lbnRfaWRcIj4nICtcclxuICAgICAgICAgICAgICAgICAgICAoYXJjSWQgPyAnSUQ6JythcmNJZCA6IFxyXG4gICAgICAgICAgICAgICAgICAgICBVdGlsLmVzY2FwZUhUTUwob3JpZ2luU3BhbklkKSArXHJcbiAgICAgICAgICAgICAgICAgICAgIGFycm93U3RyICsgXHJcbiAgICAgICAgICAgICAgICAgICAgIFV0aWwuZXNjYXBlSFRNTCh0YXJnZXRTcGFuSWQpKSArXHJcbiAgICAgICAgICAgICAgICAgICAgJzwvc3Bhbj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPC9zcGFuPicpO1xyXG4gICAgICAgIGNvbW1lbnQgKz0gKCc8ZGl2IGNsYXNzPVwiY29tbWVudF90ZXh0XCI+JyArIFxyXG4gICAgICAgICAgICAgICAgICAgIFV0aWwuZXNjYXBlSFRNTCgnXCInK2RhdGEuc3BhbnNbb3JpZ2luU3BhbklkXS50ZXh0KydcIicpICtcclxuICAgICAgICAgICAgICAgICAgICBhcnJvd1N0ciArXHJcbiAgICAgICAgICAgICAgICAgICAgVXRpbC5lc2NhcGVIVE1MKCdcIicrZGF0YS5zcGFuc1t0YXJnZXRTcGFuSWRdLnRleHQgKyAnXCInKSArXHJcbiAgICAgICAgICAgICAgICAgICAgJzwvZGl2PicpO1xyXG4gICAgICAgIGRpc3BsYXlDb21tZW50KGV2dCwgdGFyZ2V0LCBjb21tZW50LCBjb21tZW50VGV4dCwgY29tbWVudFR5cGUpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdmFyIGRpc3BsYXlTZW50Q29tbWVudCA9IGZ1bmN0aW9uKFxyXG4gICAgICAgICAgZXZ0LCB0YXJnZXQsIGNvbW1lbnRUZXh0LCBjb21tZW50VHlwZSkge1xyXG4gICAgICAgIGRpc3BsYXlDb21tZW50KGV2dCwgdGFyZ2V0LCAnJywgY29tbWVudFRleHQsIGNvbW1lbnRUeXBlKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciBoaWRlQ29tbWVudCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dChkaXNwbGF5Q29tbWVudFRpbWVyKTtcclxuICAgICAgICBpZiAoY29tbWVudERpc3BsYXllZCkge1xyXG4gICAgICAgICAgY29tbWVudFBvcHVwLnN0b3AodHJ1ZSwgdHJ1ZSkuZmFkZU91dChmdW5jdGlvbigpIHsgY29tbWVudERpc3BsYXllZCA9IGZhbHNlOyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgb25Nb3VzZU1vdmUgPSBmdW5jdGlvbihldnQpIHtcclxuICAgICAgICBpZiAoY29tbWVudERpc3BsYXllZCAmJiBzaG93VG9vbHRpcCkge1xyXG4gICAgICAgICAgYWRqdXN0VG9DdXJzb3IoZXZ0LCBjb21tZW50UG9wdXAsIDEwLCB0cnVlLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvKiBFTkQgY29tbWVudCBwb3B1cCAtIHJlbGF0ZWQgKi9cclxuXHJcblxyXG4gICAgICAvKiBTVEFSVCBmb3JtIG1hbmFnZW1lbnQgLSByZWxhdGVkICovXHJcbiAgICAgIGluaXRGb3JtID0gZnVuY3Rpb24oZm9ybSwgb3B0cykge1xyXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xyXG4gICAgICAgIHZhciBmb3JtSWQgPSBmb3JtLmF0dHIoJ2lkJyk7XHJcblxyXG4gICAgICAgIC8vIGFsc29SZXNpemUgaXMgc3BlY2lhbFxyXG4gICAgICAgIHZhciBhbHNvUmVzaXplID0gb3B0cy5hbHNvUmVzaXplO1xyXG4gICAgICAgIGRlbGV0ZSBvcHRzLmFsc29SZXNpemU7XHJcblxyXG4gICAgICAgIC8vIEFsd2F5cyBhZGQgT0sgYW5kIENhbmNlbFxyXG4gICAgICAgIHZhciBidXR0b25zID0gKG9wdHMuYnV0dG9ucyB8fCBbXSk7XHJcbiAgICAgICAgaWYgKG9wdHMubm9fb2spIHtcclxuICAgICAgICAgIGRlbGV0ZSBvcHRzLm5vX29rO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBidXR0b25zLnB1c2goe1xyXG4gICAgICAgICAgICAgIGlkOiBmb3JtSWQgKyBcIi1va1wiLFxyXG4gICAgICAgICAgICAgIHRleHQ6IFwiT0tcIixcclxuICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24oKSB7IGZvcm0uc3VibWl0KCk7IH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRzLm5vX2NhbmNlbCkge1xyXG4gICAgICAgICAgZGVsZXRlIG9wdHMubm9fY2FuY2VsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBidXR0b25zLnB1c2goe1xyXG4gICAgICAgICAgICAgIGlkOiBmb3JtSWQgKyBcIi1jYW5jZWxcIixcclxuICAgICAgICAgICAgICB0ZXh0OiBcIkNhbmNlbFwiLFxyXG4gICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigpIHsgZm9ybS5kaWFsb2coJ2Nsb3NlJyk7IH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlbGV0ZSBvcHRzLmJ1dHRvbnM7XHJcblxyXG4gICAgICAgIG9wdHMgPSAkLmV4dGVuZCh7XHJcbiAgICAgICAgICAgIGF1dG9PcGVuOiBmYWxzZSxcclxuICAgICAgICAgICAgY2xvc2VPbkVzY2FwZTogdHJ1ZSxcclxuICAgICAgICAgICAgYnV0dG9uczogYnV0dG9ucyxcclxuICAgICAgICAgICAgbW9kYWw6IHRydWVcclxuICAgICAgICAgIH0sIG9wdHMpO1xyXG5cclxuICAgICAgICBmb3JtLmRpYWxvZyhvcHRzKTtcclxuICAgICAgICBmb3JtLmJpbmQoJ2RpYWxvZ2Nsb3NlJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBpZiAoZm9ybSA9PSBjdXJyZW50Rm9ybSkge1xyXG4gICAgICAgICAgICBjdXJyZW50Rm9ybSA9IG51bGw7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIEhBQ0s6IGpRdWVyeSBVSSdzIGRpYWxvZyBkb2VzIG5vdCBzdXBwb3J0IGFsc29SZXNpemVcclxuICAgICAgICAvLyBub3IgZG9lcyByZXNpemFibGUgc3VwcG9ydCBhIGpRdWVyeSBvYmplY3Qgb2Ygc2V2ZXJhbFxyXG4gICAgICAgIC8vIGVsZW1lbnRzXHJcbiAgICAgICAgLy8gU2VlOiBodHRwOi8vYnVncy5qcXVlcnl1aS5jb20vdGlja2V0LzQ2NjZcclxuICAgICAgICBpZiAoYWxzb1Jlc2l6ZSkge1xyXG4gICAgICAgICAgZm9ybS5wYXJlbnQoKS5yZXNpemFibGUoJ29wdGlvbicsICdhbHNvUmVzaXplJyxcclxuICAgICAgICAgICAgICAnIycgKyBmb3JtLmF0dHIoJ2lkJykgKyAnLCAnICsgYWxzb1Jlc2l6ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgdmFyIHNob3dGb3JtID0gZnVuY3Rpb24oZm9ybSkge1xyXG4gICAgICAgIGN1cnJlbnRGb3JtID0gZm9ybTtcclxuICAgICAgICBpZighb3ZlcldyaXRlTW9kYWxzKXtcclxuICAgICAgICAgIC8vIGFzIHN1Z2dlc3RlZCBpbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI2NTcwNzYvanF1ZXJ5LXVpLWRpYWxvZy1maXhlZC1wb3NpdGlvbmluZ1xyXG4gICAgICAgICAgZm9ybS5wYXJlbnQoKS5jc3Moe3Bvc2l0aW9uOlwiZml4ZWRcIn0pO1xyXG4gICAgICAgICAgZm9ybS5kaWFsb2coJ29wZW4nKTtcclxuICAgICAgICAgIHNsaWRlVG9nZ2xlKCQoJyNwdWxsZG93bicpLnN0b3AoKSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZm9ybTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciBoaWRlRm9ybSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICghY3VycmVudEZvcm0pIHJldHVybjtcclxuICAgICAgICAvLyBjdXJyZW50Rm9ybS5mYWRlT3V0KGZ1bmN0aW9uKCkgeyBjdXJyZW50Rm9ybSA9IG51bGw7IH0pO1xyXG4gICAgICAgIGN1cnJlbnRGb3JtLmRpYWxvZygnY2xvc2UnKTtcclxuICAgICAgICBjdXJyZW50Rm9ybSA9IG51bGw7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvKiBFTkQgZm9ybSBtYW5hZ2VtZW50IC0gcmVsYXRlZCAqL1xyXG5cclxuXHJcbiAgICAgIC8qIFNUQVJUIGNvbGxlY3Rpb24gYnJvd3NlciAtIHJlbGF0ZWQgKi9cclxuXHJcbiAgICAgIHZhciBzZWxlY3RFbGVtZW50SW5UYWJsZSA9IGZ1bmN0aW9uKHRhYmxlLCBkb2NuYW1lLCBtZikge1xyXG4gICAgICAgIHRhYmxlID0gJCh0YWJsZSk7XHJcbiAgICAgICAgdGFibGUuZmluZCgndHInKS5yZW1vdmVDbGFzcygnc2VsZWN0ZWQnKTtcclxuICAgICAgICB2YXIgc2VsID0gJ3RyJztcclxuICAgICAgICB2YXIgJGVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKGRvY25hbWUpIHtcclxuICAgICAgICAgIHNlbCArPSAnW2RhdGEtZG9jPVwiJyArIGRvY25hbWUgKyAnXCJdJztcclxuICAgICAgICAgIGlmIChtZikge1xyXG4gICAgICAgICAgICBzZWwgKz0gJ1tkYXRhLW1mPVwiJyArIFV0aWwucGFyYW1BcnJheShtZikgKyAnXCJdJztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHZhciAkZWxlbWVudCA9IHRhYmxlLmZpbmQoc2VsKS5maXJzdCgpO1xyXG4gICAgICAgICAgJGVsZW1lbnQuYWRkQ2xhc3MoJ3NlbGVjdGVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1hdGNoRm9jdXMgPSAkZWxlbWVudCAmJiAkZWxlbWVudC5hdHRyKCdkYXRhLW1mJyk7XHJcbiAgICAgICAgbWF0Y2hlcyA9ICRlbGVtZW50ICYmICRlbGVtZW50LmF0dHIoJ2RhdGEtbWF0Y2gnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGNob29zZURvY3VtZW50ID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgdmFyICRlbGVtZW50ID0gJChldnQudGFyZ2V0KS5jbG9zZXN0KCd0cicpO1xyXG4gICAgICAgICQoJyNkb2N1bWVudF9zZWxlY3QgdHInKS5yZW1vdmVDbGFzcygnc2VsZWN0ZWQnKTtcclxuICAgICAgICAkKCcjZG9jdW1lbnRfaW5wdXQnKS52YWwoJGVsZW1lbnQuYXR0cignZGF0YS1kb2MnKSk7XHJcblxyXG4gICAgICAgICRlbGVtZW50LmFkZENsYXNzKCdzZWxlY3RlZCcpO1xyXG4gICAgICAgIG1hdGNoRm9jdXMgPSAkZWxlbWVudC5hdHRyKCdkYXRhLW1mJyk7XHJcbiAgICAgICAgbWF0Y2hlcyA9ICRlbGVtZW50LmF0dHIoJ2RhdGEtbWF0Y2gnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGNob29zZURvY3VtZW50QW5kU3VibWl0ID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgY2hvb3NlRG9jdW1lbnQoZXZ0KTtcclxuICAgICAgICBmaWxlQnJvd3NlclN1Ym1pdChldnQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgZmlsZUJyb3dzZXIgPSAkKCcjY29sbGVjdGlvbl9icm93c2VyJyk7XHJcbiAgICAgIGluaXRGb3JtKGZpbGVCcm93c2VyLCB7XHJcbiAgICAgICAgICBhbHNvUmVzaXplOiAnI2RvY3VtZW50X3NlbGVjdCcsXHJcbiAgICAgICAgICBjbG9zZTogZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgICAgIGlmICghZG9jKSB7XHJcbiAgICAgICAgICAgICAgLy8gbm8gZG9jdW1lbnQ7IHNldCBhbmQgc2hvdyB0aGUgcmVsZXZhbnQgbWVzc2FnZSwgYW5kXHJcbiAgICAgICAgICAgICAgLy8gY2xlYXIgdGhlIFwiYmxpbmRcIiB1bmxlc3Mgd2FpdGluZyBmb3IgYSBjb2xsZWN0aW9uXHJcbiAgICAgICAgICAgICAgaWYgKGZpbGVCcm93c2VyQ2xvc2VkV2l0aFN1Ym1pdCkge1xyXG4gICAgICAgICAgICAgICAgJCgnI25vX2RvY3VtZW50X21lc3NhZ2UnKS5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgICAkKCcjbG9hZGluZ19tZXNzYWdlJykuc2hvdygpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAkKCcjbG9hZGluZ19tZXNzYWdlJykuaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgJCgnI25vX2RvY3VtZW50X21lc3NhZ2UnKS5zaG93KCk7XHJcbiAgICAgICAgICAgICAgICAkKCcjd2FpdGVyJykuZGlhbG9nKCdjbG9zZScpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBzaG93Tm9Eb2NNZXNzYWdlKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWZpbGVCcm93c2VyQ2xvc2VkV2l0aFN1Ym1pdCAmJiAhc2VhcmNoQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdzZXRBcmd1bWVudHMnLCBbe30sIHRydWVdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHdpZHRoOiA1MDBcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvKiBYWFggcmVtb3ZlZCBwZXIgIzkwMFxyXG4gICAgICAvLyBpbnNlcnQgdGhlIFNhdmUgbGlua1xyXG4gICAgICB2YXIgJGZpbGVCcm93c2VyQnV0dG9uc2V0ID0gZmlsZUJyb3dzZXIuXHJcbiAgICAgICAgICBwYXJlbnQoKS5maW5kKCcudWktZGlhbG9nLWJ1dHRvbnBhbmUgLnVpLWRpYWxvZy1idXR0b25zZXQnKS5wcmVwZW5kKCcgJyk7XHJcbiAgICAgICQoJzxhIGhyZWY9XCJhamF4LmNnaT9hY3Rpb249ZG93bmxvYWRTZWFyY2hGaWxlXCIgaWQ9XCJzYXZlX3NlYXJjaFwiPlNhdmU8L2E+JykuXHJcbiAgICAgICAgICBwcmVwZW5kVG8oJGZpbGVCcm93c2VyQnV0dG9uc2V0KS5idXR0b24oKS5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xyXG4gICAgICAqL1xyXG5cclxuICAgICAgdmFyIGRvY0lucHV0SGFuZGxlciA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgIHNlbGVjdEVsZW1lbnRJblRhYmxlKCcjZG9jdW1lbnRfc2VsZWN0JywgJCh0aGlzKS52YWwoKSk7XHJcbiAgICAgIH07XHJcbiAgICAgICQoJyNkb2N1bWVudF9pbnB1dCcpLmtleXVwKGRvY0lucHV0SGFuZGxlcik7XHJcblxyXG4gICAgICB2YXIgZmlsZUJyb3dzZXJTdWJtaXQgPSBmdW5jdGlvbihldnQpIHtcclxuICAgICAgICB2YXIgX2NvbGwsIF9kb2MsIF9hcmdzLCBmb3VuZDtcclxuICAgICAgICB2YXIgaW5wdXQgPSAkKCcjZG9jdW1lbnRfaW5wdXQnKS5cclxuICAgICAgICAgICAgdmFsKCkuXHJcbiAgICAgICAgICAgIHJlcGxhY2UoL1xcLz9cXHMrJC8sICcnKS5cclxuICAgICAgICAgICAgcmVwbGFjZSgvXlxccysvLCAnJyk7XHJcbiAgICAgICAgaWYgKCFpbnB1dC5sZW5ndGgpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKDAsIDIpID09PSAnLi4nKSB7XHJcbiAgICAgICAgICAvLyAuLlxyXG4gICAgICAgICAgdmFyIHBvcyA9IGNvbGwuc3Vic3RyKDAsIGNvbGwubGVuZ3RoIC0gMSkubGFzdEluZGV4T2YoJy8nKTtcclxuICAgICAgICAgIGlmIChwb3MgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIGRpc3BhdGNoZXIucG9zdCgnbWVzc2FnZXMnLCBbW1snQXQgdGhlIHJvb3QnLCAnZXJyb3InLCAyXV1dKTtcclxuICAgICAgICAgICAgJCgnI2RvY3VtZW50X2lucHV0JykuZm9jdXMoKS5zZWxlY3QoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgX2NvbGwgPSBjb2xsLnN1YnN0cigwLCBwb3MgKyAxKTtcclxuICAgICAgICAgICAgX2RvYyA9ICcnO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoZm91bmQgPSBpbnB1dC5tYXRjaCgvXihcXC8/KSgoPzpbXlxcL10qXFwvKSopKFteXFwvP10qKSQvKSkge1xyXG4gICAgICAgICAgdmFyIGFicyA9IGZvdW5kWzFdO1xyXG4gICAgICAgICAgdmFyIGNvbGxuYW1lID0gZm91bmRbMl0uc3Vic3RyKDAsIGZvdW5kWzJdLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgdmFyIGRvY25hbWUgPSBmb3VuZFszXTtcclxuICAgICAgICAgIGlmIChhYnMpIHtcclxuICAgICAgICAgICAgX2NvbGwgPSBhYnMgKyBjb2xsbmFtZTtcclxuICAgICAgICAgICAgaWYgKF9jb2xsLmxlbmd0aCA8IDIpIGNvbGwgKz0gJy8nO1xyXG4gICAgICAgICAgICBfZG9jID0gZG9jbmFtZTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChjb2xsbmFtZSkgY29sbG5hbWUgKz0gJy8nO1xyXG4gICAgICAgICAgICBfY29sbCA9IGNvbGwgKyBjb2xsbmFtZTtcclxuICAgICAgICAgICAgX2RvYyA9IGRvY25hbWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGRpc3BhdGNoZXIucG9zdCgnbWVzc2FnZXMnLCBbW1snSW52YWxpZCBkb2N1bWVudCBuYW1lIGZvcm1hdCcsICdlcnJvcicsIDJdXV0pO1xyXG4gICAgICAgICAgJCgnI2RvY3VtZW50X2lucHV0JykuZm9jdXMoKS5zZWxlY3QoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZG9jU2Nyb2xsID0gJCgnI2RvY3VtZW50X3NlbGVjdCcpWzBdLnNjcm9sbFRvcDtcclxuICAgICAgICBmaWxlQnJvd3Nlci5maW5kKCcjZG9jdW1lbnRfc2VsZWN0IHRib2R5JykuZW1wdHkoKTtcclxuXHJcbiAgICAgICAgaWYgKGNvbGwgIT0gX2NvbGwgfHwgZG9jICE9IF9kb2MgfHxcclxuICAgICAgICAgICAgVXRpbC5wYXJhbUFycmF5KGFyZ3MubWF0Y2hmb2N1cykgIT0gbWF0Y2hGb2N1cykge1xyXG4gICAgICAgICAgLy8gc29tZXRoaW5nIGNoYW5nZWRcclxuXHJcbiAgICAgICAgICAvLyBzZXQgdG8gYWxsb3cga2VlcGluZyBcImJsaW5kXCIgZG93biBkdXJpbmcgcmVsb2FkXHJcbiAgICAgICAgICBmaWxlQnJvd3NlckNsb3NlZFdpdGhTdWJtaXQgPSB0cnVlO1xyXG4gICAgICAgICAgLy8gLi4uIGFuZCBjaGFuZ2UgQkcgbWVzc2FnZSB0byBhIG1vcmUgYXBwcm9wcmlhdGUgb25lXHJcblxyXG4gICAgICAgICAgLy8gdHJpZ2dlciBjbGVhciBhbmQgY2hhbmdlcyBpZiBzb21ldGhpbmcgb3RoZXIgdGhhbiB0aGVcclxuICAgICAgICAgIC8vIGN1cnJlbnQgdGhpbmcgaXMgY2hvc2VuLCBidXQgb25seSBibGFuayBzY3JlZW4gYmVmb3JlXHJcbiAgICAgICAgICAvLyByZW5kZXIgaWYgdGhlIGRvY3VtZW50IGNoYW5nZWQgKHByZXZlbnQgXCJmbGlja2VyXCIgb25cclxuICAgICAgICAgIC8vIGUuZy4gcGlja2luZyBzZWFyY2ggcmVzdWx0cylcclxuICAgICAgICAgIGlmIChjb2xsICE9IF9jb2xsIHx8IGRvYyAhPSBfZG9jKSB7XHJcbiAgICAgICAgICAgIGRpc3BhdGNoZXIucG9zdCgnY2xlYXJTVkcnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGRpc3BhdGNoZXIucG9zdCgnYWxsb3dSZWxvYWRCeVVSTCcpO1xyXG4gICAgICAgICAgdmFyIG5ld0FyZ3MgPSBbXTtcclxuICAgICAgICAgIGlmIChtYXRjaEZvY3VzKSBuZXdBcmdzLnB1c2goJ21hdGNoZm9jdXM9JyArIG1hdGNoRm9jdXMpO1xyXG4gICAgICAgICAgaWYgKG1hdGNoZXMpIG5ld0FyZ3MucHVzaCgnbWF0Y2g9JyArIG1hdGNoZXMpO1xyXG4gICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdzZXRDb2xsZWN0aW9uJywgW19jb2xsLCBfZG9jLCBVdGlsLmRlcGFyYW0obmV3QXJncy5qb2luKCcmJykpXSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIGhpZGUgZXZlbiBvbiBzZWxlY3QgY3VycmVudCB0aGluZ1xyXG4gICAgICAgICAgaGlkZUZvcm0oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9O1xyXG4gICAgICBmaWxlQnJvd3Nlci5cclxuICAgICAgICAgIHN1Ym1pdChmaWxlQnJvd3NlclN1Ym1pdCkuXHJcbiAgICAgICAgICBiaW5kKCdyZXNldCcsIGhpZGVGb3JtKTtcclxuXHJcbiAgICAgIHZhciBmaWxlQnJvd3NlcldhaXRpbmcgPSBmYWxzZTtcclxuICAgICAgdmFyIHNob3dGaWxlQnJvd3NlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vIGtlZXAgdGFicyBvbiBob3cgdGhlIGJyb3dzZXIgaXMgY2xvc2VkOyB3ZSBuZWVkIHRvIGtlZXAgdGhlXHJcbiAgICAgICAgLy8gXCJibGluZFwiIHVwIHdoZW4gcmV0cmlldmluZyBhIGNvbGxlY3Rpb24sIGJ1dCBub3Qgd2hlbiBjYW5jZWxpbmdcclxuICAgICAgICAvLyB3aXRob3V0IHNlbGVjdGlvbiAod291bGQgaGFuZyB0aGUgVUkpXHJcblxyXG4vLyBCUkFUIFNUQU5EQUxPTkUgTElCUkFSWSBCRUdJTlxyXG4vKlxyXG4gICAgICAgIGZpbGVCcm93c2VyQ2xvc2VkV2l0aFN1Ym1pdCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvLyBubyBwb2ludCBpbiBzaG93aW5nIHRoaXMgd2hpbGUgdGhlIGJyb3dzZXIgaXMgc2hvd25cclxuICAgICAgICBoaWRlTm9Eb2NNZXNzYWdlKCk7XHJcblxyXG4gICAgICAgIGlmIChjdXJyZW50Rm9ybSA9PSB0dXRvcmlhbEZvcm0pIHtcclxuICAgICAgICAgIGZpbGVCcm93c2VyV2FpdGluZyA9IHRydWU7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbGVCcm93c2VyV2FpdGluZyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvLyBoaWRlIFwibm8gZG9jdW1lbnRcIiBtZXNzYWdlIHdoZW4gZmlsZSBicm93c2VyIHNob3duXHJcbiAgICAgICAgLy8gVE9ETzogY2FuJ3QgbWFrZSB0aGlzIHdvcms7IEkgY2FuJ3QgZGV0ZWN0IHdoZW4gaXQgZ2V0cyBoaWRkZW4uXHJcbiAgICAgICAgLy8gaGlkZU5vRG9jTWVzc2FnZSgpO1xyXG5cclxuICAgICAgICBpZiAoIShzZWxlY3RvckRhdGEgJiYgc2hvd0Zvcm0oZmlsZUJyb3dzZXIpKSkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICB2YXIgaHRtbCA9IFsnPHRyPjx0aC8+J107XHJcbiAgICAgICAgdmFyIHRib2R5O1xyXG4gICAgICAgICQuZWFjaChzZWxlY3RvckRhdGEuaGVhZGVyLCBmdW5jdGlvbihoZWFkTm8sIGhlYWQpIHtcclxuICAgICAgICAgIGh0bWwucHVzaCgnPHRoPicgKyBoZWFkWzBdICsgJzwvdGg+Jyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaHRtbC5wdXNoKCc8L3RyPicpO1xyXG4gICAgICAgICQoJyNkb2N1bWVudF9zZWxlY3QgdGhlYWQnKS5odG1sKGh0bWwuam9pbignJykpO1xyXG5cclxuICAgICAgICBodG1sID0gW107XHJcbiAgICAgICAgLy8gTk9URTogd2Ugc2VlbSB0byBoYXZlIHNvbWUgZXhjZXNzaXZlIHNvcnRpbmcgZ29pbmcgb247XHJcbiAgICAgICAgLy8gZGlzYWJsaW5nIHRoaXMgYXMgYSB0ZXN0LiBJZiBldmVyeXRoaW5nIHdvcmtzLCBqdXN0IHJlbW92ZVxyXG4gICAgICAgIC8vIHRoZSBmb2xsb3dpbmcgY29tbWVudGVkLW91dCBsaW5lIChhbmQgdGhpcyBjb21tZW50KTpcclxuICAgICAgICAvL3NlbGVjdG9yRGF0YS5pdGVtcy5zb3J0KGRvY1NvcnRGdW5jdGlvbik7XHJcbiAgICAgICAgJC5lYWNoKHNlbGVjdG9yRGF0YS5pdGVtcywgZnVuY3Rpb24oZG9jTm8sIGRvYykge1xyXG4gICAgICAgICAgdmFyIGlzQ29sbCA9IGRvY1swXSA9PSBcImNcIjsgLy8gXCJjb2xsZWN0aW9uXCJcclxuICAgICAgICAgIC8vIHNlY29uZCBjb2x1bW4gaXMgb3B0aW9uYWwgYW5ub3RhdGlvbi1zcGVjaWZpYyBwb2ludGVyLFxyXG4gICAgICAgICAgLy8gdXNlZCAoYXQgbGVhc3QpIGZvciBzZWFyY2ggcmVzdWx0c1xyXG4gICAgICAgICAgdmFyIGFubnAgPSBkb2NbMV0gPyAoJz8nICsgVXRpbC5lc2NhcGVIVE1MKFV0aWwucGFyYW0oZG9jWzFdKSkpIDogJyc7XHJcbiAgICAgICAgICB2YXIgbmFtZSA9IFV0aWwuZXNjYXBlSFRNTChkb2NbMl0pO1xyXG4gICAgICAgICAgdmFyIGNvbGxGaWxlID0gaXNDb2xsID8gJ2NvbGxlY3Rpb24nIDogJ2ZpbGUnO1xyXG4gICAgICAgICAgLy92YXIgY29sbEZpbGVJbWcgPSBpc0NvbGwgPyAnaWNfbGlzdF9mb2xkZXIucG5nJyA6ICdpY19saXN0X2RyYWZ0cy5wbmcnO1xyXG4gICAgICAgICAgLy92YXIgY29sbEZpbGVJbWcgPSBpc0NvbGwgPyAnRnVndWUtZm9sZGVyLWhvcml6b250YWwtb3Blbi5wbmcnIDogJ0Z1Z3VlLWRvY3VtZW50LnBuZyc7XHJcbiAgICAgICAgICB2YXIgY29sbEZpbGVJbWcgPSBpc0NvbGwgPyAnRnVndWUtc2hhZG93bGVzcy1mb2xkZXItaG9yaXpvbnRhbC1vcGVuLnBuZycgOiAnRnVndWUtc2hhZG93bGVzcy1kb2N1bWVudC5wbmcnO1xyXG4gICAgICAgICAgdmFyIGNvbGxTdWZmaXggPSBpc0NvbGwgPyAnLycgOiAnJztcclxuICAgICAgICAgIGlmIChkb2NbMV0pIHtcclxuICAgICAgICAgICAgdmFyIG1hdGNoZm9jdXMgPSBkb2NbMV0ubWF0Y2hmb2N1cyB8fCBbXTtcclxuICAgICAgICAgICAgdmFyIG1mc3RyID0gJyBkYXRhLW1mPVwiJyArIFV0aWwucGFyYW1BcnJheShtYXRjaGZvY3VzKSArICdcIic7XHJcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IGRvY1sxXS5tYXRjaCB8fCBbXTtcclxuICAgICAgICAgICAgdmFyIG1hdGNoc3RyID0gJyBkYXRhLW1hdGNoPVwiJyArIFV0aWwucGFyYW1BcnJheShtYXRjaCkgKyAnXCInO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIG1hdGNoc3RyID0gJyc7XHJcbiAgICAgICAgICAgIHZhciBtZnN0ciA9ICcnO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaHRtbC5wdXNoKCc8dHIgY2xhc3M9XCInICsgY29sbEZpbGUgKyAnXCIgZGF0YS1kb2M9XCInXHJcbiAgICAgICAgICAgICsgbmFtZSArIGNvbGxTdWZmaXggKyAnXCInICsgbWF0Y2hzdHIgKyBtZnN0ciArICc+Jyk7XHJcbiAgICAgICAgICBodG1sLnB1c2goJzx0aD48aW1nIHNyYz1cInN0YXRpYy9pbWcvJyArIGNvbGxGaWxlSW1nICsgJ1wiIGFsdD1cIicgKyBjb2xsRmlsZSArICdcIi8+PC90aD4nKTtcclxuICAgICAgICAgIGh0bWwucHVzaCgnPHRoPicgKyBuYW1lICsgY29sbFN1ZmZpeCArICc8L3RoPicpO1xyXG4gICAgICAgICAgdmFyIGxlbiA9IHNlbGVjdG9yRGF0YS5oZWFkZXIubGVuZ3RoIC0gMTtcclxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHR5cGUgPSBzZWxlY3RvckRhdGEuaGVhZGVyW2kgKyAxXVsxXTtcclxuICAgICAgICAgICAgdmFyIGRhdHVtID0gZG9jW2kgKyAzXTtcclxuICAgICAgICAgICAgLy8gZm9ybWF0IHJlc3QgYWNjb3JkaW5nIHRvIFwiZGF0YSB0eXBlXCIgc3BlY2lmaWVkIGluIGhlYWRlclxyXG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVkID0gbnVsbDtcclxuICAgICAgICAgICAgdmFyIGNzc0NsYXNzID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKCF0eXBlKSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignTWlzc2luZyBkb2N1bWVudCBsaXN0IGRhdGEgdHlwZScpO1xyXG4gICAgICAgICAgICAgIGZvcm1hdHRlZCA9IGRhdHVtO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRhdHVtID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICBmb3JtYXR0ZWQgPSAnJztcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgIGZvcm1hdHRlZCA9IFV0aWwuZXNjYXBlSFRNTChkYXR1bSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZy1yaWdodCcgfHwgdHlwZSA9PT0gJ3N0cmluZy1yZXZlcnNlJykge1xyXG4gICAgICAgICAgICAgIGZvcm1hdHRlZCA9IFV0aWwuZXNjYXBlSFRNTChkYXR1bSk7XHJcbiAgICAgICAgICAgICAgY3NzQ2xhc3MgPSAncmlnaHRhbGlnbic7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZy1jZW50ZXInKSB7XHJcbiAgICAgICAgICAgICAgZm9ybWF0dGVkID0gVXRpbC5lc2NhcGVIVE1MKGRhdHVtKTtcclxuICAgICAgICAgICAgICBjc3NDbGFzcyA9ICdjZW50ZXJhbGlnbic7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RpbWUnKSB7XHJcbiAgICAgICAgICAgICAgZm9ybWF0dGVkID0gVXRpbC5mb3JtYXRUaW1lQWdvKGRhdHVtICogMTAwMCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Zsb2F0Jykge1xyXG4gICAgICAgICAgICAgIHR5cGUgPSBkZWZhdWx0RmxvYXRGb3JtYXQ7XHJcbiAgICAgICAgICAgICAgY3NzQ2xhc3MgPSAncmlnaHRhbGlnbic7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2ludCcpIHtcclxuICAgICAgICAgICAgICBmb3JtYXR0ZWQgPSAnJyArIGRhdHVtO1xyXG4gICAgICAgICAgICAgIGNzc0NsYXNzID0gJ3JpZ2h0YWxpZ24nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmb3JtYXR0ZWQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICB2YXIgbSA9IHR5cGUubWF0Y2goL14oLio/KSg/OlxcLyhyaWdodCkpPyQvKTtcclxuICAgICAgICAgICAgICBjc3NDbGFzcyA9IG1bMl0gPyAncmlnaHRhbGlnbicgOiBudWxsO1xyXG4gICAgICAgICAgICAgIGZvcm1hdHRlZCA9ICQuc3ByaW50ZihtWzFdLCBkYXR1bSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaHRtbC5wdXNoKCc8dGQnICsgKGNzc0NsYXNzID8gJyBjbGFzcz1cIicgKyBjc3NDbGFzcyArICdcIicgOiAnJykgKyAnPicgK1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkICsgJzwvdGQ+Jyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBodG1sLnB1c2goJzwvdHI+Jyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaHRtbCA9IGh0bWwuam9pbignJyk7XHJcbiAgICAgICAgdGJvZHkgPSAkKCcjZG9jdW1lbnRfc2VsZWN0IHRib2R5JykuaHRtbChodG1sKTtcclxuICAgICAgICAkKCcjZG9jdW1lbnRfc2VsZWN0JylbMF0uc2Nyb2xsVG9wID0gZG9jU2Nyb2xsO1xyXG4gICAgICAgIHRib2R5LmZpbmQoJ3RyJykuXHJcbiAgICAgICAgICAgIGNsaWNrKGNob29zZURvY3VtZW50KS5cclxuICAgICAgICAgICAgZGJsY2xpY2soY2hvb3NlRG9jdW1lbnRBbmRTdWJtaXQpO1xyXG5cclxuICAgICAgICAkKCcjZG9jdW1lbnRfc2VsZWN0IHRoZWFkIHRyIConKS5lYWNoKGZ1bmN0aW9uKHRoTm8sIHRoKSB7XHJcbiAgICAgICAgICAgIG1ha2VTb3J0Q2hhbmdlRnVuY3Rpb24oc29ydE9yZGVyLCB0aCwgdGhObyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICQoJyNjb2xsZWN0aW9uX2lucHV0JykudmFsKHNlbGVjdG9yRGF0YS5jb2xsZWN0aW9uKTtcclxuICAgICAgICAkKCcjZG9jdW1lbnRfaW5wdXQnKS52YWwoZG9jKTtcclxuXHJcbiAgICAgICAgJCgnI3JlYWRtZScpLnZhbChzZWxlY3RvckRhdGEuZGVzY3JpcHRpb24gfHwgJycpO1xyXG4gICAgICAgIGlmIChzZWxlY3RvckRhdGEuZGVzY3JpcHRpb24gJiYgXHJcbiAgICAgICAgICAgIChzZWxlY3RvckRhdGEuZGVzY3JpcHRpb24ubWF0Y2goL1xcbi8pIHx8XHJcbiAgICAgICAgICAgICBzZWxlY3RvckRhdGEuZGVzY3JpcHRpb24ubGVuZ3RoID4gNTApKSB7XHJcbiAgICAgICAgICAvLyBtdWx0aS1saW5lIG9yIGxvbmcgZGVzY3JpcHRpb247IHNob3cgXCJtb3JlXCIgYnV0dG9uIGFuZCBmaWxsXHJcbiAgICAgICAgICAvLyBkaWFsb2cgdGV4dFxyXG4gICAgICAgICAgJCgnI21vcmVfcmVhZG1lX2J1dHRvbicpLmJ1dHRvbigpOyAvLyBUT0RPOiBtb3JlIHJlYXNvbmFibGUgcGxhY2VcclxuICAgICAgICAgICQoJyNtb3JlX3JlYWRtZV9idXR0b24nKS5zaG93KCk7XHJcbiAgICAgICAgICAvLyBvbmx5IGRpc3BsYXkgdGV4dCB1cCB0byB0aGUgZmlyc3QgbmV3bGluZSBpbiB0aGUgc2hvcnQgaW5mbyovXHJcbiAgICAgICAgICAvL3ZhciBzcGxpdF9yZWFkbWVfdGV4dCA9IHNlbGVjdG9yRGF0YS5kZXNjcmlwdGlvbi5tYXRjaCgvXlteXFxuXSovKTtcclxuICAgICAgICAgIC8qJCgnI3JlYWRtZScpLnZhbChzcGxpdF9yZWFkbWVfdGV4dFswXSk7XHJcbiAgICAgICAgICAkKCcjbW9yZV9pbmZvX3JlYWRtZScpLnRleHQoc2VsZWN0b3JEYXRhLmRlc2NyaXB0aW9uKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gZW1wdHkgb3Igc2hvcnQsIHNpbmdsZS1saW5lIGRlc2NyaXB0aW9uOyBubyBuZWVkIGZvciBtb3JlXHJcbiAgICAgICAgICAkKCcjbW9yZV9yZWFkbWVfYnV0dG9uJykuaGlkZSgpO1xyXG4gICAgICAgICAgJCgnI21vcmVfaW5mb19yZWFkbWUnKS50ZXh0KCcnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNlbGVjdEVsZW1lbnRJblRhYmxlKCQoJyNkb2N1bWVudF9zZWxlY3QnKSwgZG9jLCBhcmdzLm1hdGNoZm9jdXMpO1xyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAkKCcjZG9jdW1lbnRfaW5wdXQnKS5mb2N1cygpLnNlbGVjdCgpO1xyXG4gICAgICAgIH0sIDApO1xyXG5cclxuKi9cclxuLy8gQlJBVCBTVEFOREFMT05FIExJQlJBUlkgRU5EXHJcbiAgICAgIH07IC8vIGVuZCBzaG93RmlsZUJyb3dzZXIoKVxyXG5cclxuXHJcbiAgICAgICQoJyNjb2xsZWN0aW9uX2Jyb3dzZXJfYnV0dG9uJykuY2xpY2soZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdjbGVhclNlYXJjaCcpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHZhciBjdXJyZW50U2VsZWN0b3JQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBwb3M7XHJcbiAgICAgICAgJC5lYWNoKHNlbGVjdG9yRGF0YS5pdGVtcywgZnVuY3Rpb24oZG9jTm8sIGRvY1Jvdykge1xyXG4gICAgICAgICAgaWYgKGRvY1Jvd1syXSA9PSBkb2MpIHtcclxuICAgICAgICAgICAgLy8gYXJncyBtYXkgaGF2ZSBjaGFuZ2VkLCBzbyBsYWNraW5nIGEgcGVyZmVjdCBtYXRjaCByZXR1cm5cclxuICAgICAgICAgICAgLy8gbGFzdCBtYXRjaGluZyBkb2N1bWVudCBhcyBiZXN0IGd1ZXNzXHJcbiAgICAgICAgICAgIHBvcyA9IGRvY05vO1xyXG4gICAgICAgICAgICAvLyBjaGVjayB3aGV0aGVyICdmb2N1cycgYWdyZWVzOyB0aGUgcmVzdCBvZiB0aGUgYXJncyBhcmVcclxuICAgICAgICAgICAgLy8gaXJyZWxldmFudCBmb3IgZGV0ZXJtaW5pbmcgcG9zaXRpb24uXHJcbiAgICAgICAgICAgIHZhciBjb2xsZWN0aW9uQXJncyA9IGRvY1Jvd1sxXSB8fCB7fTtcclxuICAgICAgICAgICAgaWYgKFV0aWwuaXNFcXVhbChjb2xsZWN0aW9uQXJncy5tYXRjaGZvY3VzLCBhcmdzLm1hdGNoZm9jdXMpKSB7XHJcbiAgICAgICAgICAgICAgcG9zID0gZG9jTm87XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHBvcztcclxuICAgICAgfVxyXG5cclxuICAgICAgLyogRU5EIGNvbGxlY3Rpb24gYnJvd3NlciAtIHJlbGF0ZWQgKi9cclxuXHJcblxyXG4gICAgICAvKiBTVEFSVCBzZWFyY2ggLSByZWxhdGVkICovXHJcblxyXG4gICAgICB2YXIgYWRkU3BhblR5cGVzVG9TZWxlY3QgPSBmdW5jdGlvbigkc2VsZWN0LCB0eXBlcywgaW5jbHVkZWQpIHtcclxuICAgICAgICBpZiAoIWluY2x1ZGVkKSBpbmNsdWRlZCA9IHt9O1xyXG4gICAgICAgIGlmICghaW5jbHVkZWRbJyddKSB7XHJcbiAgICAgICAgICBpbmNsdWRlZFsnJ10gPSB0cnVlO1xyXG4gICAgICAgICAgJHNlbGVjdC5odG1sKCc8b3B0aW9uIHZhbHVlPVwiXCI+LSBBbnkgLTwvb3B0aW9uPicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAkLmVhY2godHlwZXMsIGZ1bmN0aW9uKHR5cGVObywgdHlwZSkge1xyXG4gICAgICAgICAgaWYgKHR5cGUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKCFpbmNsdWRlZFt0eXBlLm5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgaW5jbHVkZWRbdHlwZS5uYW1lXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgdmFyICRvcHRpb24gPSAkKCc8b3B0aW9uIHZhbHVlPVwiJyArIFV0aWwuZXNjYXBlUXVvdGVzKHR5cGUudHlwZSkgKyAnXCIvPicpLnRleHQodHlwZS5uYW1lKTtcclxuICAgICAgICAgICAgICAkc2VsZWN0LmFwcGVuZCgkb3B0aW9uKTtcclxuICAgICAgICAgICAgICBpZiAodHlwZS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgYWRkU3BhblR5cGVzVG9TZWxlY3QoJHNlbGVjdCwgdHlwZS5jaGlsZHJlbiwgaW5jbHVkZWQpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdmFyIHJlbWVtYmVyTm9ybURiID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcclxuICAgICAgICAvLyB0aGUgdmlzdWFsaXplciBuZWVkcyB0byByZW1lbWJlciBhc3BlY3RzIG9mIHRoZSBub3JtIHNldHVwXHJcbiAgICAgICAgLy8gc28gdGhhdCBpdCBjYW4gYXZvaWQgbWFraW5nIHF1ZXJpZXMgZm9yIHVuY29uZmlndXJlZCBvclxyXG4gICAgICAgIC8vIG1pc3Npbmcgbm9ybWFsaXphdGlvbiBEQnMuXHJcbiAgICAgICAgdmFyIG5vcm1fcmVzb3VyY2VzID0gcmVzcG9uc2Uubm9ybWFsaXphdGlvbl9jb25maWcgfHwgW107XHJcbiAgICAgICAgJC5lYWNoKG5vcm1fcmVzb3VyY2VzLCBmdW5jdGlvbihub3JtTm8sIG5vcm0pIHtcclxuICAgICAgICAgIHZhciBub3JtTmFtZSA9IG5vcm1bMF07XHJcbiAgICAgICAgICB2YXIgc2VydmVyRGIgPSBub3JtWzNdO1xyXG4gICAgICAgICAgbm9ybVNlcnZlckRiQnlOb3JtRGJOYW1lW25vcm1OYW1lXSA9IHNlcnZlckRiO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgc2V0dXBTZWFyY2hUeXBlcyA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgYWRkU3BhblR5cGVzVG9TZWxlY3QoJCgnI3NlYXJjaF9mb3JtX2VudGl0eV90eXBlJyksIHJlc3BvbnNlLmVudGl0eV90eXBlcyk7XHJcbiAgICAgICAgYWRkU3BhblR5cGVzVG9TZWxlY3QoJCgnI3NlYXJjaF9mb3JtX2V2ZW50X3R5cGUnKSwgcmVzcG9uc2UuZXZlbnRfdHlwZXMpO1xyXG4gICAgICAgIGFkZFNwYW5UeXBlc1RvU2VsZWN0KCQoJyNzZWFyY2hfZm9ybV9yZWxhdGlvbl90eXBlJyksIHJlc3BvbnNlLnJlbGF0aW9uX3R5cGVzKTtcclxuICAgICAgICAvLyBuaWNlLWxvb2tpbmcgc2VsZWN0cyBhbmQgdXBsb2FkIGZpZWxkc1xyXG4gICAgICAgICQoJyNzZWFyY2hfZm9ybSBzZWxlY3QnKS5hZGRDbGFzcygndWktd2lkZ2V0IHVpLXN0YXRlLWRlZmF1bHQgdWktYnV0dG9uLXRleHQnKTtcclxuICAgICAgICAkKCcjc2VhcmNoX2Zvcm1fbG9hZF9maWxlJykuYWRkQ2xhc3MoJ3VpLXdpZGdldCB1aS1zdGF0ZS1kZWZhdWx0IHVpLWJ1dHRvbi10ZXh0Jyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHdoZW4gZXZlbnQgcm9sZSBjaGFuZ2VzLCBldmVudCB0eXBlcyBkbyBhcyB3ZWxsXHJcbiAgICAgIHZhciBzZWFyY2hFdmVudFJvbGVzID0gW107XHJcbiAgICAgIHZhciBzZWFyY2hFdmVudFJvbGVDaGFuZ2VkID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgdmFyICR0eXBlID0gJCh0aGlzKS5wYXJlbnQoKS5uZXh0KCkuY2hpbGRyZW4oJ3NlbGVjdCcpO1xyXG4gICAgICAgIHZhciB0eXBlID0gJHR5cGUudmFsKCk7XHJcbiAgICAgICAgdmFyIHJvbGUgPSAkKHRoaXMpLnZhbCgpO1xyXG4gICAgICAgIHZhciBvcmlnaW4gPSAkKCcjc2VhcmNoX2Zvcm1fZXZlbnRfdHlwZScpLnZhbCgpO1xyXG4gICAgICAgIHZhciBldmVudFR5cGUgPSBzcGFuVHlwZXNbb3JpZ2luXTtcclxuICAgICAgICB2YXIgYXJjVHlwZXMgPSBldmVudFR5cGUgJiYgZXZlbnRUeXBlLmFyY3MgfHwgW107XHJcbiAgICAgICAgdmFyIGFyY1R5cGUgPSBudWxsO1xyXG4gICAgICAgICR0eXBlLmh0bWwoJzxvcHRpb24gdmFsdWU9XCJcIj4tIEFueSAtPC9vcHRpb24+Jyk7XHJcbiAgICAgICAgJC5lYWNoKGFyY1R5cGVzLCBmdW5jdGlvbihhcmNObywgYXJjRGVzYykge1xyXG4gICAgICAgICAgaWYgKGFyY0Rlc2MudHlwZSA9PSByb2xlKSB7XHJcbiAgICAgICAgICAgIGFyY1R5cGUgPSBhcmNEZXNjO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIHRhcmdldHMgPSBhcmNUeXBlICYmIGFyY1R5cGUudGFyZ2V0cyB8fCBbXTtcclxuICAgICAgICAkLmVhY2godGFyZ2V0cywgZnVuY3Rpb24odGFyZ2V0Tm8sIHRhcmdldCkge1xyXG4gICAgICAgICAgdmFyIHNwYW5UeXBlID0gc3BhblR5cGVzW3RhcmdldF07XHJcbiAgICAgICAgICB2YXIgc3Bhbk5hbWUgPSBzcGFuVHlwZS5uYW1lIHx8IHNwYW5UeXBlLmxhYmVsc1swXSB8fCB0YXJnZXQ7XHJcbiAgICAgICAgICB2YXIgb3B0aW9uID0gJzxvcHRpb24gdmFsdWU9XCInICsgVXRpbC5lc2NhcGVRdW90ZXModGFyZ2V0KSArICdcIj4nICsgVXRpbC5lc2NhcGVIVE1MKHNwYW5OYW1lKSArICc8L29wdGlvbj4nXHJcbiAgICAgICAgICAkdHlwZS5hcHBlbmQob3B0aW9uKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyByZXR1cm4gdGhlIHR5cGUgdG8gdGhlIHNhbWUgdmFsdWUsIGlmIHBvc3NpYmxlXHJcbiAgICAgICAgaWYgKHR5cGUpIHtcclxuICAgICAgICAgICR0eXBlLnZhbCh0eXBlKTtcclxuICAgICAgICB9O1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgJCgnI3NlYXJjaF9mb3JtX2V2ZW50X3JvbGVzIC5zZWFyY2hfZXZlbnRfcm9sZSBzZWxlY3QnKS5saXZlKCdjaGFuZ2UnLCBzZWFyY2hFdmVudFJvbGVDaGFuZ2VkKTtcclxuXHJcbiAgICAgIC8vIGFkZGluZyBuZXcgcm9sZSByb3dzXHJcbiAgICAgIHZhciBhZGRFbXB0eVNlYXJjaEV2ZW50Um9sZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciAkcm9sZXMgPSAkKCcjc2VhcmNoX2Zvcm1fZXZlbnRfcm9sZXMnKTtcclxuICAgICAgICB2YXIgcm93Tm8gPSAkcm9sZXMuY2hpbGRyZW4oKS5sZW5ndGg7XHJcbiAgICAgICAgdmFyICRyb2xlID0gJCgnPHNlbGVjdCBjbGFzcz1cImZ1bGx3aWR0aFwiLz4nKTtcclxuICAgICAgICAkcm9sZS5hcHBlbmQoJzxvcHRpb24gdmFsdWU9XCJcIj4tIEFueSAtPC9vcHRpb24+Jyk7XHJcbiAgICAgICAgJC5lYWNoKHNlYXJjaEV2ZW50Um9sZXMsIGZ1bmN0aW9uKGFyY1R5cGVQYWlyTm8sIGFyY1R5cGVQYWlyKSB7XHJcbiAgICAgICAgICB2YXIgb3B0aW9uID0gJzxvcHRpb24gdmFsdWU9XCInICsgVXRpbC5lc2NhcGVRdW90ZXMoYXJjVHlwZVBhaXJbMF0pICsgJ1wiPicgKyBVdGlsLmVzY2FwZUhUTUwoYXJjVHlwZVBhaXJbMV0pICsgJzwvb3B0aW9uPidcclxuICAgICAgICAgICRyb2xlLmFwcGVuZChvcHRpb24pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciAkdHlwZSA9ICQoJzxzZWxlY3QgY2xhc3M9XCJmdWxsd2lkdGhcIi8+Jyk7XHJcbiAgICAgICAgdmFyICR0ZXh0ID0gJCgnPGlucHV0IGNsYXNzPVwiZnVsbHdpZHRoXCIvPicpO1xyXG4gICAgICAgIHZhciBidXR0b24gPSAkKCc8aW5wdXQgdHlwZT1cImJ1dHRvblwiLz4nKTtcclxuICAgICAgICB2YXIgcm93QnV0dG9uID0gJCgnPHRkLz4nKS5hcHBlbmQoYnV0dG9uKTtcclxuICAgICAgICBpZiAocm93Tm8pIHtcclxuICAgICAgICAgIHJvd0J1dHRvbi5hZGRDbGFzcygnc2VhcmNoX2V2ZW50X3JvbGVfZGVsJyk7XHJcbiAgICAgICAgICBidXR0b24udmFsKCdcXHUyMDEzJyk7IC8vIG4tZGFzaFxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByb3dCdXR0b24uYWRkQ2xhc3MoJ3NlYXJjaF9ldmVudF9yb2xlX2FkZCcpO1xyXG4gICAgICAgICAgYnV0dG9uLnZhbCgnKycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgJHRyID0gJCgnPHRyLz4nKS5cclxuICAgICAgICAgIGFwcGVuZCgkKCc8dGQgY2xhc3M9XCJzZWFyY2hfZXZlbnRfcm9sZVwiLz4nKS5hcHBlbmQoJHJvbGUpKS5cclxuICAgICAgICAgIGFwcGVuZCgkKCc8dGQgY2xhc3M9XCJzZWFyY2hfZXZlbnRfdHlwZVwiLz4nKS5hcHBlbmQoJHR5cGUpKS5cclxuICAgICAgICAgIGFwcGVuZCgkKCc8dGQgY2xhc3M9XCJzZWFyY2hfZXZlbnRfdGV4dFwiLz4nKS5hcHBlbmQoJHRleHQpKS5cclxuICAgICAgICAgIGFwcGVuZChyb3dCdXR0b24pO1xyXG4gICAgICAgICRyb2xlcy5hcHBlbmQoJHRyKTtcclxuICAgICAgICAkcm9sZS50cmlnZ2VyKCdjaGFuZ2UnKTtcclxuICAgICAgICAvLyBzdHlsZSBzZWxlY3RvclxyXG4gICAgICAgICRyb2xlLmFkZENsYXNzKCd1aS13aWRnZXQgdWktc3RhdGUtZGVmYXVsdCB1aS1idXR0b24tdGV4dCcpO1xyXG4gICAgICAgICR0eXBlLmFkZENsYXNzKCd1aS13aWRnZXQgdWktc3RhdGUtZGVmYXVsdCB1aS1idXR0b24tdGV4dCcpO1xyXG4gICAgICAgIC8vIHN0eWxlIGJ1dHRvblxyXG4gICAgICAgIGJ1dHRvbi5idXR0b24oKTtcclxuICAgICAgICBidXR0b24uYWRkQ2xhc3MoJ3NtYWxsLWJ1dHRvbnMgdWktYnV0dG9uLXRleHQnKS5yZW1vdmVDbGFzcygndWktYnV0dG9uJyk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBkZWxldGluZyByb2xlIHJvd3NcclxuICAgICAgdmFyIGRlbFNlYXJjaEV2ZW50Um9sZSA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgICRyb3cgPSAkKHRoaXMpLmNsb3Nlc3QoJ3RyJyk7XHJcbiAgICAgICAgJHJvdy5yZW1vdmUoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgJCgnI3NlYXJjaF9mb3JtX2V2ZW50X3JvbGVzIC5zZWFyY2hfZXZlbnRfcm9sZV9hZGQgaW5wdXQnKS5saXZlKCdjbGljaycsIGFkZEVtcHR5U2VhcmNoRXZlbnRSb2xlKTtcclxuICAgICAgJCgnI3NlYXJjaF9mb3JtX2V2ZW50X3JvbGVzIC5zZWFyY2hfZXZlbnRfcm9sZV9kZWwgaW5wdXQnKS5saXZlKCdjbGljaycsIGRlbFNlYXJjaEV2ZW50Um9sZSk7XHJcblxyXG4gICAgICAvLyBXaGVuIGV2ZW50IHR5cGUgY2hhbmdlcywgdGhlIGV2ZW50IHJvbGVzIGRvIGFzIHdlbGxcclxuICAgICAgLy8gQWxzbywgcHV0IGluIG9uZSBlbXB0eSByb2xlIHJvd1xyXG4gICAgICAkKCcjc2VhcmNoX2Zvcm1fZXZlbnRfdHlwZScpLmNoYW5nZShmdW5jdGlvbihldnQpIHtcclxuICAgICAgICB2YXIgJHJvbGVzID0gJCgnI3NlYXJjaF9mb3JtX2V2ZW50X3JvbGVzJykuZW1wdHkoKTtcclxuICAgICAgICBzZWFyY2hFdmVudFJvbGVzID0gW107XHJcbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IHNwYW5UeXBlc1skKHRoaXMpLnZhbCgpXTtcclxuICAgICAgICB2YXIgYXJjVHlwZXMgPSBldmVudFR5cGUgJiYgZXZlbnRUeXBlLmFyY3MgfHwgW107XHJcbiAgICAgICAgJC5lYWNoKGFyY1R5cGVzLCBmdW5jdGlvbihhcmNUeXBlTm8sIGFyY1R5cGUpIHtcclxuICAgICAgICAgIHZhciBhcmNUeXBlTmFtZSA9IGFyY1R5cGUubGFiZWxzICYmIGFyY1R5cGUubGFiZWxzWzBdIHx8IGFyY1R5cGUudHlwZTtcclxuICAgICAgICAgIHNlYXJjaEV2ZW50Um9sZXMucHVzaChbYXJjVHlwZS50eXBlLCBhcmNUeXBlTmFtZV0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGFkZEVtcHR5U2VhcmNoRXZlbnRSb2xlKCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gd2hlbiByZWxhdGlvbiBjaGFuZ2VzLCBjaGFuZ2UgY2hvaWNlcyBvZiBhcmcxIHR5cGVcclxuICAgICAgJCgnI3NlYXJjaF9mb3JtX3JlbGF0aW9uX3R5cGUnKS5jaGFuZ2UoZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgdmFyIHJlbFR5cGVUeXBlID0gJCh0aGlzKS52YWwoKTtcclxuICAgICAgICB2YXIgJGFyZzEgPSAkKCcjc2VhcmNoX2Zvcm1fcmVsYXRpb25fYXJnMV90eXBlJykuXHJcbiAgICAgICAgICAgIGh0bWwoJzxvcHRpb24gdmFsdWU9XCJcIj4tIEFueSAtPC9vcHRpb24+Jyk7XHJcbiAgICAgICAgdmFyICRhcmcyID0gJCgnI3NlYXJjaF9mb3JtX3JlbGF0aW9uX2FyZzJfdHlwZScpLmVtcHR5KCk7XHJcbiAgICAgICAgJC5lYWNoKHNwYW5UeXBlcyxcclxuICAgICAgICAgIGZ1bmN0aW9uKHNwYW5UeXBlVHlwZSwgc3BhblR5cGUpIHtcclxuICAgICAgICAgIGlmIChzcGFuVHlwZS5hcmNzKSB7XHJcbiAgICAgICAgICAgICQuZWFjaChzcGFuVHlwZS5hcmNzLCBmdW5jdGlvbihhcmNUeXBlTm8sIGFyY1R5cGUpIHtcclxuICAgICAgICAgICAgICBpZiAoYXJjVHlwZS50eXBlID09PSByZWxUeXBlVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNwYW5OYW1lID0gc3BhblR5cGUubmFtZTtcclxuICAgICAgICAgICAgICAgIHZhciBvcHRpb24gPSAnPG9wdGlvbiB2YWx1ZT1cIicgKyBVdGlsLmVzY2FwZVF1b3RlcyhzcGFuVHlwZVR5cGUpICsgJ1wiPicgKyBVdGlsLmVzY2FwZUhUTUwoc3Bhbk5hbWUpICsgJzwvb3B0aW9uPidcclxuICAgICAgICAgICAgICAgICRhcmcxLmFwcGVuZChvcHRpb24pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgJCgnI3NlYXJjaF9mb3JtX3JlbGF0aW9uX2FyZzFfdHlwZScpLmNoYW5nZSgpO1xyXG4gICAgICAgIC8vIHN0eWxlIHRoZSBzZWxlY3RzXHJcbiAgICAgICAgJGFyZzEuYWRkQ2xhc3MoJ3VpLXdpZGdldCB1aS1zdGF0ZS1kZWZhdWx0IHVpLWJ1dHRvbi10ZXh0Jyk7XHJcbiAgICAgICAgJGFyZzIuYWRkQ2xhc3MoJ3VpLXdpZGdldCB1aS1zdGF0ZS1kZWZhdWx0IHVpLWJ1dHRvbi10ZXh0Jyk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gd2hlbiBhcmcxIHR5cGUgY2hhbmdlcywgY2hhbmdlIGNob2ljZXMgb2YgYXJnMiB0eXBlXHJcbiAgICAgICQoJyNzZWFyY2hfZm9ybV9yZWxhdGlvbl9hcmcxX3R5cGUnKS5jaGFuZ2UoZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgdmFyICRhcmcyID0gJCgnI3NlYXJjaF9mb3JtX3JlbGF0aW9uX2FyZzJfdHlwZScpLlxyXG4gICAgICAgICAgICBodG1sKCc8b3B0aW9uIHZhbHVlPVwiXCI+LSBBbnkgLTwvb3B0aW9uPicpO1xyXG4gICAgICAgIHZhciByZWxUeXBlID0gJCgnI3NlYXJjaF9mb3JtX3JlbGF0aW9uX3R5cGUnKS52YWwoKTtcclxuICAgICAgICB2YXIgYXJnMVR5cGUgPSBzcGFuVHlwZXNbJCh0aGlzKS52YWwoKV07XHJcbiAgICAgICAgdmFyIGFyY1R5cGVzID0gYXJnMVR5cGUgJiYgYXJnMVR5cGUuYXJjcyB8fCBbXTtcclxuICAgICAgICB2YXIgYXJjVHlwZSA9IG51bGw7XHJcbiAgICAgICAgJC5lYWNoKGFyY1R5cGVzLCBmdW5jdGlvbihhcmNObywgYXJjRGVzYykge1xyXG4gICAgICAgICAgaWYgKGFyY0Rlc2MudHlwZSA9PSByZWxUeXBlKSB7XHJcbiAgICAgICAgICAgIGFyY1R5cGUgPSBhcmNEZXNjO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGFyY1R5cGUgJiYgYXJjVHlwZS50YXJnZXRzKSB7XHJcbiAgICAgICAgICAkLmVhY2goYXJjVHlwZS50YXJnZXRzLCBmdW5jdGlvbihzcGFuVHlwZU5vLCBzcGFuVHlwZVR5cGUpIHtcclxuICAgICAgICAgICAgdmFyIHNwYW5OYW1lID0gVXRpbC5zcGFuRGlzcGxheUZvcm0oc3BhblR5cGVzLCBzcGFuVHlwZVR5cGUpO1xyXG4gICAgICAgICAgICB2YXIgb3B0aW9uID0gJzxvcHRpb24gdmFsdWU9XCInICsgVXRpbC5lc2NhcGVRdW90ZXMoc3BhblR5cGVUeXBlKSArICdcIj4nICsgVXRpbC5lc2NhcGVIVE1MKHNwYW5OYW1lKSArICc8L29wdGlvbj4nXHJcbiAgICAgICAgICAgICRhcmcyLmFwcGVuZChvcHRpb24pO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgICQoJyNzZWFyY2hfZm9ybV9ub3RlX2NhdGVnb3J5JykuY2hhbmdlKGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgIHZhciBjYXRlZ29yeSA9ICQodGhpcykudmFsKCk7XHJcbiAgICAgICAgdmFyICR0eXBlID0gJCgnI3NlYXJjaF9mb3JtX25vdGVfdHlwZScpO1xyXG4gICAgICAgIGlmICgkLmluQXJyYXkoY2F0ZWdvcnksIFsnZW50aXR5JywgJ2V2ZW50JywgJ3JlbGF0aW9uJ10pICE9IC0xKSB7XHJcbiAgICAgICAgICAkdHlwZS5odG1sKCQoJyNzZWFyY2hfZm9ybV8nICsgY2F0ZWdvcnkgKyAnX3R5cGUnKS5odG1sKCkpLnZhbCgnJyk7XHJcbiAgICAgICAgICAkKCcjc2VhcmNoX2Zvcm1fbm90ZV90eXBlX3Jvdzpub3QoOnZpc2libGUpJykuc2hvdygnaGlnaGxpZ2h0Jyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICR0eXBlLmh0bWwoJycpO1xyXG4gICAgICAgICAgJCgnI3NlYXJjaF9mb3JtX25vdGVfdHlwZV9yb3c6dmlzaWJsZScpLmhpZGUoJ2hpZ2hsaWdodCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgLy8gY29udGV4dCBsZW5ndGggc2V0dGluZyBzaG91bGQgb25seSBiZSB2aXNpYmxlIGlmXHJcbiAgICAgIC8vIGNvbmNvcmRhbmNpbmcgaXMgb25cclxuICAgICAgLy8gVE9ETzogQGFtYWRhbm1hdGg6IGhlbHAsIG15IGpRdWVyeSBpcyBob3JyaWJsZVxyXG4gICAgICBpZiAoJCgnI2NvbmNvcmRhbmNpbmdfb24nKS5pcygnOmNoZWNrZWQnKSkge1xyXG4gICAgICAgICQoJyNjb250ZXh0X3NpemVfZGl2Jykuc2hvdyhcImhpZ2hsaWdodFwiKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAkKCcjY29udGV4dF9zaXplX2RpdicpLmhpZGUoXCJoaWdobGlnaHRcIik7XHJcbiAgICAgIH1cclxuICAgICAgJCgnI2NvbmNvcmRhbmNpbmcgaW5wdXRbdHlwZT1cInJhZGlvXCJdJykuY2hhbmdlKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICgkKCcjY29uY29yZGFuY2luZ19vbicpLmlzKCc6Y2hlY2tlZCcpKSB7XHJcbiAgICAgICAgICAkKCcjY29udGV4dF9zaXplX2RpdicpLnNob3coXCJoaWdobGlnaHRcIik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICQoJyNjb250ZXh0X3NpemVfZGl2JykuaGlkZShcImhpZ2hsaWdodFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICAkKCcjc2VhcmNoX29wdGlvbnMgZGl2LmFkdmFuY2VkT3B0aW9ucycpLmhpZGUoXCJoaWdobGlnaHRcIik7XHJcbiAgICAgIC8vIHNldCB1cCBhZHZhbmNlZCBzZWFyY2ggb3B0aW9uczsgb25seSB2aXNpYmxlIGlzIGNsaWNrZWRcclxuICAgICAgdmFyIGFkdmFuY2VkU2VhcmNoT3B0aW9uc1Zpc2libGUgPSBmYWxzZTtcclxuICAgICAgJCgnI2FkdmFuY2VkX3NlYXJjaF9vcHRpb25fdG9nZ2xlJykuY2xpY2soZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgaWYgKGFkdmFuY2VkU2VhcmNoT3B0aW9uc1Zpc2libGUpIHtcclxuICAgICAgICAgICQoJyNzZWFyY2hfb3B0aW9ucyBkaXYuYWR2YW5jZWRPcHRpb25zJykuaGlkZShcImhpZ2hsaWdodFwiKTtcclxuICAgICAgICAgICQoJyNhZHZhbmNlZF9zZWFyY2hfb3B0aW9uX3RvZ2dsZScpLnRleHQoXCJTaG93IGFkdmFuY2VkXCIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAkKCcjc2VhcmNoX29wdGlvbnMgZGl2LmFkdmFuY2VkT3B0aW9ucycpLnNob3coXCJoaWdobGlnaHRcIik7XHJcbiAgICAgICAgICAkKCcjYWR2YW5jZWRfc2VhcmNoX29wdGlvbl90b2dnbGUnKS50ZXh0KFwiSGlkZSBhZHZhbmNlZFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWR2YW5jZWRTZWFyY2hPcHRpb25zVmlzaWJsZSA9ICFhZHZhbmNlZFNlYXJjaE9wdGlvbnNWaXNpYmxlO1xyXG4gICAgICAgIC8vIGJsb2NrIGRlZmF1bHRcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdmFyIGFjdGl2ZVNlYXJjaFRhYiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vIGFjdGl2ZVRhYjogMCA9IFRleHQsIDEgPSBFbnRpdHksIDIgPSBFdmVudCwgMyA9IFJlbGF0aW9uLCA0ID0gTm90ZXMsIDUgPSBMb2FkXHJcbiAgICAgICAgdmFyIGFjdGl2ZVRhYiA9ICQoJyNzZWFyY2hfdGFicycpLnRhYnMoJ29wdGlvbicsICdzZWxlY3RlZCcpO1xyXG4gICAgICAgIHJldHVybiBbJ3NlYXJjaFRleHQnLCAnc2VhcmNoRW50aXR5JywgJ3NlYXJjaEV2ZW50JyxcclxuICAgICAgICAgICAgJ3NlYXJjaFJlbGF0aW9uJywgJ3NlYXJjaE5vdGUnLCAnc2VhcmNoTG9hZCddW2FjdGl2ZVRhYl07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBvblNlYXJjaFRhYlNlbGVjdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBhY3Rpb24gPSBhY3RpdmVTZWFyY2hUYWIoKTtcclxuICAgICAgICBzd2l0Y2ggKGFjdGlvbikge1xyXG4gICAgICAgICAgY2FzZSAnc2VhcmNoVGV4dCc6XHJcbiAgICAgICAgICAgICQoJyNzZWFyY2hfZm9ybV90ZXh0X3RleHQnKS5mb2N1cygpLnNlbGVjdCgpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ3NlYXJjaEVudGl0eSc6XHJcbiAgICAgICAgICAgICQoJyNzZWFyY2hfZm9ybV9lbnRpdHlfdGV4dCcpLmZvY3VzKCkuc2VsZWN0KCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnc2VhcmNoRXZlbnQnOlxyXG4gICAgICAgICAgICAkKCcjc2VhcmNoX2Zvcm1fZXZlbnRfdHJpZ2dlcicpLmZvY3VzKCkuc2VsZWN0KCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnc2VhcmNoUmVsYXRpb24nOlxyXG4gICAgICAgICAgICAkKCcjc2VhcmNoX2Zvcm1fcmVsYXRpb25fdHlwZScpLmZvY3VzKCkuc2VsZWN0KCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnc2VhcmNoTm90ZSc6XHJcbiAgICAgICAgICAgICQoJyNzZWFyY2hfZm9ybV9ub3RlX3RleHQnKS5mb2N1cygpLnNlbGVjdCgpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ3NlYXJjaExvYWQnOlxyXG4gICAgICAgICAgICAkKCcjc2VhcmNoX2Zvcm1fbG9hZF9maWxlJykuZm9jdXMoKS5zZWxlY3QoKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gc2V0IHVwIGpRdWVyeSBVSSBlbGVtZW50cyBpbiBzZWFyY2ggZm9ybVxyXG4gICAgICAkKCcjc2VhcmNoX3RhYnMnKS50YWJzKHtcclxuICAgICAgICBzaG93OiBvblNlYXJjaFRhYlNlbGVjdFxyXG4gICAgICB9KTtcclxuICAgICAgJCgnI3NlYXJjaF9mb3JtJykuZmluZCgnLnJhZGlvX2dyb3VwJykuYnV0dG9uc2V0KCk7XHJcblxyXG4gICAgICB2YXIgYXBwbHlTZWFyY2hSZXN1bHRzID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcclxuICAgICAgICBpZiAoIXNlYXJjaEFjdGl2ZSkge1xyXG4gICAgICAgICAgY29sbGVjdGlvblNvcnRPcmRlciA9IHNvcnRPcmRlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdzZWFyY2hSZXN1bHRzUmVjZWl2ZWQnLCBbcmVzcG9uc2VdKTtcclxuICAgICAgICBzZWFyY2hBY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIHVwZGF0ZVNlYXJjaEJ1dHRvbnMoKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciBzZWFyY2hGb3JtID0gJCgnI3NlYXJjaF9mb3JtJyk7XHJcblxyXG4gICAgICB2YXIgc2VhcmNoRm9ybVN1Ym1pdCA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgIC8vIGhhY2sgYXJvdW5kIGVtcHR5IGRvY3VtZW50OyBcIlwiIHdvdWxkIGJlIGludGVycHJldGVkIGFzXHJcbiAgICAgICAgLy8gbWlzc2luZyBhcmd1bWVudCBieSBzZXJ2ZXIgZGlzcGF0Y2hlciAoaXNzdWUgIzUxMylcclxuICAgICAgICAvLyBUT0RPOiBkbyB0aGlzIHByb3Blcmx5LCBhdm9pZGluZyBtYWdpYyBzdHJpbmdzXHJcbiAgICAgICAgdmFyIGFjdGlvbiA9IGFjdGl2ZVNlYXJjaFRhYigpO1xyXG4gICAgICAgIHZhciBkb2NBcmcgPSBkb2MgPyBkb2MgOiBcIi9OTy1ET0NVTUVOVC9cIjtcclxuICAgICAgICB2YXIgb3B0cyA9IHtcclxuICAgICAgICAgIGFjdGlvbiA6IGFjdGlvbixcclxuICAgICAgICAgIGNvbGxlY3Rpb24gOiBjb2xsLFxyXG4gICAgICAgICAgZG9jdW1lbnQ6IGRvY0FyZyxcclxuICAgICAgICAgIC8vIFRPRE8gdGhlIHNlYXJjaCBmb3JtIGdvdCBjb21wbGV4IDopXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgc3dpdGNoIChhY3Rpb24pIHtcclxuICAgICAgICAgIGNhc2UgJ3NlYXJjaFRleHQnOlxyXG4gICAgICAgICAgICBvcHRzLnRleHQgPSAkKCcjc2VhcmNoX2Zvcm1fdGV4dF90ZXh0JykudmFsKCk7XHJcbiAgICAgICAgICAgIGlmICghb3B0cy50ZXh0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgIGRpc3BhdGNoZXIucG9zdCgnbWVzc2FnZXMnLCBbW1snUGxlYXNlIGZpbGwgaW4gdGhlIHRleHQgdG8gc2VhcmNoIGZvciEnLCAnY29tbWVudCddXV0pO1xyXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ3NlYXJjaEVudGl0eSc6XHJcbiAgICAgICAgICAgIG9wdHMudHlwZSA9ICQoJyNzZWFyY2hfZm9ybV9lbnRpdHlfdHlwZScpLnZhbCgpIHx8ICcnO1xyXG4gICAgICAgICAgICBvcHRzLnRleHQgPSAkKCcjc2VhcmNoX2Zvcm1fZW50aXR5X3RleHQnKS52YWwoKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdzZWFyY2hFdmVudCc6XHJcbiAgICAgICAgICAgIG9wdHMudHlwZSA9ICQoJyNzZWFyY2hfZm9ybV9ldmVudF90eXBlJykudmFsKCkgfHwgJyc7XHJcbiAgICAgICAgICAgIG9wdHMudHJpZ2dlciA9ICQoJyNzZWFyY2hfZm9ybV9ldmVudF90cmlnZ2VyJykudmFsKCk7XHJcbiAgICAgICAgICAgIHZhciBlYXJncyA9IFtdO1xyXG4gICAgICAgICAgICAkKCcjc2VhcmNoX2Zvcm1fZXZlbnRfcm9sZXMgdHInKS5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgIHZhciBlYXJnID0ge307XHJcbiAgICAgICAgICAgICAgZWFyZy5yb2xlID0gJCh0aGlzKS5maW5kKCcuc2VhcmNoX2V2ZW50X3JvbGUgc2VsZWN0JykudmFsKCkgfHwgJyc7XHJcbiAgICAgICAgICAgICAgZWFyZy50eXBlID0gJCh0aGlzKS5maW5kKCcuc2VhcmNoX2V2ZW50X3R5cGUgc2VsZWN0JykudmFsKCkgfHwgJyc7XHJcbiAgICAgICAgICAgICAgZWFyZy50ZXh0ID0gJCh0aGlzKS5maW5kKCcuc2VhcmNoX2V2ZW50X3RleHQgaW5wdXQnKS52YWwoKTtcclxuICAgICAgICAgICAgICBlYXJncy5wdXNoKGVhcmcpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgb3B0cy5hcmdzID0gJC50b0pTT04oZWFyZ3MpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ3NlYXJjaFJlbGF0aW9uJzpcclxuICAgICAgICAgICAgb3B0cy50eXBlID0gJCgnI3NlYXJjaF9mb3JtX3JlbGF0aW9uX3R5cGUnKS52YWwoKSB8fCAnJztcclxuICAgICAgICAgICAgb3B0cy5hcmcxID0gJCgnI3NlYXJjaF9mb3JtX3JlbGF0aW9uX2FyZzFfdGV4dCcpLnZhbCgpO1xyXG4gICAgICAgICAgICBvcHRzLmFyZzF0eXBlID0gJCgnI3NlYXJjaF9mb3JtX3JlbGF0aW9uX2FyZzFfdHlwZScpLnZhbCgpIHx8ICcnO1xyXG4gICAgICAgICAgICBvcHRzLmFyZzIgPSAkKCcjc2VhcmNoX2Zvcm1fcmVsYXRpb25fYXJnMl90ZXh0JykudmFsKCk7XHJcbiAgICAgICAgICAgIG9wdHMuYXJnMnR5cGUgPSAkKCcjc2VhcmNoX2Zvcm1fcmVsYXRpb25fYXJnMl90eXBlJykudmFsKCkgfHwgJyc7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnc2VhcmNoTm90ZSc6XHJcbiAgICAgICAgICAgIG9wdHMuY2F0ZWdvcnkgPSAkKCcjc2VhcmNoX2Zvcm1fbm90ZV9jYXRlZ29yeScpLnZhbCgpIHx8ICcnO1xyXG4gICAgICAgICAgICBvcHRzLnR5cGUgPSAkKCcjc2VhcmNoX2Zvcm1fbm90ZV90eXBlJykudmFsKCkgfHwgJyc7XHJcbiAgICAgICAgICAgIG9wdHMudGV4dCA9ICQoJyNzZWFyY2hfZm9ybV9ub3RlX3RleHQnKS52YWwoKSB8fCAnJztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdzZWFyY2hMb2FkJzpcclxuICAgICAgICAgICAgYXBwbHlTZWFyY2hSZXN1bHRzKGxvYWRlZFNlYXJjaERhdGEpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBmaWxsIGluIHNjb3BlIG9mIHNlYXJjaCAoXCJkb2N1bWVudFwiIC8gXCJjb2xsZWN0aW9uXCIpXHJcbiAgICAgICAgdmFyIHNlYXJjaFNjb3BlID0gJCgnI3NlYXJjaF9zY29wZSBpbnB1dDpjaGVja2VkJykudmFsKCk7XHJcbiAgICAgICAgb3B0cy5zY29wZSA9IHNlYXJjaFNjb3BlO1xyXG5cclxuICAgICAgICAvLyBhZGp1c3Qgc3BlY2lmaWMgYWN0aW9uIHRvIGludm9rZSBieSBzY29wZVxyXG4gICAgICAgIGlmIChzZWFyY2hTY29wZSA9PSBcImRvY3VtZW50XCIpIHtcclxuICAgICAgICAgIG9wdHMuYWN0aW9uID0gb3B0cy5hY3Rpb24gKyBcIkluRG9jdW1lbnRcIjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgb3B0cy5hY3Rpb24gPSBvcHRzLmFjdGlvbiArIFwiSW5Db2xsZWN0aW9uXCI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBmaWxsIGluIGNvbmNvcmRhbmNpbmcgb3B0aW9uc1xyXG4gICAgICAgIG9wdHMuY29uY29yZGFuY2luZyA9ICQoJyNjb25jb3JkYW5jaW5nX29uJykuaXMoJzpjaGVja2VkJyk7XHJcbiAgICAgICAgb3B0cy5jb250ZXh0X2xlbmd0aCA9ICQoJyNjb250ZXh0X2xlbmd0aCcpLnZhbCgpO1xyXG5cclxuICAgICAgICAvLyBmaWxsIGluIHRleHQgbWF0Y2ggb3B0aW9uc1xyXG4gICAgICAgIG9wdHMudGV4dF9tYXRjaCA9ICQoJyN0ZXh0X21hdGNoIGlucHV0OmNoZWNrZWQnKS52YWwoKVxyXG4gICAgICAgIG9wdHMubWF0Y2hfY2FzZSA9ICQoJyNtYXRjaF9jYXNlX29uJykuaXMoJzpjaGVja2VkJyk7XHJcblxyXG4gICAgICAgIGRpc3BhdGNoZXIucG9zdCgnaGlkZUZvcm0nKTtcclxuICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ2FqYXgnLCBbb3B0cywgZnVuY3Rpb24ocmVzcG9uc2UpIHtcclxuICAgICAgICAgIGlmKHJlc3BvbnNlICYmIHJlc3BvbnNlLml0ZW1zICYmIHJlc3BvbnNlLml0ZW1zLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IG1pZ2h0IGNvbnNpZGVyIGhhdmluZyB0aGlzIG1lc3NhZ2UgY29tZSBmcm9tIHRoZVxyXG4gICAgICAgICAgICAvLyBzZXJ2ZXIgaW5zdGVhZFxyXG4gICAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ21lc3NhZ2VzJywgW1tbJ05vIG1hdGNoZXMgdG8gc2VhcmNoLicsICdjb21tZW50J11dXSk7XHJcbiAgICAgICAgICAgIGRpc3BhdGNoZXIucG9zdCgnY2xlYXJTZWFyY2gnLCBbdHJ1ZV0pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYXBwbHlTZWFyY2hSZXN1bHRzKHJlc3BvbnNlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XSk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgJCgnI3NlYXJjaF9mb3JtX2xvYWRfZmlsZScpLmNoYW5nZShmdW5jdGlvbihldnQpIHtcclxuICAgICAgICB2YXIgJGZpbGUgPSAkKCcjc2VhcmNoX2Zvcm1fbG9hZF9maWxlJyk7XHJcbiAgICAgICAgdmFyIGZpbGUgPSAkZmlsZVswXS5maWxlc1swXTtcclxuICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuICAgICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdtZXNzYWdlcycsIFtbWydUaGUgZmlsZSBjb3VsZCBub3QgYmUgcmVhZC4nLCAnZXJyb3InXV1dKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbihldnQpIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGxvYWRlZFNlYXJjaERhdGEgPSBKU09OLnBhcnNlKGV2dC50YXJnZXQucmVzdWx0KTtcclxuICAgICAgICAgICAgLy8gVE9ETyBYWFggY2hlY2sgZm9yIHZhbGlkaXR5IG9mIGNvbnRlbnRzLCBub3QganVzdCB3aGV0aGVyXHJcbiAgICAgICAgICAgIC8vIGl0J3MgdmFsaWQgSlNPTiBvciBub3Q7IHRocm93IHNvbWV0aGluZyBpZiBub3RcclxuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcclxuICAgICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdtZXNzYWdlcycsIFtbWydUaGUgZmlsZSBjb250YWlucyBpbnZhbGlkIGRhdGEuJywgJ2Vycm9yJ11dXSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGUpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHNlYXJjaEZvcm0uc3VibWl0KHNlYXJjaEZvcm1TdWJtaXQpO1xyXG5cclxuICAgICAgaW5pdEZvcm0oc2VhcmNoRm9ybSwge1xyXG4gICAgICAgICAgd2lkdGg6IDUwMCxcclxuICAgICAgICAgIC8vIGFsc29SZXNpemU6ICcjc2VhcmNoX3RhYnMnLFxyXG4gICAgICAgICAgcmVzaXphYmxlOiBmYWxzZSxcclxuICAgICAgICAgIG9wZW46IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgICAgICBrZXltYXAgPSB7fTtcclxuICAgICAgICAgIH0sXHJcbiAgICAgIH0pO1xyXG4gICAgICAkKCcjc2VhcmNoX2Zvcm1fY2xlYXInKS5hdHRyKCd0aXRsZScsICdDbGVhciB0aGUgc2VhcmNoIGFuZCByZXN1bWUgbm9ybWFsIGNvbGxlY3Rpb24gYnJvd3NpbmcnKTtcclxuXHJcbiAgICAgIHZhciBzaG93U2VhcmNoRm9ybSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vIHRoaXMuY2hlY2tlZCA9IHNlYXJjaEFjdGl2ZTsgLy8gVE9ETzogZHVwPyB1bm5lY2Vzc2FyeT8gcmVtb3ZlIGlmIHllcy5cclxuICAgICAgICB1cGRhdGVTZWFyY2hCdXR0b25zKCk7XHJcbiAgICAgICAgJCgnI3NlYXJjaF9mb3JtX2V2ZW50X3R5cGUnKS5jaGFuZ2UoKTtcclxuICAgICAgICAkKCcjc2VhcmNoX2Zvcm1fcmVsYXRpb25fdHlwZScpLmNoYW5nZSgpO1xyXG4gICAgICAgIGRpc3BhdGNoZXIucG9zdCgnc2hvd0Zvcm0nLCBbc2VhcmNoRm9ybV0pO1xyXG4gICAgICAgIG9uU2VhcmNoVGFiU2VsZWN0KCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgICQoJyNzZWFyY2hfYnV0dG9uJykuY2xpY2soc2hvd1NlYXJjaEZvcm0pO1xyXG5cclxuICAgICAgdmFyIGNsZWFyU2VhcmNoUmVzdWx0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vIGNsZWFyIFVJLCBkb24ndCBzaG93IGNvbGxlY3Rpb24gYnJvd3NlclxyXG4gICAgICAgIGRpc3BhdGNoZXIucG9zdCgnY2xlYXJTZWFyY2gnLCBbdHJ1ZV0pO1xyXG4gICAgICAgIC8vIFRPRE86IHRoaXMgd2FzIHRoZSBvbmx5IHdheSBJIGZvdW5kIHRvIHJlc2V0IHNlYXJjaC4gSXRcclxuICAgICAgICAvLyB0cmlnZ2VyIGFuIHVubmVjZXNzYXJ5IHJvdW5kLXRyaXAgdG8gdGhlIHNlcnZlciwgdGhvdWdoLFxyXG4gICAgICAgIC8vIHNvIHRoZXJlIHNob3VsZCBiZSBhIGJldHRlciB3YXkgLi4uXHJcbiAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdzZXRBcmd1bWVudHMnLCBbe30sIHRydWVdKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgJCgnI2NsZWFyX3NlYXJjaF9idXR0b24nKS5jbGljayhjbGVhclNlYXJjaFJlc3VsdHMpO1xyXG5cclxuICAgICAgdmFyIHVwZGF0ZVNlYXJjaEJ1dHRvbnMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAkc2VhcmNoQnV0dG9uID0gJCgnI3NlYXJjaF9idXR0b24nKTtcclxuICAgICAgICAkc2VhcmNoQnV0dG9uWzBdLmNoZWNrZWQgPSBzZWFyY2hBY3RpdmU7XHJcbiAgICAgICAgJHNlYXJjaEJ1dHRvbi5idXR0b24oJ3JlZnJlc2gnKTtcclxuICAgICAgICAkY2xlYXJTZWFyY2hCdXR0b24gPSAkKCcjY2xlYXJfc2VhcmNoX2J1dHRvbicpO1xyXG4gICAgICAgIGlmIChzZWFyY2hBY3RpdmUpIHtcclxuICAgICAgICAgICAgLy8gVE9ETzogdGhpcyBpcyBhIGJpdCBwb29yIGZvcm0sIHVzaW5nIGpRdWVyeSBVSSBjbGFzc2VzXHJcbiAgICAgICAgICAgIC8vIGRpcmVjdGx5IC0tIGFyZSB0aGVzZSBuYW1lcyBndWFyYW50ZWVkIHRvIGJlIHN0YWJsZT9cclxuICAgICAgICAgICAgJCgnI3NlYXJjaF9idXR0b25fbGFiZWwnKS5yZW1vdmVDbGFzcygndWktY29ybmVyLWFsbCcpO1xyXG4gICAgICAgICAgICAkKCcjc2VhcmNoX2J1dHRvbl9sYWJlbCcpLmFkZENsYXNzKCd1aS1jb3JuZXItbGVmdCcpO1xyXG4gICAgICAgICAgICAkY2xlYXJTZWFyY2hCdXR0b24uc2hvdygpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICQoJyNzZWFyY2hfYnV0dG9uX2xhYmVsJykucmVtb3ZlQ2xhc3MoJ3VpLWNvcm5lci1sZWZ0Jyk7XHJcbiAgICAgICAgICAgICQoJyNzZWFyY2hfYnV0dG9uX2xhYmVsJykuYWRkQ2xhc3MoJ3VpLWNvcm5lci1hbGwnKTtcclxuICAgICAgICAgICAgJGNsZWFyU2VhcmNoQnV0dG9uLmhpZGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8qIEVORCBzZWFyY2ggLSByZWxhdGVkICovXHJcblxyXG5cclxuICAgICAgLyogU1RBUlQgZGF0YSBkaWFsb2cgLSByZWxhdGVkICovXHJcblxyXG4gICAgICB2YXIgZGF0YUZvcm0gPSAkKCcjZGF0YV9mb3JtJyk7XHJcbiAgICAgIHZhciBkYXRhRm9ybVN1Ym1pdCA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgIGRpc3BhdGNoZXIucG9zdCgnaGlkZUZvcm0nKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH07XHJcbiAgICAgIGRhdGFGb3JtLnN1Ym1pdChkYXRhRm9ybVN1Ym1pdCk7XHJcbiAgICAgIGluaXRGb3JtKGRhdGFGb3JtLCB7XHJcbiAgICAgICAgICB3aWR0aDogNTAwLFxyXG4gICAgICAgICAgcmVzaXphYmxlOiBmYWxzZSxcclxuICAgICAgICAgIG5vX2NhbmNlbDogdHJ1ZSxcclxuICAgICAgICAgIG9wZW46IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgICAgICBrZXltYXAgPSB7fTtcclxuICAgICAgICAgICAgLy8gYXNwZWN0cyBvZiB0aGUgZGF0YSBmb3JtIHJlbGF0aW5nIHRvIHRoZSBjdXJyZW50IGRvY3VtZW50IHNob3VsZFxyXG4gICAgICAgICAgICAvLyBvbmx5IGJlIHNob3duIHdoZW4gYSBkb2N1bWVudCBpcyBzZWxlY3RlZC5cclxuICAgICAgICAgICAgaWYgKCFkb2MpIHtcclxuICAgICAgICAgICAgICAkKCcjZG9jdW1lbnRfZXhwb3J0JykuaGlkZSgpO1xyXG4gICAgICAgICAgICAgICQoJyNkb2N1bWVudF92aXN1YWxpemF0aW9uJykuaGlkZSgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICQoJyNkb2N1bWVudF9leHBvcnQnKS5zaG93KCk7XHJcbiAgICAgICAgICAgICAgJCgnI2RvY3VtZW50X3Zpc3VhbGl6YXRpb24nKS5zaG93KCk7XHJcbiAgICAgICAgICAgICAgLy8gdGhlIFNWRyBidXR0b24gY2FuIG9ubHkgYmUgYWNjZXNzZWQgdGhyb3VnaCB0aGUgZGF0YSBmb3JtLFxyXG4gICAgICAgICAgICAgIC8vIHNvIHdlJ2xsIHNwYXJlIHVubmVjZXNzYXJ5IHNhdmVzIGJ5IG9ubHkgc2F2aW5nIGhlcmVcclxuICAgICAgICAgICAgICBzYXZlU1ZHKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgICQoJyNkYXRhX2J1dHRvbicpLmNsaWNrKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGRpc3BhdGNoZXIucG9zdCgnc2hvd0Zvcm0nLCBbZGF0YUZvcm1dKTtcclxuICAgICAgfSk7XHJcbiAgICAgIC8vIG1ha2UgbmljZS1sb29raW5nIGJ1dHRvbnMgZm9yIGNoZWNrYm94ZXMgYW5kIGJ1dHRvbnNcclxuICAgICAgJCgnI2RhdGFfZm9ybScpLmZpbmQoJ2lucHV0W3R5cGU9XCJjaGVja2JveFwiXScpLmJ1dHRvbigpO1xyXG4gICAgICAkKCcjZGF0YV9mb3JtJykuZmluZCgnaW5wdXRbdHlwZT1cImJ1dHRvblwiXScpLmJ1dHRvbigpO1xyXG5cclxuICAgICAgLy8gcmVzaXplIGludmFsaWRhdGVzIHN0b3JlZCB2aXN1YWxpemF0aW9uIChTVkcgZXRjLik7IGFkZCBhXHJcbiAgICAgIC8vIGJ1dHRvbiB0byByZWdlblxyXG4gICAgICAkKCcjc3RvcmVkX2ZpbGVfcmVnZW5lcmF0ZScpLmJ1dHRvbigpLmhpZGUoKTtcclxuICAgICAgJCgnI3N0b3JlZF9maWxlX3JlZ2VuZXJhdGUnKS5jbGljayhmdW5jdGlvbihldnQpIHtcclxuICAgICAgICAkKCcjc3RvcmVkX2ZpbGVfcmVnZW5lcmF0ZScpLmhpZGUoKTtcclxuICAgICAgICBzYXZlU1ZHKCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLyogRU5EIGRhdGEgZGlhbG9nIC0gcmVsYXRlZCAqL1xyXG5cclxuXHJcbiAgICAgIC8qIFNUQVJUIG9wdGlvbnMgZGlhbG9nIC0gcmVsYXRlZCAqL1xyXG5cclxuICAgICAgdmFyIG9wdGlvbnNGb3JtID0gJCgnI29wdGlvbnNfZm9ybScpO1xyXG4gICAgICB2YXIgb3B0aW9uc0Zvcm1TdWJtaXQgPSBmdW5jdGlvbihldnQpIHtcclxuICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ2hpZGVGb3JtJyk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9O1xyXG4gICAgICBvcHRpb25zRm9ybS5zdWJtaXQob3B0aW9uc0Zvcm1TdWJtaXQpO1xyXG4gICAgICBpbml0Rm9ybShvcHRpb25zRm9ybSwge1xyXG4gICAgICAgICAgd2lkdGg6IDU1MCxcclxuICAgICAgICAgIHJlc2l6YWJsZTogZmFsc2UsXHJcbiAgICAgICAgICBub19jYW5jZWw6IHRydWUsXHJcbiAgICAgICAgICBvcGVuOiBmdW5jdGlvbihldnQpIHtcclxuICAgICAgICAgICAga2V5bWFwID0ge307XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICAkKCcjb3B0aW9uc19idXR0b24nKS5jbGljayhmdW5jdGlvbigpIHtcclxuICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ3Nob3dGb3JtJywgW29wdGlvbnNGb3JtXSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICAvLyBtYWtlIG5pY2UtbG9va2luZyBidXR0b25zIGZvciBjaGVja2JveGVzIGFuZCByYWRpb3NcclxuICAgICAgJCgnI29wdGlvbnNfZm9ybScpLmZpbmQoJ2lucHV0W3R5cGU9XCJjaGVja2JveFwiXScpLmJ1dHRvbigpO1xyXG4gICAgICAkKCcjb3B0aW9uc19mb3JtJykuZmluZCgnLnJhZGlvX2dyb3VwJykuYnV0dG9uc2V0KCk7XHJcbiAgICAgICQoJyNyYXBpZF9tb2RlbCcpLmFkZENsYXNzKCd1aS13aWRnZXQgdWktc3RhdGUtZGVmYXVsdCB1aS1idXR0b24tdGV4dCcpO1xyXG5cclxuICAgICAgdmFyIGZpbGxEaXNhbWJpZ3VhdG9yT3B0aW9ucyA9IGZ1bmN0aW9uKGRpc2FtYmlndWF0b3JzKSB7XHJcbiAgICAgICAgJCgnI2Fubm90YXRpb25fc3BlZWQzJykuYnV0dG9uKGRpc2FtYmlndWF0b3JzLmxlbmd0aCA/ICdlbmFibGUnOiAnZGlzYWJsZScpO1xyXG4gICAgICAgIC8vWFhYOiBXZSBuZWVkIHRvIGRpc2FibGUgcmFwaWQgaW4gdGhlIGNvbmYgdG9vIGlmIGl0IGlzIG5vdCBhdmFpbGFibGVcclxuICAgICAgICB2YXIgJHJhcGlkX21vZGUgPSAkKCcjcmFwaWRfbW9kZWwnKS5odG1sKCcnKTtcclxuICAgICAgICAkLmVhY2goZGlzYW1iaWd1YXRvcnMsIGZ1bmN0aW9uKG1vZGVsTm8sIG1vZGVsKSB7XHJcbiAgICAgICAgICB2YXIgJG9wdGlvbiA9ICQoJzxvcHRpb24vPicpLmF0dHIoJ3ZhbHVlJywgbW9kZWxbMl0pLnRleHQobW9kZWxbMl0pO1xyXG4gICAgICAgICAgJHJhcGlkX21vZGUuYXBwZW5kKCRvcHRpb24pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgLyogRU5EIG9wdGlvbnMgZGlhbG9nIC0gcmVsYXRlZCAqL1xyXG5cclxuXHJcbiAgICAgIC8qIFNUQVJUIFwibW9yZSBjb2xsZWN0aW9uIGluZm9ybWF0aW9uXCIgZGlhbG9nIC0gcmVsYXRlZCAqL1xyXG5cclxuICAgICAgdmFyIG1vcmVJbmZvRGlhbG9nID0gJCgnI21vcmVfaW5mb3JtYXRpb25fZGlhbG9nJyk7XHJcbiAgICAgIHZhciBtb3JlSW5mb0RpYWxvZ1N1Ym1pdCA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgIGRpc3BhdGNoZXIucG9zdCgnaGlkZUZvcm0nKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH07XHJcbiAgICAgIG1vcmVJbmZvRGlhbG9nLnN1Ym1pdChtb3JlSW5mb0RpYWxvZ1N1Ym1pdCk7XHJcbiAgICAgIGluaXRGb3JtKG1vcmVJbmZvRGlhbG9nLCB7XHJcbiAgICAgICAgICB3aWR0aDogNTAwLFxyXG4gICAgICAgICAgbm9fY2FuY2VsOiB0cnVlLFxyXG4gICAgICAgICAgb3BlbjogZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgICAgIGtleW1hcCA9IHt9O1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGFsc29SZXNpemU6ICcjbW9yZV9pbmZvX3JlYWRtZScsXHJcbiAgICAgIH0pO1xyXG4gICAgICAkKCcjbW9yZV9yZWFkbWVfYnV0dG9uJykuY2xpY2soZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdzaG93Rm9ybScsIFttb3JlSW5mb0RpYWxvZ10pO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8qIEVORCBcIm1vcmUgY29sbGVjdGlvbiBpbmZvcm1hdGlvblwiIGRpYWxvZyAtIHJlbGF0ZWQgKi9cclxuXHJcblxyXG4gICAgICB2YXIgb25LZXlEb3duID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgdmFyIGNvZGUgPSBldnQud2hpY2g7XHJcblxyXG4gICAgICAgIGlmIChjb2RlID09PSAkLnVpLmtleUNvZGUuRVNDQVBFKSB7XHJcbiAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ21lc3NhZ2VzJywgW2ZhbHNlXSk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY3VycmVudEZvcm0pIHtcclxuICAgICAgICAgIGlmIChjb2RlID09PSAkLnVpLmtleUNvZGUuRU5URVIpIHtcclxuICAgICAgICAgICAgLy8gZG9uJ3QgdHJpZ2dlciBzdWJtaXQgaW4gdGV4dGFyZWFzIHRvIGFsbG93IG11bHRpbGluZSB0ZXh0XHJcbiAgICAgICAgICAgIC8vIGVudHJ5XHJcbiAgICAgICAgICAgIC8vIE5PVEU6IHNwZWMgc2VlbXMgdG8gcmVxdWlyZSB0aGlzIHRvIGJlIHVwcGVyLWNhc2UsXHJcbiAgICAgICAgICAgIC8vIGJ1dCBhdCBsZWFzdCBjaHJvbWUgOC4wLjU1Mi4yMTUgcmV0dXJucyBsb3dlcmNhc2VkXHJcbiAgICAgICAgICAgIHZhciBub2RlVHlwZSA9IGV2dC50YXJnZXQudHlwZSA/IGV2dC50YXJnZXQudHlwZS50b0xvd2VyQ2FzZSgpIDogJyc7XHJcbiAgICAgICAgICAgIGlmIChldnQudGFyZ2V0Lm5vZGVOYW1lICYmIFxyXG4gICAgICAgICAgICAgICAgZXZ0LnRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09ICdpbnB1dCcgJiYgXHJcbiAgICAgICAgICAgICAgICAobm9kZVR5cGUgPT0gJ3RleHQnIHx8IFxyXG4gICAgICAgICAgICAgICAgIG5vZGVUeXBlID09ICdwYXNzd29yZCcpKSB7XHJcbiAgICAgICAgICAgICAgY3VycmVudEZvcm0udHJpZ2dlcignc3VibWl0Jyk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGV2dC5jdHJsS2V5ICYmXHJcbiAgICAgICAgICAgICAgICAoY29kZSA9PSAnRicuY2hhckNvZGVBdCgwKSB8fCBjb2RlID09ICdHJy5jaGFyQ29kZUF0KDApKSkge1xyXG4gICAgICAgICAgICAvLyBwcmV2ZW50IEN0cmwtRi9DdHJsLUcgaW4gZm9ybXNcclxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjb2RlID09PSAkLnVpLmtleUNvZGUuVEFCKSB7XHJcbiAgICAgICAgICBzaG93RmlsZUJyb3dzZXIoKTtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT0gJC51aS5rZXlDb2RlLkxFRlQpIHtcclxuICAgICAgICAgIHJldHVybiBtb3ZlSW5GaWxlQnJvd3NlcigtMSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAkLnVpLmtleUNvZGUuUklHSFQpIHtcclxuICAgICAgICAgIHJldHVybiBtb3ZlSW5GaWxlQnJvd3NlcigrMSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChldnQuc2hpZnRLZXkgJiYgY29kZSA9PT0gJC51aS5rZXlDb2RlLlVQKSB7XHJcbiAgICAgICAgICBhdXRvUGFnaW5nKHRydWUpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZXZ0LnNoaWZ0S2V5ICYmIGNvZGUgPT09ICQudWkua2V5Q29kZS5ET1dOKSB7XHJcbiAgICAgICAgICBhdXRvUGFnaW5nKGZhbHNlKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGV2dC5jdHJsS2V5ICYmIGNvZGUgPT0gJ0YnLmNoYXJDb2RlQXQoMCkpIHtcclxuICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgc2hvd1NlYXJjaEZvcm0oKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHNlYXJjaEFjdGl2ZSAmJiBldnQuY3RybEtleSAmJiBjb2RlID09ICdHJy5jaGFyQ29kZUF0KDApKSB7XHJcbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgIHJldHVybiBtb3ZlSW5GaWxlQnJvd3NlcigrMSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChzZWFyY2hBY3RpdmUgJiYgZXZ0LmN0cmxLZXkgJiYgY29kZSA9PSAnSycuY2hhckNvZGVBdCgwKSkge1xyXG4gICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICBjbGVhclNlYXJjaFJlc3VsdHMoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgbW92ZUluRmlsZUJyb3dzZXIgPSBmdW5jdGlvbihkaXIpIHtcclxuICAgICAgICB2YXIgcG9zID0gY3VycmVudFNlbGVjdG9yUG9zaXRpb24oKTtcclxuICAgICAgICB2YXIgbmV3UG9zID0gcG9zICsgZGlyO1xyXG4gICAgICAgIGlmIChuZXdQb3MgPj0gMCAmJiBuZXdQb3MgPCBzZWxlY3RvckRhdGEuaXRlbXMubGVuZ3RoICYmXHJcbiAgICAgICAgICAgIHNlbGVjdG9yRGF0YS5pdGVtc1tuZXdQb3NdWzBdICE9IFwiY1wiKSB7XHJcbiAgICAgICAgICAvLyBub3QgYXQgdGhlIHN0YXJ0LCBhbmQgdGhlIHByZXZpb3VzIGlzIG5vdCBhIGNvbGxlY3Rpb24gKGRpcilcclxuICAgICAgICAgIGRpc3BhdGNoZXIucG9zdCgnYWxsb3dSZWxvYWRCeVVSTCcpO1xyXG4gICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdzZXREb2N1bWVudCcsIFtzZWxlY3RvckRhdGEuaXRlbXNbbmV3UG9zXVsyXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JEYXRhLml0ZW1zW25ld1Bvc11bMV1dKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9O1xyXG4gICAgIFxyXG4gICAgICAvKiBBdXRvbWF0aWNhbGx5IHByb2NlZWQgZnJvbSBkb2N1bWVudCB0byBkb2N1bWVudCAqLyBcclxuICAgICAgdmFyIGF1dG9QYWdpbmdUaW1lb3V0ID0gbnVsbDtcclxuICAgICAgdmFyIGF1dG9QYWdpbmcgPSBmdW5jdGlvbihvbikge1xyXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KGF1dG9QYWdpbmdUaW1lb3V0KTtcclxuICAgICAgICAgIGlmIChvbikge1xyXG4gICAgICAgICAgICBhdXRvUGFnaW5nVGltZW91dCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgIG1vdmVJbkZpbGVCcm93c2VyKCsxKTtcclxuICAgICAgICAgICAgfSwgMjAwMCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgcmVzaXplRnVuY3Rpb24gPSBmdW5jdGlvbihldnQpIHtcclxuICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ3JlbmRlckRhdGEnKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciByZXNpemVyVGltZW91dCA9IG51bGw7XHJcbiAgICAgIHZhciBvblJlc2l6ZSA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgIGlmIChldnQudGFyZ2V0ID09PSB3aW5kb3cpIHtcclxuICAgICAgICAgIGNsZWFyVGltZW91dChyZXNpemVyVGltZW91dCk7XHJcbiAgICAgICAgICByZXNpemVyVGltZW91dCA9IHNldFRpbWVvdXQocmVzaXplRnVuY3Rpb24sIDEwMCk7IC8vIFRPRE8gaXMgMTAwbXMgb2theT9cclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgY29sbGVjdGlvbkxvYWRlZCA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgaWYgKHJlc3BvbnNlLmV4Y2VwdGlvbikge1xyXG4gICAgICAgICAgaWYgKHJlc3BvbnNlLmV4Y2VwdGlvbiA9PSAnYW5ub3RhdGlvbkNvbGxlY3Rpb25Ob3RGb3VuZCcgfHxcclxuICAgICAgICAgICAgICByZXNwb25zZS5leGNlcHRpb24gPT0gJ2NvbGxlY3Rpb25Ob3RBY2Nlc3NpYmxlJykge1xyXG4gICAgICAgICAgICAgIC8vIHJldmVydCB0byBsYXN0IGdvb2RcclxuICAgICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdzZXRDb2xsZWN0aW9uJywgW2xhc3RHb29kQ29sbGVjdGlvbl0pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ21lc3NhZ2VzJywgW1tbJ1Vua25vd24gZXJyb3I6ICcgKyByZXNwb25zZS5leGNlcHRpb24sICdlcnJvciddXV0pO1xyXG4gICAgICAgICAgICAgIGRpc3BhdGNoZXIucG9zdCgnc2V0Q29sbGVjdGlvbicsIFsnLyddKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbGFzdEdvb2RDb2xsZWN0aW9uID0gcmVzcG9uc2UuY29sbGVjdGlvbjtcclxuICAgICAgICAgIGZpbGxEaXNhbWJpZ3VhdG9yT3B0aW9ucyhyZXNwb25zZS5kaXNhbWJpZ3VhdG9yX2NvbmZpZyk7XHJcbiAgICAgICAgICBzZWxlY3RvckRhdGEgPSByZXNwb25zZTtcclxuICAgICAgICAgIGRvY3VtZW50TGlzdGluZyA9IHJlc3BvbnNlOyAvLyAnYmFja3VwJ1xyXG4gICAgICAgICAgc2VhcmNoQ29uZmlnID0gcmVzcG9uc2Uuc2VhcmNoX2NvbmZpZztcclxuICAgICAgICAgIHNlbGVjdG9yRGF0YS5pdGVtcy5zb3J0KGRvY1NvcnRGdW5jdGlvbik7XHJcbiAgICAgICAgICBzZXR1cFNlYXJjaFR5cGVzKHJlc3BvbnNlKTtcclxuICAgICAgICAgIC8vIHNjcm9sbGVyIGF0IHRoZSB0b3BcclxuICAgICAgICAgIGRvY1Njcm9sbCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgdmFyIHNlYXJjaFJlc3VsdHNSZWNlaXZlZCA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgaWYgKHJlc3BvbnNlLmV4Y2VwdGlvbikge1xyXG4gICAgICAgICAgICA7IC8vIFRPRE86IHJlYXNvbmFibGUgcmVhY3Rpb25cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc2VsZWN0b3JEYXRhID0gcmVzcG9uc2U7XHJcbiAgICAgICAgICBzb3J0T3JkZXIgPSBbMiwgMV07IC8vIHJlc2V0XHJcbiAgICAgICAgICAvLyBOT1RFOiBkb24ndCBzb3J0LCBhbGxvd2luZyBvcmRlciBpbiB3aGljaFxyXG4gICAgICAgICAgLy8gcmVzcG9uc2VzIGFyZSBnaXZlbiB0byBiZSB1c2VkIGFzIGRlZmF1bHRcclxuICAgICAgICAgIC8vc2VsZWN0b3JEYXRhLml0ZW1zLnNvcnQoZG9jU29ydEZ1bmN0aW9uKTtcclxuICAgICAgICAgIGlmIChyZXNwb25zZS5hY3Rpb24ubWF0Y2goL0NvbGxlY3Rpb24kLykpIHtcclxuICAgICAgICAgICAgc2hvd0ZpbGVCcm93c2VyKCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgaXRlbSA9IHJlc3BvbnNlLml0ZW1zWzBdO1xyXG4gICAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ3NldERvY3VtZW50JywgW2l0ZW1bMl0sIGl0ZW1bMV1dKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgICQoJyNzYXZlX3NlYXJjaCcpLmNzcygnZGlzcGxheScsICdpbmxpbmUtYmxvY2snKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgY2xlYXJTZWFyY2ggPSBmdW5jdGlvbihkb250U2hvd0ZpbGVCcm93c2VyKSB7XHJcbiAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdoaWRlRm9ybScpO1xyXG5cclxuICAgICAgICAvLyBiYWNrIG9mZiB0byBkb2N1bWVudCBjb2xsZWN0aW9uXHJcbiAgICAgICAgaWYgKHNlYXJjaEFjdGl2ZSkge1xyXG4gICAgICAgICAgJCgnI3NhdmVfc2VhcmNoJykuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcclxuICAgICAgICAgIHNlbGVjdG9yRGF0YSA9IGRvY3VtZW50TGlzdGluZztcclxuICAgICAgICAgIHNvcnRPcmRlciA9IGNvbGxlY3Rpb25Tb3J0T3JkZXI7XHJcbiAgICAgICAgICBzZWxlY3RvckRhdGEuaXRlbXMuc29ydChkb2NTb3J0RnVuY3Rpb24pO1xyXG4gICAgICAgICAgc2VhcmNoQWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICB1cGRhdGVTZWFyY2hCdXR0b25zKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWRvbnRTaG93RmlsZUJyb3dzZXIpIHtcclxuICAgICAgICAgIHNob3dGaWxlQnJvd3NlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHNhdmVTVkdUaW1lciA9IG51bGw7XHJcbiAgICAgIHZhciBzYXZlU1ZHID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKGN1cnJlbnREb2N1bWVudFNWR3NhdmVkKSB7XHJcbiAgICAgICAgICAvLyBubyBuZWVkIHRvIHN0b3JlIGFnYWluXHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNsZWFyVGltZW91dChzYXZlU1ZHVGltZXIpO1xyXG4gICAgICAgICQoJyNzdG9yZWRfZmlsZV9yZWdlbmVyYXRlJykuaGlkZSgpO1xyXG4gICAgICAgICQoJyNzdG9yZWRfZmlsZV9zcGlubmVyJykuc2hvdygpXHJcbiAgICAgICAgc2F2ZVNWR1RpbWVyID0gZGlzcGF0Y2hlci5wb3N0KDEsICdhamF4JywgW3tcclxuICAgICAgICAgIGFjdGlvbjogJ3N0b3JlU1ZHJyxcclxuICAgICAgICAgIHN2ZzogJCgnI3N2ZycpLmh0bWwoKSxcclxuICAgICAgICAgIGNvbGxlY3Rpb246IGNvbGwsXHJcbiAgICAgICAgICBkb2N1bWVudDogZG9jXHJcbiAgICAgICAgfSwgJ3NhdmVkU1ZHJ10pO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdmFyIG9uRG9uZVJlbmRlcmluZyA9IGZ1bmN0aW9uKGNvbGwsIGRvYywgYXJncykge1xyXG4gICAgICAgIGlmIChhcmdzICYmICFhcmdzLmVkaXRlZCkge1xyXG4gICAgICAgICAgdmFyIHN2Z3RvcCA9ICQoJ3N2ZycpLm9mZnNldCgpLnRvcDtcclxuICAgICAgICAgIHZhciAkaW5Gb2N1cyA9ICQoJyNzdmcgYW5pbWF0ZVtkYXRhLXR5cGU9XCJmb2N1c1wiXTpmaXJzdCcpLnBhcmVudCgpO1xyXG4gICAgICAgICAgaWYgKCRpbkZvY3VzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAkKCdodG1sLGJvZHknKS5cclxuICAgICAgICAgICAgICAgIGFuaW1hdGUoeyBzY3JvbGxUb3A6ICRpbkZvY3VzLm9mZnNldCgpLnRvcCAtIHN2Z3RvcCAtIHdpbmRvdy5pbm5lckhlaWdodCAvIDIgfSwgeyBkdXJhdGlvbjogJ3Nsb3cnLCBlYXNpbmc6ICdzd2luZyd9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdhbGxvd1JlbG9hZEJ5VVJMJyk7XHJcbiAgICAgICAgaWYgKCFjdXJyZW50Rm9ybSkge1xyXG4gICAgICAgICAgJCgnI3dhaXRlcicpLmRpYWxvZygnY2xvc2UnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBvblN0YXJ0ZWRSZW5kZXJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBoaWRlRm9ybSgpO1xyXG4gICAgICAgIGlmICghY3VycmVudEZvcm0pIHtcclxuICAgICAgICAgICQoJyN3YWl0ZXInKS5kaWFsb2coJ29wZW4nKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBzYXZlZFNWR3JlY2VpdmVkID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcclxuICAgICAgICAkKCcjc3RvcmVkX2ZpbGVfc3Bpbm5lcicpLmhpZGUoKVxyXG5cclxuICAgICAgICBpZiAocmVzcG9uc2UgJiYgcmVzcG9uc2UuZXhjZXB0aW9uID09ICdjb3JydXB0U1ZHJykge1xyXG4gICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdtZXNzYWdlcycsIFtbWydDYW5ub3Qgc2F2ZSBTVkc6IGNvcnJ1cHQnLCAnZXJyb3InXV1dKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyICRkb3dubG9hZFN0b3JlZCA9ICQoJyNkb3dubG9hZF9zdG9yZWQnKS5lbXB0eSgpLnNob3coKTtcclxuICAgICAgICAkLmVhY2gocmVzcG9uc2Uuc3RvcmVkLCBmdW5jdGlvbihzdG9yZWRObywgc3RvcmVkKSB7XHJcbiAgICAgICAgICB2YXIgcGFyYW1zID0ge1xyXG4gICAgICAgICAgICAnYWN0aW9uJzogJ3JldHJpZXZlU3RvcmVkJyxcclxuICAgICAgICAgICAgJ2RvY3VtZW50JzogZG9jLFxyXG4gICAgICAgICAgICAnc3VmZml4Jzogc3RvcmVkLnN1ZmZpeCxcclxuICAgICAgICAgICAgLy8gVE9ETzogRXh0cmFjdCB0aGUgcHJvdG9jb2wgdmVyc2lvbiBpbnRvIHNvbWV3aGVyZSBnbG9iYWxcclxuICAgICAgICAgICAgJ3Byb3RvY29sJzogMVxyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIHZhciAkZG93bmxvYWRMaW5rID0gJCgnPGEgaWQ9XCJkb3dubG9hZF8nK3N0b3JlZC5uYW1lKydcIicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgdGFyZ2V0PVwiJytzdG9yZWQubmFtZSsnXCInICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPicrc3RvcmVkLm5hbWUrJzwvYT4nKTtcclxuICAgICAgICAgICRkb3dubG9hZExpbmsuYXR0cignaHJlZicsICdhamF4LmNnaT8nICsgJC5wYXJhbShwYXJhbXMpKTtcclxuICAgICAgICAgICRkb3dubG9hZExpbmsuYnV0dG9uKCk7XHJcbiAgICAgICAgICBpZiAoc3RvcmVkTm8pICRkb3dubG9hZFN0b3JlZC5hcHBlbmQoJyAnKTtcclxuICAgICAgICAgICRkb3dubG9hZFN0b3JlZC5hcHBlbmQoJGRvd25sb2FkTGluayk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY3VycmVudERvY3VtZW50U1ZHc2F2ZWQgPSB0cnVlO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdmFyIGludmFsaWRhdGVTYXZlZFNWRyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vIGFzc3VtaW5nIHRoYXQgaW52YWxpZGF0aW9uIG9mIHRoZSBTVkcgaW52YWxpZGF0ZXMgYWxsIHN0b3JlZFxyXG4gICAgICAgIC8vIHN0YXRpYyB2aXN1YWxpemF0aW9ucywgYXMgb3RoZXJzIGFyZSBkZXJpdmVkIGZyb20gdGhlIFNWR1xyXG4gICAgICAgICQoJyNkb3dubG9hZF9zdG9yZWQnKS5oaWRlKCk7XHJcbiAgICAgICAgLy8gaGF2ZSBhIHdheSB0byByZWdlbmVyYXRlIGlmIGRpYWxvZyBvcGVuIHdoZW4gZGF0YSBpbnZhbGlkYXRlZFxyXG4gICAgICAgICQoJyNzdG9yZWRfZmlsZV9yZWdlbmVyYXRlJykuc2hvdygpO1xyXG4gICAgICAgIGN1cnJlbnREb2N1bWVudFNWR3NhdmVkID0gZmFsc2U7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgb25OZXdTb3VyY2VEYXRhID0gZnVuY3Rpb24oc291cmNlRGF0YSkge1xyXG4gICAgICAgIGlmICghc291cmNlRGF0YSkgcmV0dXJuO1xyXG4gICAgICAgIHZhciAkc291cmNlRmlsZXMgPSAkKCcjc291cmNlX2ZpbGVzJykuZW1wdHkoKTtcclxuICAgICAgICAvKiBBZGQgZG93bmxvYWQgbGlua3MgZm9yIGFsbCBhdmFpbGFibGUgZXh0ZW5zaW9ucyAqL1xyXG4gICAgICAgICQuZWFjaChzb3VyY2VEYXRhLnNvdXJjZV9maWxlcywgZnVuY3Rpb24oZXh0Tm8sIGV4dCkge1xyXG4gICAgICAgICAgdmFyICRsaW5rID0gJCgnPGEgdGFyZ2V0PVwiYnJhdF9zZWFyY2hcIi8+JykuXHJcbiAgICAgICAgICAgICAgdGV4dChleHQpLlxyXG4gICAgICAgICAgICAgIGF0dHIoJ2hyZWYnLFxyXG4gICAgICAgICAgICAgICAgICAnYWpheC5jZ2k/YWN0aW9uPWRvd25sb2FkRmlsZSZjb2xsZWN0aW9uPScgKyBlbmNvZGVVUklDb21wb25lbnQoY29sbCkgK1xyXG4gICAgICAgICAgICAgICAgICAnJmRvY3VtZW50PScgKyBlbmNvZGVVUklDb21wb25lbnQoZG9jKSArICcmZXh0ZW5zaW9uPScgKyBlbmNvZGVVUklDb21wb25lbnQoZXh0KSArXHJcbiAgICAgICAgICAgICAgICAgIC8vIFRPRE86IEV4dHJhY3QgdGhlIHByb3RvY29sIHZlcnNpb24gaW50byBzb21ld2hlcmUgZ2xvYmFsXHJcbiAgICAgICAgICAgICAgICAgICcmcHJvdG9jb2w9JyArIDEpO1xyXG4gICAgICAgICAgJGxpbmsuYnV0dG9uKCk7XHJcbiAgICAgICAgICBpZiAoZXh0Tm8pICRzb3VyY2VGaWxlcy5hcHBlbmQoJyAnKTtcclxuICAgICAgICAgICRzb3VyY2VGaWxlcy5hcHBlbmQoJGxpbmspO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qIEFkZCBhIGRvd25sb2FkIGxpbmsgZm9yIHRoZSB3aG9sZSBjb2xsZWN0aW9uICovXHJcbiAgICAgICAgaW52YWxpZGF0ZVNhdmVkU1ZHKCk7XHJcblxyXG4gICAgICAgIG10aW1lID0gc291cmNlRGF0YS5tdGltZTtcclxuICAgICAgICBpZiAobXRpbWUpIHtcclxuICAgICAgICAgIC8vIHdlJ3JlIGdldHRpbmcgc2Vjb25kcyBhbmQgbmVlZCBtaWxsaXNlY29uZHNcclxuICAgICAgICAgIC8vJCgnI2RvY3VtZW50X2N0aW1lJykudGV4dChcIkNyZWF0ZWQ6IFwiICsgQW5ub3RhdG9yLmZvcm1hdFRpbWUoMTAwMCAqIHNvdXJjZURhdGEuY3RpbWUpKS5jc3MoXCJkaXNwbGF5XCIsIFwiaW5saW5lXCIpO1xyXG4gICAgICAgICAgJCgnI2RvY3VtZW50X210aW1lJykudGV4dChcIkxhc3QgbW9kaWZpZWQ6IFwiICsgVXRpbC5mb3JtYXRUaW1lQWdvKDEwMDAgKiBtdGltZSkpLnNob3coKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8kKCcjZG9jdW1lbnRfY3RpbWUnKS5jc3MoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcclxuICAgICAgICAgICQoJyNkb2N1bWVudF9tdGltZScpLmhpZGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vQlJBVCBTVEFOREFMT05FIExJQlJBUlkgQkVHSU5cclxuICAgICAgLy9XZSBkbyBubyB1c2Ugbm90aW9uIG9mIGRvY3VtZW50c1xyXG4gICAgICAvKiovXHJcbiAgICAgIHZhciBnb3RDdXJyZW50ID0gZnVuY3Rpb24oX2NvbGwsIF9kb2MsIF9hcmdzKSB7XHJcbiAgICAgICAgdmFyIG9sZENvbGwgPSBjb2xsO1xyXG5cclxuICAgICAgICBjb2xsID0gX2NvbGw7XHJcbiAgICAgICAgZG9jID0gX2RvYztcclxuICAgICAgICBhcmdzID0gX2FyZ3M7XHJcblxyXG4gICAgICAgIC8vIGlmIHdlIGhhdmUgYSBzcGVjaWZpYyBkb2N1bWVudCwgaGlkZSB0aGUgXCJubyBkb2N1bWVudFwiIG1lc3NhZ2VcclxuICAgICAgICBpZiAoX2RvYykge1xyXG4gICAgICAgICAgaGlkZU5vRG9jTWVzc2FnZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIGNvbGxlY3Rpb24gY2hhbmdlLCB1cGRhdGUgXCJjb2xsZWN0aW9uIGRvd25sb2FkXCIgYW5kXHJcbiAgICAgICAgLy8gXCJzaWRlLWJ5LXNpZGUgY29tcGFyaXNvblwiIGJ1dHRvbnNcclxuICAgICAgICBpZiAob2xkQ29sbCAhPSBjb2xsKSB7XHJcbiAgICAgICAgICB2YXIgJHNvdXJjZUNvbGxlY3Rpb24gPSAkKCcjc291cmNlX2NvbGxlY3Rpb24nKS5lbXB0eSgpO1xyXG4gICAgICAgICAgdmFyICRjb2xsZWN0aW9uRG93bmxvYWRMaW5rID0gJCgnPGEgdGFyZ2V0PVwiYnJhdF9zZWFyY2hcIi8+JylcclxuICAgICAgICAgICAgLnRleHQoJ0Rvd25sb2FkIHRhci5neicpXHJcbiAgICAgICAgICAgIC5hdHRyKCdocmVmJywgJ2FqYXguY2dpP2FjdGlvbj1kb3dubG9hZENvbGxlY3Rpb24mY29sbGVjdGlvbj0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGNvbGwpXHJcbiAgICAgICAgICAgIC8vIFRPRE86IEV4dHJhY3QgdGhlIHByb3RvY29sIHZlcnNpb24gaW50byBzb21ld2hlcmUgZ2xvYmFsXHJcbiAgICAgICAgICAgICsgJyZwcm90b2NvbD0nICsgMSk7XHJcbiAgICAgICAgICAkc291cmNlQ29sbGVjdGlvbi5hcHBlbmQoJGNvbGxlY3Rpb25Eb3dubG9hZExpbmspO1xyXG4gICAgICAgICAgJGNvbGxlY3Rpb25Eb3dubG9hZExpbmsuYnV0dG9uKCk7XHJcblxyXG4gICAgICAgICAgJGNtcEJ1dHRvbiA9ICQoJyNzaWRlLWJ5LXNpZGVfY21wJykuZW1wdHkoKTtcclxuICAgICAgICAgIHZhciAkY21wTGluayA9ICQoJzxhIHRhcmdldD1cIl9ibGFua1wiLz4nKVxyXG4gICAgICAgICAgICAudGV4dCgnQ29tcGFyaXNvbiBtb2RlJylcclxuICAgICAgICAgICAgLmF0dHIoJ2hyZWYnLCAnZGlmZi54aHRtbD9kaWZmPScgKyBlbmNvZGVVUklDb21wb25lbnQoY29sbCkpO1xyXG4gICAgICAgICAgJGNtcEJ1dHRvbi5hcHBlbmQoJGNtcExpbmspO1xyXG4gICAgICAgICAgJGNtcExpbmsuYnV0dG9uKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL0JSQVQgU1RBTkRBTE9ORSBMSUJSQVJZIEJFR0lOXHJcbiAgICAgICAgLypcclxuICAgICAgICAkZG9jTmFtZSA9ICQoJyNkb2N1bWVudF9uYW1lIGlucHV0JykudmFsKGNvbGwgKyBkb2MpO1xyXG4gICAgICAgIHZhciBkb2NOYW1lID0gJGRvY05hbWVbMF07XHJcbiAgICAgICAgLy8gVE9ETyBkbyB0aGlzIG9uIHJlc2l6ZSwgYXMgd2VsbFxyXG4gICAgICAgIC8vIHNjcm9sbCB0aGUgZG9jdW1lbnQgbmFtZSB0byB0aGUgcmlnaHQsIHNvIHRoZSBuYW1lIGlzIHZpc2libGVcclxuICAgICAgICAvLyAoZXZlbiBpZiB0aGUgY29sbGVjdGlvbiBuYW1lIGlzbid0LCBmdWxseSlcclxuICAgICAgICBkb2NOYW1lLnNjcm9sbExlZnQgPSBkb2NOYW1lLnNjcm9sbFdpZHRoO1xyXG5cclxuICAgICAgICAkKCcjZG9jdW1lbnRfbXRpbWUnKS5oaWRlKCk7XHJcbiAgICAgICAgKi9cclxuICAgICAgICAvL0JSQVQgU1RBTkRBTE9ORSBMSUJSQVJZIEVORFxyXG4gICAgICAgIGludmFsaWRhdGVTYXZlZFNWRygpO1xyXG4gICAgICB9O1xyXG4gICAgICAvKiovXHJcbiAgICAgIC8vQlJBVCBTVEFOREFMT05FIExJQlJBUlkgRU5EXHJcblxyXG4gICAgICB2YXIgc2xpZGVUb2dnbGUgPSBmdW5jdGlvbihlbCwgc2hvdywgYXV0b0hlaWdodCwgYm90dG9tKSB7XHJcbiAgICAgICAgdmFyIGVsID0gJChlbCk7XHJcbiAgICAgICAgdmFyIHZpc2libGUgPSBlbC5pcyhcIjp2aXNpYmxlXCIpO1xyXG4gICAgICAgIHZhciBoZWlnaHQ7XHJcblxyXG4gICAgICAgIGlmIChzaG93ID09PSB1bmRlZmluZWQpIHNob3cgPSAhdmlzaWJsZTtcclxuXHJcbiAgICAgICAgLy8gQGFtYWRhbm1hdGg6IGNvbW1lbnRpbmcgdGhpcyBvdXQgYXBwZWFycyB0byByZW1vdmUgdGhlIGFubm95aW5nXHJcbiAgICAgICAgLy8gbWlzZmVhdHVyZSB3aGVyZSBpdCdzIHBvc3NpYmxlIHRvIHN0b3AgdGhlIG1lbnUgaGFsZndheSBieVxyXG4gICAgICAgIC8vIG1vdXNpbmcgb3V0IGFuZCBiYWNrIGluIGR1cmluZyBjbG9zaW5nLiBQbGVhc2UgY2hlY2sgdGhhdFxyXG4gICAgICAgIC8vIHRoaXMgZG9lc24ndCBpbnRyb2R1Y2Ugb3RoZXIgdHJvdWJsZSBhbmQgcmVtb3ZlIHRoZXNlIGxpbmVzLlxyXG4vLyAgICAgICAgIGlmIChzaG93ID09PSB2aXNpYmxlKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgIGlmICghYXV0b0hlaWdodCkge1xyXG4gICAgICAgICAgaGVpZ2h0ID0gZWwuZGF0YShcImNhY2hlZEhlaWdodFwiKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZWwuaGVpZ2h0KCdhdXRvJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaGVpZ2h0KSB7XHJcbiAgICAgICAgICBoZWlnaHQgPSBlbC5zaG93KCkuaGVpZ2h0KCk7XHJcbiAgICAgICAgICBlbC5kYXRhKCdjYWNoZWRIZWlnaHQnLCBoZWlnaHQpO1xyXG4gICAgICAgICAgaWYgKCF2aXNpYmxlKSBlbC5oaWRlKCkuY3NzKHsgaGVpZ2h0OiAwIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHNob3cpIHtcclxuICAgICAgICAgIGVsLnNob3coKS5hbmltYXRlKHsgaGVpZ2h0OiBoZWlnaHQgfSwge1xyXG4gICAgICAgICAgICBkdXJhdGlvbjogMTUwLFxyXG4gICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGF1dG9IZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIGVsLmhlaWdodCgnYXV0bycpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3RlcDogYm90dG9tID8gZnVuY3Rpb24obm93LCBmeCkge1xyXG4gICAgICAgICAgICAgIGZ4LmVsZW0uc2Nyb2xsVG9wID0gZnguZWxlbS5zY3JvbGxIZWlnaHQ7XHJcbiAgICAgICAgICAgIH0gOiB1bmRlZmluZWRcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBlbC5hbmltYXRlKHsgaGVpZ2h0OiAwIH0sIHtcclxuICAgICAgICAgICAgZHVyYXRpb246IDMwMCxcclxuICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgIGVsLmhpZGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgbWVudVRpbWVyID0gbnVsbDtcclxuICAgICAgJCgnI2hlYWRlcicpLlxyXG4gICAgICAgIG1vdXNlZW50ZXIoZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgICBjbGVhclRpbWVvdXQobWVudVRpbWVyKTtcclxuICAgICAgICAgIHNsaWRlVG9nZ2xlKCQoJyNwdWxsZG93bicpLnN0b3AoKSwgdHJ1ZSk7XHJcbiAgICAgICAgfSkuXHJcbiAgICAgICAgbW91c2VsZWF2ZShmdW5jdGlvbihldnQpIHtcclxuICAgICAgICAgIGNsZWFyVGltZW91dChtZW51VGltZXIpO1xyXG4gICAgICAgICAgbWVudVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgc2xpZGVUb2dnbGUoJCgnI3B1bGxkb3duJykuc3RvcCgpLCBmYWxzZSk7XHJcbiAgICAgICAgICB9LCA1MDApO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgJCgnI2xhYmVsX2FiYnJldmlhdGlvbnMgaW5wdXQnKS5jbGljayhmdW5jdGlvbihldnQpIHtcclxuICAgICAgICB2YXIgdmFsID0gdGhpcy52YWx1ZTtcclxuICAgICAgICB2YWwgPSB2YWwgPT09ICdvbic7XHJcbiAgICAgICAgaWYgKHZhbCkge1xyXG4gICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdtZXNzYWdlcycsIFtbWydBYmJyZXZpYXRpb25zIGFyZSBub3cgb24nLCAnY29tbWVudCddXV0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ21lc3NhZ2VzJywgW1tbJ0FiYnJldmlhdGlvbnMgYXJlIG5vdyBvZmYnLCAnY29tbWVudCddXV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ2FiYnJldnMnLCBbdmFsXSk7XHJcbiAgICAgICAgLy8gVE9ETzogWFhYOiBmb3Igc29tZSBpbnNhbmUgcmVhc29uLCBkb2luZyB0aGUgZm9sbG93aW5nIGNhbGxcclxuICAgICAgICAvLyBzeW5jaHJvbm91c2x5IGJyZWFrcyB0aGUgY2hlY2tib3ggKCM0NTYpLiBJZiB5b3UgZXZlciBmaWd1cmVcclxuICAgICAgICAvLyBvdXQgd2h5LCBpdCB3b3VsZCBtYWtlIG1vcmUgc2Vuc2UgdG8gY2FsbFxyXG4gICAgICAgIC8vICAgIGRpc3BhdGNoZXIucG9zdCgncmVzZXREYXRhJyk7XHJcbiAgICAgICAgLy8gd2l0aG91dCB0aGUgYXN5bmNoLlxyXG4gICAgICAgIGRpc3BhdGNoZXIucG9zdCgxLCAncmVzZXREYXRhJyk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgJCgnI3RleHRfYmFja2dyb3VuZHMgaW5wdXQnKS5jbGljayhmdW5jdGlvbihldnQpIHtcclxuICAgICAgICB2YXIgdmFsID0gdGhpcy52YWx1ZTtcclxuICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ3RleHRCYWNrZ3JvdW5kcycsIFt2YWxdKTtcclxuICAgICAgICAvLyBUT0RPOiBYWFg6IHNlZSBjb21tZW50IGFib3ZlIGZvciB3aHkgdGhpcyBpcyBhc3luY2hyb25vdXNcclxuICAgICAgICBkaXNwYXRjaGVyLnBvc3QoMSwgJ3Jlc2V0RGF0YScpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgICQoJyNsYXlvdXRfZGVuc2l0eSBpbnB1dCcpLmNsaWNrKGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgIHZhciB2YWwgPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgIGRpc3BhdGNoZXIucG9zdCgnbGF5b3V0RGVuc2l0eScsIFt2YWxdKTtcclxuICAgICAgICAvLyBUT0RPOiBYWFg6IHNlZSBjb21tZW50IGFib3ZlIGZvciB3aHkgdGhpcyBpcyBhc3luY2hyb25vdXNcclxuICAgICAgICBkaXNwYXRjaGVyLnBvc3QoMSwgJ3Jlc2V0RGF0YScpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAkKCcjc3ZnX3dpZHRoX3VuaXQgaW5wdXQnKS5jbGljayhmdW5jdGlvbihldnQpIHtcclxuICAgICAgICB2YXIgd2lkdGhfdW5pdCA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgdmFyIHdpZHRoX3ZhbHVlID0gJCgnI3N2Z193aWR0aF92YWx1ZScpWzBdLnZhbHVlO1xyXG4gICAgICAgIHZhciB2YWwgPSB3aWR0aF92YWx1ZSt3aWR0aF91bml0O1xyXG4gICAgICAgIGRpc3BhdGNoZXIucG9zdCgnc3ZnV2lkdGgnLCBbdmFsXSk7XHJcbiAgICAgICAgLy8gVE9ETzogWFhYOiBzZWUgY29tbWVudCBhYm92ZSBmb3Igd2h5IHRoaXMgaXMgYXN5bmNocm9ub3VzXHJcbiAgICAgICAgZGlzcGF0Y2hlci5wb3N0KDEsICdyZXNldERhdGEnKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgJCgnI2Fubm90YXRpb25fc3BlZWQgaW5wdXQnKS5jbGljayhmdW5jdGlvbihldnQpIHtcclxuICAgICAgICB2YXIgdmFsID0gdGhpcy52YWx1ZTtcclxuICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ2Fubm90YXRpb25TcGVlZCcsIFt2YWxdKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH0pOyAgICAgIFxyXG4gICAgXHJcbiAgICAgICQoJyNwdWxsZG93bicpLmZpbmQoJ2lucHV0JykuYnV0dG9uKCk7XHJcbiAgICAgIHZhciBoZWFkZXJIZWlnaHQgPSAkKCcjbWFpbkhlYWRlcicpLmhlaWdodCgpO1xyXG4gICAgICAkKCcjc3ZnJykuY3NzKCdtYXJnaW4tdG9wJywgaGVhZGVySGVpZ2h0ICsgMTApO1xyXG4gICAgICBhYm91dERpYWxvZyA9ICQoJyNhYm91dCcpO1xyXG4gICAgICBhYm91dERpYWxvZy5kaWFsb2coe1xyXG4gICAgICAgICAgICBhdXRvT3BlbjogZmFsc2UsXHJcbiAgICAgICAgICAgIGNsb3NlT25Fc2NhcGU6IHRydWUsXHJcbiAgICAgICAgICAgIHJlc2l6YWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIG1vZGFsOiB0cnVlLFxyXG4gICAgICAgICAgICBvcGVuOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGFib3V0RGlhbG9nLmZpbmQoJyonKS5ibHVyKCk7XHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYmVmb3JlQ2xvc2U6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEZvcm0gPSBudWxsO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAkKCcjbWFpbmxvZ28nKS5jbGljayhmdW5jdGlvbigpIHtcclxuICAgICAgICBzaG93Rm9ybShhYm91dERpYWxvZyk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gVE9ETzogY29weSBmcm9tIGFubm90YXRvcl91aTsgRFJZIGl0IHVwXHJcbiAgICAgIHZhciBhZGp1c3RGb3JtVG9DdXJzb3IgPSBmdW5jdGlvbihldnQsIGVsZW1lbnQpIHtcclxuICAgICAgICB2YXIgc2NyZWVuSGVpZ2h0ID0gJCh3aW5kb3cpLmhlaWdodCgpIC0gODsgLy8gVE9ETyBIQUNLIC0gbm8gaWRlYSB3aHkgLTggaXMgbmVlZGVkXHJcbiAgICAgICAgdmFyIHNjcmVlbldpZHRoID0gJCh3aW5kb3cpLndpZHRoKCkgLSA4O1xyXG4gICAgICAgIHZhciBlbGVtZW50SGVpZ2h0ID0gZWxlbWVudC5oZWlnaHQoKTtcclxuICAgICAgICB2YXIgZWxlbWVudFdpZHRoID0gZWxlbWVudC53aWR0aCgpO1xyXG4gICAgICAgIHZhciB5ID0gTWF0aC5taW4oZXZ0LmNsaWVudFksIHNjcmVlbkhlaWdodCAtIGVsZW1lbnRIZWlnaHQpO1xyXG4gICAgICAgIHZhciB4ID0gTWF0aC5taW4oZXZ0LmNsaWVudFgsIHNjcmVlbldpZHRoIC0gZWxlbWVudFdpZHRoKTtcclxuICAgICAgICBlbGVtZW50LmNzcyh7IHRvcDogeSwgbGVmdDogeCB9KTtcclxuICAgICAgfTtcclxuICAgICAgdmFyIHZpZXdzcGFuRm9ybSA9ICQoJyN2aWV3c3Bhbl9mb3JtJyk7XHJcblxyXG4gICAgICB2YXIgb25TaW5nbGVDbGljayA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgIHZhciB0YXJnZXQgPSAkKGV2dC50YXJnZXQpO1xyXG4gICAgICAgIHZhciBpZDtcclxuICAgICAgICBpZiAoaWQgPSB0YXJnZXQuYXR0cignZGF0YS1zcGFuLWlkJykpIHtcclxuICAgICAgICAgIHZhciBzcGFuID0gZGF0YS5zcGFuc1tpZF07XHJcbiAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ3NnbGNsaWNrJywgW3NwYW5dKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgb25EYmxDbGljayA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgIGlmICh1c2VyICYmIGFubm90YXRpb25BdmFpbGFibGUpIHJldHVybjtcclxuICAgICAgICB2YXIgdGFyZ2V0ID0gJChldnQudGFyZ2V0KTtcclxuICAgICAgICB2YXIgaWQ7XHJcbiAgICAgICAgaWYgKGlkID0gdGFyZ2V0LmF0dHIoJ2RhdGEtc3Bhbi1pZCcpKSB7XHJcbiAgICAgICAgICB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkucmVtb3ZlQWxsUmFuZ2VzKCk7XHJcbiAgICAgICAgICB2YXIgc3BhbiA9IGRhdGEuc3BhbnNbaWRdO1xyXG5cclxuICAgICAgICAgIHZhciB1cmxIYXNoID0gVVJMSGFzaC5wYXJzZSh3aW5kb3cubG9jYXRpb24uaGFzaCk7XHJcbiAgICAgICAgICB1cmxIYXNoLnNldEFyZ3VtZW50KCdmb2N1cycsIFtbc3Bhbi5pZF1dKTtcclxuICAgICAgICAgICQoJyN2aWV3c3Bhbl9oaWdobGlnaHRfbGluaycpLnNob3coKS5hdHRyKCdocmVmJywgdXJsSGFzaC5nZXRIYXNoKCkpO1xyXG5cclxuICAgICAgICAgICQoJyN2aWV3c3Bhbl9zZWxlY3RlZCcpLnRleHQoc3Bhbi50ZXh0KTtcclxuICAgICAgICAgIHZhciBlbmNvZGVkVGV4dCA9IGVuY29kZVVSSUNvbXBvbmVudChzcGFuLnRleHQpO1xyXG4gICAgICAgICAgJC5lYWNoKHNlYXJjaENvbmZpZywgZnVuY3Rpb24oc2VhcmNoTm8sIHNlYXJjaCkge1xyXG4gICAgICAgICAgICAkKCcjdmlld3NwYW5fJytzZWFyY2hbMF0pLmF0dHIoJ2hyZWYnLCBzZWFyY2hbMV0ucmVwbGFjZSgnJXMnLCBlbmNvZGVkVGV4dCkpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICAvLyBhbm5vdGF0b3IgY29tbWVudHNcclxuICAgICAgICAgICQoJyN2aWV3c3Bhbl9ub3RlcycpLnZhbChzcGFuLmFubm90YXRvck5vdGVzIHx8ICcnKTtcclxuICAgICAgICAgIGRpc3BhdGNoZXIucG9zdCgnc2hvd0Zvcm0nLCBbdmlld3NwYW5Gb3JtXSk7XHJcbiAgICAgICAgICAkKCcjdmlld3NwYW5fZm9ybS1vaycpLmZvY3VzKCk7XHJcbiAgICAgICAgICBhZGp1c3RGb3JtVG9DdXJzb3IoZXZ0LCB2aWV3c3BhbkZvcm0ucGFyZW50KCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgICAgdmlld3NwYW5Gb3JtLnN1Ym1pdChmdW5jdGlvbihldnQpIHtcclxuICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ2hpZGVGb3JtJyk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHZhciBhdXRoRm9ybSA9ICQoJyNhdXRoX2Zvcm0nKTtcclxuICAgICAgaW5pdEZvcm0oYXV0aEZvcm0sIHsgcmVzaXphYmxlOiBmYWxzZSB9KTtcclxuICAgICAgdmFyIGF1dGhGb3JtU3VibWl0ID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdoaWRlRm9ybScpO1xyXG4gICAgICAgIHZhciBfdXNlciA9ICQoJyNhdXRoX3VzZXInKS52YWwoKTtcclxuICAgICAgICB2YXIgcGFzc3dvcmQgPSAkKCcjYXV0aF9wYXNzJykudmFsKCk7XHJcbiAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdhamF4JywgW3tcclxuICAgICAgICAgICAgYWN0aW9uOiAnbG9naW4nLFxyXG4gICAgICAgICAgICB1c2VyOiBfdXNlcixcclxuICAgICAgICAgICAgcGFzc3dvcmQ6IHBhc3N3b3JkLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmV4Y2VwdGlvbikge1xyXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdzaG93Rm9ybScsIFthdXRoRm9ybV0pO1xyXG4gICAgICAgICAgICAgICAgJCgnI2F1dGhfdXNlcicpLnNlbGVjdCgpLmZvY3VzKCk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHVzZXIgPSBfdXNlcjtcclxuICAgICAgICAgICAgICAgICQoJyNhdXRoX2J1dHRvbicpLnZhbCgnTG9nb3V0ICcgKyB1c2VyKTtcclxuICAgICAgICAgICAgICAgICQoJyNhdXRoX3VzZXInKS52YWwoJycpO1xyXG4gICAgICAgICAgICAgICAgJCgnI2F1dGhfcGFzcycpLnZhbCgnJyk7XHJcbiAgICAgICAgICAgICAgICAkKCcubG9naW4nKS5zaG93KCk7XHJcbiAgICAgICAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ3VzZXInLCBbdXNlcl0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1dKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH07XHJcbiAgICAgICQoJyNhdXRoX2J1dHRvbicpLmNsaWNrKGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgIGlmICh1c2VyKSB7XHJcbiAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ2FqYXgnLCBbe1xyXG4gICAgICAgICAgICBhY3Rpb246ICdsb2dvdXQnXHJcbiAgICAgICAgICB9LCBmdW5jdGlvbihyZXNwb25zZSkge1xyXG4gICAgICAgICAgICB1c2VyID0gbnVsbDtcclxuICAgICAgICAgICAgJCgnI2F1dGhfYnV0dG9uJykudmFsKCdMb2dpbicpO1xyXG4gICAgICAgICAgICAkKCcubG9naW4nKS5oaWRlKCk7XHJcbiAgICAgICAgICAgIGRpc3BhdGNoZXIucG9zdCgndXNlcicsIFtudWxsXSk7XHJcbiAgICAgICAgICB9XSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGRpc3BhdGNoZXIucG9zdCgnc2hvd0Zvcm0nLCBbYXV0aEZvcm1dKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBhdXRoRm9ybS5zdWJtaXQoYXV0aEZvcm1TdWJtaXQpO1xyXG5cclxuXHJcbiAgICAgIHZhciB0dXRvcmlhbEZvcm0gPSAkKCcjdHV0b3JpYWwnKTtcclxuICAgICAgaWYgKCEkLmJyb3dzZXIud2Via2l0KSB7XHJcbiAgICAgICAgLy8gSW5qZWN0IHRoZSBicm93c2VyIHdhcm5pbmdcclxuICAgICAgICAkKCcjYnJvd3Nlcndhcm5pbmcnKS5jc3MoJ2Rpc3BsYXknLCAnYmxvY2snKTtcclxuICAgICAgfVxyXG4gICAgICBpbml0Rm9ybSh0dXRvcmlhbEZvcm0sIHtcclxuICAgICAgICB3aWR0aDogODAwLFxyXG4gICAgICAgIGhlaWdodDogNjAwLFxyXG4gICAgICAgIG5vX2NhbmNlbDogdHJ1ZSxcclxuICAgICAgICBub19vazogdHJ1ZSxcclxuICAgICAgICBidXR0b25zOiBbe1xyXG4gICAgICAgICAgaWQ6IFwidHV0b3JpYWwtb2tcIixcclxuICAgICAgICAgIHRleHQ6IFwiT0tcIixcclxuICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigpIHsgdHV0b3JpYWxGb3JtLmRpYWxvZygnY2xvc2UnKTsgfVxyXG4gICAgICAgIH1dLFxyXG4gICAgICAgIGNsb3NlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGlmIChmaWxlQnJvd3NlcldhaXRpbmcpIHtcclxuICAgICAgICAgICAgc2hvd0ZpbGVCcm93c2VyKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHZhciBpbml0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdpbml0Rm9ybScsIFt2aWV3c3BhbkZvcm0sIHtcclxuICAgICAgICAgICAgd2lkdGg6IDc2MCxcclxuICAgICAgICAgICAgbm9fY2FuY2VsOiB0cnVlXHJcbiAgICAgICAgICB9XSk7XHJcbiAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdhamF4JywgW3tcclxuICAgICAgICAgICAgYWN0aW9uOiAnd2hvYW1pJ1xyXG4gICAgICAgICAgfSwgZnVuY3Rpb24ocmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgdmFyIGF1dGhfYnV0dG9uID0gJCgnI2F1dGhfYnV0dG9uJyk7XHJcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS51c2VyKSB7XHJcbiAgICAgICAgICAgICAgdXNlciA9IHJlc3BvbnNlLnVzZXI7XHJcbiAgICAgICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdtZXNzYWdlcycsIFtbWydXZWxjb21lIGJhY2ssIHVzZXIgXCInICsgdXNlciArICdcIicsICdjb21tZW50J11dXSk7XHJcbiAgICAgICAgICAgICAgYXV0aF9idXR0b24udmFsKCdMb2dvdXQgJyArIHVzZXIpO1xyXG4gICAgICAgICAgICAgIGRpc3BhdGNoZXIucG9zdCgndXNlcicsIFt1c2VyXSk7XHJcbiAgICAgICAgICAgICAgJCgnLmxvZ2luJykuc2hvdygpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHVzZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgIGF1dGhfYnV0dG9uLnZhbCgnTG9naW4nKTtcclxuICAgICAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ3VzZXInLCBbbnVsbF0pO1xyXG4gICAgICAgICAgICAgICQoJy5sb2dpbicpLmhpZGUoKTtcclxuICAgICAgICAgICAgICAvLyBkb24ndCBzaG93IHR1dG9yaWFsIGlmIHRoZXJlJ3MgYSBzcGVjaWZpYyBkb2N1bWVudCAoYW5ub3lhbmNlKVxyXG4gICAgICAgICAgICAgIGlmICghZG9jKSB7XHJcbiAgICAgICAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ3Nob3dGb3JtJywgW3R1dG9yaWFsRm9ybV0pO1xyXG4gICAgICAgICAgICAgICAgJCgnI3R1dG9yaWFsLW9rJykuZm9jdXMoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7IGtlZXA6IHRydWUgfVxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIGRpc3BhdGNoZXIucG9zdCgnYWpheCcsIFt7IGFjdGlvbjogJ2xvYWRDb25mJyB9LCBmdW5jdGlvbihyZXNwb25zZSkge1xyXG4gICAgICAgICAgaWYgKHJlc3BvbnNlLmNvbmZpZyAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgLy8gVE9ETzogY2hlY2sgZm9yIGV4Y2VwdGlvbnNcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICBDb25maWd1cmF0aW9uID0gSlNPTi5wYXJzZShyZXNwb25zZS5jb25maWcpO1xyXG4gICAgICAgICAgICB9IGNhdGNoKHgpIHtcclxuICAgICAgICAgICAgICAvLyBYWFggQmFkIGNvbmZpZ1xyXG4gICAgICAgICAgICAgIENvbmZpZ3VyYXRpb24gPSB7fTtcclxuICAgICAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ21lc3NhZ2VzJywgW1tbJ0NvcnJ1cHRlZCBjb25maWd1cmF0aW9uOyByZXNldHRpbmcuJywgJ2Vycm9yJ11dXSk7XHJcbiAgICAgICAgICAgICAgY29uZmlndXJhdGlvbkNoYW5nZWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBUT0RPOiBtYWtlIHdob2xlLW9iamVjdCBhc3NpZ25tZW50IHdvcmtcclxuICAgICAgICAgICAgLy8gQGFtYWRhbm1hdGg6IGhlbHAhIFRoaXMgY29kZSBpcyBob3JyaWJsZVxyXG4gICAgICAgICAgICAvLyBDb25maWd1cmF0aW9uLnN2Z1dpZHRoID0gc3RvcmVkQ29uZi5zdmdXaWR0aDtcclxuICAgICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdzdmdXaWR0aCcsIFtDb25maWd1cmF0aW9uLnN2Z1dpZHRoXSk7XHJcbiAgICAgICAgICAgIC8vIENvbmZpZ3VyYXRpb24uYWJicmV2c09uID0gc3RvcmVkQ29uZi5hYmJyZXZzT24gPT0gXCJ0cnVlXCI7XHJcbiAgICAgICAgICAgIC8vIENvbmZpZ3VyYXRpb24udGV4dEJhY2tncm91bmRzID0gc3RvcmVkQ29uZi50ZXh0QmFja2dyb3VuZHM7XHJcbiAgICAgICAgICAgIC8vIENvbmZpZ3VyYXRpb24ucmFwaWRNb2RlT24gPSBzdG9yZWRDb25mLnJhcGlkTW9kZU9uID09IFwidHJ1ZVwiO1xyXG4gICAgICAgICAgICAvLyBDb25maWd1cmF0aW9uLmNvbmZpcm1Nb2RlT24gPSBzdG9yZWRDb25mLmNvbmZpcm1Nb2RlT24gPT0gXCJ0cnVlXCI7XHJcbiAgICAgICAgICAgIC8vIENvbmZpZ3VyYXRpb24uYXV0b3JlZnJlc2hPbiA9IHN0b3JlZENvbmYuYXV0b3JlZnJlc2hPbiA9PSBcInRydWVcIjtcclxuICAgICAgICAgICAgaWYgKENvbmZpZ3VyYXRpb24uYXV0b3JlZnJlc2hPbikge1xyXG4gICAgICAgICAgICAgIGNoZWNrRm9yRG9jdW1lbnRDaGFuZ2VzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQ29uZmlndXJhdGlvbi52aXN1YWwubWFyZ2luLnggPSBwYXJzZUludChzdG9yZWRDb25mLnZpc3VhbC5tYXJnaW4ueCk7XHJcbiAgICAgICAgICAgIC8vIENvbmZpZ3VyYXRpb24udmlzdWFsLm1hcmdpbi55ID0gcGFyc2VJbnQoc3RvcmVkQ29uZi52aXN1YWwubWFyZ2luLnkpO1xyXG4gICAgICAgICAgICAvLyBDb25maWd1cmF0aW9uLnZpc3VhbC5ib3hTcGFjaW5nID0gcGFyc2VJbnQoc3RvcmVkQ29uZi52aXN1YWwuYm94U3BhY2luZyk7XHJcbiAgICAgICAgICAgIC8vIENvbmZpZ3VyYXRpb24udmlzdWFsLmN1cmx5SGVpZ2h0ID0gcGFyc2VJbnQoc3RvcmVkQ29uZi52aXN1YWwuY3VybHlIZWlnaHQpO1xyXG4gICAgICAgICAgICAvLyBDb25maWd1cmF0aW9uLnZpc3VhbC5hcmNTcGFjaW5nID0gcGFyc2VJbnQoc3RvcmVkQ29uZi52aXN1YWwuYXJjU3BhY2luZyk7XHJcbiAgICAgICAgICAgIC8vIENvbmZpZ3VyYXRpb24udmlzdWFsLmFyY1N0YXJ0SGVpZ2h0ID0gcGFyc2VJbnQoc3RvcmVkQ29uZi52aXN1YWwuYXJjU3RhcnRIZWlnaHQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdjb25maWd1cmF0aW9uVXBkYXRlZCcpO1xyXG4gICAgICAgIH1dKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciBub0ZpbGVTcGVjaWZpZWQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAvLyBub3QgKG9ubHkpIGFuIGVycm9yLCBzbyBubyBtZXNzYWdpbmdcclxuICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ2NsZWFyU1ZHJyk7XHJcbiAgICAgICAgc2hvd0ZpbGVCcm93c2VyKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBzaG93VW5hYmxlVG9SZWFkVGV4dEZpbGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ21lc3NhZ2VzJywgW1tbJ1VuYWJsZSB0byByZWFkIHRoZSB0ZXh0IGZpbGUuJywgJ2Vycm9yJ11dXSk7XHJcbiAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdjbGVhclNWRycpO1xyXG4gICAgICAgIHNob3dGaWxlQnJvd3NlcigpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdmFyIHNob3dBbm5vdGF0aW9uRmlsZU5vdEZvdW5kID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdtZXNzYWdlcycsIFtbWydBbm5vdGF0aW9uIGZpbGUgbm90IGZvdW5kLicsICdlcnJvciddXV0pO1xyXG4gICAgICAgIGRpc3BhdGNoZXIucG9zdCgnY2xlYXJTVkcnKTtcclxuICAgICAgICBzaG93RmlsZUJyb3dzZXIoKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciBzaG93VW5rbm93bkVycm9yID0gZnVuY3Rpb24oZXhjZXB0aW9uKSB7XHJcbiAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdtZXNzYWdlcycsIFtbWydVbmtub3duIGVycm9yOiAnICsgZXhjZXB0aW9uLCAnZXJyb3InXV1dKTtcclxuICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ2NsZWFyU1ZHJyk7XHJcbiAgICAgICAgc2hvd0ZpbGVCcm93c2VyKCk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgcmVsb2FkRGlyZWN0b3J5V2l0aFNsYXNoID0gZnVuY3Rpb24oc291cmNlRGF0YSkge1xyXG4gICAgICAgIHZhciBjb2xsZWN0aW9uID0gc291cmNlRGF0YS5jb2xsZWN0aW9uICsgc291cmNlRGF0YS5kb2N1bWVudCArICcvJztcclxuICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ3NldENvbGxlY3Rpb24nLCBbY29sbGVjdGlvbiwgJycsIHNvdXJjZURhdGEuYXJndW1lbnRzXSk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBUT0RPOiBjb25maXJtIGF0dHJpYnV0ZVR5cGVzIHVubmVjZXNzYXJ5IGFuZCByZW1vdmVcclxuLy8gICAgICAgdmFyIHNwYW5BbmRBdHRyaWJ1dGVUeXBlc0xvYWRlZCA9IGZ1bmN0aW9uKF9zcGFuVHlwZXMsIF9hdHRyaWJ1dGVUeXBlcykge1xyXG4vLyAgICAgICAgIHNwYW5UeXBlcyA9IF9zcGFuVHlwZXM7XHJcbi8vICAgICAgICAgYXR0cmlidXRlVHlwZXMgPSBfYXR0cmlidXRlVHlwZXM7XHJcbi8vICAgICAgIH07XHJcbiAgICAgIC8vIFRPRE86IHNwYW5BbmRBdHRyaWJ1dGVUeXBlc0xvYWRlZCBpcyBvYnZpb3VzbHkgbm90IGRlc2NyaXB0aXZlIG9mXHJcbiAgICAgIC8vIHRoZSBmdWxsIGZ1bmN0aW9uLiBSZW5hbWUgcmVhc29uYWJseS5cclxuICAgICAgdmFyIHNwYW5BbmRBdHRyaWJ1dGVUeXBlc0xvYWRlZCA9IGZ1bmN0aW9uKF9zcGFuVHlwZXMsIF9lbnRpdHlBdHRyaWJ1dGVUeXBlcywgX2V2ZW50QXR0cmlidXRlVHlwZXMsIF9yZWxhdGlvblR5cGVzSGFzaCkge1xyXG4gICAgICAgIHNwYW5UeXBlcyA9IF9zcGFuVHlwZXM7XHJcbiAgICAgICAgcmVsYXRpb25UeXBlc0hhc2ggPSBfcmVsYXRpb25UeXBlc0hhc2g7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgYW5ub3RhdGlvbklzQXZhaWxhYmxlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgYW5ub3RhdGlvbkF2YWlsYWJsZSA9IHRydWU7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBoaWRlIGFueXRoaW5nIHJlcXVpcmluZyBsb2dpbiwganVzdCBpbiBjYXNlXHJcbiAgICAgICQoJy5sb2dpbicpLmhpZGUoKTtcclxuXHJcbiAgICAgIC8vIFhYWCBUT0RPIGEgbG90XHJcbiAgICAgIHZhciB0b3VjaFN0YXJ0O1xyXG4gICAgICB2YXIgb25Ub3VjaFN0YXJ0ID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAgICAgLy8gZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgZXZ0ID0gZXZ0Lm9yaWdpbmFsRXZlbnQ7XHJcbiAgICAgICAgaWYgKGV2dC50b3VjaGVzLmxlbmd0aCA9PSAxKSB7XHJcbiAgICAgICAgICAvLyBzaW5nbGUgdG91Y2g7IHN0YXJ0IHRyYWNraW5nIHRvIHNlZSBpZiB3ZSdyZSBkb2luZ1xyXG4gICAgICAgICAgLy8gbGVmdC9yaWdodFxyXG4gICAgICAgICAgdG91Y2hTdGFydCA9ICQuZXh0ZW5kKHt9LCBldnQudG91Y2hlc1swXSk7IC8vIGNsb25lXHJcbiAgICAgICAgfSBlbHNlIGlmIChldnQudG91Y2hlcy5sZW5ndGggPT0gNCkge1xyXG4gICAgICAgICAgLy8gNCBmaW5nZXIgdGFwOiBmaWxlIGJyb3dzZXJcclxuICAgICAgICAgIHNob3dGaWxlQnJvd3NlcigpO1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgICAgdmFyIG9uVG91Y2hFbmQgPSBmdW5jdGlvbihldnQpIHtcclxuICAgICAgICAvLyBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICBldnQgPSBldnQub3JpZ2luYWxFdmVudDtcclxuICAgICAgICAkLmVhY2goZXZ0LmNoYW5nZWRUb3VjaGVzLCBmdW5jdGlvbih0b3VjaEVuZE5vLCB0b3VjaEVuZCkge1xyXG4gICAgICAgICAgaWYgKHRvdWNoU3RhcnQuaWRlbnRpZmllciA9PSB0b3VjaEVuZC5pZGVudGlmaWVyKSB7XHJcbiAgICAgICAgICAgIHZhciBkeCA9IHRvdWNoRW5kLnNjcmVlblggLSB0b3VjaFN0YXJ0LnNjcmVlblg7XHJcbiAgICAgICAgICAgIHZhciBkeSA9IHRvdWNoRW5kLnNjcmVlblkgLSB0b3VjaFN0YXJ0LnNjcmVlblk7XHJcbiAgICAgICAgICAgIHZhciBhZHggPSBNYXRoLmFicyhkeCk7XHJcbiAgICAgICAgICAgIHZhciBhZHkgPSBNYXRoLmFicyhkeSk7XHJcbiAgICAgICAgICAgIGlmIChhZHggPiAyMDAgJiYgYWR5IDwgYWR4IC8gMikge1xyXG4gICAgICAgICAgICAgIC8vIGl0J3MgbGVmdC9yaWdodCFcclxuICAgICAgICAgICAgICByZXR1cm4gbW92ZUluRmlsZUJyb3dzZXIoZHggPCAwID8gLTEgOiArMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciBkb2N1bWVudENoYW5nZXNUaW1lciA9IG51bGw7XHJcbiAgICAgIHZhciBtYXhEb2N1bWVudENoYW5nZXNUaW1lb3V0ID0gMzIgKiAxMDAwO1xyXG4gICAgICB2YXIgZG9jdW1lbnRDaGFuZ2VzVGltZW91dCA9IDEgKiAxMDAwO1xyXG4gICAgICB2YXIgY2hlY2tGb3JEb2N1bWVudENoYW5nZXMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoY29sbCAmJiBkb2MgJiYgZGlzcGF0Y2hlci5wb3N0KCdpc1JlbG9hZE9rYXknLCBbXSwgJ2FsbCcpKSB7XHJcbiAgICAgICAgICBvcHRzID0ge1xyXG4gICAgICAgICAgICAnYWN0aW9uJzogJ2dldERvY3VtZW50VGltZXN0YW1wJyxcclxuICAgICAgICAgICAgJ2NvbGxlY3Rpb24nOiBjb2xsLFxyXG4gICAgICAgICAgICAnZG9jdW1lbnQnOiBkb2NcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGRpc3BhdGNoZXIucG9zdCgnYWpheCcsIFtvcHRzLCBmdW5jdGlvbihyZXNwb25zZSkge1xyXG4gICAgICAgICAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgICAgICAgIGlmIChtdGltZSAhPSByZXNwb25zZS5tdGltZSkge1xyXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdjdXJyZW50JywgW2NvbGwsIGRvYywgYXJncywgdHJ1ZV0pO1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRDaGFuZ2VzVGltZW91dCA9IDEgKiAxMDAwO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudENoYW5nZXNUaW1lb3V0ICo9IDI7XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnRDaGFuZ2VzVGltZW91dCA+PSBtYXhEb2N1bWVudENoYW5nZXNUaW1lb3V0KVxyXG4gICAgICAgICAgICAgICAgICBkb2N1bWVudENoYW5nZXNUaW1lb3V0ID0gbWF4RG9jdW1lbnRDaGFuZ2VzVGltZW91dDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1dKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZG9jdW1lbnRDaGFuZ2VzVGltZW91dCA9IDEgKiAxMDAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkb2N1bWVudENoYW5nZXNUaW1lciA9IHNldFRpbWVvdXQoY2hlY2tGb3JEb2N1bWVudENoYW5nZXMsIGRvY3VtZW50Q2hhbmdlc1RpbWVvdXQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoQ29uZmlndXJhdGlvbi5hdXRvcmVmcmVzaE9uKSB7XHJcbiAgICAgICAgY2hlY2tGb3JEb2N1bWVudENoYW5nZXMoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgJCgnI2F1dG9yZWZyZXNoX21vZGUnKS5jbGljayhmdW5jdGlvbihldnQpIHtcclxuICAgICAgICB2YXIgdmFsID0gdGhpcy5jaGVja2VkO1xyXG4gICAgICAgIGlmICh2YWwpIHtcclxuICAgICAgICAgIENvbmZpZ3VyYXRpb24uYXV0b3JlZnJlc2hPbiA9IHRydWU7XHJcbiAgICAgICAgICBjaGVja0ZvckRvY3VtZW50Q2hhbmdlcygpO1xyXG4gICAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdtZXNzYWdlcycsIFtbWydBdXRvcmVmcmVzaCBtb2RlIGlzIG5vdyBvbicsICdjb21tZW50J11dXSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIENvbmZpZ3VyYXRpb24uYXV0b3JlZnJlc2hPbiA9IGZhbHNlO1xyXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KGRvY3VtZW50Q2hhbmdlc1RpbWVyKTtcclxuICAgICAgICAgIGRpc3BhdGNoZXIucG9zdCgnbWVzc2FnZXMnLCBbW1snQXV0b3JlZnJlc2ggbW9kZSBpcyBub3cgb2ZmJywgJ2NvbW1lbnQnXV1dKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGlzcGF0Y2hlci5wb3N0KCdjb25maWd1cmF0aW9uQ2hhbmdlZCcpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHZhciBpc1JlbG9hZE9rYXkgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAvLyBkbyBub3QgcmVsb2FkIHdoaWxlIHRoZSB1c2VyIGlzIGluIHRoZSBkaWFsb2dcclxuICAgICAgICByZXR1cm4gY3VycmVudEZvcm0gPT0gbnVsbDtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciBjb25maWd1cmF0aW9uQ2hhbmdlZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vIGp1c3QgYXNzdW1lIHRoYXQgYW55IGNvbmZpZyBjaGFuZ2UgbWFrZXMgc3RvcmVkXHJcbiAgICAgICAgLy8gdmlzdWFsaXphdGlvbnMgaW52YWxpZC4gVGhpcyBpcyBhIGJpdCBleGNlc3NpdmUgKG5vdCBhbGxcclxuICAgICAgICAvLyBvcHRpb25zIGFmZmVjdCB2aXN1YWxpemF0aW9uKSBidXQgbW9zdGx5IGhhcm1sZXNzLlxyXG4gICAgICAgIGludmFsaWRhdGVTYXZlZFNWRygpO1xyXG5cclxuICAgICAgICAvLyBzYXZlIGNvbmZpZ3VyYXRpb24gY2hhbmdlZCBieSB1c2VyIGFjdGlvblxyXG4gICAgICAgIGRpc3BhdGNoZXIucG9zdCgnYWpheCcsIFt7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAnc2F2ZUNvbmYnLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZzogSlNPTi5zdHJpbmdpZnkoQ29uZmlndXJhdGlvbiksXHJcbiAgICAgICAgICAgICAgICB9LCBudWxsXSk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvL0JSQVQgU1RBTkRBTE9ORSBMSUJSQVJZIEJFR0lOXHJcbiAgICAgIC8vQ29uZmlnIG11c3QgYmUgbWFuYWdlZCBvdXRzaWRlIHRoZSBjb21wb25lbnRcclxuICAgICAgLypcclxuICAgICAgdmFyIHVwZGF0ZUNvbmZpZ3VyYXRpb25VSSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vIHVwZGF0ZSBVSSB0byByZWZsZWN0IG5vbi11c2VyIGNvbmZpZyBjaGFuZ2VzIChlLmcuIGxvYWQpXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQW5ub3RhdGlvbiBtb2RlXHJcbiAgICAgICAgaWYgKENvbmZpZ3VyYXRpb24uY29uZmlybU1vZGVPbikge1xyXG4gICAgICAgICAgJCgnI2Fubm90YXRpb25fc3BlZWQxJylbMF0uY2hlY2tlZCA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIGlmIChDb25maWd1cmF0aW9uLnJhcGlkTW9kZU9uKSB7XHJcbiAgICAgICAgICAkKCcjYW5ub3RhdGlvbl9zcGVlZDMnKVswXS5jaGVja2VkID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgJCgnI2Fubm90YXRpb25fc3BlZWQyJylbMF0uY2hlY2tlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICQoJyNhbm5vdGF0aW9uX3NwZWVkIGlucHV0JykuYnV0dG9uKCdyZWZyZXNoJyk7XHJcblxyXG4gICAgICAgIC8vIExhYmVsIGFiYnJldnNcclxuICAgICAgICAkKCcjbGFiZWxfYWJicmV2aWF0aW9uc19vbicpWzBdLmNoZWNrZWQgID0gQ29uZmlndXJhdGlvbi5hYmJyZXZzT247XHJcbiAgICAgICAgJCgnI2xhYmVsX2FiYnJldmlhdGlvbnNfb2ZmJylbMF0uY2hlY2tlZCA9ICFDb25maWd1cmF0aW9uLmFiYnJldnNPbjsgXHJcbiAgICAgICAgJCgnI2xhYmVsX2FiYnJldmlhdGlvbnMgaW5wdXQnKS5idXR0b24oJ3JlZnJlc2gnKTtcclxuXHJcbiAgICAgICAgLy8gVGV4dCBiYWNrZ3JvdW5kcyAgICAgICAgXHJcbiAgICAgICAgJCgnI3RleHRfYmFja2dyb3VuZHMgaW5wdXRbdmFsdWU9XCInK0NvbmZpZ3VyYXRpb24udGV4dEJhY2tncm91bmRzKydcIl0nKVswXS5jaGVja2VkID0gdHJ1ZTtcclxuICAgICAgICAkKCcjdGV4dF9iYWNrZ3JvdW5kcyBpbnB1dCcpLmJ1dHRvbigncmVmcmVzaCcpO1xyXG5cclxuICAgICAgICAvLyBTVkcgd2lkdGhcclxuICAgICAgICB2YXIgc3BsaXRTdmdXaWR0aCA9IENvbmZpZ3VyYXRpb24uc3ZnV2lkdGgubWF0Y2goL14oLio/KShweHxcXCUpJC8pO1xyXG4gICAgICAgIGlmICghc3BsaXRTdmdXaWR0aCkge1xyXG4gICAgICAgICAgLy8gVE9ETzogcmVzZXQgdG8gc2Vuc2libGUgdmFsdWU/XHJcbiAgICAgICAgICBkaXNwYXRjaGVyLnBvc3QoJ21lc3NhZ2VzJywgW1tbJ0Vycm9yIHBhcnNpbmcgU1ZHIHdpZHRoIFwiJytDb25maWd1cmF0aW9uLnN2Z1dpZHRoKydcIicsICdlcnJvcicsIDJdXV0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAkKCcjc3ZnX3dpZHRoX3ZhbHVlJylbMF0udmFsdWUgPSBzcGxpdFN2Z1dpZHRoWzFdO1xyXG4gICAgICAgICAgJCgnI3N2Z193aWR0aF91bml0IGlucHV0W3ZhbHVlPVwiJytzcGxpdFN2Z1dpZHRoWzJdKydcIl0nKVswXS5jaGVja2VkID0gdHJ1ZTtcclxuICAgICAgICAgICQoJyNzdmdfd2lkdGhfdW5pdCBpbnB1dCcpLmJ1dHRvbigncmVmcmVzaCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQXV0b3JlZnJlc2hcclxuICAgICAgICAkKCcjYXV0b3JlZnJlc2hfbW9kZScpWzBdLmNoZWNrZWQgPSBDb25maWd1cmF0aW9uLmF1dG9yZWZyZXNoT247XHJcbiAgICAgICAgJCgnI2F1dG9yZWZyZXNoX21vZGUnKS5idXR0b24oJ3JlZnJlc2gnKTtcclxuICAgICAgfSovXHJcblxyXG4gICAgICAkKCcjcHJldicpLmJ1dHRvbigpLmNsaWNrKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBtb3ZlSW5GaWxlQnJvd3NlcigtMSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICAkKCcjbmV4dCcpLmJ1dHRvbigpLmNsaWNrKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBtb3ZlSW5GaWxlQnJvd3NlcigrMSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICAkKCcjZm9vdGVyJykuc2hvdygpO1xyXG5cclxuICAgICAgdmFyIHJlbWVtYmVyRGF0YSA9IGZ1bmN0aW9uKF9kYXRhKSB7XHJcbiAgICAgICAgaWYgKF9kYXRhICYmICFfZGF0YS5leGNlcHRpb24pIHtcclxuICAgICAgICAgIGRhdGEgPSBfZGF0YTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgb25TY3JlYW1pbmdIYWx0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgJCgnI3dhaXRlcicpLmRpYWxvZygnY2xvc2UnKTtcclxuICAgICAgICAkKCcjcHVsbGRvd24sICNuYXZidXR0b25zLCAjc3Bpbm5lcicpLnJlbW92ZSgpO1xyXG4gICAgICAgIGRpc3BhdGNoZXIucG9zdCgnaGlkZUZvcm0nKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGRpc3BhdGNoZXIuXHJcbiAgICAgICAgICBvbignaW5pdCcsIGluaXQpLlxyXG4gICAgICAgICAgb24oJ2RhdGFSZWFkeScsIHJlbWVtYmVyRGF0YSkuXHJcbiAgICAgICAgICBvbignYW5ub3RhdGlvbklzQXZhaWxhYmxlJywgYW5ub3RhdGlvbklzQXZhaWxhYmxlKS5cclxuICAgICAgICAgIG9uKCdtZXNzYWdlcycsIGRpc3BsYXlNZXNzYWdlcykuXHJcbiAgICAgICAgICBvbignZGlzcGxheVNwYW5Db21tZW50JywgZGlzcGxheVNwYW5Db21tZW50KS5cclxuICAgICAgICAgIG9uKCdkaXNwbGF5QXJjQ29tbWVudCcsIGRpc3BsYXlBcmNDb21tZW50KS5cclxuICAgICAgICAgIG9uKCdkaXNwbGF5U2VudENvbW1lbnQnLCBkaXNwbGF5U2VudENvbW1lbnQpLlxyXG4gICAgICAgICAgb24oJ2RvY0NoYW5nZWQnLCBvbkRvY0NoYW5nZWQpLlxyXG4gICAgICAgICAgb24oJ2hpZGVDb21tZW50JywgaGlkZUNvbW1lbnQpLlxyXG4gICAgICAgICAgb24oJ3Nob3dGb3JtJywgc2hvd0Zvcm0pLlxyXG4gICAgICAgICAgb24oJ2hpZGVGb3JtJywgaGlkZUZvcm0pLlxyXG4gICAgICAgICAgb24oJ2luaXRGb3JtJywgaW5pdEZvcm0pLlxyXG4gICAgICAgICAgb24oJ2NvbGxlY3Rpb25Mb2FkZWQnLCByZW1lbWJlck5vcm1EYikuXHJcbiAgICAgICAgICBvbignY29sbGVjdGlvbkxvYWRlZCcsIGNvbGxlY3Rpb25Mb2FkZWQpLlxyXG4gICAgICAgICAgb24oJ3NwYW5BbmRBdHRyaWJ1dGVUeXBlc0xvYWRlZCcsIHNwYW5BbmRBdHRyaWJ1dGVUeXBlc0xvYWRlZCkuXHJcbiAgICAgICAgICBvbignaXNSZWxvYWRPa2F5JywgaXNSZWxvYWRPa2F5KS5cclxuICAgICAgICAgIG9uKCdjdXJyZW50JywgZ290Q3VycmVudCkuXHJcbiAgICAgICAgICBvbignZG9uZVJlbmRlcmluZycsIG9uRG9uZVJlbmRlcmluZykuXHJcbiAgICAgICAgICBvbignc3RhcnRlZFJlbmRlcmluZycsIG9uU3RhcnRlZFJlbmRlcmluZykuXHJcbiAgICAgICAgICBvbignbmV3U291cmNlRGF0YScsIG9uTmV3U291cmNlRGF0YSkuXHJcbiAgICAgICAgICBvbignc2F2ZWRTVkcnLCBzYXZlZFNWR3JlY2VpdmVkKS5cclxuICAgICAgICAgIG9uKCdyZW5kZXJFcnJvcjpub0ZpbGVTcGVjaWZpZWQnLCBub0ZpbGVTcGVjaWZpZWQpLlxyXG4gICAgICAgICAgb24oJ3JlbmRlckVycm9yOmFubm90YXRpb25GaWxlTm90Rm91bmQnLCBzaG93QW5ub3RhdGlvbkZpbGVOb3RGb3VuZCkuXHJcbiAgICAgICAgICBvbigncmVuZGVyRXJyb3I6dW5hYmxlVG9SZWFkVGV4dEZpbGUnLCBzaG93VW5hYmxlVG9SZWFkVGV4dEZpbGUpLlxyXG4gICAgICAgICAgb24oJ3JlbmRlckVycm9yOmlzRGlyZWN0b3J5RXJyb3InLCByZWxvYWREaXJlY3RvcnlXaXRoU2xhc2gpLlxyXG4gICAgICAgICAgb24oJ3Vua25vd25FcnJvcicsIHNob3dVbmtub3duRXJyb3IpLlxyXG4gICAgICAgICAgb24oJ2tleWRvd24nLCBvbktleURvd24pLlxyXG4gICAgICAgICAgb24oJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKS5cclxuICAgICAgICAgIG9uKCdkYmxjbGljaycsIG9uRGJsQ2xpY2spLlxyXG4gICAgICAgICAgb24oJ2NsaWNrJywgb25TaW5nbGVDbGljaykuXHJcbiAgICAgICAgICBvbigndG91Y2hzdGFydCcsIG9uVG91Y2hTdGFydCkuXHJcbiAgICAgICAgICBvbigndG91Y2hlbmQnLCBvblRvdWNoRW5kKS5cclxuICAgICAgICAgIG9uKCdyZXNpemUnLCBvblJlc2l6ZSkuXHJcbiAgICAgICAgICBvbignc2VhcmNoUmVzdWx0c1JlY2VpdmVkJywgc2VhcmNoUmVzdWx0c1JlY2VpdmVkKS5cclxuICAgICAgICAgIG9uKCdjbGVhclNlYXJjaCcsIGNsZWFyU2VhcmNoKS5cclxuICAgICAgICAgIG9uKCdjbGVhclNWRycsIHNob3dOb0RvY01lc3NhZ2UpLlxyXG4gICAgICAgICAgb24oJ3NjcmVhbWluZ0hhbHQnLCBvblNjcmVhbWluZ0hhbHQpLlxyXG4gICAgICAgICAgLy9vbignY29uZmlndXJhdGlvblVwZGF0ZWQnLCB1cGRhdGVDb25maWd1cmF0aW9uVUkpLlxyXG4gICAgICAgICAgb24oJ2NvbmZpZ3VyYXRpb25DaGFuZ2VkJywgY29uZmlndXJhdGlvbkNoYW5nZWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gVmlzdWFsaXplclVJO1xyXG59KShqUXVlcnksIHdpbmRvdyk7XHJcblxyXG4vLyBCUkFUIFNUQU5EQUxPTkUgTElCUkFSWSBCRUdJTlxyXG4vLyBCcm93c2VyaWZ5IGV4cG9ydFxyXG5tb2R1bGUuZXhwb3J0cyA9IFZpc3VhbGl6ZXJVSTtcclxuLy8gQlJBVCBTVEFOREFMT05FIExJQlJBUlkgRU5EXHJcbiIsIndpbmRvdy4kID0gcmVxdWlyZSgnLi9jbGllbnQvbGliL25vZGUtanF1ZXJ5LTEuNy4xJyk7IC8vcmVxdWlyZSgnanF1ZXJ5LW5vZGUtYnJvd3NlcmlmeScpOyAvLyBAMS43LjIgKytcclxuTE9OR19BTk5PVEFUSU9OX0NPTlNUID0gXCJMb25nQW5ub3RhdGlvblwiO1xyXG5cclxud2luZG93LkJyYXRGcm9udGVuZEVkaXRvciA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNvbGxEYXRhLCBkb2NEYXRhLCBvcHRpb25zKSB7XHJcbiAgICBpZiAoIShlbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VsZW1lbnQgc2hvdWxkIGJlIGFuIGluc3RhbmNlIG9mIEVsZW1lbnQnKTtcclxuICAgIH1cclxuXHJcbiAgICBjb2xsRGF0YSA9IGNvbGxEYXRhIHx8IHt9O1xyXG4gICAgZG9jRGF0YSA9IGRvY0RhdGEgfHwge307XHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICAvL0RFRkFVTFQgT1BUSU9OU1xyXG4gICAgbmV3T3B0aW9ucyA9IHtcclxuICAgICAgICBhY3RpdmF0ZUVkaXRpb246IHRydWUsXHJcbiAgICAgICAgb3ZlcldyaXRlTW9kYWxzOiBmYWxzZSxcclxuICAgICAgICBzaG93VG9vbHRpcDogZmFsc2UsXHJcbiAgICAgICAgYXNzZXRzUGF0aDogXCJzcmMvYXNzZXRzL2JyYXQtY2xpZW50L3N0YXRpYy9cIixcclxuICAgICAgICBtYXhGcmFnbWVudExlbmd0aDogNDAsXHJcbiAgICAgICAgc2hvd1Rvb2x0aXA6IHRydWUsXHJcbiAgICAgICAgb3ZlcldyaXRlTW9kYWxzOiBmYWxzZSxcclxuICAgICAgICB3ZWJGb250VVJMczogW1xyXG4gICAgICAgICAgICAnZm9udHMvQXN0bG9jaC1Cb2xkLnR0ZicsXHJcbiAgICAgICAgICAgICdmb250cy9QVF9TYW5zLUNhcHRpb24tV2ViLVJlZ3VsYXIudHRmJyxcclxuICAgICAgICAgICAgJ2ZvbnRzL0xpYmVyYXRpb25fU2Fucy1SZWd1bGFyLnR0ZidcclxuICAgICAgICBdLFxyXG4gICAgICAgIGFqYXg6ICdsb2NhbCcgLy8gJ2xvY2FsJywgJ2V4dGVybmFsJyBvciAnbm9ybWFsJ1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBJZiBvcHRpb24gZGVmaW5lZCwgb3Zlci13cml0ZSBuZXdPcHRpb25zXHJcbiAgICBmb3IodmFyIG9wdCBpbiBvcHRpb25zKXtcclxuICAgICAgICBpZihvcHRpb25zLmhhc093blByb3BlcnR5KG9wdCkpe1xyXG4gICAgICAgICAgICBuZXdPcHRpb25zW29wdF0gPSBvcHRpb25zW29wdF07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICB0aGlzLmNvbGxEYXRhID0gY29sbERhdGE7XHJcbiAgICB0aGlzLmRvY0RhdGEgPSBkb2NEYXRhO1xyXG4gICAgdGhpcy5vcHRpb25zID0gbmV3T3B0aW9ucztcclxuICAgIHRoaXMuaW5pdCgpO1xyXG59O1xyXG5cclxuQnJhdEZyb250ZW5kRWRpdG9yLnByb3RvdHlwZSA9IHtcclxuICAgIGNvbnN0cnVjdG9yOiBCcmF0RnJvbnRlbmRFZGl0b3IsXHJcbiAgICBpbml0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGh0bWwgPSByZXF1aXJlKCcuL2JyYXQuaHRtbCcpO1xyXG4gICAgICAgIHNlbGYuZWxlbWVudC5pbm5lckhUTUwgPSBodG1sO1xyXG4gICAgICAgIHNlbGYuc2V0SHRtbEltZ1NyYygpO1xyXG5cclxuICAgICAgICB3aW5kb3cualF1ZXJ5ID0gJDtcclxuICAgICAgICAoZnVuY3Rpb24oJCl7XHJcbiAgICAgICAgICAgIC8vIHJlcXVpcmUoJy4vaW5kZXguY3NzJyk7IC8vVE9ETzogSWYgcG9zc2libGUsIGluY2x1ZGUgY3NzIGluIG1pbi5qcyAoYnJvd3NlcmlmeS1jc3MpXHJcbiAgICAgICAgICAgIHJlcXVpcmUoJy4vY2xpZW50L2xpYi9qcXVlcnktdWkubWluJyk7XHJcbiAgICAgICAgICAgIHJlcXVpcmUoJy4vY2xpZW50L2xpYi9qcXVlcnkuc3ZnLm1pbicpO1xyXG4gICAgICAgICAgICByZXF1aXJlKCcuL2NsaWVudC9saWIvanF1ZXJ5LnN2Z2RvbS5taW4nKTtcclxuICAgICAgICAgICAgcmVxdWlyZSgnanF1ZXJ5LWJicScpO1xyXG4gICAgICAgICAgICByZXF1aXJlKCcuL2NsaWVudC9saWIvanF1ZXJ5LnNwcmludGYnKTtcclxuICAgICAgICAgICAgcmVxdWlyZSgnLi9jbGllbnQvbGliL2pxdWVyeS5qc29uLm1pbicpO1xyXG4gICAgICAgICAgICAvL1RPRE8gRml4IHRoaXMgZXJyb3JcclxuICAgICAgICAgICAgd2luZG93LldlYkZvbnQgPSByZXF1aXJlKCcuL2NsaWVudC9saWIvd2ViZm9udC5qcycpLldlYkZvbnQ7IC8vVW5jYXVnaHQgVHlwZUVycm9yOiBDYW5ub3Qgc2V0IHByb3BlcnR5ICdXZWJGb250JyBvZiB1bmRlZmluZWRcclxuXHJcbiAgICAgICAgICAgIC8vYnJhdCBnbG9iYWwgaGVscGVyc1xyXG4gICAgICAgICAgICB2YXIgQ29uZmlnPSByZXF1aXJlKCcuL2NsaWVudC9zcmMvY29uZmlndXJhdGlvbicpO1xyXG4gICAgICAgICAgICB3aW5kb3cuQ29uZmlndXJhdGlvbiA9IG5ldyBDb25maWcoKTtcclxuICAgICAgICAgICAgd2luZG93LlV0aWwgPSByZXF1aXJlKCcuL2NsaWVudC9zcmMvdXRpbCcpO1xyXG5cclxuICAgICAgICAgICAgLy8gYnJhdCBtb2R1bGVzXHJcbiAgICAgICAgICAgIHdpbmRvdy5EaXNwYXRjaGVyID0gcmVxdWlyZSgnLi9jbGllbnQvc3JjL2Rpc3BhdGNoZXInKTtcclxuICAgICAgICAgICAgd2luZG93LlVSTEhhc2ggPSByZXF1aXJlKCcuL2NsaWVudC9zcmMvdXJsX2hhc2gnKTsgLy9UT0RPIEZpZ3VyZSBvdXRcclxuICAgICAgICAgICAgd2luZG93LkxvY2FsQWpheCA9IHJlcXVpcmUoJy4vY2xpZW50L3NyYy9sb2NhbF9hamF4Jyk7XHJcbiAgICAgICAgICAgIHdpbmRvdy5BamF4ID0gcmVxdWlyZSgnLi9jbGllbnQvc3JjL2FqYXguanMnKTtcclxuICAgICAgICAgICAgd2luZG93LlZpc3VhbGl6ZXIgPSByZXF1aXJlKCcuL2NsaWVudC9zcmMvdmlzdWFsaXplcicpO1xyXG4gICAgICAgICAgICB3aW5kb3cuVmlzdWFsaXplclVJID0gcmVxdWlyZSgnLi9jbGllbnQvc3JjL3Zpc3VhbGl6ZXJfdWknKTtcclxuICAgICAgICAgICAgd2luZG93LkFubm90YXRvclVJID0gcmVxdWlyZSgnLi9jbGllbnQvc3JjL2Fubm90YXRvcl91aScpO1xyXG4gICAgICAgICAgICB3aW5kb3cuU3Bpbm5lciA9IHJlcXVpcmUoJy4vY2xpZW50L3NyYy9zcGlubmVyJyk7XHJcblxyXG4gICAgICAgICAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgc2VsZi5kaXNwYXRjaGVyID0gbmV3IERpc3BhdGNoZXIoKTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaChzZWxmLm9wdGlvbnMuYWpheCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2xvY2FsJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hamF4ID0gbmV3IExvY2FsQWpheChzZWxmLmRpc3BhdGNoZXIsIHNlbGYub3B0aW9ucy5tYXhGcmFnbWVudExlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ25vcm1hbCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYWpheCA9IG5ldyBBamF4KHNlbGYuZGlzcGF0Y2hlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V4dGVybmFsJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hamF4ID0gbmV3IExvY2FsQWpheChzZWxmLmRpc3BhdGNoZXIsIHNlbGYub3B0aW9ucy5tYXhGcmFnbWVudExlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGFic29sdXRlV2ViRm9udHNVUkxTID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYub3B0aW9ucy5hc3NldHNQYXRoICsgc2VsZi5vcHRpb25zLndlYkZvbnRVUkxzWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYub3B0aW9ucy5hc3NldHNQYXRoICsgc2VsZi5vcHRpb25zLndlYkZvbnRVUkxzWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYub3B0aW9ucy5hc3NldHNQYXRoICsgc2VsZi5vcHRpb25zLndlYkZvbnRVUkxzWzJdLFxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgIHNlbGYudmlzdWFsaXplciA9IG5ldyBWaXN1YWxpemVyKHNlbGYuZGlzcGF0Y2hlciwgJ3N2ZycsIGFic29sdXRlV2ViRm9udHNVUkxTKTtcclxuICAgICAgICAgICAgICAgIHNlbGYuc3ZnID0gc2VsZi52aXN1YWxpemVyLnN2ZztcclxuICAgICAgICAgICAgICAgIGlmKHNlbGYub3B0aW9ucy5hY3RpdmF0ZUVkaXRpb24gPT09IHRydWUpe1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYudmlzdWFsaXplclVJID0gbmV3IFZpc3VhbGl6ZXJVSShzZWxmLmRpc3BhdGNoZXIsIHNlbGYuc3ZnLCBzZWxmLm9wdGlvbnMuc2hvd1Rvb2x0aXAsIHNlbGYub3B0aW9ucy5vdmVyV3JpdGVNb2RhbHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYW5ub3RhdG9yVUkgPSBuZXcgQW5ub3RhdG9yVUkoc2VsZi5kaXNwYXRjaGVyLCBzZWxmLnN2Zyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VsZi5zcGlubmVyID0gbmV3IFNwaW5uZXIoc2VsZi5kaXNwYXRjaGVyLCAnI3NwaW5uZXInKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2hlci5wb3N0KCdpbml0Jyk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoc2VsZi5vcHRpb25zLm1heEZyYWdtZW50TGVuZ3RoID4gMCl7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hZGRMb25nQW5ub3RhdGlvbkVudGl0eUF0dHJpYnV0ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHNlbGYuZG9jRGF0YS5jb2xsZWN0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2hlci5wb3N0KCdjb2xsZWN0aW9uTG9hZGVkJywgW3NlbGYuY29sbERhdGFdKTtcclxuICAgICAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2hlci5wb3N0KCdyZXF1ZXN0UmVuZGVyRGF0YScsIFtzZWxmLmRvY0RhdGFdKTtcclxuICAgICAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2hlci5wb3N0KCdjdXJyZW50JywgW3NlbGYuY29sbERhdGEsIHNlbGYuZG9jRGF0YSwge31dKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIH0pKCQpO1xyXG4gICAgfSxcclxuICAgIGFkZExvbmdBbm5vdGF0aW9uRW50aXR5QXR0cmlidXRlOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIC8vIFNwZWNpYWwgc3ltYm9sIGZvciBzcGxpdHRlZCBsb25nIGFubm90YXRpb25zXHJcbiAgICAgICAgdGhpcy5jb2xsRGF0YS5lbnRpdHlfYXR0cmlidXRlX3R5cGVzLnB1c2goIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IExPTkdfQU5OT1RBVElPTl9DT05TVCxcclxuICAgICAgICAgICAgXCJ0eXBlXCIgIDogTE9OR19BTk5PVEFUSU9OX0NPTlNULFxyXG4gICAgICAgICAgICBcInZhbHVlc1wiOiB7IExPTkdfQU5OT1RBVElPTl9DT05TVDogeyBcImdseXBoXCI6IFwi4oa5XCIgfSB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jb2xsRGF0YS5lbnRpdHlfdHlwZXMuZm9yRWFjaChmdW5jdGlvbih0eXBlKXtcclxuICAgICAgICAgICAgdHlwZS5hdHRyaWJ1dGVzLnB1c2goTE9OR19BTk5PVEFUSU9OX0NPTlNUKTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBzZXRIdG1sSW1nU3JjOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBzcGlubmVycyA9IHRoaXMuZWxlbWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiYnJhdC1zcGlubmVyXCIpO1xyXG4gICAgICAgIHZhciBtYWduaWZpZXJzID0gdGhpcy5lbGVtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJicmF0LWZ1Z3VlLXNoYWRvd2xlc3MtbWFnbmlmaWVyXCIpO1xyXG4gICAgICAgIHZhciBleHRlcm5hbHMgPSB0aGlzLmVsZW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImJyYXQtZnVndWUtc2hhZG93bGVzcy1leHRlcm5hbFwiKTtcclxuXHJcbiAgICAgICAgaWYoc3Bpbm5lcnMgJiYgc3Bpbm5lcnMubGVuZ3RoKXtcclxuICAgICAgICAgICAgc3Bpbm5lcnNbMF0uc3JjID0gdGhpcy5vcHRpb25zLmFzc2V0c1BhdGggKyAnaW1nL3NwaW5uZXIuZ2lmJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYobWFnbmlmaWVycyAmJiBtYWduaWZpZXJzLmxlbmd0aCl7XHJcbiAgICAgICAgICAgIG1hZ25pZmllcnNbMF0uc3JjID0gdGhpcy5vcHRpb25zLmFzc2V0c1BhdGggKyAnaW1nL0Z1Z3VlLXNoYWRvd2xlc3MtbWFnbmlmaWVyLnBuZyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGV4dGVybmFscyAmJiBleHRlcm5hbHMubGVuZ3RoKXtcclxuICAgICAgICAgICAgZXh0ZXJuYWxzWzBdLnNyYyA9IHRoaXMub3B0aW9ucy5hc3NldHNQYXRoICsgJ2ltZy9GdWd1ZS1zaGFkb3dsZXNzLWV4dGVybmFsLnBuZyc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG4iLCIvKiFcbiAqIGpRdWVyeSBCQlE6IEJhY2sgQnV0dG9uICYgUXVlcnkgTGlicmFyeSAtIHYxLjNwcmUgLSA4LzI2LzIwMTBcbiAqIGh0dHA6Ly9iZW5hbG1hbi5jb20vcHJvamVjdHMvanF1ZXJ5LWJicS1wbHVnaW4vXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwIFwiQ293Ym95XCIgQmVuIEFsbWFuXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgYW5kIEdQTCBsaWNlbnNlcy5cbiAqIGh0dHA6Ly9iZW5hbG1hbi5jb20vYWJvdXQvbGljZW5zZS9cbiAqL1xuXG4vLyBTY3JpcHQ6IGpRdWVyeSBCQlE6IEJhY2sgQnV0dG9uICYgUXVlcnkgTGlicmFyeVxuLy9cbi8vICpWZXJzaW9uOiAxLjNwcmUsIExhc3QgdXBkYXRlZDogOC8yNi8yMDEwKlxuLy9cbi8vIFByb2plY3QgSG9tZSAtIGh0dHA6Ly9iZW5hbG1hbi5jb20vcHJvamVjdHMvanF1ZXJ5LWJicS1wbHVnaW4vXG4vLyBHaXRIdWIgICAgICAgLSBodHRwOi8vZ2l0aHViLmNvbS9jb3dib3kvanF1ZXJ5LWJicS9cbi8vIFNvdXJjZSAgICAgICAtIGh0dHA6Ly9naXRodWIuY29tL2Nvd2JveS9qcXVlcnktYmJxL3Jhdy9tYXN0ZXIvanF1ZXJ5LmJhLWJicS5qc1xuLy8gKE1pbmlmaWVkKSAgIC0gaHR0cDovL2dpdGh1Yi5jb20vY293Ym95L2pxdWVyeS1iYnEvcmF3L21hc3Rlci9qcXVlcnkuYmEtYmJxLm1pbi5qcyAoMi4ya2IgZ3ppcHBlZClcbi8vXG4vLyBBYm91dDogTGljZW5zZVxuLy9cbi8vIENvcHlyaWdodCAoYykgMjAxMCBcIkNvd2JveVwiIEJlbiBBbG1hbixcbi8vIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBhbmQgR1BMIGxpY2Vuc2VzLlxuLy8gaHR0cDovL2JlbmFsbWFuLmNvbS9hYm91dC9saWNlbnNlL1xuLy9cbi8vIEFib3V0OiBFeGFtcGxlc1xuLy9cbi8vIFRoZXNlIHdvcmtpbmcgZXhhbXBsZXMsIGNvbXBsZXRlIHdpdGggZnVsbHkgY29tbWVudGVkIGNvZGUsIGlsbHVzdHJhdGUgYSBmZXdcbi8vIHdheXMgaW4gd2hpY2ggdGhpcyBwbHVnaW4gY2FuIGJlIHVzZWQuXG4vL1xuLy8gQmFzaWMgQUpBWCAgICAgLSBodHRwOi8vYmVuYWxtYW4uY29tL2NvZGUvcHJvamVjdHMvanF1ZXJ5LWJicS9leGFtcGxlcy9mcmFnbWVudC1iYXNpYy9cbi8vIEFkdmFuY2VkIEFKQVggIC0gaHR0cDovL2JlbmFsbWFuLmNvbS9jb2RlL3Byb2plY3RzL2pxdWVyeS1iYnEvZXhhbXBsZXMvZnJhZ21lbnQtYWR2YW5jZWQvXG4vLyBqUXVlcnkgVUkgVGFicyAtIGh0dHA6Ly9iZW5hbG1hbi5jb20vY29kZS9wcm9qZWN0cy9qcXVlcnktYmJxL2V4YW1wbGVzL2ZyYWdtZW50LWpxdWVyeS11aS10YWJzL1xuLy8gRGVwYXJhbSAgICAgICAgLSBodHRwOi8vYmVuYWxtYW4uY29tL2NvZGUvcHJvamVjdHMvanF1ZXJ5LWJicS9leGFtcGxlcy9kZXBhcmFtL1xuLy9cbi8vIEFib3V0OiBTdXBwb3J0IGFuZCBUZXN0aW5nXG4vL1xuLy8gSW5mb3JtYXRpb24gYWJvdXQgd2hhdCB2ZXJzaW9uIG9yIHZlcnNpb25zIG9mIGpRdWVyeSB0aGlzIHBsdWdpbiBoYXMgYmVlblxuLy8gdGVzdGVkIHdpdGgsIHdoYXQgYnJvd3NlcnMgaXQgaGFzIGJlZW4gdGVzdGVkIGluLCBhbmQgd2hlcmUgdGhlIHVuaXQgdGVzdHNcbi8vIHJlc2lkZSAoc28geW91IGNhbiB0ZXN0IGl0IHlvdXJzZWxmKS5cbi8vXG4vLyBqUXVlcnkgVmVyc2lvbnMgLSAxLjIuNiwgMS4zLjIsIDEuNC4xLCAxLjQuMlxuLy8gQnJvd3NlcnMgVGVzdGVkIC0gSW50ZXJuZXQgRXhwbG9yZXIgNi04LCBGaXJlZm94IDItNCwgQ2hyb21lIDUtNiwgU2FmYXJpIDMuMi01LFxuLy8gICAgICAgICAgICAgICAgICAgT3BlcmEgOS42LTEwLjYwLCBpUGhvbmUgMy4xLCBBbmRyb2lkIDEuNi0yLjIsIEJsYWNrQmVycnkgNC42LTUuXG4vLyBVbml0IFRlc3RzICAgICAgLSBodHRwOi8vYmVuYWxtYW4uY29tL2NvZGUvcHJvamVjdHMvanF1ZXJ5LWJicS91bml0L1xuLy9cbi8vIEFib3V0OiBSZWxlYXNlIEhpc3Rvcnlcbi8vXG4vLyAxLjNwcmUgLSAoOC8yNi8yMDEwKSBJbnRlZ3JhdGVkIDxqUXVlcnkgaGFzaGNoYW5nZSBldmVudD4gdjEuMywgd2hpY2ggYWRkc1xuLy8gICAgICAgICBkb2N1bWVudC50aXRsZSBhbmQgZG9jdW1lbnQuZG9tYWluIHN1cHBvcnQgaW4gSUU2LzcsIEJsYWNrQmVycnlcbi8vICAgICAgICAgc3VwcG9ydCwgYmV0dGVyIElmcmFtZSBoaWRpbmcgZm9yIGFjY2Vzc2liaWxpdHkgcmVhc29ucywgYW5kIHRoZSBuZXdcbi8vICAgICAgICAgPGpRdWVyeS5mbi5oYXNoY2hhbmdlPiBcInNob3J0Y3V0XCIgbWV0aG9kLiBBZGRlZCB0aGVcbi8vICAgICAgICAgPGpRdWVyeS5wYXJhbS5zb3J0ZWQ+IG1ldGhvZCB3aGljaCByZWR1Y2VzIHRoZSBwb3NzaWJpbGl0eSBvZlxuLy8gICAgICAgICBleHRyYW5lb3VzIGhhc2hjaGFuZ2UgZXZlbnQgdHJpZ2dlcmluZy4gQWRkZWQgdGhlXG4vLyAgICAgICAgIDxqUXVlcnkucGFyYW0uZnJhZ21lbnQuYWpheENyYXdsYWJsZT4gbWV0aG9kIHdoaWNoIGNhbiBiZSB1c2VkIHRvXG4vLyAgICAgICAgIGVuYWJsZSBHb29nbGUgXCJBSkFYIENyYXdsYWJsZSBtb2RlLlwiXG4vLyAxLjIuMSAtICgyLzE3LzIwMTApIEFjdHVhbGx5IGZpeGVkIHRoZSBzdGFsZSB3aW5kb3cubG9jYXRpb24gU2FmYXJpIGJ1ZyBmcm9tXG4vLyAgICAgICAgIDxqUXVlcnkgaGFzaGNoYW5nZSBldmVudD4gaW4gQkJRLCB3aGljaCB3YXMgdGhlIG1haW4gcmVhc29uIGZvciB0aGVcbi8vICAgICAgICAgcHJldmlvdXMgcmVsZWFzZSFcbi8vIDEuMiAgIC0gKDIvMTYvMjAxMCkgSW50ZWdyYXRlZCA8alF1ZXJ5IGhhc2hjaGFuZ2UgZXZlbnQ+IHYxLjIsIHdoaWNoIGZpeGVzIGFcbi8vICAgICAgICAgU2FmYXJpIGJ1ZywgdGhlIGV2ZW50IGNhbiBub3cgYmUgYm91bmQgYmVmb3JlIERPTSByZWFkeSwgYW5kIElFNi83XG4vLyAgICAgICAgIHBhZ2Ugc2hvdWxkIG5vIGxvbmdlciBzY3JvbGwgd2hlbiB0aGUgZXZlbnQgaXMgZmlyc3QgYm91bmQuIEFsc29cbi8vICAgICAgICAgYWRkZWQgdGhlIDxqUXVlcnkucGFyYW0uZnJhZ21lbnQubm9Fc2NhcGU+IG1ldGhvZCwgYW5kIHJld29ya2VkIHRoZVxuLy8gICAgICAgICA8aGFzaGNoYW5nZSBldmVudCAoQkJRKT4gaW50ZXJuYWwgXCJhZGRcIiBtZXRob2QgdG8gYmUgY29tcGF0aWJsZSB3aXRoXG4vLyAgICAgICAgIGNoYW5nZXMgbWFkZSB0byB0aGUgalF1ZXJ5IDEuNC4yIHNwZWNpYWwgZXZlbnRzIEFQSS5cbi8vIDEuMS4xIC0gKDEvMjIvMjAxMCkgSW50ZWdyYXRlZCA8alF1ZXJ5IGhhc2hjaGFuZ2UgZXZlbnQ+IHYxLjEsIHdoaWNoIGZpeGVzIGFuXG4vLyAgICAgICAgIG9ic2N1cmUgSUU4IEVtdWxhdGVJRTcgbWV0YSB0YWcgY29tcGF0aWJpbGl0eSBtb2RlIGJ1Zy5cbi8vIDEuMSAgIC0gKDEvOS8yMDEwKSBCcm9rZSBvdXQgdGhlIGpRdWVyeSBCQlEgZXZlbnQuc3BlY2lhbCA8aGFzaGNoYW5nZSBldmVudD5cbi8vICAgICAgICAgZnVuY3Rpb25hbGl0eSBpbnRvIGEgc2VwYXJhdGUgcGx1Z2luIGZvciB1c2VycyB3aG8gd2FudCBqdXN0IHRoZVxuLy8gICAgICAgICBiYXNpYyBldmVudCAmIGJhY2sgYnV0dG9uIHN1cHBvcnQsIHdpdGhvdXQgYWxsIHRoZSBleHRyYSBhd2Vzb21lbmVzc1xuLy8gICAgICAgICB0aGF0IEJCUSBwcm92aWRlcy4gVGhpcyBwbHVnaW4gd2lsbCBiZSBpbmNsdWRlZCBhcyBwYXJ0IG9mIGpRdWVyeSBCQlEsXG4vLyAgICAgICAgIGJ1dCBhbHNvIGJlIGF2YWlsYWJsZSBzZXBhcmF0ZWx5LiBTZWUgPGpRdWVyeSBoYXNoY2hhbmdlIGV2ZW50PlxuLy8gICAgICAgICBwbHVnaW4gZm9yIG1vcmUgaW5mb3JtYXRpb24uIEFsc28gYWRkZWQgdGhlIDxqUXVlcnkuYmJxLnJlbW92ZVN0YXRlPlxuLy8gICAgICAgICBtZXRob2QgYW5kIGFkZGVkIGFkZGl0aW9uYWwgPGpRdWVyeS5kZXBhcmFtPiBleGFtcGxlcy5cbi8vIDEuMC4zIC0gKDEyLzIvMjAwOSkgRml4ZWQgYW4gaXNzdWUgaW4gSUUgNiB3aGVyZSBsb2NhdGlvbi5zZWFyY2ggYW5kXG4vLyAgICAgICAgIGxvY2F0aW9uLmhhc2ggd291bGQgcmVwb3J0IGluY29ycmVjdGx5IGlmIHRoZSBoYXNoIGNvbnRhaW5lZCB0aGUgP1xuLy8gICAgICAgICBjaGFyYWN0ZXIuIEFsc28gPGpRdWVyeS5wYXJhbS5xdWVyeXN0cmluZz4gYW5kIDxqUXVlcnkucGFyYW0uZnJhZ21lbnQ+XG4vLyAgICAgICAgIHdpbGwgbm8gbG9uZ2VyIHBhcnNlIHBhcmFtcyBvdXQgb2YgYSBVUkwgdGhhdCBkb2Vzbid0IGNvbnRhaW4gPyBvciAjLFxuLy8gICAgICAgICByZXNwZWN0aXZlbHkuXG4vLyAxLjAuMiAtICgxMC8xMC8yMDA5KSBGaXhlZCBhbiBpc3N1ZSBpbiBJRSA2Lzcgd2hlcmUgdGhlIGhpZGRlbiBJRlJBTUUgY2F1c2VkXG4vLyAgICAgICAgIGEgXCJUaGlzIHBhZ2UgY29udGFpbnMgYm90aCBzZWN1cmUgYW5kIG5vbnNlY3VyZSBpdGVtcy5cIiB3YXJuaW5nIHdoZW5cbi8vICAgICAgICAgdXNlZCBvbiBhbiBodHRwczovLyBwYWdlLlxuLy8gMS4wLjEgLSAoMTAvNy8yMDA5KSBGaXhlZCBhbiBpc3N1ZSBpbiBJRSA4LiBTaW5jZSBib3RoIFwiSUU3XCIgYW5kIFwiSUU4XG4vLyAgICAgICAgIENvbXBhdGliaWxpdHkgVmlld1wiIG1vZGVzIGVycm9uZW91c2x5IHJlcG9ydCB0aGF0IHRoZSBicm93c2VyXG4vLyAgICAgICAgIHN1cHBvcnRzIHRoZSBuYXRpdmUgd2luZG93Lm9uaGFzaGNoYW5nZSBldmVudCwgYSBzbGlnaHRseSBtb3JlXG4vLyAgICAgICAgIHJvYnVzdCB0ZXN0IG5lZWRlZCB0byBiZSBhZGRlZC5cbi8vIDEuMCAgIC0gKDEwLzIvMjAwOSkgSW5pdGlhbCByZWxlYXNlXG5cbihmdW5jdGlvbigkLHdpbmRvdyl7XG4gIGNvbnNvbGUuaW5mbygneWVzIScpXG4gICckOm5vbXVuZ2UnOyAvLyBVc2VkIGJ5IFlVSSBjb21wcmVzc29yLlxuXG4gIC8vIFNvbWUgY29udmVuaWVudCBzaG9ydGN1dHMuXG4gIHZhciB1bmRlZmluZWQsXG4gICAgYXBzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLFxuICAgIGRlY29kZSA9IGRlY29kZVVSSUNvbXBvbmVudCxcblxuICAgIC8vIE1ldGhvZCAvIG9iamVjdCByZWZlcmVuY2VzLlxuICAgIGpxX3BhcmFtID0gJC5wYXJhbSxcbiAgICBqcV9wYXJhbV9zb3J0ZWQsXG4gICAganFfcGFyYW1fZnJhZ21lbnQsXG4gICAganFfZGVwYXJhbSxcbiAgICBqcV9kZXBhcmFtX2ZyYWdtZW50LFxuICAgIGpxX2JicSA9ICQuYmJxID0gJC5iYnEgfHwge30sXG4gICAganFfYmJxX3B1c2hTdGF0ZSxcbiAgICBqcV9iYnFfZ2V0U3RhdGUsXG4gICAganFfZWxlbVVybEF0dHIsXG4gICAgc3BlY2lhbCA9ICQuZXZlbnQuc3BlY2lhbCxcblxuICAgIC8vIFJldXNlZCBzdHJpbmdzLlxuICAgIHN0cl9oYXNoY2hhbmdlID0gJ2hhc2hjaGFuZ2UnLFxuICAgIHN0cl9xdWVyeXN0cmluZyA9ICdxdWVyeXN0cmluZycsXG4gICAgc3RyX2ZyYWdtZW50ID0gJ2ZyYWdtZW50JyxcbiAgICBzdHJfZWxlbVVybEF0dHIgPSAnZWxlbVVybEF0dHInLFxuICAgIHN0cl9ocmVmID0gJ2hyZWYnLFxuICAgIHN0cl9zcmMgPSAnc3JjJyxcblxuICAgIC8vIFJldXNlZCBSZWdFeHAuXG4gICAgcmVfcGFyYW1zX3F1ZXJ5c3RyaW5nID0gL14uKlxcP3wjLiokL2csXG4gICAgcmVfcGFyYW1zX2ZyYWdtZW50LFxuICAgIHJlX2ZyYWdtZW50LFxuICAgIHJlX25vX2VzY2FwZSxcblxuICAgIGFqYXhfY3Jhd2xhYmxlLFxuICAgIGZyYWdtZW50X3ByZWZpeCxcblxuICAgIC8vIFVzZWQgYnkgalF1ZXJ5LmVsZW1VcmxBdHRyLlxuICAgIGVsZW1VcmxBdHRyX2NhY2hlID0ge307XG5cbiAgLy8gQSBmZXcgY29tbW9ubHkgdXNlZCBiaXRzLCBicm9rZW4gb3V0IHRvIGhlbHAgcmVkdWNlIG1pbmlmaWVkIGZpbGUgc2l6ZS5cblxuICBmdW5jdGlvbiBpc19zdHJpbmcoIGFyZyApIHtcbiAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG4gIH07XG5cbiAgLy8gV2h5IHdyaXRlIHRoZSBzYW1lIGZ1bmN0aW9uIHR3aWNlPyBMZXQncyBjdXJyeSEgTW1tbSwgY3VycnkuLlxuXG4gIGZ1bmN0aW9uIGN1cnJ5KCBmdW5jICkge1xuICAgIHZhciBhcmdzID0gYXBzLmNhbGwoIGFyZ3VtZW50cywgMSApO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoIHRoaXMsIGFyZ3MuY29uY2F0KCBhcHMuY2FsbCggYXJndW1lbnRzICkgKSApO1xuICAgIH07XG4gIH07XG5cbiAgLy8gR2V0IGxvY2F0aW9uLmhhc2ggKG9yIHdoYXQgeW91J2QgZXhwZWN0IGxvY2F0aW9uLmhhc2ggdG8gYmUpIHNhbnMgYW55XG4gIC8vIGxlYWRpbmcgIy4gVGhhbmtzIGZvciBtYWtpbmcgdGhpcyBuZWNlc3NhcnksIEZpcmVmb3ghXG4gIGZ1bmN0aW9uIGdldF9mcmFnbWVudCggdXJsICkge1xuICAgIHJldHVybiB1cmwucmVwbGFjZSggcmVfZnJhZ21lbnQsICckMicgKTtcbiAgfTtcblxuICAvLyBHZXQgbG9jYXRpb24uc2VhcmNoIChvciB3aGF0IHlvdSdkIGV4cGVjdCBsb2NhdGlvbi5zZWFyY2ggdG8gYmUpIHNhbnMgYW55XG4gIC8vIGxlYWRpbmcgIy4gVGhhbmtzIGZvciBtYWtpbmcgdGhpcyBuZWNlc3NhcnksIElFNiFcbiAgZnVuY3Rpb24gZ2V0X3F1ZXJ5c3RyaW5nKCB1cmwgKSB7XG4gICAgcmV0dXJuIHVybC5yZXBsYWNlKCAvKD86XltePyNdKlxcPyhbXiNdKikuKiQpPy4qLywgJyQxJyApO1xuICB9O1xuXG4gIC8vIFNlY3Rpb246IFBhcmFtICh0byBzdHJpbmcpXG4gIC8vXG4gIC8vIE1ldGhvZDogalF1ZXJ5LnBhcmFtLnF1ZXJ5c3RyaW5nXG4gIC8vXG4gIC8vIFJldHJpZXZlIHRoZSBxdWVyeSBzdHJpbmcgZnJvbSBhIFVSTCBvciBpZiBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCwgdGhlXG4gIC8vIGN1cnJlbnQgd2luZG93LmxvY2F0aW9uLmhyZWYuXG4gIC8vXG4gIC8vIFVzYWdlOlxuICAvL1xuICAvLyA+IGpRdWVyeS5wYXJhbS5xdWVyeXN0cmluZyggWyB1cmwgXSApO1xuICAvL1xuICAvLyBBcmd1bWVudHM6XG4gIC8vXG4gIC8vICB1cmwgLSAoU3RyaW5nKSBBIFVSTCBjb250YWluaW5nIHF1ZXJ5IHN0cmluZyBwYXJhbXMgdG8gYmUgcGFyc2VkLiBJZiB1cmxcbiAgLy8gICAgaXMgbm90IHBhc3NlZCwgdGhlIGN1cnJlbnQgd2luZG93LmxvY2F0aW9uLmhyZWYgaXMgdXNlZC5cbiAgLy9cbiAgLy8gUmV0dXJuczpcbiAgLy9cbiAgLy8gIChTdHJpbmcpIFRoZSBwYXJzZWQgcXVlcnkgc3RyaW5nLCB3aXRoIGFueSBsZWFkaW5nIFwiP1wiIHJlbW92ZWQuXG4gIC8vXG5cbiAgLy8gTWV0aG9kOiBqUXVlcnkucGFyYW0ucXVlcnlzdHJpbmcgKGJ1aWxkIHVybClcbiAgLy9cbiAgLy8gTWVyZ2UgYSBVUkwsIHdpdGggb3Igd2l0aG91dCBwcmUtZXhpc3RpbmcgcXVlcnkgc3RyaW5nIHBhcmFtcywgcGx1cyBhbnlcbiAgLy8gb2JqZWN0LCBwYXJhbXMgc3RyaW5nIG9yIFVSTCBjb250YWluaW5nIHF1ZXJ5IHN0cmluZyBwYXJhbXMgaW50byBhIG5ldyBVUkwuXG4gIC8vXG4gIC8vIFVzYWdlOlxuICAvL1xuICAvLyA+IGpRdWVyeS5wYXJhbS5xdWVyeXN0cmluZyggdXJsLCBwYXJhbXMgWywgbWVyZ2VfbW9kZSBdICk7XG4gIC8vXG4gIC8vIEFyZ3VtZW50czpcbiAgLy9cbiAgLy8gIHVybCAtIChTdHJpbmcpIEEgdmFsaWQgVVJMIGZvciBwYXJhbXMgdG8gYmUgbWVyZ2VkIGludG8uIFRoaXMgVVJMIG1heVxuICAvLyAgICBjb250YWluIGEgcXVlcnkgc3RyaW5nIGFuZC9vciBmcmFnbWVudCAoaGFzaCkuXG4gIC8vICBwYXJhbXMgLSAoU3RyaW5nKSBBIHBhcmFtcyBzdHJpbmcgb3IgVVJMIGNvbnRhaW5pbmcgcXVlcnkgc3RyaW5nIHBhcmFtcyB0b1xuICAvLyAgICBiZSBtZXJnZWQgaW50byB1cmwuXG4gIC8vICBwYXJhbXMgLSAoT2JqZWN0KSBBIHBhcmFtcyBvYmplY3QgdG8gYmUgbWVyZ2VkIGludG8gdXJsLlxuICAvLyAgbWVyZ2VfbW9kZSAtIChOdW1iZXIpIE1lcmdlIGJlaGF2aW9yIGRlZmF1bHRzIHRvIDAgaWYgbWVyZ2VfbW9kZSBpcyBub3RcbiAgLy8gICAgc3BlY2lmaWVkLCBhbmQgaXMgYXMtZm9sbG93czpcbiAgLy9cbiAgLy8gICAgKiAwOiBwYXJhbXMgaW4gdGhlIHBhcmFtcyBhcmd1bWVudCB3aWxsIG92ZXJyaWRlIGFueSBxdWVyeSBzdHJpbmdcbiAgLy8gICAgICAgICBwYXJhbXMgaW4gdXJsLlxuICAvLyAgICAqIDE6IGFueSBxdWVyeSBzdHJpbmcgcGFyYW1zIGluIHVybCB3aWxsIG92ZXJyaWRlIHBhcmFtcyBpbiB0aGUgcGFyYW1zXG4gIC8vICAgICAgICAgYXJndW1lbnQuXG4gIC8vICAgICogMjogcGFyYW1zIGFyZ3VtZW50IHdpbGwgY29tcGxldGVseSByZXBsYWNlIGFueSBxdWVyeSBzdHJpbmcgaW4gdXJsLlxuICAvL1xuICAvLyBSZXR1cm5zOlxuICAvL1xuICAvLyAgKFN0cmluZykgQSBVUkwgd2l0aCBhIHVybGVuY29kZWQgcXVlcnkgc3RyaW5nIGluIHRoZSBmb3JtYXQgJz9hPWImYz1kJmU9ZicuXG5cbiAgLy8gTWV0aG9kOiBqUXVlcnkucGFyYW0uZnJhZ21lbnRcbiAgLy9cbiAgLy8gUmV0cmlldmUgdGhlIGZyYWdtZW50IChoYXNoKSBmcm9tIGEgVVJMIG9yIGlmIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkLCB0aGVcbiAgLy8gY3VycmVudCB3aW5kb3cubG9jYXRpb24uaHJlZi5cbiAgLy9cbiAgLy8gVXNhZ2U6XG4gIC8vXG4gIC8vID4galF1ZXJ5LnBhcmFtLmZyYWdtZW50KCBbIHVybCBdICk7XG4gIC8vXG4gIC8vIEFyZ3VtZW50czpcbiAgLy9cbiAgLy8gIHVybCAtIChTdHJpbmcpIEEgVVJMIGNvbnRhaW5pbmcgZnJhZ21lbnQgKGhhc2gpIHBhcmFtcyB0byBiZSBwYXJzZWQuIElmXG4gIC8vICAgIHVybCBpcyBub3QgcGFzc2VkLCB0aGUgY3VycmVudCB3aW5kb3cubG9jYXRpb24uaHJlZiBpcyB1c2VkLlxuICAvL1xuICAvLyBSZXR1cm5zOlxuICAvL1xuICAvLyAgKFN0cmluZykgVGhlIHBhcnNlZCBmcmFnbWVudCAoaGFzaCkgc3RyaW5nLCB3aXRoIGFueSBsZWFkaW5nIFwiI1wiIHJlbW92ZWQuXG5cbiAgLy8gTWV0aG9kOiBqUXVlcnkucGFyYW0uZnJhZ21lbnQgKGJ1aWxkIHVybClcbiAgLy9cbiAgLy8gTWVyZ2UgYSBVUkwsIHdpdGggb3Igd2l0aG91dCBwcmUtZXhpc3RpbmcgZnJhZ21lbnQgKGhhc2gpIHBhcmFtcywgcGx1cyBhbnlcbiAgLy8gb2JqZWN0LCBwYXJhbXMgc3RyaW5nIG9yIFVSTCBjb250YWluaW5nIGZyYWdtZW50IChoYXNoKSBwYXJhbXMgaW50byBhIG5ld1xuICAvLyBVUkwuXG4gIC8vXG4gIC8vIFVzYWdlOlxuICAvL1xuICAvLyA+IGpRdWVyeS5wYXJhbS5mcmFnbWVudCggdXJsLCBwYXJhbXMgWywgbWVyZ2VfbW9kZSBdICk7XG4gIC8vXG4gIC8vIEFyZ3VtZW50czpcbiAgLy9cbiAgLy8gIHVybCAtIChTdHJpbmcpIEEgdmFsaWQgVVJMIGZvciBwYXJhbXMgdG8gYmUgbWVyZ2VkIGludG8uIFRoaXMgVVJMIG1heVxuICAvLyAgICBjb250YWluIGEgcXVlcnkgc3RyaW5nIGFuZC9vciBmcmFnbWVudCAoaGFzaCkuXG4gIC8vICBwYXJhbXMgLSAoU3RyaW5nKSBBIHBhcmFtcyBzdHJpbmcgb3IgVVJMIGNvbnRhaW5pbmcgZnJhZ21lbnQgKGhhc2gpIHBhcmFtc1xuICAvLyAgICB0byBiZSBtZXJnZWQgaW50byB1cmwuXG4gIC8vICBwYXJhbXMgLSAoT2JqZWN0KSBBIHBhcmFtcyBvYmplY3QgdG8gYmUgbWVyZ2VkIGludG8gdXJsLlxuICAvLyAgbWVyZ2VfbW9kZSAtIChOdW1iZXIpIE1lcmdlIGJlaGF2aW9yIGRlZmF1bHRzIHRvIDAgaWYgbWVyZ2VfbW9kZSBpcyBub3RcbiAgLy8gICAgc3BlY2lmaWVkLCBhbmQgaXMgYXMtZm9sbG93czpcbiAgLy9cbiAgLy8gICAgKiAwOiBwYXJhbXMgaW4gdGhlIHBhcmFtcyBhcmd1bWVudCB3aWxsIG92ZXJyaWRlIGFueSBmcmFnbWVudCAoaGFzaClcbiAgLy8gICAgICAgICBwYXJhbXMgaW4gdXJsLlxuICAvLyAgICAqIDE6IGFueSBmcmFnbWVudCAoaGFzaCkgcGFyYW1zIGluIHVybCB3aWxsIG92ZXJyaWRlIHBhcmFtcyBpbiB0aGVcbiAgLy8gICAgICAgICBwYXJhbXMgYXJndW1lbnQuXG4gIC8vICAgICogMjogcGFyYW1zIGFyZ3VtZW50IHdpbGwgY29tcGxldGVseSByZXBsYWNlIGFueSBxdWVyeSBzdHJpbmcgaW4gdXJsLlxuICAvL1xuICAvLyBSZXR1cm5zOlxuICAvL1xuICAvLyAgKFN0cmluZykgQSBVUkwgd2l0aCBhIHVybGVuY29kZWQgZnJhZ21lbnQgKGhhc2gpIGluIHRoZSBmb3JtYXQgJyNhPWImYz1kJmU9ZicuXG5cbiAgZnVuY3Rpb24ganFfcGFyYW1fc3ViKCBpc19mcmFnbWVudCwgZ2V0X2Z1bmMsIHVybCwgcGFyYW1zLCBtZXJnZV9tb2RlICkge1xuICAgIHZhciByZXN1bHQsXG4gICAgICBxcyxcbiAgICAgIG1hdGNoZXMsXG4gICAgICB1cmxfcGFyYW1zLFxuICAgICAgaGFzaDtcblxuICAgIGlmICggcGFyYW1zICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAvLyBCdWlsZCBVUkwgYnkgbWVyZ2luZyBwYXJhbXMgaW50byB1cmwgc3RyaW5nLlxuXG4gICAgICAvLyBtYXRjaGVzWzFdID0gdXJsIHBhcnQgdGhhdCBwcmVjZWRlcyBwYXJhbXMsIG5vdCBpbmNsdWRpbmcgdHJhaWxpbmcgPy8jXG4gICAgICAvLyBtYXRjaGVzWzJdID0gcGFyYW1zLCBub3QgaW5jbHVkaW5nIGxlYWRpbmcgPy8jXG4gICAgICAvLyBtYXRjaGVzWzNdID0gaWYgaW4gJ3F1ZXJ5c3RyaW5nJyBtb2RlLCBoYXNoIGluY2x1ZGluZyBsZWFkaW5nICMsIG90aGVyd2lzZSAnJ1xuICAgICAgbWF0Y2hlcyA9IHVybC5tYXRjaCggaXNfZnJhZ21lbnQgPyByZV9mcmFnbWVudCA6IC9eKFteIz9dKilcXD8/KFteI10qKSgjPy4qKS8gKTtcblxuICAgICAgLy8gR2V0IHRoZSBoYXNoIGlmIGluICdxdWVyeXN0cmluZycgbW9kZSwgYW5kIGl0IGV4aXN0cy5cbiAgICAgIGhhc2ggPSBtYXRjaGVzWzNdIHx8ICcnO1xuXG4gICAgICBpZiAoIG1lcmdlX21vZGUgPT09IDIgJiYgaXNfc3RyaW5nKCBwYXJhbXMgKSApIHtcbiAgICAgICAgLy8gSWYgbWVyZ2VfbW9kZSBpcyAyIGFuZCBwYXJhbXMgaXMgYSBzdHJpbmcsIG1lcmdlIHRoZSBmcmFnbWVudCAvIHF1ZXJ5XG4gICAgICAgIC8vIHN0cmluZyBpbnRvIHRoZSBVUkwgd2hvbGVzYWxlLCB3aXRob3V0IGNvbnZlcnRpbmcgaXQgaW50byBhbiBvYmplY3QuXG4gICAgICAgIHFzID0gcGFyYW1zLnJlcGxhY2UoIGlzX2ZyYWdtZW50ID8gcmVfcGFyYW1zX2ZyYWdtZW50IDogcmVfcGFyYW1zX3F1ZXJ5c3RyaW5nLCAnJyApO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDb252ZXJ0IHJlbGV2YW50IHBhcmFtcyBpbiB1cmwgdG8gb2JqZWN0LlxuICAgICAgICB1cmxfcGFyYW1zID0ganFfZGVwYXJhbSggbWF0Y2hlc1syXSApO1xuXG4gICAgICAgIHBhcmFtcyA9IGlzX3N0cmluZyggcGFyYW1zIClcblxuICAgICAgICAgIC8vIENvbnZlcnQgcGFzc2VkIHBhcmFtcyBzdHJpbmcgaW50byBvYmplY3QuXG4gICAgICAgICAgPyBqcV9kZXBhcmFtWyBpc19mcmFnbWVudCA/IHN0cl9mcmFnbWVudCA6IHN0cl9xdWVyeXN0cmluZyBdKCBwYXJhbXMgKVxuXG4gICAgICAgICAgLy8gUGFzc2VkIHBhcmFtcyBvYmplY3QuXG4gICAgICAgICAgOiBwYXJhbXM7XG5cbiAgICAgICAgcXMgPSBtZXJnZV9tb2RlID09PSAyID8gcGFyYW1zICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGFzc2VkIHBhcmFtcyByZXBsYWNlIHVybCBwYXJhbXNcbiAgICAgICAgICA6IG1lcmdlX21vZGUgPT09IDEgID8gJC5leHRlbmQoIHt9LCBwYXJhbXMsIHVybF9wYXJhbXMgKSAgLy8gdXJsIHBhcmFtcyBvdmVycmlkZSBwYXNzZWQgcGFyYW1zXG4gICAgICAgICAgOiAkLmV4dGVuZCgge30sIHVybF9wYXJhbXMsIHBhcmFtcyApOyAgICAgICAgICAgICAgICAgICAgIC8vIHBhc3NlZCBwYXJhbXMgb3ZlcnJpZGUgdXJsIHBhcmFtc1xuXG4gICAgICAgIC8vIENvbnZlcnQgcGFyYW1zIG9iamVjdCBpbnRvIGEgc29ydGVkIHBhcmFtcyBzdHJpbmcuXG4gICAgICAgIHFzID0ganFfcGFyYW1fc29ydGVkKCBxcyApO1xuXG4gICAgICAgIC8vIFVuZXNjYXBlIGNoYXJhY3RlcnMgc3BlY2lmaWVkIHZpYSAkLnBhcmFtLm5vRXNjYXBlLiBTaW5jZSBvbmx5IGhhc2gtXG4gICAgICAgIC8vIGhpc3RvcnkgdXNlcnMgaGF2ZSByZXF1ZXN0ZWQgdGhpcyBmZWF0dXJlLCBpdCdzIG9ubHkgZW5hYmxlZCBmb3JcbiAgICAgICAgLy8gZnJhZ21lbnQtcmVsYXRlZCBwYXJhbXMgc3RyaW5ncy5cbiAgICAgICAgaWYgKCBpc19mcmFnbWVudCApIHtcbiAgICAgICAgICBxcyA9IHFzLnJlcGxhY2UoIHJlX25vX2VzY2FwZSwgZGVjb2RlICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQnVpbGQgVVJMIGZyb20gdGhlIGJhc2UgdXJsLCBxdWVyeXN0cmluZyBhbmQgaGFzaC4gSW4gJ3F1ZXJ5c3RyaW5nJ1xuICAgICAgLy8gbW9kZSwgPyBpcyBvbmx5IGFkZGVkIGlmIGEgcXVlcnkgc3RyaW5nIGV4aXN0cy4gSW4gJ2ZyYWdtZW50JyBtb2RlLCAjXG4gICAgICAvLyBpcyBhbHdheXMgYWRkZWQuXG4gICAgICByZXN1bHQgPSBtYXRjaGVzWzFdICsgKCBpc19mcmFnbWVudCA/IGZyYWdtZW50X3ByZWZpeCA6IHFzIHx8ICFtYXRjaGVzWzFdID8gJz8nIDogJycgKSArIHFzICsgaGFzaDtcblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBVUkwgd2FzIHBhc3NlZCBpbiwgcGFyc2UgcGFyYW1zIGZyb20gVVJMIHN0cmluZywgb3RoZXJ3aXNlIHBhcnNlXG4gICAgICAvLyBwYXJhbXMgZnJvbSB3aW5kb3cubG9jYXRpb24uaHJlZi5cbiAgICAgIHJlc3VsdCA9IGdldF9mdW5jKCB1cmwgIT09IHVuZGVmaW5lZCA/IHVybCA6IGxvY2F0aW9uLmhyZWYgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIGpxX3BhcmFtWyBzdHJfcXVlcnlzdHJpbmcgXSAgICAgICAgICAgICAgICAgID0gY3VycnkoIGpxX3BhcmFtX3N1YiwgMCwgZ2V0X3F1ZXJ5c3RyaW5nICk7XG4gIGpxX3BhcmFtWyBzdHJfZnJhZ21lbnQgXSA9IGpxX3BhcmFtX2ZyYWdtZW50ID0gY3VycnkoIGpxX3BhcmFtX3N1YiwgMSwgZ2V0X2ZyYWdtZW50ICk7XG5cbiAgLy8gTWV0aG9kOiBqUXVlcnkucGFyYW0uc29ydGVkXG4gIC8vXG4gIC8vIFJldHVybnMgYSBwYXJhbXMgc3RyaW5nIGVxdWl2YWxlbnQgdG8gdGhhdCByZXR1cm5lZCBieSB0aGUgaW50ZXJuYWxcbiAgLy8galF1ZXJ5LnBhcmFtIG1ldGhvZCwgYnV0IHNvcnRlZCwgd2hpY2ggbWFrZXMgaXQgc3VpdGFibGUgZm9yIHVzZSBhcyBhXG4gIC8vIGNhY2hlIGtleS5cbiAgLy9cbiAgLy8gRm9yIGV4YW1wbGUsIGluIG1vc3QgYnJvd3NlcnMgalF1ZXJ5LnBhcmFtKHt6OjEsYToyfSkgcmV0dXJucyBcIno9MSZhPTJcIlxuICAvLyBhbmQgalF1ZXJ5LnBhcmFtKHthOjIsejoxfSkgcmV0dXJucyBcImE9MiZ6PTFcIi4gRXZlbiB0aG91Z2ggYm90aCB0aGVcbiAgLy8gb2JqZWN0cyBiZWluZyBzZXJpYWxpemVkIGFuZCB0aGUgcmVzdWx0aW5nIHBhcmFtcyBzdHJpbmdzIGFyZSBlcXVpdmFsZW50LFxuICAvLyBpZiB0aGVzZSBwYXJhbXMgc3RyaW5ncyB3ZXJlIHNldCBpbnRvIHRoZSBsb2NhdGlvbi5oYXNoIGZyYWdtZW50XG4gIC8vIHNlcXVlbnRpYWxseSwgdGhlIGhhc2hjaGFuZ2UgZXZlbnQgd291bGQgYmUgdHJpZ2dlcmVkIHVubmVjZXNzYXJpbHksIHNpbmNlXG4gIC8vIHRoZSBzdHJpbmdzIGFyZSBkaWZmZXJlbnQgKGV2ZW4gdGhvdWdoIHRoZSBkYXRhIGRlc2NyaWJlZCBieSB0aGVtIGlzIHRoZVxuICAvLyBzYW1lKS4gQnkgc29ydGluZyB0aGUgcGFyYW1zIHN0cmluZywgdW5lY2Vzc2FyeSBoYXNoY2hhbmdlIGV2ZW50IHRyaWdnZXJpbmdcbiAgLy8gY2FuIGJlIGF2b2lkZWQuXG4gIC8vXG4gIC8vIFVzYWdlOlxuICAvL1xuICAvLyA+IGpRdWVyeS5wYXJhbS5zb3J0ZWQoIG9iaiBbLCB0cmFkaXRpb25hbCBdICk7XG4gIC8vXG4gIC8vIEFyZ3VtZW50czpcbiAgLy9cbiAgLy8gIG9iaiAtIChPYmplY3QpIEFuIG9iamVjdCB0byBiZSBzZXJpYWxpemVkLlxuICAvLyAgdHJhZGl0aW9uYWwgLSAoQm9vbGVhbikgUGFyYW1zIGRlZXAvc2hhbGxvdyBzZXJpYWxpemF0aW9uIG1vZGUuIFNlZSB0aGVcbiAgLy8gICAgZG9jdW1lbnRhdGlvbiBhdCBodHRwOi8vYXBpLmpxdWVyeS5jb20valF1ZXJ5LnBhcmFtLyBmb3IgbW9yZSBkZXRhaWwuXG4gIC8vXG4gIC8vIFJldHVybnM6XG4gIC8vXG4gIC8vICAoU3RyaW5nKSBBIHNvcnRlZCBwYXJhbXMgc3RyaW5nLlxuXG4gIGpxX3BhcmFtLnNvcnRlZCA9IGpxX3BhcmFtX3NvcnRlZCA9IGZ1bmN0aW9uKCBhLCB0cmFkaXRpb25hbCApIHtcbiAgICB2YXIgYXJyID0gW10sXG4gICAgICBvYmogPSB7fTtcblxuICAgICQuZWFjaCgganFfcGFyYW0oIGEsIHRyYWRpdGlvbmFsICkuc3BsaXQoICcmJyApLCBmdW5jdGlvbihpLHYpe1xuICAgICAgdmFyIGtleSA9IHYucmVwbGFjZSggLyg/OiU1Qnw9KS4qJC8sICcnICksXG4gICAgICAgIGtleV9vYmogPSBvYmpbIGtleSBdO1xuXG4gICAgICBpZiAoICFrZXlfb2JqICkge1xuICAgICAgICBrZXlfb2JqID0gb2JqWyBrZXkgXSA9IFtdO1xuICAgICAgICBhcnIucHVzaCgga2V5ICk7XG4gICAgICB9XG5cbiAgICAgIGtleV9vYmoucHVzaCggdiApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuICQubWFwKCBhcnIuc29ydCgpLCBmdW5jdGlvbih2KXtcbiAgICAgIHJldHVybiBvYmpbIHYgXTtcbiAgICB9KS5qb2luKCAnJicgKTtcbiAgfTtcblxuICAvLyBNZXRob2Q6IGpRdWVyeS5wYXJhbS5mcmFnbWVudC5ub0VzY2FwZVxuICAvL1xuICAvLyBTcGVjaWZ5IGNoYXJhY3RlcnMgdGhhdCB3aWxsIGJlIGxlZnQgdW5lc2NhcGVkIHdoZW4gZnJhZ21lbnRzIGFyZSBjcmVhdGVkXG4gIC8vIG9yIG1lcmdlZCB1c2luZyA8alF1ZXJ5LnBhcmFtLmZyYWdtZW50Piwgb3Igd2hlbiB0aGUgZnJhZ21lbnQgaXMgbW9kaWZpZWRcbiAgLy8gdXNpbmcgPGpRdWVyeS5iYnEucHVzaFN0YXRlPi4gVGhpcyBvcHRpb24gb25seSBhcHBsaWVzIHRvIHNlcmlhbGl6ZWQgZGF0YVxuICAvLyBvYmplY3QgZnJhZ21lbnRzLCBhbmQgbm90IHNldC1hcy1zdHJpbmcgZnJhZ21lbnRzLiBEb2VzIG5vdCBhZmZlY3QgdGhlXG4gIC8vIHF1ZXJ5IHN0cmluZy4gRGVmYXVsdHMgdG8gXCIsL1wiIChjb21tYSwgZm9yd2FyZCBzbGFzaCkuXG4gIC8vXG4gIC8vIE5vdGUgdGhhdCB0aGlzIGlzIGNvbnNpZGVyZWQgYSBwdXJlbHkgYWVzdGhldGljIG9wdGlvbiwgYW5kIHdpbGwgaGVscCB0b1xuICAvLyBjcmVhdGUgVVJMcyB0aGF0IFwibG9vayBwcmV0dHlcIiBpbiB0aGUgYWRkcmVzcyBiYXIgb3IgYm9va21hcmtzLCB3aXRob3V0XG4gIC8vIGFmZmVjdGluZyBmdW5jdGlvbmFsaXR5IGluIGFueSB3YXkuIFRoYXQgYmVpbmcgc2FpZCwgYmUgY2FyZWZ1bCB0byBub3RcbiAgLy8gdW5lc2NhcGUgY2hhcmFjdGVycyB0aGF0IGFyZSB1c2VkIGFzIGRlbGltaXRlcnMgb3Igc2VydmUgYSBzcGVjaWFsXG4gIC8vIHB1cnBvc2UsIHN1Y2ggYXMgdGhlIFwiIz8mPStcIiAob2N0b3Rob3JwZSwgcXVlc3Rpb24gbWFyaywgYW1wZXJzYW5kLFxuICAvLyBlcXVhbHMsIHBsdXMpIGNoYXJhY3RlcnMuXG4gIC8vXG4gIC8vIFVzYWdlOlxuICAvL1xuICAvLyA+IGpRdWVyeS5wYXJhbS5mcmFnbWVudC5ub0VzY2FwZSggWyBjaGFycyBdICk7XG4gIC8vXG4gIC8vIEFyZ3VtZW50czpcbiAgLy9cbiAgLy8gIGNoYXJzIC0gKFN0cmluZykgVGhlIGNoYXJhY3RlcnMgdG8gbm90IGVzY2FwZSBpbiB0aGUgZnJhZ21lbnQuIElmXG4gIC8vICAgIHVuc3BlY2lmaWVkLCBkZWZhdWx0cyB0byBlbXB0eSBzdHJpbmcgKGVzY2FwZSBhbGwgY2hhcmFjdGVycykuXG4gIC8vXG4gIC8vIFJldHVybnM6XG4gIC8vXG4gIC8vICBOb3RoaW5nLlxuXG4gIGpxX3BhcmFtX2ZyYWdtZW50Lm5vRXNjYXBlID0gZnVuY3Rpb24oIGNoYXJzICkge1xuICAgIGNoYXJzID0gY2hhcnMgfHwgJyc7XG4gICAgdmFyIGFyciA9ICQubWFwKCBjaGFycy5zcGxpdCgnJyksIGVuY29kZVVSSUNvbXBvbmVudCApO1xuICAgIHJlX25vX2VzY2FwZSA9IG5ldyBSZWdFeHAoIGFyci5qb2luKCd8JyksICdnJyApO1xuICB9O1xuXG4gIC8vIEEgc2Vuc2libGUgZGVmYXVsdC4gVGhlc2UgYXJlIHRoZSBjaGFyYWN0ZXJzIHBlb3BsZSBzZWVtIHRvIGNvbXBsYWluIGFib3V0XG4gIC8vIFwidWdsaWZ5aW5nIHVwIHRoZSBVUkxcIiB0aGUgbW9zdC5cbiAganFfcGFyYW1fZnJhZ21lbnQubm9Fc2NhcGUoICcsLycgKTtcblxuICAvLyBNZXRob2Q6IGpRdWVyeS5wYXJhbS5mcmFnbWVudC5hamF4Q3Jhd2xhYmxlXG4gIC8vXG4gIC8vIFRPRE86IERFU0NSSUJFXG4gIC8vXG4gIC8vIFVzYWdlOlxuICAvL1xuICAvLyA+IGpRdWVyeS5wYXJhbS5mcmFnbWVudC5hamF4Q3Jhd2xhYmxlKCBbIHN0YXRlIF0gKTtcbiAgLy9cbiAgLy8gQXJndW1lbnRzOlxuICAvL1xuICAvLyAgc3RhdGUgLSAoQm9vbGVhbikgVE9ETzogREVTQ1JJQkVcbiAgLy9cbiAgLy8gUmV0dXJuczpcbiAgLy9cbiAgLy8gIChCb29sZWFuKSBUaGUgY3VycmVudCBhamF4Q3Jhd2xhYmxlIHN0YXRlLlxuXG4gIGpxX3BhcmFtX2ZyYWdtZW50LmFqYXhDcmF3bGFibGUgPSBmdW5jdGlvbiggc3RhdGUgKSB7XG4gICAgaWYgKCBzdGF0ZSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgaWYgKCBzdGF0ZSApIHtcbiAgICAgICAgcmVfcGFyYW1zX2ZyYWdtZW50ID0gL14uKig/OiMhfCMpLztcbiAgICAgICAgcmVfZnJhZ21lbnQgPSAvXihbXiNdKikoPzojIXwjKT8oLiopJC87XG4gICAgICAgIGZyYWdtZW50X3ByZWZpeCA9ICcjISc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZV9wYXJhbXNfZnJhZ21lbnQgPSAvXi4qIy87XG4gICAgICAgIHJlX2ZyYWdtZW50ID0gL14oW14jXSopIz8oLiopJC87XG4gICAgICAgIGZyYWdtZW50X3ByZWZpeCA9ICcjJztcbiAgICAgIH1cbiAgICAgIGFqYXhfY3Jhd2xhYmxlID0gISFzdGF0ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWpheF9jcmF3bGFibGU7XG4gIH07XG5cbiAganFfcGFyYW1fZnJhZ21lbnQuYWpheENyYXdsYWJsZSggMCApO1xuXG4gIC8vIFNlY3Rpb246IERlcGFyYW0gKGZyb20gc3RyaW5nKVxuICAvL1xuICAvLyBNZXRob2Q6IGpRdWVyeS5kZXBhcmFtXG4gIC8vXG4gIC8vIERlc2VyaWFsaXplIGEgcGFyYW1zIHN0cmluZyBpbnRvIGFuIG9iamVjdCwgb3B0aW9uYWxseSBjb2VyY2luZyBudW1iZXJzLFxuICAvLyBib29sZWFucywgbnVsbCBhbmQgdW5kZWZpbmVkIHZhbHVlczsgdGhpcyBtZXRob2QgaXMgdGhlIGNvdW50ZXJwYXJ0IHRvIHRoZVxuICAvLyBpbnRlcm5hbCBqUXVlcnkucGFyYW0gbWV0aG9kLlxuICAvL1xuICAvLyBVc2FnZTpcbiAgLy9cbiAgLy8gPiBqUXVlcnkuZGVwYXJhbSggcGFyYW1zIFssIGNvZXJjZSBdICk7XG4gIC8vXG4gIC8vIEFyZ3VtZW50czpcbiAgLy9cbiAgLy8gIHBhcmFtcyAtIChTdHJpbmcpIEEgcGFyYW1zIHN0cmluZyB0byBiZSBwYXJzZWQuXG4gIC8vICBjb2VyY2UgLSAoQm9vbGVhbikgSWYgdHJ1ZSwgY29lcmNlcyBhbnkgbnVtYmVycyBvciB0cnVlLCBmYWxzZSwgbnVsbCwgYW5kXG4gIC8vICAgIHVuZGVmaW5lZCB0byB0aGVpciBhY3R1YWwgdmFsdWUuIERlZmF1bHRzIHRvIGZhbHNlIGlmIG9taXR0ZWQuXG4gIC8vXG4gIC8vIFJldHVybnM6XG4gIC8vXG4gIC8vICAoT2JqZWN0KSBBbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBkZXNlcmlhbGl6ZWQgcGFyYW1zIHN0cmluZy5cblxuICAkLmRlcGFyYW0gPSBqcV9kZXBhcmFtID0gZnVuY3Rpb24oIHBhcmFtcywgY29lcmNlICkge1xuICAgIHZhciBvYmogPSB7fSxcbiAgICAgIGNvZXJjZV90eXBlcyA9IHsgJ3RydWUnOiAhMCwgJ2ZhbHNlJzogITEsICdudWxsJzogbnVsbCB9O1xuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBuYW1lPXZhbHVlIHBhaXJzLlxuICAgICQuZWFjaCggcGFyYW1zLnJlcGxhY2UoIC9cXCsvZywgJyAnICkuc3BsaXQoICcmJyApLCBmdW5jdGlvbihqLHYpe1xuICAgICAgdmFyIHBhcmFtID0gdi5zcGxpdCggJz0nICksXG4gICAgICAgIGtleSA9IGRlY29kZSggcGFyYW1bMF0gKSxcbiAgICAgICAgdmFsLFxuICAgICAgICBjdXIgPSBvYmosXG4gICAgICAgIGkgPSAwLFxuXG4gICAgICAgIC8vIElmIGtleSBpcyBtb3JlIGNvbXBsZXggdGhhbiAnZm9vJywgbGlrZSAnYVtdJyBvciAnYVtiXVtjXScsIHNwbGl0IGl0XG4gICAgICAgIC8vIGludG8gaXRzIGNvbXBvbmVudCBwYXJ0cy5cbiAgICAgICAga2V5cyA9IGtleS5zcGxpdCggJ11bJyApLFxuICAgICAgICBrZXlzX2xhc3QgPSBrZXlzLmxlbmd0aCAtIDE7XG5cbiAgICAgIC8vIElmIHRoZSBmaXJzdCBrZXlzIHBhcnQgY29udGFpbnMgWyBhbmQgdGhlIGxhc3QgZW5kcyB3aXRoIF0sIHRoZW4gW11cbiAgICAgIC8vIGFyZSBjb3JyZWN0bHkgYmFsYW5jZWQuXG4gICAgICBpZiAoIC9cXFsvLnRlc3QoIGtleXNbMF0gKSAmJiAvXFxdJC8udGVzdCgga2V5c1sga2V5c19sYXN0IF0gKSApIHtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSB0cmFpbGluZyBdIGZyb20gdGhlIGxhc3Qga2V5cyBwYXJ0LlxuICAgICAgICBrZXlzWyBrZXlzX2xhc3QgXSA9IGtleXNbIGtleXNfbGFzdCBdLnJlcGxhY2UoIC9cXF0kLywgJycgKTtcblxuICAgICAgICAvLyBTcGxpdCBmaXJzdCBrZXlzIHBhcnQgaW50byB0d28gcGFydHMgb24gdGhlIFsgYW5kIGFkZCB0aGVtIGJhY2sgb250b1xuICAgICAgICAvLyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBrZXlzIGFycmF5LlxuICAgICAgICBrZXlzID0ga2V5cy5zaGlmdCgpLnNwbGl0KCdbJykuY29uY2F0KCBrZXlzICk7XG5cbiAgICAgICAga2V5c19sYXN0ID0ga2V5cy5sZW5ndGggLSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQmFzaWMgJ2Zvbycgc3R5bGUga2V5LlxuICAgICAgICBrZXlzX2xhc3QgPSAwO1xuICAgICAgfVxuXG4gICAgICAvLyBBcmUgd2UgZGVhbGluZyB3aXRoIGEgbmFtZT12YWx1ZSBwYWlyLCBvciBqdXN0IGEgbmFtZT9cbiAgICAgIGlmICggcGFyYW0ubGVuZ3RoID09PSAyICkge1xuICAgICAgICB2YWwgPSBkZWNvZGUoIHBhcmFtWzFdICk7XG5cbiAgICAgICAgLy8gQ29lcmNlIHZhbHVlcy5cbiAgICAgICAgaWYgKCBjb2VyY2UgKSB7XG4gICAgICAgICAgdmFsID0gdmFsICYmICFpc05hTih2YWwpICAgICAgICAgICAgPyArdmFsICAgICAgICAgICAgICAvLyBudW1iZXJcbiAgICAgICAgICAgIDogdmFsID09PSAndW5kZWZpbmVkJyAgICAgICAgICAgICA/IHVuZGVmaW5lZCAgICAgICAgIC8vIHVuZGVmaW5lZFxuICAgICAgICAgICAgOiBjb2VyY2VfdHlwZXNbdmFsXSAhPT0gdW5kZWZpbmVkID8gY29lcmNlX3R5cGVzW3ZhbF0gLy8gdHJ1ZSwgZmFsc2UsIG51bGxcbiAgICAgICAgICAgIDogdmFsOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0cmluZ1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBrZXlzX2xhc3QgKSB7XG4gICAgICAgICAgLy8gQ29tcGxleCBrZXksIGJ1aWxkIGRlZXAgb2JqZWN0IHN0cnVjdHVyZSBiYXNlZCBvbiBhIGZldyBydWxlczpcbiAgICAgICAgICAvLyAqIFRoZSAnY3VyJyBwb2ludGVyIHN0YXJ0cyBhdCB0aGUgb2JqZWN0IHRvcC1sZXZlbC5cbiAgICAgICAgICAvLyAqIFtdID0gYXJyYXkgcHVzaCAobiBpcyBzZXQgdG8gYXJyYXkgbGVuZ3RoKSwgW25dID0gYXJyYXkgaWYgbiBpc1xuICAgICAgICAgIC8vICAgbnVtZXJpYywgb3RoZXJ3aXNlIG9iamVjdC5cbiAgICAgICAgICAvLyAqIElmIGF0IHRoZSBsYXN0IGtleXMgcGFydCwgc2V0IHRoZSB2YWx1ZS5cbiAgICAgICAgICAvLyAqIEZvciBlYWNoIGtleXMgcGFydCwgaWYgdGhlIGN1cnJlbnQgbGV2ZWwgaXMgdW5kZWZpbmVkIGNyZWF0ZSBhblxuICAgICAgICAgIC8vICAgb2JqZWN0IG9yIGFycmF5IGJhc2VkIG9uIHRoZSB0eXBlIG9mIHRoZSBuZXh0IGtleXMgcGFydC5cbiAgICAgICAgICAvLyAqIE1vdmUgdGhlICdjdXInIHBvaW50ZXIgdG8gdGhlIG5leHQgbGV2ZWwuXG4gICAgICAgICAgLy8gKiBSaW5zZSAmIHJlcGVhdC5cbiAgICAgICAgICBmb3IgKCA7IGkgPD0ga2V5c19sYXN0OyBpKysgKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXlzW2ldID09PSAnJyA/IGN1ci5sZW5ndGggOiBrZXlzW2ldO1xuICAgICAgICAgICAgY3VyID0gY3VyW2tleV0gPSBpIDwga2V5c19sYXN0XG4gICAgICAgICAgICAgID8gY3VyW2tleV0gfHwgKCBrZXlzW2krMV0gJiYgaXNOYU4oIGtleXNbaSsxXSApID8ge30gOiBbXSApXG4gICAgICAgICAgICAgIDogdmFsO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFNpbXBsZSBrZXksIGV2ZW4gc2ltcGxlciBydWxlcywgc2luY2Ugb25seSBzY2FsYXJzIGFuZCBzaGFsbG93XG4gICAgICAgICAgLy8gYXJyYXlzIGFyZSBhbGxvd2VkLlxuXG4gICAgICAgICAgaWYgKCAkLmlzQXJyYXkoIG9ialtrZXldICkgKSB7XG4gICAgICAgICAgICAvLyB2YWwgaXMgYWxyZWFkeSBhbiBhcnJheSwgc28gcHVzaCBvbiB0aGUgbmV4dCB2YWx1ZS5cbiAgICAgICAgICAgIG9ialtrZXldLnB1c2goIHZhbCApO1xuXG4gICAgICAgICAgfSBlbHNlIGlmICggb2JqW2tleV0gIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgIC8vIHZhbCBpc24ndCBhbiBhcnJheSwgYnV0IHNpbmNlIGEgc2Vjb25kIHZhbHVlIGhhcyBiZWVuIHNwZWNpZmllZCxcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgdmFsIGludG8gYW4gYXJyYXkuXG4gICAgICAgICAgICBvYmpba2V5XSA9IFsgb2JqW2tleV0sIHZhbCBdO1xuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHZhbCBpcyBhIHNjYWxhci5cbiAgICAgICAgICAgIG9ialtrZXldID0gdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYgKCBrZXkgKSB7XG4gICAgICAgIC8vIE5vIHZhbHVlIHdhcyBkZWZpbmVkLCBzbyBzZXQgc29tZXRoaW5nIG1lYW5pbmdmdWwuXG4gICAgICAgIG9ialtrZXldID0gY29lcmNlXG4gICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICA6ICcnO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBNZXRob2Q6IGpRdWVyeS5kZXBhcmFtLnF1ZXJ5c3RyaW5nXG4gIC8vXG4gIC8vIFBhcnNlIHRoZSBxdWVyeSBzdHJpbmcgZnJvbSBhIFVSTCBvciB0aGUgY3VycmVudCB3aW5kb3cubG9jYXRpb24uaHJlZixcbiAgLy8gZGVzZXJpYWxpemluZyBpdCBpbnRvIGFuIG9iamVjdCwgb3B0aW9uYWxseSBjb2VyY2luZyBudW1iZXJzLCBib29sZWFucyxcbiAgLy8gbnVsbCBhbmQgdW5kZWZpbmVkIHZhbHVlcy5cbiAgLy9cbiAgLy8gVXNhZ2U6XG4gIC8vXG4gIC8vID4galF1ZXJ5LmRlcGFyYW0ucXVlcnlzdHJpbmcoIFsgdXJsIF0gWywgY29lcmNlIF0gKTtcbiAgLy9cbiAgLy8gQXJndW1lbnRzOlxuICAvL1xuICAvLyAgdXJsIC0gKFN0cmluZykgQW4gb3B0aW9uYWwgcGFyYW1zIHN0cmluZyBvciBVUkwgY29udGFpbmluZyBxdWVyeSBzdHJpbmdcbiAgLy8gICAgcGFyYW1zIHRvIGJlIHBhcnNlZC4gSWYgdXJsIGlzIG9taXR0ZWQsIHRoZSBjdXJyZW50XG4gIC8vICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmIGlzIHVzZWQuXG4gIC8vICBjb2VyY2UgLSAoQm9vbGVhbikgSWYgdHJ1ZSwgY29lcmNlcyBhbnkgbnVtYmVycyBvciB0cnVlLCBmYWxzZSwgbnVsbCwgYW5kXG4gIC8vICAgIHVuZGVmaW5lZCB0byB0aGVpciBhY3R1YWwgdmFsdWUuIERlZmF1bHRzIHRvIGZhbHNlIGlmIG9taXR0ZWQuXG4gIC8vXG4gIC8vIFJldHVybnM6XG4gIC8vXG4gIC8vICAoT2JqZWN0KSBBbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBkZXNlcmlhbGl6ZWQgcGFyYW1zIHN0cmluZy5cblxuICAvLyBNZXRob2Q6IGpRdWVyeS5kZXBhcmFtLmZyYWdtZW50XG4gIC8vXG4gIC8vIFBhcnNlIHRoZSBmcmFnbWVudCAoaGFzaCkgZnJvbSBhIFVSTCBvciB0aGUgY3VycmVudCB3aW5kb3cubG9jYXRpb24uaHJlZixcbiAgLy8gZGVzZXJpYWxpemluZyBpdCBpbnRvIGFuIG9iamVjdCwgb3B0aW9uYWxseSBjb2VyY2luZyBudW1iZXJzLCBib29sZWFucyxcbiAgLy8gbnVsbCBhbmQgdW5kZWZpbmVkIHZhbHVlcy5cbiAgLy9cbiAgLy8gVXNhZ2U6XG4gIC8vXG4gIC8vID4galF1ZXJ5LmRlcGFyYW0uZnJhZ21lbnQoIFsgdXJsIF0gWywgY29lcmNlIF0gKTtcbiAgLy9cbiAgLy8gQXJndW1lbnRzOlxuICAvL1xuICAvLyAgdXJsIC0gKFN0cmluZykgQW4gb3B0aW9uYWwgcGFyYW1zIHN0cmluZyBvciBVUkwgY29udGFpbmluZyBmcmFnbWVudCAoaGFzaClcbiAgLy8gICAgcGFyYW1zIHRvIGJlIHBhcnNlZC4gSWYgdXJsIGlzIG9taXR0ZWQsIHRoZSBjdXJyZW50IHdpbmRvdy5sb2NhdGlvbi5ocmVmXG4gIC8vICAgIGlzIHVzZWQuXG4gIC8vICBjb2VyY2UgLSAoQm9vbGVhbikgSWYgdHJ1ZSwgY29lcmNlcyBhbnkgbnVtYmVycyBvciB0cnVlLCBmYWxzZSwgbnVsbCwgYW5kXG4gIC8vICAgIHVuZGVmaW5lZCB0byB0aGVpciBhY3R1YWwgdmFsdWUuIERlZmF1bHRzIHRvIGZhbHNlIGlmIG9taXR0ZWQuXG4gIC8vXG4gIC8vIFJldHVybnM6XG4gIC8vXG4gIC8vICAoT2JqZWN0KSBBbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBkZXNlcmlhbGl6ZWQgcGFyYW1zIHN0cmluZy5cblxuICBmdW5jdGlvbiBqcV9kZXBhcmFtX3N1YiggaXNfZnJhZ21lbnQsIHVybF9vcl9wYXJhbXMsIGNvZXJjZSApIHtcbiAgICBpZiAoIHVybF9vcl9wYXJhbXMgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdXJsX29yX3BhcmFtcyA9PT0gJ2Jvb2xlYW4nICkge1xuICAgICAgLy8gdXJsX29yX3BhcmFtcyBub3Qgc3BlY2lmaWVkLlxuICAgICAgY29lcmNlID0gdXJsX29yX3BhcmFtcztcbiAgICAgIHVybF9vcl9wYXJhbXMgPSBqcV9wYXJhbVsgaXNfZnJhZ21lbnQgPyBzdHJfZnJhZ21lbnQgOiBzdHJfcXVlcnlzdHJpbmcgXSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cmxfb3JfcGFyYW1zID0gaXNfc3RyaW5nKCB1cmxfb3JfcGFyYW1zIClcbiAgICAgICAgPyB1cmxfb3JfcGFyYW1zLnJlcGxhY2UoIGlzX2ZyYWdtZW50ID8gcmVfcGFyYW1zX2ZyYWdtZW50IDogcmVfcGFyYW1zX3F1ZXJ5c3RyaW5nLCAnJyApXG4gICAgICAgIDogdXJsX29yX3BhcmFtcztcbiAgICB9XG5cbiAgICByZXR1cm4ganFfZGVwYXJhbSggdXJsX29yX3BhcmFtcywgY29lcmNlICk7XG4gIH07XG5cbiAganFfZGVwYXJhbVsgc3RyX3F1ZXJ5c3RyaW5nIF0gICAgICAgICAgICAgICAgICAgID0gY3VycnkoIGpxX2RlcGFyYW1fc3ViLCAwICk7XG4gIGpxX2RlcGFyYW1bIHN0cl9mcmFnbWVudCBdID0ganFfZGVwYXJhbV9mcmFnbWVudCA9IGN1cnJ5KCBqcV9kZXBhcmFtX3N1YiwgMSApO1xuXG4gIC8vIFNlY3Rpb246IEVsZW1lbnQgbWFuaXB1bGF0aW9uXG4gIC8vXG4gIC8vIE1ldGhvZDogalF1ZXJ5LmVsZW1VcmxBdHRyXG4gIC8vXG4gIC8vIEdldCB0aGUgaW50ZXJuYWwgXCJEZWZhdWx0IFVSTCBhdHRyaWJ1dGUgcGVyIHRhZ1wiIGxpc3QsIG9yIGF1Z21lbnQgdGhlIGxpc3RcbiAgLy8gd2l0aCBhZGRpdGlvbmFsIHRhZy1hdHRyaWJ1dGUgcGFpcnMsIGluIGNhc2UgdGhlIGRlZmF1bHRzIGFyZSBpbnN1ZmZpY2llbnQuXG4gIC8vXG4gIC8vIEluIHRoZSA8alF1ZXJ5LmZuLnF1ZXJ5c3RyaW5nPiBhbmQgPGpRdWVyeS5mbi5mcmFnbWVudD4gbWV0aG9kcywgdGhpcyBsaXN0XG4gIC8vIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIGF0dHJpYnV0ZSBjb250YWlucyB0aGUgVVJMIHRvIGJlIG1vZGlmaWVkLCBpZlxuICAvLyBhbiBcImF0dHJcIiBwYXJhbSBpcyBub3Qgc3BlY2lmaWVkLlxuICAvL1xuICAvLyBEZWZhdWx0IFRhZy1BdHRyaWJ1dGUgTGlzdDpcbiAgLy9cbiAgLy8gIGEgICAgICAtIGhyZWZcbiAgLy8gIGJhc2UgICAtIGhyZWZcbiAgLy8gIGlmcmFtZSAtIHNyY1xuICAvLyAgaW1nICAgIC0gc3JjXG4gIC8vICBpbnB1dCAgLSBzcmNcbiAgLy8gIGZvcm0gICAtIGFjdGlvblxuICAvLyAgbGluayAgIC0gaHJlZlxuICAvLyAgc2NyaXB0IC0gc3JjXG4gIC8vXG4gIC8vIFVzYWdlOlxuICAvL1xuICAvLyA+IGpRdWVyeS5lbGVtVXJsQXR0ciggWyB0YWdfYXR0ciBdICk7XG4gIC8vXG4gIC8vIEFyZ3VtZW50czpcbiAgLy9cbiAgLy8gIHRhZ19hdHRyIC0gKE9iamVjdCkgQW4gb2JqZWN0IGNvbnRhaW5pbmcgYSBsaXN0IG9mIHRhZyBuYW1lcyBhbmQgdGhlaXJcbiAgLy8gICAgYXNzb2NpYXRlZCBkZWZhdWx0IGF0dHJpYnV0ZSBuYW1lcyBpbiB0aGUgZm9ybWF0IHsgdGFnOiAnYXR0cicsIC4uLiB9IHRvXG4gIC8vICAgIGJlIG1lcmdlZCBpbnRvIHRoZSBpbnRlcm5hbCB0YWctYXR0cmlidXRlIGxpc3QuXG4gIC8vXG4gIC8vIFJldHVybnM6XG4gIC8vXG4gIC8vICAoT2JqZWN0KSBBbiBvYmplY3QgY29udGFpbmluZyBhbGwgc3RvcmVkIHRhZy1hdHRyaWJ1dGUgdmFsdWVzLlxuXG4gIC8vIE9ubHkgZGVmaW5lIGZ1bmN0aW9uIGFuZCBzZXQgZGVmYXVsdHMgaWYgZnVuY3Rpb24gZG9lc24ndCBhbHJlYWR5IGV4aXN0LCBhc1xuICAvLyB0aGUgdXJsSW50ZXJuYWwgcGx1Z2luIHdpbGwgcHJvdmlkZSB0aGlzIG1ldGhvZCBhcyB3ZWxsLlxuICAkWyBzdHJfZWxlbVVybEF0dHIgXSB8fCAoJFsgc3RyX2VsZW1VcmxBdHRyIF0gPSBmdW5jdGlvbiggb2JqICkge1xuICAgIHJldHVybiAkLmV4dGVuZCggZWxlbVVybEF0dHJfY2FjaGUsIG9iaiApO1xuICB9KSh7XG4gICAgYTogc3RyX2hyZWYsXG4gICAgYmFzZTogc3RyX2hyZWYsXG4gICAgaWZyYW1lOiBzdHJfc3JjLFxuICAgIGltZzogc3RyX3NyYyxcbiAgICBpbnB1dDogc3RyX3NyYyxcbiAgICBmb3JtOiAnYWN0aW9uJyxcbiAgICBsaW5rOiBzdHJfaHJlZixcbiAgICBzY3JpcHQ6IHN0cl9zcmNcbiAgfSk7XG5cbiAganFfZWxlbVVybEF0dHIgPSAkWyBzdHJfZWxlbVVybEF0dHIgXTtcblxuICAvLyBNZXRob2Q6IGpRdWVyeS5mbi5xdWVyeXN0cmluZ1xuICAvL1xuICAvLyBVcGRhdGUgVVJMIGF0dHJpYnV0ZSBpbiBvbmUgb3IgbW9yZSBlbGVtZW50cywgbWVyZ2luZyB0aGUgY3VycmVudCBVUkwgKHdpdGhcbiAgLy8gb3Igd2l0aG91dCBwcmUtZXhpc3RpbmcgcXVlcnkgc3RyaW5nIHBhcmFtcykgcGx1cyBhbnkgcGFyYW1zIG9iamVjdCBvclxuICAvLyBzdHJpbmcgaW50byBhIG5ldyBVUkwsIHdoaWNoIGlzIHRoZW4gc2V0IGludG8gdGhhdCBhdHRyaWJ1dGUuIExpa2VcbiAgLy8gPGpRdWVyeS5wYXJhbS5xdWVyeXN0cmluZyAoYnVpbGQgdXJsKT4sIGJ1dCBmb3IgYWxsIGVsZW1lbnRzIGluIGEgalF1ZXJ5XG4gIC8vIGNvbGxlY3Rpb24uXG4gIC8vXG4gIC8vIFVzYWdlOlxuICAvL1xuICAvLyA+IGpRdWVyeSgnc2VsZWN0b3InKS5xdWVyeXN0cmluZyggWyBhdHRyLCBdIHBhcmFtcyBbLCBtZXJnZV9tb2RlIF0gKTtcbiAgLy9cbiAgLy8gQXJndW1lbnRzOlxuICAvL1xuICAvLyAgYXR0ciAtIChTdHJpbmcpIE9wdGlvbmFsIG5hbWUgb2YgYW4gYXR0cmlidXRlIHRoYXQgd2lsbCBjb250YWluIGEgVVJMIHRvXG4gIC8vICAgIG1lcmdlIHBhcmFtcyBvciB1cmwgaW50by4gU2VlIDxqUXVlcnkuZWxlbVVybEF0dHI+IGZvciBhIGxpc3Qgb2YgZGVmYXVsdFxuICAvLyAgICBhdHRyaWJ1dGVzLlxuICAvLyAgcGFyYW1zIC0gKE9iamVjdCkgQSBwYXJhbXMgb2JqZWN0IHRvIGJlIG1lcmdlZCBpbnRvIHRoZSBVUkwgYXR0cmlidXRlLlxuICAvLyAgcGFyYW1zIC0gKFN0cmluZykgQSBVUkwgY29udGFpbmluZyBxdWVyeSBzdHJpbmcgcGFyYW1zLCBvciBwYXJhbXMgc3RyaW5nXG4gIC8vICAgIHRvIGJlIG1lcmdlZCBpbnRvIHRoZSBVUkwgYXR0cmlidXRlLlxuICAvLyAgbWVyZ2VfbW9kZSAtIChOdW1iZXIpIE1lcmdlIGJlaGF2aW9yIGRlZmF1bHRzIHRvIDAgaWYgbWVyZ2VfbW9kZSBpcyBub3RcbiAgLy8gICAgc3BlY2lmaWVkLCBhbmQgaXMgYXMtZm9sbG93czpcbiAgLy9cbiAgLy8gICAgKiAwOiBwYXJhbXMgaW4gdGhlIHBhcmFtcyBhcmd1bWVudCB3aWxsIG92ZXJyaWRlIGFueSBwYXJhbXMgaW4gYXR0ciBVUkwuXG4gIC8vICAgICogMTogYW55IHBhcmFtcyBpbiBhdHRyIFVSTCB3aWxsIG92ZXJyaWRlIHBhcmFtcyBpbiB0aGUgcGFyYW1zIGFyZ3VtZW50LlxuICAvLyAgICAqIDI6IHBhcmFtcyBhcmd1bWVudCB3aWxsIGNvbXBsZXRlbHkgcmVwbGFjZSBhbnkgcXVlcnkgc3RyaW5nIGluIGF0dHJcbiAgLy8gICAgICAgICBVUkwuXG4gIC8vXG4gIC8vIFJldHVybnM6XG4gIC8vXG4gIC8vICAoalF1ZXJ5KSBUaGUgaW5pdGlhbCBqUXVlcnkgY29sbGVjdGlvbiBvZiBlbGVtZW50cywgYnV0IHdpdGggbW9kaWZpZWQgVVJMXG4gIC8vICBhdHRyaWJ1dGUgdmFsdWVzLlxuXG4gIC8vIE1ldGhvZDogalF1ZXJ5LmZuLmZyYWdtZW50XG4gIC8vXG4gIC8vIFVwZGF0ZSBVUkwgYXR0cmlidXRlIGluIG9uZSBvciBtb3JlIGVsZW1lbnRzLCBtZXJnaW5nIHRoZSBjdXJyZW50IFVSTCAod2l0aFxuICAvLyBvciB3aXRob3V0IHByZS1leGlzdGluZyBmcmFnbWVudC9oYXNoIHBhcmFtcykgcGx1cyBhbnkgcGFyYW1zIG9iamVjdCBvclxuICAvLyBzdHJpbmcgaW50byBhIG5ldyBVUkwsIHdoaWNoIGlzIHRoZW4gc2V0IGludG8gdGhhdCBhdHRyaWJ1dGUuIExpa2VcbiAgLy8gPGpRdWVyeS5wYXJhbS5mcmFnbWVudCAoYnVpbGQgdXJsKT4sIGJ1dCBmb3IgYWxsIGVsZW1lbnRzIGluIGEgalF1ZXJ5XG4gIC8vIGNvbGxlY3Rpb24uXG4gIC8vXG4gIC8vIFVzYWdlOlxuICAvL1xuICAvLyA+IGpRdWVyeSgnc2VsZWN0b3InKS5mcmFnbWVudCggWyBhdHRyLCBdIHBhcmFtcyBbLCBtZXJnZV9tb2RlIF0gKTtcbiAgLy9cbiAgLy8gQXJndW1lbnRzOlxuICAvL1xuICAvLyAgYXR0ciAtIChTdHJpbmcpIE9wdGlvbmFsIG5hbWUgb2YgYW4gYXR0cmlidXRlIHRoYXQgd2lsbCBjb250YWluIGEgVVJMIHRvXG4gIC8vICAgIG1lcmdlIHBhcmFtcyBpbnRvLiBTZWUgPGpRdWVyeS5lbGVtVXJsQXR0cj4gZm9yIGEgbGlzdCBvZiBkZWZhdWx0XG4gIC8vICAgIGF0dHJpYnV0ZXMuXG4gIC8vICBwYXJhbXMgLSAoT2JqZWN0KSBBIHBhcmFtcyBvYmplY3QgdG8gYmUgbWVyZ2VkIGludG8gdGhlIFVSTCBhdHRyaWJ1dGUuXG4gIC8vICBwYXJhbXMgLSAoU3RyaW5nKSBBIFVSTCBjb250YWluaW5nIGZyYWdtZW50IChoYXNoKSBwYXJhbXMsIG9yIHBhcmFtc1xuICAvLyAgICBzdHJpbmcgdG8gYmUgbWVyZ2VkIGludG8gdGhlIFVSTCBhdHRyaWJ1dGUuXG4gIC8vICBtZXJnZV9tb2RlIC0gKE51bWJlcikgTWVyZ2UgYmVoYXZpb3IgZGVmYXVsdHMgdG8gMCBpZiBtZXJnZV9tb2RlIGlzIG5vdFxuICAvLyAgICBzcGVjaWZpZWQsIGFuZCBpcyBhcy1mb2xsb3dzOlxuICAvL1xuICAvLyAgICAqIDA6IHBhcmFtcyBpbiB0aGUgcGFyYW1zIGFyZ3VtZW50IHdpbGwgb3ZlcnJpZGUgYW55IHBhcmFtcyBpbiBhdHRyIFVSTC5cbiAgLy8gICAgKiAxOiBhbnkgcGFyYW1zIGluIGF0dHIgVVJMIHdpbGwgb3ZlcnJpZGUgcGFyYW1zIGluIHRoZSBwYXJhbXMgYXJndW1lbnQuXG4gIC8vICAgICogMjogcGFyYW1zIGFyZ3VtZW50IHdpbGwgY29tcGxldGVseSByZXBsYWNlIGFueSBmcmFnbWVudCAoaGFzaCkgaW4gYXR0clxuICAvLyAgICAgICAgIFVSTC5cbiAgLy9cbiAgLy8gUmV0dXJuczpcbiAgLy9cbiAgLy8gIChqUXVlcnkpIFRoZSBpbml0aWFsIGpRdWVyeSBjb2xsZWN0aW9uIG9mIGVsZW1lbnRzLCBidXQgd2l0aCBtb2RpZmllZCBVUkxcbiAgLy8gIGF0dHJpYnV0ZSB2YWx1ZXMuXG5cbiAgZnVuY3Rpb24ganFfZm5fc3ViKCBtb2RlLCBmb3JjZV9hdHRyLCBwYXJhbXMsIG1lcmdlX21vZGUgKSB7XG4gICAgaWYgKCAhaXNfc3RyaW5nKCBwYXJhbXMgKSAmJiB0eXBlb2YgcGFyYW1zICE9PSAnb2JqZWN0JyApIHtcbiAgICAgIC8vIGZvcmNlX2F0dHIgbm90IHNwZWNpZmllZC5cbiAgICAgIG1lcmdlX21vZGUgPSBwYXJhbXM7XG4gICAgICBwYXJhbXMgPSBmb3JjZV9hdHRyO1xuICAgICAgZm9yY2VfYXR0ciA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgdGhhdCA9ICQodGhpcyksXG5cbiAgICAgICAgLy8gR2V0IGF0dHJpYnV0ZSBzcGVjaWZpZWQsIG9yIGRlZmF1bHQgc3BlY2lmaWVkIHZpYSAkLmVsZW1VcmxBdHRyLlxuICAgICAgICBhdHRyID0gZm9yY2VfYXR0ciB8fCBqcV9lbGVtVXJsQXR0cigpWyAoIHRoaXMubm9kZU5hbWUgfHwgJycgKS50b0xvd2VyQ2FzZSgpIF0gfHwgJycsXG5cbiAgICAgICAgLy8gR2V0IFVSTCB2YWx1ZS5cbiAgICAgICAgdXJsID0gYXR0ciAmJiB0aGF0LmF0dHIoIGF0dHIgKSB8fCAnJztcblxuICAgICAgLy8gVXBkYXRlIGF0dHJpYnV0ZSB3aXRoIG5ldyBVUkwuXG4gICAgICB0aGF0LmF0dHIoIGF0dHIsIGpxX3BhcmFtWyBtb2RlIF0oIHVybCwgcGFyYW1zLCBtZXJnZV9tb2RlICkgKTtcbiAgICB9KTtcblxuICB9O1xuXG4gICQuZm5bIHN0cl9xdWVyeXN0cmluZyBdID0gY3VycnkoIGpxX2ZuX3N1Yiwgc3RyX3F1ZXJ5c3RyaW5nICk7XG4gICQuZm5bIHN0cl9mcmFnbWVudCBdICAgID0gY3VycnkoIGpxX2ZuX3N1Yiwgc3RyX2ZyYWdtZW50ICk7XG5cbiAgLy8gU2VjdGlvbjogSGlzdG9yeSwgaGFzaGNoYW5nZSBldmVudFxuICAvL1xuICAvLyBNZXRob2Q6IGpRdWVyeS5iYnEucHVzaFN0YXRlXG4gIC8vXG4gIC8vIEFkZHMgYSAnc3RhdGUnIGludG8gdGhlIGJyb3dzZXIgaGlzdG9yeSBhdCB0aGUgY3VycmVudCBwb3NpdGlvbiwgc2V0dGluZ1xuICAvLyBsb2NhdGlvbi5oYXNoIGFuZCB0cmlnZ2VyaW5nIGFueSBib3VuZCA8aGFzaGNoYW5nZSBldmVudD4gY2FsbGJhY2tzXG4gIC8vIChwcm92aWRlZCB0aGUgbmV3IHN0YXRlIGlzIGRpZmZlcmVudCB0aGFuIHRoZSBwcmV2aW91cyBzdGF0ZSkuXG4gIC8vXG4gIC8vIElmIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkLCBhbiBlbXB0eSBzdGF0ZSBpcyBjcmVhdGVkLCB3aGljaCBpcyBqdXN0IGFcbiAgLy8gc2hvcnRjdXQgZm9yIGpRdWVyeS5iYnEucHVzaFN0YXRlKCB7fSwgMiApLlxuICAvL1xuICAvLyBVc2FnZTpcbiAgLy9cbiAgLy8gPiBqUXVlcnkuYmJxLnB1c2hTdGF0ZSggWyBwYXJhbXMgWywgbWVyZ2VfbW9kZSBdIF0gKTtcbiAgLy9cbiAgLy8gQXJndW1lbnRzOlxuICAvL1xuICAvLyAgcGFyYW1zIC0gKFN0cmluZykgQSBzZXJpYWxpemVkIHBhcmFtcyBzdHJpbmcgb3IgYSBoYXNoIHN0cmluZyBiZWdpbm5pbmdcbiAgLy8gICAgd2l0aCAjIHRvIG1lcmdlIGludG8gbG9jYXRpb24uaGFzaC5cbiAgLy8gIHBhcmFtcyAtIChPYmplY3QpIEEgcGFyYW1zIG9iamVjdCB0byBtZXJnZSBpbnRvIGxvY2F0aW9uLmhhc2guXG4gIC8vICBtZXJnZV9tb2RlIC0gKE51bWJlcikgTWVyZ2UgYmVoYXZpb3IgZGVmYXVsdHMgdG8gMCBpZiBtZXJnZV9tb2RlIGlzIG5vdFxuICAvLyAgICBzcGVjaWZpZWQgKHVubGVzcyBhIGhhc2ggc3RyaW5nIGJlZ2lubmluZyB3aXRoICMgaXMgc3BlY2lmaWVkLCBpbiB3aGljaFxuICAvLyAgICBjYXNlIG1lcmdlIGJlaGF2aW9yIGRlZmF1bHRzIHRvIDIpLCBhbmQgaXMgYXMtZm9sbG93czpcbiAgLy9cbiAgLy8gICAgKiAwOiBwYXJhbXMgaW4gdGhlIHBhcmFtcyBhcmd1bWVudCB3aWxsIG92ZXJyaWRlIGFueSBwYXJhbXMgaW4gdGhlXG4gIC8vICAgICAgICAgY3VycmVudCBzdGF0ZS5cbiAgLy8gICAgKiAxOiBhbnkgcGFyYW1zIGluIHRoZSBjdXJyZW50IHN0YXRlIHdpbGwgb3ZlcnJpZGUgcGFyYW1zIGluIHRoZSBwYXJhbXNcbiAgLy8gICAgICAgICBhcmd1bWVudC5cbiAgLy8gICAgKiAyOiBwYXJhbXMgYXJndW1lbnQgd2lsbCBjb21wbGV0ZWx5IHJlcGxhY2UgY3VycmVudCBzdGF0ZS5cbiAgLy9cbiAgLy8gUmV0dXJuczpcbiAgLy9cbiAgLy8gIE5vdGhpbmcuXG4gIC8vXG4gIC8vIEFkZGl0aW9uYWwgTm90ZXM6XG4gIC8vXG4gIC8vICAqIFNldHRpbmcgYW4gZW1wdHkgc3RhdGUgbWF5IGNhdXNlIHRoZSBicm93c2VyIHRvIHNjcm9sbC5cbiAgLy8gICogVW5saWtlIHRoZSBmcmFnbWVudCBhbmQgcXVlcnlzdHJpbmcgbWV0aG9kcywgaWYgYSBoYXNoIHN0cmluZyBiZWdpbm5pbmdcbiAgLy8gICAgd2l0aCAjIGlzIHNwZWNpZmllZCBhcyB0aGUgcGFyYW1zIGFncnVtZW50LCBtZXJnZV9tb2RlIGRlZmF1bHRzIHRvIDIuXG5cbiAganFfYmJxLnB1c2hTdGF0ZSA9IGpxX2JicV9wdXNoU3RhdGUgPSBmdW5jdGlvbiggcGFyYW1zLCBtZXJnZV9tb2RlICkge1xuICAgIGlmICggaXNfc3RyaW5nKCBwYXJhbXMgKSAmJiAvXiMvLnRlc3QoIHBhcmFtcyApICYmIG1lcmdlX21vZGUgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgIC8vIFBhcmFtcyBzdHJpbmcgYmVnaW5zIHdpdGggIyBhbmQgbWVyZ2VfbW9kZSBub3Qgc3BlY2lmaWVkLCBzbyBjb21wbGV0ZWx5XG4gICAgICAvLyBvdmVyd3JpdGUgd2luZG93LmxvY2F0aW9uLmhhc2guXG4gICAgICBtZXJnZV9tb2RlID0gMjtcbiAgICB9XG5cbiAgICB2YXIgaGFzX2FyZ3MgPSBwYXJhbXMgIT09IHVuZGVmaW5lZCxcbiAgICAgIC8vIE1lcmdlIHBhcmFtcyBpbnRvIHdpbmRvdy5sb2NhdGlvbiB1c2luZyAkLnBhcmFtLmZyYWdtZW50LlxuICAgICAgdXJsID0ganFfcGFyYW1fZnJhZ21lbnQoIGxvY2F0aW9uLmhyZWYsXG4gICAgICAgIGhhc19hcmdzID8gcGFyYW1zIDoge30sIGhhc19hcmdzID8gbWVyZ2VfbW9kZSA6IDIgKTtcblxuICAgIC8vIFNldCBuZXcgd2luZG93LmxvY2F0aW9uLmhyZWYuIE5vdGUgdGhhdCBTYWZhcmkgMyAmIENocm9tZSBiYXJmIG9uXG4gICAgLy8gbG9jYXRpb24uaGFzaCA9ICcjJyBzbyB0aGUgZW50aXJlIFVSTCBpcyBzZXQuXG4gICAgbG9jYXRpb24uaHJlZiA9IHVybDtcbiAgfTtcblxuICAvLyBNZXRob2Q6IGpRdWVyeS5iYnEuZ2V0U3RhdGVcbiAgLy9cbiAgLy8gUmV0cmlldmVzIHRoZSBjdXJyZW50ICdzdGF0ZScgZnJvbSB0aGUgYnJvd3NlciBoaXN0b3J5LCBwYXJzaW5nXG4gIC8vIGxvY2F0aW9uLmhhc2ggZm9yIGEgc3BlY2lmaWMga2V5IG9yIHJldHVybmluZyBhbiBvYmplY3QgY29udGFpbmluZyB0aGVcbiAgLy8gZW50aXJlIHN0YXRlLCBvcHRpb25hbGx5IGNvZXJjaW5nIG51bWJlcnMsIGJvb2xlYW5zLCBudWxsIGFuZCB1bmRlZmluZWRcbiAgLy8gdmFsdWVzLlxuICAvL1xuICAvLyBVc2FnZTpcbiAgLy9cbiAgLy8gPiBqUXVlcnkuYmJxLmdldFN0YXRlKCBbIGtleSBdIFssIGNvZXJjZSBdICk7XG4gIC8vXG4gIC8vIEFyZ3VtZW50czpcbiAgLy9cbiAgLy8gIGtleSAtIChTdHJpbmcpIEFuIG9wdGlvbmFsIHN0YXRlIGtleSBmb3Igd2hpY2ggdG8gcmV0dXJuIGEgdmFsdWUuXG4gIC8vICBjb2VyY2UgLSAoQm9vbGVhbikgSWYgdHJ1ZSwgY29lcmNlcyBhbnkgbnVtYmVycyBvciB0cnVlLCBmYWxzZSwgbnVsbCwgYW5kXG4gIC8vICAgIHVuZGVmaW5lZCB0byB0aGVpciBhY3R1YWwgdmFsdWUuIERlZmF1bHRzIHRvIGZhbHNlLlxuICAvL1xuICAvLyBSZXR1cm5zOlxuICAvL1xuICAvLyAgKEFueXRoaW5nKSBJZiBrZXkgaXMgcGFzc2VkLCByZXR1cm5zIHRoZSB2YWx1ZSBjb3JyZXNwb25kaW5nIHdpdGggdGhhdCBrZXlcbiAgLy8gICAgaW4gdGhlIGxvY2F0aW9uLmhhc2ggJ3N0YXRlJywgb3IgdW5kZWZpbmVkLiBJZiBub3QsIGFuIG9iamVjdFxuICAvLyAgICByZXByZXNlbnRpbmcgdGhlIGVudGlyZSAnc3RhdGUnIGlzIHJldHVybmVkLlxuXG4gIGpxX2JicS5nZXRTdGF0ZSA9IGpxX2JicV9nZXRTdGF0ZSA9IGZ1bmN0aW9uKCBrZXksIGNvZXJjZSApIHtcbiAgICByZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGtleSA9PT0gJ2Jvb2xlYW4nXG4gICAgICA/IGpxX2RlcGFyYW1fZnJhZ21lbnQoIGtleSApIC8vICdrZXknIHJlYWxseSBtZWFucyAnY29lcmNlJyBoZXJlXG4gICAgICA6IGpxX2RlcGFyYW1fZnJhZ21lbnQoIGNvZXJjZSApWyBrZXkgXTtcbiAgfTtcblxuICAvLyBNZXRob2Q6IGpRdWVyeS5iYnEucmVtb3ZlU3RhdGVcbiAgLy9cbiAgLy8gUmVtb3ZlIG9uZSBvciBtb3JlIGtleXMgZnJvbSB0aGUgY3VycmVudCBicm93c2VyIGhpc3RvcnkgJ3N0YXRlJywgY3JlYXRpbmdcbiAgLy8gYSBuZXcgc3RhdGUsIHNldHRpbmcgbG9jYXRpb24uaGFzaCBhbmQgdHJpZ2dlcmluZyBhbnkgYm91bmRcbiAgLy8gPGhhc2hjaGFuZ2UgZXZlbnQ+IGNhbGxiYWNrcyAocHJvdmlkZWQgdGhlIG5ldyBzdGF0ZSBpcyBkaWZmZXJlbnQgdGhhblxuICAvLyB0aGUgcHJldmlvdXMgc3RhdGUpLlxuICAvL1xuICAvLyBJZiBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCwgYW4gZW1wdHkgc3RhdGUgaXMgY3JlYXRlZCwgd2hpY2ggaXMganVzdCBhXG4gIC8vIHNob3J0Y3V0IGZvciBqUXVlcnkuYmJxLnB1c2hTdGF0ZSgge30sIDIgKS5cbiAgLy9cbiAgLy8gVXNhZ2U6XG4gIC8vXG4gIC8vID4galF1ZXJ5LmJicS5yZW1vdmVTdGF0ZSggWyBrZXkgWywga2V5IC4uLiBdIF0gKTtcbiAgLy9cbiAgLy8gQXJndW1lbnRzOlxuICAvL1xuICAvLyAga2V5IC0gKFN0cmluZykgT25lIG9yIG1vcmUga2V5IHZhbHVlcyB0byByZW1vdmUgZnJvbSB0aGUgY3VycmVudCBzdGF0ZSxcbiAgLy8gICAgcGFzc2VkIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzLlxuICAvLyAga2V5IC0gKEFycmF5KSBBIHNpbmdsZSBhcnJheSBhcmd1bWVudCB0aGF0IGNvbnRhaW5zIGEgbGlzdCBvZiBrZXkgdmFsdWVzXG4gIC8vICAgIHRvIHJlbW92ZSBmcm9tIHRoZSBjdXJyZW50IHN0YXRlLlxuICAvL1xuICAvLyBSZXR1cm5zOlxuICAvL1xuICAvLyAgTm90aGluZy5cbiAgLy9cbiAgLy8gQWRkaXRpb25hbCBOb3RlczpcbiAgLy9cbiAgLy8gICogU2V0dGluZyBhbiBlbXB0eSBzdGF0ZSBtYXkgY2F1c2UgdGhlIGJyb3dzZXIgdG8gc2Nyb2xsLlxuXG4gIGpxX2JicS5yZW1vdmVTdGF0ZSA9IGZ1bmN0aW9uKCBhcnIgKSB7XG4gICAgdmFyIHN0YXRlID0ge307XG5cbiAgICAvLyBJZiBvbmUgb3IgbW9yZSBhcmd1bWVudHMgaXMgcGFzc2VkLi5cbiAgICBpZiAoIGFyciAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgc3RhdGUuXG4gICAgICBzdGF0ZSA9IGpxX2JicV9nZXRTdGF0ZSgpO1xuXG4gICAgICAvLyBGb3IgZWFjaCBwYXNzZWQga2V5LCBkZWxldGUgdGhlIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgZnJvbSB0aGUgY3VycmVudFxuICAgICAgLy8gc3RhdGUuXG4gICAgICAkLmVhY2goICQuaXNBcnJheSggYXJyICkgPyBhcnIgOiBhcmd1bWVudHMsIGZ1bmN0aW9uKGksdil7XG4gICAgICAgIGRlbGV0ZSBzdGF0ZVsgdiBdO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gU2V0IHRoZSBzdGF0ZSwgY29tcGxldGVseSBvdmVycmlkaW5nIGFueSBleGlzdGluZyBzdGF0ZS5cbiAgICBqcV9iYnFfcHVzaFN0YXRlKCBzdGF0ZSwgMiApO1xuICB9O1xuXG4gIC8vIEV2ZW50OiBoYXNoY2hhbmdlIGV2ZW50IChCQlEpXG4gIC8vXG4gIC8vIFVzYWdlIGluIGpRdWVyeSAxLjQgYW5kIG5ld2VyOlxuICAvL1xuICAvLyBJbiBqUXVlcnkgMS40IGFuZCBuZXdlciwgdGhlIGV2ZW50IG9iamVjdCBwYXNzZWQgaW50byBhbnkgaGFzaGNoYW5nZSBldmVudFxuICAvLyBjYWxsYmFjayBpcyBhdWdtZW50ZWQgd2l0aCBhIGNvcHkgb2YgdGhlIGxvY2F0aW9uLmhhc2ggZnJhZ21lbnQgYXQgdGhlIHRpbWVcbiAgLy8gdGhlIGV2ZW50IHdhcyB0cmlnZ2VyZWQgYXMgaXRzIGV2ZW50LmZyYWdtZW50IHByb3BlcnR5LiBJbiBhZGRpdGlvbiwgdGhlXG4gIC8vIGV2ZW50LmdldFN0YXRlIG1ldGhvZCBvcGVyYXRlcyBvbiB0aGlzIHByb3BlcnR5IChpbnN0ZWFkIG9mIGxvY2F0aW9uLmhhc2gpXG4gIC8vIHdoaWNoIGFsbG93cyB0aGlzIGZyYWdtZW50LWFzLWEtc3RhdGUgdG8gYmUgcmVmZXJlbmNlZCBsYXRlciwgZXZlbiBhZnRlclxuICAvLyB3aW5kb3cubG9jYXRpb24gbWF5IGhhdmUgY2hhbmdlZC5cbiAgLy9cbiAgLy8gTm90ZSB0aGF0IGV2ZW50LmZyYWdtZW50IGFuZCBldmVudC5nZXRTdGF0ZSBhcmUgbm90IGRlZmluZWQgYWNjb3JkaW5nIHRvXG4gIC8vIFczQyAob3IgYW55IG90aGVyKSBzcGVjaWZpY2F0aW9uLCBidXQgd2lsbCBzdGlsbCBiZSBhdmFpbGFibGUgd2hldGhlciBvclxuICAvLyBub3QgdGhlIGhhc2hjaGFuZ2UgZXZlbnQgZXhpc3RzIG5hdGl2ZWx5IGluIHRoZSBicm93c2VyLCBiZWNhdXNlIG9mIHRoZVxuICAvLyB1dGlsaXR5IHRoZXkgcHJvdmlkZS5cbiAgLy9cbiAgLy8gVGhlIGV2ZW50LmZyYWdtZW50IHByb3BlcnR5IGNvbnRhaW5zIHRoZSBvdXRwdXQgb2YgPGpRdWVyeS5wYXJhbS5mcmFnbWVudD5cbiAgLy8gYW5kIHRoZSBldmVudC5nZXRTdGF0ZSBtZXRob2QgaXMgZXF1aXZhbGVudCB0byB0aGUgPGpRdWVyeS5iYnEuZ2V0U3RhdGU+XG4gIC8vIG1ldGhvZC5cbiAgLy9cbiAgLy8gPiAkKHdpbmRvdykuYmluZCggJ2hhc2hjaGFuZ2UnLCBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIC8vID4gICB2YXIgaGFzaF9zdHIgPSBldmVudC5mcmFnbWVudCxcbiAgLy8gPiAgICAgcGFyYW1fb2JqID0gZXZlbnQuZ2V0U3RhdGUoKSxcbiAgLy8gPiAgICAgcGFyYW1fdmFsID0gZXZlbnQuZ2V0U3RhdGUoICdwYXJhbV9uYW1lJyApLFxuICAvLyA+ICAgICBwYXJhbV92YWxfY29lcmNlZCA9IGV2ZW50LmdldFN0YXRlKCAncGFyYW1fbmFtZScsIHRydWUgKTtcbiAgLy8gPiAgIC4uLlxuICAvLyA+IH0pO1xuICAvL1xuICAvLyBVc2FnZSBpbiBqUXVlcnkgMS4zLjI6XG4gIC8vXG4gIC8vIEluIGpRdWVyeSAxLjMuMiwgdGhlIGV2ZW50IG9iamVjdCBjYW5ub3QgdG8gYmUgYXVnbWVudGVkIGFzIGluIGpRdWVyeSAxLjQrLFxuICAvLyBzbyB0aGUgZnJhZ21lbnQgc3RhdGUgaXNuJ3QgYm91bmQgdG8gdGhlIGV2ZW50IG9iamVjdCBhbmQgbXVzdCBpbnN0ZWFkIGJlXG4gIC8vIHBhcnNlZCB1c2luZyB0aGUgPGpRdWVyeS5wYXJhbS5mcmFnbWVudD4gYW5kIDxqUXVlcnkuYmJxLmdldFN0YXRlPiBtZXRob2RzLlxuICAvL1xuICAvLyA+ICQod2luZG93KS5iaW5kKCAnaGFzaGNoYW5nZScsIGZ1bmN0aW9uKCBldmVudCApIHtcbiAgLy8gPiAgIHZhciBoYXNoX3N0ciA9ICQucGFyYW0uZnJhZ21lbnQoKSxcbiAgLy8gPiAgICAgcGFyYW1fb2JqID0gJC5iYnEuZ2V0U3RhdGUoKSxcbiAgLy8gPiAgICAgcGFyYW1fdmFsID0gJC5iYnEuZ2V0U3RhdGUoICdwYXJhbV9uYW1lJyApLFxuICAvLyA+ICAgICBwYXJhbV92YWxfY29lcmNlZCA9ICQuYmJxLmdldFN0YXRlKCAncGFyYW1fbmFtZScsIHRydWUgKTtcbiAgLy8gPiAgIC4uLlxuICAvLyA+IH0pO1xuICAvL1xuICAvLyBBZGRpdGlvbmFsIE5vdGVzOlxuICAvL1xuICAvLyAqIER1ZSB0byBjaGFuZ2VzIGluIHRoZSBzcGVjaWFsIGV2ZW50cyBBUEksIGpRdWVyeSBCQlEgdjEuMiBvciBuZXdlciBpc1xuICAvLyAgIHJlcXVpcmVkIHRvIGVuYWJsZSB0aGUgYXVnbWVudGVkIGV2ZW50IG9iamVjdCBpbiBqUXVlcnkgMS40LjIgYW5kIG5ld2VyLlxuICAvLyAqIFNlZSA8alF1ZXJ5IGhhc2hjaGFuZ2UgZXZlbnQ+IGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uLlxuXG4gIHNwZWNpYWxbIHN0cl9oYXNoY2hhbmdlIF0gPSAkLmV4dGVuZCggc3BlY2lhbFsgc3RyX2hhc2hjaGFuZ2UgXSwge1xuXG4gICAgLy8gQXVnbWVudGluZyB0aGUgZXZlbnQgb2JqZWN0IHdpdGggdGhlIC5mcmFnbWVudCBwcm9wZXJ0eSBhbmQgLmdldFN0YXRlXG4gICAgLy8gbWV0aG9kIHJlcXVpcmVzIGpRdWVyeSAxLjQgb3IgbmV3ZXIuIE5vdGU6IHdpdGggMS4zLjIsIGV2ZXJ5dGhpbmcgd2lsbFxuICAgIC8vIHdvcmssIGJ1dCB0aGUgZXZlbnQgd29uJ3QgYmUgYXVnbWVudGVkKVxuICAgIGFkZDogZnVuY3Rpb24oIGhhbmRsZU9iaiApIHtcbiAgICAgIHZhciBvbGRfaGFuZGxlcjtcblxuICAgICAgZnVuY3Rpb24gbmV3X2hhbmRsZXIoZSkge1xuICAgICAgICAvLyBlLmZyYWdtZW50IGlzIHNldCB0byB0aGUgdmFsdWUgb2YgbG9jYXRpb24uaGFzaCAod2l0aCBhbnkgbGVhZGluZyAjXG4gICAgICAgIC8vIHJlbW92ZWQpIGF0IHRoZSB0aW1lIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQuXG4gICAgICAgIHZhciBoYXNoID0gZVsgc3RyX2ZyYWdtZW50IF0gPSBqcV9wYXJhbV9mcmFnbWVudCgpO1xuXG4gICAgICAgIC8vIGUuZ2V0U3RhdGUoKSB3b3JrcyBqdXN0IGxpa2UgJC5iYnEuZ2V0U3RhdGUoKSwgYnV0IHVzZXMgdGhlXG4gICAgICAgIC8vIGUuZnJhZ21lbnQgcHJvcGVydHkgc3RvcmVkIG9uIHRoZSBldmVudCBvYmplY3QuXG4gICAgICAgIGUuZ2V0U3RhdGUgPSBmdW5jdGlvbigga2V5LCBjb2VyY2UgKSB7XG4gICAgICAgICAgcmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBrZXkgPT09ICdib29sZWFuJ1xuICAgICAgICAgICAgPyBqcV9kZXBhcmFtKCBoYXNoLCBrZXkgKSAvLyAna2V5JyByZWFsbHkgbWVhbnMgJ2NvZXJjZScgaGVyZVxuICAgICAgICAgICAgOiBqcV9kZXBhcmFtKCBoYXNoLCBjb2VyY2UgKVsga2V5IF07XG4gICAgICAgIH07XG5cbiAgICAgICAgb2xkX2hhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuICAgICAgfTtcblxuICAgICAgLy8gVGhpcyBtYXkgc2VlbSBhIGxpdHRsZSBjb21wbGljYXRlZCwgYnV0IGl0IG5vcm1hbGl6ZXMgdGhlIHNwZWNpYWwgZXZlbnRcbiAgICAgIC8vIC5hZGQgbWV0aG9kIGJldHdlZW4galF1ZXJ5IDEuNC8xLjQuMSBhbmQgMS40LjIrXG4gICAgICBpZiAoICQuaXNGdW5jdGlvbiggaGFuZGxlT2JqICkgKSB7XG4gICAgICAgIC8vIDEuNCwgMS40LjFcbiAgICAgICAgb2xkX2hhbmRsZXIgPSBoYW5kbGVPYmo7XG4gICAgICAgIHJldHVybiBuZXdfaGFuZGxlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIDEuNC4yK1xuICAgICAgICBvbGRfaGFuZGxlciA9IGhhbmRsZU9iai5oYW5kbGVyO1xuICAgICAgICBoYW5kbGVPYmouaGFuZGxlciA9IG5ld19oYW5kbGVyO1xuICAgICAgfVxuICAgIH1cblxuICB9KTtcblxufSkoalF1ZXJ5LHRoaXMpO1xuXG4vKiFcbiAqIGpRdWVyeSBoYXNoY2hhbmdlIGV2ZW50IC0gdjEuMyAtIDcvMjEvMjAxMFxuICogaHR0cDovL2JlbmFsbWFuLmNvbS9wcm9qZWN0cy9qcXVlcnktaGFzaGNoYW5nZS1wbHVnaW4vXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwIFwiQ293Ym95XCIgQmVuIEFsbWFuXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgYW5kIEdQTCBsaWNlbnNlcy5cbiAqIGh0dHA6Ly9iZW5hbG1hbi5jb20vYWJvdXQvbGljZW5zZS9cbiAqL1xuXG4vLyBTY3JpcHQ6IGpRdWVyeSBoYXNoY2hhbmdlIGV2ZW50XG4vL1xuLy8gKlZlcnNpb246IDEuMywgTGFzdCB1cGRhdGVkOiA3LzIxLzIwMTAqXG4vL1xuLy8gUHJvamVjdCBIb21lIC0gaHR0cDovL2JlbmFsbWFuLmNvbS9wcm9qZWN0cy9qcXVlcnktaGFzaGNoYW5nZS1wbHVnaW4vXG4vLyBHaXRIdWIgICAgICAgLSBodHRwOi8vZ2l0aHViLmNvbS9jb3dib3kvanF1ZXJ5LWhhc2hjaGFuZ2UvXG4vLyBTb3VyY2UgICAgICAgLSBodHRwOi8vZ2l0aHViLmNvbS9jb3dib3kvanF1ZXJ5LWhhc2hjaGFuZ2UvcmF3L21hc3Rlci9qcXVlcnkuYmEtaGFzaGNoYW5nZS5qc1xuLy8gKE1pbmlmaWVkKSAgIC0gaHR0cDovL2dpdGh1Yi5jb20vY293Ym95L2pxdWVyeS1oYXNoY2hhbmdlL3Jhdy9tYXN0ZXIvanF1ZXJ5LmJhLWhhc2hjaGFuZ2UubWluLmpzICgwLjhrYiBnemlwcGVkKVxuLy9cbi8vIEFib3V0OiBMaWNlbnNlXG4vL1xuLy8gQ29weXJpZ2h0IChjKSAyMDEwIFwiQ293Ym95XCIgQmVuIEFsbWFuLFxuLy8gRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwgbGljZW5zZXMuXG4vLyBodHRwOi8vYmVuYWxtYW4uY29tL2Fib3V0L2xpY2Vuc2UvXG4vL1xuLy8gQWJvdXQ6IEV4YW1wbGVzXG4vL1xuLy8gVGhlc2Ugd29ya2luZyBleGFtcGxlcywgY29tcGxldGUgd2l0aCBmdWxseSBjb21tZW50ZWQgY29kZSwgaWxsdXN0cmF0ZSBhIGZld1xuLy8gd2F5cyBpbiB3aGljaCB0aGlzIHBsdWdpbiBjYW4gYmUgdXNlZC5cbi8vXG4vLyBoYXNoY2hhbmdlIGV2ZW50IC0gaHR0cDovL2JlbmFsbWFuLmNvbS9jb2RlL3Byb2plY3RzL2pxdWVyeS1oYXNoY2hhbmdlL2V4YW1wbGVzL2hhc2hjaGFuZ2UvXG4vLyBkb2N1bWVudC5kb21haW4gLSBodHRwOi8vYmVuYWxtYW4uY29tL2NvZGUvcHJvamVjdHMvanF1ZXJ5LWhhc2hjaGFuZ2UvZXhhbXBsZXMvZG9jdW1lbnRfZG9tYWluL1xuLy9cbi8vIEFib3V0OiBTdXBwb3J0IGFuZCBUZXN0aW5nXG4vL1xuLy8gSW5mb3JtYXRpb24gYWJvdXQgd2hhdCB2ZXJzaW9uIG9yIHZlcnNpb25zIG9mIGpRdWVyeSB0aGlzIHBsdWdpbiBoYXMgYmVlblxuLy8gdGVzdGVkIHdpdGgsIHdoYXQgYnJvd3NlcnMgaXQgaGFzIGJlZW4gdGVzdGVkIGluLCBhbmQgd2hlcmUgdGhlIHVuaXQgdGVzdHNcbi8vIHJlc2lkZSAoc28geW91IGNhbiB0ZXN0IGl0IHlvdXJzZWxmKS5cbi8vXG4vLyBqUXVlcnkgVmVyc2lvbnMgLSAxLjIuNiwgMS4zLjIsIDEuNC4xLCAxLjQuMlxuLy8gQnJvd3NlcnMgVGVzdGVkIC0gSW50ZXJuZXQgRXhwbG9yZXIgNi04LCBGaXJlZm94IDItNCwgQ2hyb21lIDUtNiwgU2FmYXJpIDMuMi01LFxuLy8gICAgICAgICAgICAgICAgICAgT3BlcmEgOS42LTEwLjYwLCBpUGhvbmUgMy4xLCBBbmRyb2lkIDEuNi0yLjIsIEJsYWNrQmVycnkgNC42LTUuXG4vLyBVbml0IFRlc3RzICAgICAgLSBodHRwOi8vYmVuYWxtYW4uY29tL2NvZGUvcHJvamVjdHMvanF1ZXJ5LWhhc2hjaGFuZ2UvdW5pdC9cbi8vXG4vLyBBYm91dDogS25vd24gaXNzdWVzXG4vL1xuLy8gV2hpbGUgdGhpcyBqUXVlcnkgaGFzaGNoYW5nZSBldmVudCBpbXBsZW1lbnRhdGlvbiBpcyBxdWl0ZSBzdGFibGUgYW5kXG4vLyByb2J1c3QsIHRoZXJlIGFyZSBhIGZldyB1bmZvcnR1bmF0ZSBicm93c2VyIGJ1Z3Mgc3Vycm91bmRpbmcgZXhwZWN0ZWRcbi8vIGhhc2hjaGFuZ2UgZXZlbnQtYmFzZWQgYmVoYXZpb3JzLCBpbmRlcGVuZGVudCBvZiBhbnkgSmF2YVNjcmlwdFxuLy8gd2luZG93Lm9uaGFzaGNoYW5nZSBhYnN0cmFjdGlvbi4gU2VlIHRoZSBmb2xsb3dpbmcgZXhhbXBsZXMgZm9yIG1vcmVcbi8vIGluZm9ybWF0aW9uOlxuLy9cbi8vIENocm9tZTogQmFjayBCdXR0b24gLSBodHRwOi8vYmVuYWxtYW4uY29tL2NvZGUvcHJvamVjdHMvanF1ZXJ5LWhhc2hjaGFuZ2UvZXhhbXBsZXMvYnVnLWNocm9tZS1iYWNrLWJ1dHRvbi9cbi8vIEZpcmVmb3g6IFJlbW90ZSBYTUxIdHRwUmVxdWVzdCAtIGh0dHA6Ly9iZW5hbG1hbi5jb20vY29kZS9wcm9qZWN0cy9qcXVlcnktaGFzaGNoYW5nZS9leGFtcGxlcy9idWctZmlyZWZveC1yZW1vdGUteGhyL1xuLy8gV2ViS2l0OiBCYWNrIEJ1dHRvbiBpbiBhbiBJZnJhbWUgLSBodHRwOi8vYmVuYWxtYW4uY29tL2NvZGUvcHJvamVjdHMvanF1ZXJ5LWhhc2hjaGFuZ2UvZXhhbXBsZXMvYnVnLXdlYmtpdC1oYXNoLWlmcmFtZS9cbi8vIFNhZmFyaTogQmFjayBCdXR0b24gZnJvbSBhIGRpZmZlcmVudCBkb21haW4gLSBodHRwOi8vYmVuYWxtYW4uY29tL2NvZGUvcHJvamVjdHMvanF1ZXJ5LWhhc2hjaGFuZ2UvZXhhbXBsZXMvYnVnLXNhZmFyaS1iYWNrLWZyb20tZGlmZi1kb21haW4vXG4vL1xuLy8gQWxzbyBub3RlIHRoYXQgc2hvdWxkIGEgYnJvd3NlciBuYXRpdmVseSBzdXBwb3J0IHRoZSB3aW5kb3cub25oYXNoY2hhbmdlXG4vLyBldmVudCwgYnV0IG5vdCByZXBvcnQgdGhhdCBpdCBkb2VzLCB0aGUgZmFsbGJhY2sgcG9sbGluZyBsb29wIHdpbGwgYmUgdXNlZC5cbi8vXG4vLyBBYm91dDogUmVsZWFzZSBIaXN0b3J5XG4vL1xuLy8gMS4zICAgLSAoNy8yMS8yMDEwKSBSZW9yZ2FuaXplZCBJRTYvNyBJZnJhbWUgY29kZSB0byBtYWtlIGl0IG1vcmVcbi8vICAgICAgICAgXCJyZW1vdmFibGVcIiBmb3IgbW9iaWxlLW9ubHkgZGV2ZWxvcG1lbnQuIEFkZGVkIElFNi83IGRvY3VtZW50LnRpdGxlXG4vLyAgICAgICAgIHN1cHBvcnQuIEF0dGVtcHRlZCB0byBtYWtlIElmcmFtZSBhcyBoaWRkZW4gYXMgcG9zc2libGUgYnkgdXNpbmdcbi8vICAgICAgICAgdGVjaG5pcXVlcyBmcm9tIGh0dHA6Ly93d3cucGFjaWVsbG9ncm91cC5jb20vYmxvZy8/cD02MDQuIEFkZGVkXG4vLyAgICAgICAgIHN1cHBvcnQgZm9yIHRoZSBcInNob3J0Y3V0XCIgZm9ybWF0ICQod2luZG93KS5oYXNoY2hhbmdlKCBmbiApIGFuZFxuLy8gICAgICAgICAkKHdpbmRvdykuaGFzaGNoYW5nZSgpIGxpa2UgalF1ZXJ5IHByb3ZpZGVzIGZvciBidWlsdC1pbiBldmVudHMuXG4vLyAgICAgICAgIFJlbmFtZWQgalF1ZXJ5Lmhhc2hjaGFuZ2VEZWxheSB0byA8alF1ZXJ5LmZuLmhhc2hjaGFuZ2UuZGVsYXk+IGFuZFxuLy8gICAgICAgICBsb3dlcmVkIGl0cyBkZWZhdWx0IHZhbHVlIHRvIDUwLiBBZGRlZCA8alF1ZXJ5LmZuLmhhc2hjaGFuZ2UuZG9tYWluPlxuLy8gICAgICAgICBhbmQgPGpRdWVyeS5mbi5oYXNoY2hhbmdlLnNyYz4gcHJvcGVydGllcyBwbHVzIGRvY3VtZW50LWRvbWFpbi5odG1sXG4vLyAgICAgICAgIGZpbGUgdG8gYWRkcmVzcyBhY2Nlc3MgZGVuaWVkIGlzc3VlcyB3aGVuIHNldHRpbmcgZG9jdW1lbnQuZG9tYWluIGluXG4vLyAgICAgICAgIElFNi83LlxuLy8gMS4yICAgLSAoMi8xMS8yMDEwKSBGaXhlZCBhIGJ1ZyB3aGVyZSBjb21pbmcgYmFjayB0byBhIHBhZ2UgdXNpbmcgdGhpcyBwbHVnaW5cbi8vICAgICAgICAgZnJvbSBhIHBhZ2Ugb24gYW5vdGhlciBkb21haW4gd291bGQgY2F1c2UgYW4gZXJyb3IgaW4gU2FmYXJpIDQuIEFsc28sXG4vLyAgICAgICAgIElFNi83IElmcmFtZSBpcyBub3cgaW5zZXJ0ZWQgYWZ0ZXIgdGhlIGJvZHkgKHRoaXMgYWN0dWFsbHkgd29ya3MpLFxuLy8gICAgICAgICB3aGljaCBwcmV2ZW50cyB0aGUgcGFnZSBmcm9tIHNjcm9sbGluZyB3aGVuIHRoZSBldmVudCBpcyBmaXJzdCBib3VuZC5cbi8vICAgICAgICAgRXZlbnQgY2FuIGFsc28gbm93IGJlIGJvdW5kIGJlZm9yZSBET00gcmVhZHksIGJ1dCBpdCB3b24ndCBiZSB1c2FibGVcbi8vICAgICAgICAgYmVmb3JlIHRoZW4gaW4gSUU2LzcuXG4vLyAxLjEgICAtICgxLzIxLzIwMTApIEluY29ycG9yYXRlZCBkb2N1bWVudC5kb2N1bWVudE1vZGUgdGVzdCB0byBmaXggSUU4IGJ1Z1xuLy8gICAgICAgICB3aGVyZSBicm93c2VyIHZlcnNpb24gaXMgaW5jb3JyZWN0bHkgcmVwb3J0ZWQgYXMgOC4wLCBkZXNwaXRlXG4vLyAgICAgICAgIGluY2x1c2lvbiBvZiB0aGUgWC1VQS1Db21wYXRpYmxlIElFPUVtdWxhdGVJRTcgbWV0YSB0YWcuXG4vLyAxLjAgICAtICgxLzkvMjAxMCkgSW5pdGlhbCBSZWxlYXNlLiBCcm9rZSBvdXQgdGhlIGpRdWVyeSBCQlEgZXZlbnQuc3BlY2lhbFxuLy8gICAgICAgICB3aW5kb3cub25oYXNoY2hhbmdlIGZ1bmN0aW9uYWxpdHkgaW50byBhIHNlcGFyYXRlIHBsdWdpbiBmb3IgdXNlcnNcbi8vICAgICAgICAgd2hvIHdhbnQganVzdCB0aGUgYmFzaWMgZXZlbnQgJiBiYWNrIGJ1dHRvbiBzdXBwb3J0LCB3aXRob3V0IGFsbCB0aGVcbi8vICAgICAgICAgZXh0cmEgYXdlc29tZW5lc3MgdGhhdCBCQlEgcHJvdmlkZXMuIFRoaXMgcGx1Z2luIHdpbGwgYmUgaW5jbHVkZWQgYXNcbi8vICAgICAgICAgcGFydCBvZiBqUXVlcnkgQkJRLCBidXQgYWxzbyBiZSBhdmFpbGFibGUgc2VwYXJhdGVseS5cblxuKGZ1bmN0aW9uKCQsd2luZG93LHVuZGVmaW5lZCl7XG4gICckOm5vbXVuZ2UnOyAvLyBVc2VkIGJ5IFlVSSBjb21wcmVzc29yLlxuXG4gIC8vIFJldXNlZCBzdHJpbmcuXG4gIHZhciBzdHJfaGFzaGNoYW5nZSA9ICdoYXNoY2hhbmdlJyxcblxuICAgIC8vIE1ldGhvZCAvIG9iamVjdCByZWZlcmVuY2VzLlxuICAgIGRvYyA9IGRvY3VtZW50LFxuICAgIGZha2Vfb25oYXNoY2hhbmdlLFxuICAgIHNwZWNpYWwgPSAkLmV2ZW50LnNwZWNpYWwsXG5cbiAgICAvLyBEb2VzIHRoZSBicm93c2VyIHN1cHBvcnQgd2luZG93Lm9uaGFzaGNoYW5nZT8gTm90ZSB0aGF0IElFOCBydW5uaW5nIGluXG4gICAgLy8gSUU3IGNvbXBhdGliaWxpdHkgbW9kZSByZXBvcnRzIHRydWUgZm9yICdvbmhhc2hjaGFuZ2UnIGluIHdpbmRvdywgZXZlblxuICAgIC8vIHRob3VnaCB0aGUgZXZlbnQgaXNuJ3Qgc3VwcG9ydGVkLCBzbyBhbHNvIHRlc3QgZG9jdW1lbnQuZG9jdW1lbnRNb2RlLlxuICAgIGRvY19tb2RlID0gZG9jLmRvY3VtZW50TW9kZSxcbiAgICBzdXBwb3J0c19vbmhhc2hjaGFuZ2UgPSAnb24nICsgc3RyX2hhc2hjaGFuZ2UgaW4gd2luZG93ICYmICggZG9jX21vZGUgPT09IHVuZGVmaW5lZCB8fCBkb2NfbW9kZSA+IDcgKTtcblxuICAvLyBHZXQgbG9jYXRpb24uaGFzaCAob3Igd2hhdCB5b3UnZCBleHBlY3QgbG9jYXRpb24uaGFzaCB0byBiZSkgc2FucyBhbnlcbiAgLy8gbGVhZGluZyAjLiBUaGFua3MgZm9yIG1ha2luZyB0aGlzIG5lY2Vzc2FyeSwgRmlyZWZveCFcbiAgZnVuY3Rpb24gZ2V0X2ZyYWdtZW50KCB1cmwgKSB7XG4gICAgdXJsID0gdXJsIHx8IGxvY2F0aW9uLmhyZWY7XG4gICAgcmV0dXJuICcjJyArIHVybC5yZXBsYWNlKCAvXlteI10qIz8oLiopJC8sICckMScgKTtcbiAgfTtcblxuICAvLyBNZXRob2Q6IGpRdWVyeS5mbi5oYXNoY2hhbmdlXG4gIC8vXG4gIC8vIEJpbmQgYSBoYW5kbGVyIHRvIHRoZSB3aW5kb3cub25oYXNoY2hhbmdlIGV2ZW50IG9yIHRyaWdnZXIgYWxsIGJvdW5kXG4gIC8vIHdpbmRvdy5vbmhhc2hjaGFuZ2UgZXZlbnQgaGFuZGxlcnMuIFRoaXMgYmVoYXZpb3IgaXMgY29uc2lzdGVudCB3aXRoXG4gIC8vIGpRdWVyeSdzIGJ1aWx0LWluIGV2ZW50IGhhbmRsZXJzLlxuICAvL1xuICAvLyBVc2FnZTpcbiAgLy9cbiAgLy8gPiBqUXVlcnkod2luZG93KS5oYXNoY2hhbmdlKCBbIGhhbmRsZXIgXSApO1xuICAvL1xuICAvLyBBcmd1bWVudHM6XG4gIC8vXG4gIC8vICBoYW5kbGVyIC0gKEZ1bmN0aW9uKSBPcHRpb25hbCBoYW5kbGVyIHRvIGJlIGJvdW5kIHRvIHRoZSBoYXNoY2hhbmdlXG4gIC8vICAgIGV2ZW50LiBUaGlzIGlzIGEgXCJzaG9ydGN1dFwiIGZvciB0aGUgbW9yZSB2ZXJib3NlIGZvcm06XG4gIC8vICAgIGpRdWVyeSh3aW5kb3cpLmJpbmQoICdoYXNoY2hhbmdlJywgaGFuZGxlciApLiBJZiBoYW5kbGVyIGlzIG9taXR0ZWQsXG4gIC8vICAgIGFsbCBib3VuZCB3aW5kb3cub25oYXNoY2hhbmdlIGV2ZW50IGhhbmRsZXJzIHdpbGwgYmUgdHJpZ2dlcmVkLiBUaGlzXG4gIC8vICAgIGlzIGEgc2hvcnRjdXQgZm9yIHRoZSBtb3JlIHZlcmJvc2VcbiAgLy8gICAgalF1ZXJ5KHdpbmRvdykudHJpZ2dlciggJ2hhc2hjaGFuZ2UnICkuIFRoZXNlIGZvcm1zIGFyZSBkZXNjcmliZWQgaW5cbiAgLy8gICAgdGhlIDxoYXNoY2hhbmdlIGV2ZW50PiBzZWN0aW9uLlxuICAvL1xuICAvLyBSZXR1cm5zOlxuICAvL1xuICAvLyAgKGpRdWVyeSkgVGhlIGluaXRpYWwgalF1ZXJ5IGNvbGxlY3Rpb24gb2YgZWxlbWVudHMuXG5cbiAgLy8gQWxsb3cgdGhlIFwic2hvcnRjdXRcIiBmb3JtYXQgJChlbGVtKS5oYXNoY2hhbmdlKCBmbiApIGZvciBiaW5kaW5nIGFuZFxuICAvLyAkKGVsZW0pLmhhc2hjaGFuZ2UoKSBmb3IgdHJpZ2dlcmluZywgbGlrZSBqUXVlcnkgZG9lcyBmb3IgYnVpbHQtaW4gZXZlbnRzLlxuICAkLmZuWyBzdHJfaGFzaGNoYW5nZSBdID0gZnVuY3Rpb24oIGZuICkge1xuICAgIHJldHVybiBmbiA/IHRoaXMuYmluZCggc3RyX2hhc2hjaGFuZ2UsIGZuICkgOiB0aGlzLnRyaWdnZXIoIHN0cl9oYXNoY2hhbmdlICk7XG4gIH07XG5cbiAgLy8gUHJvcGVydHk6IGpRdWVyeS5mbi5oYXNoY2hhbmdlLmRlbGF5XG4gIC8vXG4gIC8vIFRoZSBudW1lcmljIGludGVydmFsIChpbiBtaWxsaXNlY29uZHMpIGF0IHdoaWNoIHRoZSA8aGFzaGNoYW5nZSBldmVudD5cbiAgLy8gcG9sbGluZyBsb29wIGV4ZWN1dGVzLiBEZWZhdWx0cyB0byA1MC5cblxuICAvLyBQcm9wZXJ0eTogalF1ZXJ5LmZuLmhhc2hjaGFuZ2UuZG9tYWluXG4gIC8vXG4gIC8vIElmIHlvdSdyZSBzZXR0aW5nIGRvY3VtZW50LmRvbWFpbiBpbiB5b3VyIEphdmFTY3JpcHQsIGFuZCB5b3Ugd2FudCBoYXNoXG4gIC8vIGhpc3RvcnkgdG8gd29yayBpbiBJRTYvNywgbm90IG9ubHkgbXVzdCB0aGlzIHByb3BlcnR5IGJlIHNldCwgYnV0IHlvdSBtdXN0XG4gIC8vIGFsc28gc2V0IGRvY3VtZW50LmRvbWFpbiBCRUZPUkUgalF1ZXJ5IGlzIGxvYWRlZCBpbnRvIHRoZSBwYWdlLiBUaGlzXG4gIC8vIHByb3BlcnR5IGlzIG9ubHkgYXBwbGljYWJsZSBpZiB5b3UgYXJlIHN1cHBvcnRpbmcgSUU2LzcgKG9yIElFOCBvcGVyYXRpbmdcbiAgLy8gaW4gXCJJRTcgY29tcGF0aWJpbGl0eVwiIG1vZGUpLlxuICAvL1xuICAvLyBJbiBhZGRpdGlvbiwgdGhlIDxqUXVlcnkuZm4uaGFzaGNoYW5nZS5zcmM+IHByb3BlcnR5IG11c3QgYmUgc2V0IHRvIHRoZVxuICAvLyBwYXRoIG9mIHRoZSBpbmNsdWRlZCBcImRvY3VtZW50LWRvbWFpbi5odG1sXCIgZmlsZSwgd2hpY2ggY2FuIGJlIHJlbmFtZWQgb3JcbiAgLy8gbW9kaWZpZWQgaWYgbmVjZXNzYXJ5IChub3RlIHRoYXQgdGhlIGRvY3VtZW50LmRvbWFpbiBzcGVjaWZpZWQgbXVzdCBiZSB0aGVcbiAgLy8gc2FtZSBpbiBib3RoIHlvdXIgbWFpbiBKYXZhU2NyaXB0IGFzIHdlbGwgYXMgaW4gdGhpcyBmaWxlKS5cbiAgLy9cbiAgLy8gVXNhZ2U6XG4gIC8vXG4gIC8vIGpRdWVyeS5mbi5oYXNoY2hhbmdlLmRvbWFpbiA9IGRvY3VtZW50LmRvbWFpbjtcblxuICAvLyBQcm9wZXJ0eTogalF1ZXJ5LmZuLmhhc2hjaGFuZ2Uuc3JjXG4gIC8vXG4gIC8vIElmLCBmb3Igc29tZSByZWFzb24sIHlvdSBuZWVkIHRvIHNwZWNpZnkgYW4gSWZyYW1lIHNyYyBmaWxlIChmb3IgZXhhbXBsZSxcbiAgLy8gd2hlbiBzZXR0aW5nIGRvY3VtZW50LmRvbWFpbiBhcyBpbiA8alF1ZXJ5LmZuLmhhc2hjaGFuZ2UuZG9tYWluPiksIHlvdSBjYW5cbiAgLy8gZG8gc28gdXNpbmcgdGhpcyBwcm9wZXJ0eS4gTm90ZSB0aGF0IHdoZW4gdXNpbmcgdGhpcyBwcm9wZXJ0eSwgaGlzdG9yeVxuICAvLyB3b24ndCBiZSByZWNvcmRlZCBpbiBJRTYvNyB1bnRpbCB0aGUgSWZyYW1lIHNyYyBmaWxlIGxvYWRzLiBUaGlzIHByb3BlcnR5XG4gIC8vIGlzIG9ubHkgYXBwbGljYWJsZSBpZiB5b3UgYXJlIHN1cHBvcnRpbmcgSUU2LzcgKG9yIElFOCBvcGVyYXRpbmcgaW4gXCJJRTdcbiAgLy8gY29tcGF0aWJpbGl0eVwiIG1vZGUpLlxuICAvL1xuICAvLyBVc2FnZTpcbiAgLy9cbiAgLy8galF1ZXJ5LmZuLmhhc2hjaGFuZ2Uuc3JjID0gJ3BhdGgvdG8vZmlsZS5odG1sJztcblxuICAkLmZuWyBzdHJfaGFzaGNoYW5nZSBdLmRlbGF5ID0gNTA7XG4gIC8qXG4gICQuZm5bIHN0cl9oYXNoY2hhbmdlIF0uZG9tYWluID0gbnVsbDtcbiAgJC5mblsgc3RyX2hhc2hjaGFuZ2UgXS5zcmMgPSBudWxsO1xuICAqL1xuXG4gIC8vIEV2ZW50OiBoYXNoY2hhbmdlIGV2ZW50XG4gIC8vXG4gIC8vIEZpcmVkIHdoZW4gbG9jYXRpb24uaGFzaCBjaGFuZ2VzLiBJbiBicm93c2VycyB0aGF0IHN1cHBvcnQgaXQsIHRoZSBuYXRpdmVcbiAgLy8gSFRNTDUgd2luZG93Lm9uaGFzaGNoYW5nZSBldmVudCBpcyB1c2VkLCBvdGhlcndpc2UgYSBwb2xsaW5nIGxvb3AgaXNcbiAgLy8gaW5pdGlhbGl6ZWQsIHJ1bm5pbmcgZXZlcnkgPGpRdWVyeS5mbi5oYXNoY2hhbmdlLmRlbGF5PiBtaWxsaXNlY29uZHMgdG9cbiAgLy8gc2VlIGlmIHRoZSBoYXNoIGhhcyBjaGFuZ2VkLiBJbiBJRTYvNyAoYW5kIElFOCBvcGVyYXRpbmcgaW4gXCJJRTdcbiAgLy8gY29tcGF0aWJpbGl0eVwiIG1vZGUpLCBhIGhpZGRlbiBJZnJhbWUgaXMgY3JlYXRlZCB0byBhbGxvdyB0aGUgYmFjayBidXR0b25cbiAgLy8gYW5kIGhhc2gtYmFzZWQgaGlzdG9yeSB0byB3b3JrLlxuICAvL1xuICAvLyBVc2FnZSBhcyBkZXNjcmliZWQgaW4gPGpRdWVyeS5mbi5oYXNoY2hhbmdlPjpcbiAgLy9cbiAgLy8gPiAvLyBCaW5kIGFuIGV2ZW50IGhhbmRsZXIuXG4gIC8vID4galF1ZXJ5KHdpbmRvdykuaGFzaGNoYW5nZSggZnVuY3Rpb24oZSkge1xuICAvLyA+ICAgdmFyIGhhc2ggPSBsb2NhdGlvbi5oYXNoO1xuICAvLyA+ICAgLi4uXG4gIC8vID4gfSk7XG4gIC8vID5cbiAgLy8gPiAvLyBNYW51YWxseSB0cmlnZ2VyIHRoZSBldmVudCBoYW5kbGVyLlxuICAvLyA+IGpRdWVyeSh3aW5kb3cpLmhhc2hjaGFuZ2UoKTtcbiAgLy9cbiAgLy8gQSBtb3JlIHZlcmJvc2UgdXNhZ2UgdGhhdCBhbGxvd3MgZm9yIGV2ZW50IG5hbWVzcGFjaW5nOlxuICAvL1xuICAvLyA+IC8vIEJpbmQgYW4gZXZlbnQgaGFuZGxlci5cbiAgLy8gPiBqUXVlcnkod2luZG93KS5iaW5kKCAnaGFzaGNoYW5nZScsIGZ1bmN0aW9uKGUpIHtcbiAgLy8gPiAgIHZhciBoYXNoID0gbG9jYXRpb24uaGFzaDtcbiAgLy8gPiAgIC4uLlxuICAvLyA+IH0pO1xuICAvLyA+XG4gIC8vID4gLy8gTWFudWFsbHkgdHJpZ2dlciB0aGUgZXZlbnQgaGFuZGxlci5cbiAgLy8gPiBqUXVlcnkod2luZG93KS50cmlnZ2VyKCAnaGFzaGNoYW5nZScgKTtcbiAgLy9cbiAgLy8gQWRkaXRpb25hbCBOb3RlczpcbiAgLy9cbiAgLy8gKiBUaGUgcG9sbGluZyBsb29wIGFuZCBJZnJhbWUgYXJlIG5vdCBjcmVhdGVkIHVudGlsIGF0IGxlYXN0IG9uZSBoYW5kbGVyXG4gIC8vICAgaXMgYWN0dWFsbHkgYm91bmQgdG8gdGhlICdoYXNoY2hhbmdlJyBldmVudC5cbiAgLy8gKiBJZiB5b3UgbmVlZCB0aGUgYm91bmQgaGFuZGxlcihzKSB0byBleGVjdXRlIGltbWVkaWF0ZWx5LCBpbiBjYXNlcyB3aGVyZVxuICAvLyAgIGEgbG9jYXRpb24uaGFzaCBleGlzdHMgb24gcGFnZSBsb2FkLCB2aWEgYm9va21hcmsgb3IgcGFnZSByZWZyZXNoIGZvclxuICAvLyAgIGV4YW1wbGUsIHVzZSBqUXVlcnkod2luZG93KS5oYXNoY2hhbmdlKCkgb3IgdGhlIG1vcmUgdmVyYm9zZVxuICAvLyAgIGpRdWVyeSh3aW5kb3cpLnRyaWdnZXIoICdoYXNoY2hhbmdlJyApLlxuICAvLyAqIFRoZSBldmVudCBjYW4gYmUgYm91bmQgYmVmb3JlIERPTSByZWFkeSwgYnV0IHNpbmNlIGl0IHdvbid0IGJlIHVzYWJsZVxuICAvLyAgIGJlZm9yZSB0aGVuIGluIElFNi83IChkdWUgdG8gdGhlIG5lY2Vzc2FyeSBJZnJhbWUpLCByZWNvbW1lbmRlZCB1c2FnZSBpc1xuICAvLyAgIHRvIGJpbmQgaXQgaW5zaWRlIGEgRE9NIHJlYWR5IGhhbmRsZXIuXG5cbiAgLy8gT3ZlcnJpZGUgZXhpc3RpbmcgJC5ldmVudC5zcGVjaWFsLmhhc2hjaGFuZ2UgbWV0aG9kcyAoYWxsb3dpbmcgdGhpcyBwbHVnaW5cbiAgLy8gdG8gYmUgZGVmaW5lZCBhZnRlciBqUXVlcnkgQkJRIGluIEJCUSdzIHNvdXJjZSBjb2RlKS5cbiAgc3BlY2lhbFsgc3RyX2hhc2hjaGFuZ2UgXSA9ICQuZXh0ZW5kKCBzcGVjaWFsWyBzdHJfaGFzaGNoYW5nZSBdLCB7XG5cbiAgICAvLyBDYWxsZWQgb25seSB3aGVuIHRoZSBmaXJzdCAnaGFzaGNoYW5nZScgZXZlbnQgaXMgYm91bmQgdG8gd2luZG93LlxuICAgIHNldHVwOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIElmIHdpbmRvdy5vbmhhc2hjaGFuZ2UgaXMgc3VwcG9ydGVkIG5hdGl2ZWx5LCB0aGVyZSdzIG5vdGhpbmcgdG8gZG8uLlxuICAgICAgaWYgKCBzdXBwb3J0c19vbmhhc2hjaGFuZ2UgKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgICAvLyBPdGhlcndpc2UsIHdlIG5lZWQgdG8gY3JlYXRlIG91ciBvd24uIEFuZCB3ZSBkb24ndCB3YW50IHRvIGNhbGwgdGhpc1xuICAgICAgLy8gdW50aWwgdGhlIHVzZXIgYmluZHMgdG8gdGhlIGV2ZW50LCBqdXN0IGluIGNhc2UgdGhleSBuZXZlciBkbywgc2luY2UgaXRcbiAgICAgIC8vIHdpbGwgY3JlYXRlIGEgcG9sbGluZyBsb29wIGFuZCBwb3NzaWJseSBldmVuIGEgaGlkZGVuIElmcmFtZS5cbiAgICAgICQoIGZha2Vfb25oYXNoY2hhbmdlLnN0YXJ0ICk7XG4gICAgfSxcblxuICAgIC8vIENhbGxlZCBvbmx5IHdoZW4gdGhlIGxhc3QgJ2hhc2hjaGFuZ2UnIGV2ZW50IGlzIHVuYm91bmQgZnJvbSB3aW5kb3cuXG4gICAgdGVhcmRvd246IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gSWYgd2luZG93Lm9uaGFzaGNoYW5nZSBpcyBzdXBwb3J0ZWQgbmF0aXZlbHksIHRoZXJlJ3Mgbm90aGluZyB0byBkby4uXG4gICAgICBpZiAoIHN1cHBvcnRzX29uaGFzaGNoYW5nZSApIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAgIC8vIE90aGVyd2lzZSwgd2UgbmVlZCB0byBzdG9wIG91cnMgKGlmIHBvc3NpYmxlKS5cbiAgICAgICQoIGZha2Vfb25oYXNoY2hhbmdlLnN0b3AgKTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgLy8gZmFrZV9vbmhhc2hjaGFuZ2UgZG9lcyBhbGwgdGhlIHdvcmsgb2YgdHJpZ2dlcmluZyB0aGUgd2luZG93Lm9uaGFzaGNoYW5nZVxuICAvLyBldmVudCBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LCBpbmNsdWRpbmcgY3JlYXRpbmcgYVxuICAvLyBwb2xsaW5nIGxvb3AgdG8gd2F0Y2ggZm9yIGhhc2ggY2hhbmdlcyBhbmQgaW4gSUUgNi83IGNyZWF0aW5nIGEgaGlkZGVuXG4gIC8vIElmcmFtZSB0byBlbmFibGUgYmFjayBhbmQgZm9yd2FyZC5cbiAgZmFrZV9vbmhhc2hjaGFuZ2UgPSAoZnVuY3Rpb24oKXtcbiAgICB2YXIgc2VsZiA9IHt9LFxuICAgICAgdGltZW91dF9pZCxcblxuICAgICAgLy8gUmVtZW1iZXIgdGhlIGluaXRpYWwgaGFzaCBzbyBpdCBkb2Vzbid0IGdldCB0cmlnZ2VyZWQgaW1tZWRpYXRlbHkuXG4gICAgICBsYXN0X2hhc2ggPSBnZXRfZnJhZ21lbnQoKSxcblxuICAgICAgZm5fcmV0dmFsID0gZnVuY3Rpb24odmFsKXsgcmV0dXJuIHZhbDsgfSxcbiAgICAgIGhpc3Rvcnlfc2V0ID0gZm5fcmV0dmFsLFxuICAgICAgaGlzdG9yeV9nZXQgPSBmbl9yZXR2YWw7XG5cbiAgICAvLyBTdGFydCB0aGUgcG9sbGluZyBsb29wLlxuICAgIHNlbGYuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRpbWVvdXRfaWQgfHwgcG9sbCgpO1xuICAgIH07XG5cbiAgICAvLyBTdG9wIHRoZSBwb2xsaW5nIGxvb3AuXG4gICAgc2VsZi5zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aW1lb3V0X2lkICYmIGNsZWFyVGltZW91dCggdGltZW91dF9pZCApO1xuICAgICAgdGltZW91dF9pZCA9IHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgLy8gVGhpcyBwb2xsaW5nIGxvb3AgY2hlY2tzIGV2ZXJ5ICQuZm4uaGFzaGNoYW5nZS5kZWxheSBtaWxsaXNlY29uZHMgdG8gc2VlXG4gICAgLy8gaWYgbG9jYXRpb24uaGFzaCBoYXMgY2hhbmdlZCwgYW5kIHRyaWdnZXJzIHRoZSAnaGFzaGNoYW5nZScgZXZlbnQgb25cbiAgICAvLyB3aW5kb3cgd2hlbiBuZWNlc3NhcnkuXG4gICAgZnVuY3Rpb24gcG9sbCgpIHtcbiAgICAgIHZhciBoYXNoID0gZ2V0X2ZyYWdtZW50KCksXG4gICAgICAgIGhpc3RvcnlfaGFzaCA9IGhpc3RvcnlfZ2V0KCBsYXN0X2hhc2ggKTtcblxuICAgICAgaWYgKCBoYXNoICE9PSBsYXN0X2hhc2ggKSB7XG4gICAgICAgIGhpc3Rvcnlfc2V0KCBsYXN0X2hhc2ggPSBoYXNoLCBoaXN0b3J5X2hhc2ggKTtcblxuICAgICAgICAkKHdpbmRvdykudHJpZ2dlciggc3RyX2hhc2hjaGFuZ2UgKTtcblxuICAgICAgfSBlbHNlIGlmICggaGlzdG9yeV9oYXNoICE9PSBsYXN0X2hhc2ggKSB7XG4gICAgICAgIGxvY2F0aW9uLmhyZWYgPSBsb2NhdGlvbi5ocmVmLnJlcGxhY2UoIC8jLiovLCAnJyApICsgaGlzdG9yeV9oYXNoO1xuICAgICAgfVxuXG4gICAgICB0aW1lb3V0X2lkID0gc2V0VGltZW91dCggcG9sbCwgJC5mblsgc3RyX2hhc2hjaGFuZ2UgXS5kZWxheSApO1xuICAgIH07XG5cbiAgICAvLyB2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZcbiAgICAvLyB2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2IFJFTU9WRSBJRiBOT1QgU1VQUE9SVElORyBJRTYvNy84IHZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZcbiAgICAvLyB2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZcbiAgICAoL21zaWV8dHJpZGVudC9pKS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICFzdXBwb3J0c19vbmhhc2hjaGFuZ2UgJiYgKGZ1bmN0aW9uKCl7XG4gICAgICAvLyBOb3Qgb25seSBkbyBJRTYvNyBuZWVkIHRoZSBcIm1hZ2ljYWxcIiBJZnJhbWUgdHJlYXRtZW50LCBidXQgc28gZG9lcyBJRThcbiAgICAgIC8vIHdoZW4gcnVubmluZyBpbiBcIklFNyBjb21wYXRpYmlsaXR5XCIgbW9kZS5cblxuICAgICAgdmFyIGlmcmFtZSxcbiAgICAgICAgaWZyYW1lX3NyYztcblxuICAgICAgLy8gV2hlbiB0aGUgZXZlbnQgaXMgYm91bmQgYW5kIHBvbGxpbmcgc3RhcnRzIGluIElFIDYvNywgY3JlYXRlIGEgaGlkZGVuXG4gICAgICAvLyBJZnJhbWUgZm9yIGhpc3RvcnkgaGFuZGxpbmcuXG4gICAgICBzZWxmLnN0YXJ0ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaWYgKCAhaWZyYW1lICkge1xuICAgICAgICAgIGlmcmFtZV9zcmMgPSAkLmZuWyBzdHJfaGFzaGNoYW5nZSBdLnNyYztcbiAgICAgICAgICBpZnJhbWVfc3JjID0gaWZyYW1lX3NyYyAmJiBpZnJhbWVfc3JjICsgZ2V0X2ZyYWdtZW50KCk7XG5cbiAgICAgICAgICAvLyBDcmVhdGUgaGlkZGVuIElmcmFtZS4gQXR0ZW1wdCB0byBtYWtlIElmcmFtZSBhcyBoaWRkZW4gYXMgcG9zc2libGVcbiAgICAgICAgICAvLyBieSB1c2luZyB0ZWNobmlxdWVzIGZyb20gaHR0cDovL3d3dy5wYWNpZWxsb2dyb3VwLmNvbS9ibG9nLz9wPTYwNC5cbiAgICAgICAgICBpZnJhbWUgPSAkKCc8aWZyYW1lIHRhYmluZGV4PVwiLTFcIiB0aXRsZT1cImVtcHR5XCIvPicpLmhpZGUoKVxuXG4gICAgICAgICAgICAvLyBXaGVuIElmcmFtZSBoYXMgY29tcGxldGVseSBsb2FkZWQsIGluaXRpYWxpemUgdGhlIGhpc3RvcnkgYW5kXG4gICAgICAgICAgICAvLyBzdGFydCBwb2xsaW5nLlxuICAgICAgICAgICAgLm9uZSggJ2xvYWQnLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICBpZnJhbWVfc3JjIHx8IGhpc3Rvcnlfc2V0KCBnZXRfZnJhZ21lbnQoKSApO1xuICAgICAgICAgICAgICBwb2xsKCk7XG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAvLyBMb2FkIElmcmFtZSBzcmMgaWYgc3BlY2lmaWVkLCBvdGhlcndpc2Ugbm90aGluZy5cbiAgICAgICAgICAgIC5hdHRyKCAnc3JjJywgaWZyYW1lX3NyYyB8fCAnamF2YXNjcmlwdDowJyApXG5cbiAgICAgICAgICAgIC8vIEFwcGVuZCBJZnJhbWUgYWZ0ZXIgdGhlIGVuZCBvZiB0aGUgYm9keSB0byBwcmV2ZW50IHVubmVjZXNzYXJ5XG4gICAgICAgICAgICAvLyBpbml0aWFsIHBhZ2Ugc2Nyb2xsaW5nICh5ZXMsIHRoaXMgd29ya3MpLlxuICAgICAgICAgICAgLmluc2VydEFmdGVyKCAnYm9keScgKVswXS5jb250ZW50V2luZG93O1xuXG4gICAgICAgICAgLy8gV2hlbmV2ZXIgYGRvY3VtZW50LnRpdGxlYCBjaGFuZ2VzLCB1cGRhdGUgdGhlIElmcmFtZSdzIHRpdGxlIHRvXG4gICAgICAgICAgLy8gcHJldHRpZnkgdGhlIGJhY2svbmV4dCBoaXN0b3J5IG1lbnUgZW50cmllcy4gU2luY2UgSUUgc29tZXRpbWVzXG4gICAgICAgICAgLy8gZXJyb3JzIHdpdGggXCJVbnNwZWNpZmllZCBlcnJvclwiIHRoZSB2ZXJ5IGZpcnN0IHRpbWUgdGhpcyBpcyBzZXRcbiAgICAgICAgICAvLyAoeWVzLCB2ZXJ5IHVzZWZ1bCkgd3JhcCB0aGlzIHdpdGggYSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgICAgZG9jLm9ucHJvcGVydHljaGFuZ2UgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKCBldmVudC5wcm9wZXJ0eU5hbWUgPT09ICd0aXRsZScgKSB7XG4gICAgICAgICAgICAgICAgaWZyYW1lLmRvY3VtZW50LnRpdGxlID0gZG9jLnRpdGxlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoKGUpIHt9XG4gICAgICAgICAgfTtcblxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBPdmVycmlkZSB0aGUgXCJzdG9wXCIgbWV0aG9kIHNpbmNlIGFuIElFNi83IElmcmFtZSB3YXMgY3JlYXRlZC4gRXZlblxuICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIGxvbmdlciBhbnkgYm91bmQgZXZlbnQgaGFuZGxlcnMsIHRoZSBwb2xsaW5nIGxvb3BcbiAgICAgIC8vIGlzIHN0aWxsIG5lY2Vzc2FyeSBmb3IgYmFjay9uZXh0IHRvIHdvcmsgYXQgYWxsIVxuICAgICAgc2VsZi5zdG9wID0gZm5fcmV0dmFsO1xuXG4gICAgICAvLyBHZXQgaGlzdG9yeSBieSBsb29raW5nIGF0IHRoZSBoaWRkZW4gSWZyYW1lJ3MgbG9jYXRpb24uaGFzaC5cbiAgICAgIGhpc3RvcnlfZ2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRfZnJhZ21lbnQoIGlmcmFtZS5sb2NhdGlvbi5ocmVmICk7XG4gICAgICB9O1xuXG4gICAgICAvLyBTZXQgYSBuZXcgaGlzdG9yeSBpdGVtIGJ5IG9wZW5pbmcgYW5kIHRoZW4gY2xvc2luZyB0aGUgSWZyYW1lXG4gICAgICAvLyBkb2N1bWVudCwgKnRoZW4qIHNldHRpbmcgaXRzIGxvY2F0aW9uLmhhc2guIElmIGRvY3VtZW50LmRvbWFpbiBoYXNcbiAgICAgIC8vIGJlZW4gc2V0LCB1cGRhdGUgdGhhdCBhcyB3ZWxsLlxuICAgICAgaGlzdG9yeV9zZXQgPSBmdW5jdGlvbiggaGFzaCwgaGlzdG9yeV9oYXNoICkge1xuICAgICAgICB2YXIgaWZyYW1lX2RvYyA9IGlmcmFtZS5kb2N1bWVudCxcbiAgICAgICAgICBkb21haW4gPSAkLmZuWyBzdHJfaGFzaGNoYW5nZSBdLmRvbWFpbjtcblxuICAgICAgICBpZiAoIGhhc2ggIT09IGhpc3RvcnlfaGFzaCApIHtcbiAgICAgICAgICAvLyBVcGRhdGUgSWZyYW1lIHdpdGggYW55IGluaXRpYWwgYGRvY3VtZW50LnRpdGxlYCB0aGF0IG1pZ2h0IGJlIHNldC5cbiAgICAgICAgICBpZnJhbWVfZG9jLnRpdGxlID0gZG9jLnRpdGxlO1xuXG4gICAgICAgICAgLy8gT3BlbmluZyB0aGUgSWZyYW1lJ3MgZG9jdW1lbnQgYWZ0ZXIgaXQgaGFzIGJlZW4gY2xvc2VkIGlzIHdoYXRcbiAgICAgICAgICAvLyBhY3R1YWxseSBhZGRzIGEgaGlzdG9yeSBlbnRyeS5cbiAgICAgICAgICBpZnJhbWVfZG9jLm9wZW4oKTtcblxuICAgICAgICAgIC8vIFNldCBkb2N1bWVudC5kb21haW4gZm9yIHRoZSBJZnJhbWUgZG9jdW1lbnQgYXMgd2VsbCwgaWYgbmVjZXNzYXJ5LlxuICAgICAgICAgIGRvbWFpbiAmJiBpZnJhbWVfZG9jLndyaXRlKCAnPHNjcmlwdD5kb2N1bWVudC5kb21haW49XCInICsgZG9tYWluICsgJ1wiPC9zY3JpcHQ+JyApO1xuXG4gICAgICAgICAgaWZyYW1lX2RvYy5jbG9zZSgpO1xuXG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSBJZnJhbWUncyBoYXNoLCBmb3IgZ3JlYXQganVzdGljZS5cbiAgICAgICAgICBpZnJhbWUubG9jYXRpb24uaGFzaCA9IGhhc2g7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICB9KSgpO1xuICAgIC8vIF5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAgIC8vIF5eXl5eXl5eXl5eXl5eXl5eXl4gUkVNT1ZFIElGIE5PVCBTVVBQT1JUSU5HIElFNi83LzggXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAgIC8vIF5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH0pKCk7XG5cbn0pKGpRdWVyeSx0aGlzKTtcbiJdfQ==
